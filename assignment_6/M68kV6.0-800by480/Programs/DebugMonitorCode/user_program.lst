680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 12 Apr 2023      Time: 18:16:39          Source: C:\M68KV6.0-800BY480\PROGRAMS\DEBUGMONITORCODE\USER_PROGRAM.SRC

                       1          section   code
                       2   **********************************************************************************************************
                       3   * CSTART.ASM  -  C startup-code
                       4   *
                       5   *          Initialises the system prior to running the users main() program
                       6   *
                       7   *          1) Sets up the user program stack pointer
                       8   *          2) Switches to User mode in the 68000
                       9   *          3) Enables All Interrupts 1-7 on 68000
                      10   *          4) Copies all initialised C program variables from Rom to Ram prior to running main()
                      11   *
                      12   **********************************************************************************************************
00000000              13                   align
                      14   
                      15   
                      16   **********************************************************************************************************
                      17   * The Following ORG Statement marks the address of the start of the this CStart Program
                      18   *
                      19   * The debug Monitor and Flash Load and Program routines assume your program lives here
                      20   **********************************************************************************************************
08000000              21                   org       $08000000
08000000  46FC 2000   22   start:          move.w    #$2000,SR             clear interrupts to enable all, move to supervisor mode
                      23   
                      24   ******************************************************************************************
                      25   * Set unitialised global variables to 0 at startup
                      26   ******************************************************************************************
08000004  207C 0800   27   mainloop        movea.l   #BssStart,a0          point a0 to the start of the initialised data section held in ROM
08000008  21EC      
0800000A  203C 0000   28                   move.l    #BssLength,d0         figure out how many bytes of C program variables data to copy
0800000E  0022      
08000010  6700 0024   29                   beq       go_main               if no data to copy go straight to program
08000014  10FC 0000   30   Zeroinit        move.b    #0,(a0)+              copy the C program initialise variables from rom to ram
08000018  5380        31                   subq.l    #1,d0
0800001A  66F8        32                   bne       Zeroinit
                      33   
                      34   *******************************************************************************************
                      35   * last minute initialisation before calling main
                      36   *******************************************************************************************
                      37   
0800001C  23FC FFFF   38                   move.l    #-1,__ungetbuf         required for use of scanf() etc in C programs
08000020  FFFF 0800 
08000024  21E0      
08000026  42B9 0800   39                   clr.l     __allocp               used by malloc() in C
0800002A  21E4      
0800002C  23FC 0800   40                   move.l    #heap,__heap           pointer to free memory
08000030  220E 0800 
08000034  21E8      
08000036  4EB9 0800   41   go_main         jsr       _main
0800003A  11E4      
0800003C  60C2        42                   bra       start
                      43   
                      44   ; C:\M68KV6.0-800BY480\PROGRAMS\DEBUGMONITORCODE\M68KUSERPROGRAM (DE1).C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                      45   ; #include <stdio.h>
                      46   ; #include <string.h>
                      47   ; #include <ctype.h>
                      48   ; //IMPORTANT
                      49   ; //
                      50   ; // Uncomment one of the two #defines below
                      51   ; // Define StartOfExceptionVectorTable as 08030000 if running programs from sram or
                      52   ; // 0B000000 for running programs from dram
                      53   ; //
                      54   ; // In your labs, you will initially start by designing a system with SRam and later move to
                      55   ; // Dram, so these constants will need to be changed based on the version of the system you have
                      56   ; // building
                      57   ; //
                      58   ; // The working 68k system SOF file posted on canvas that you can use for your pre-lab
                      59   ; // is based around Dram so #define accordingly before building
                      60   ; //SRAM
                      61   ; //#define StartOfExceptionVectorTable 0x08030000
                      62   ; //DRAM
                      63   ; #define StartOfExceptionVectorTable 0x0B000000
                      64   ; /**********************************************************************************************
                      65   ; **	Parallel port addresses
                      66   ; **********************************************************************************************/
                      67   ; #define PortA   *(volatile unsigned char *)(0x00400000)
                      68   ; #define PortB   *(volatile unsigned char *)(0x00400002)
                      69   ; #define PortC   *(volatile unsigned char *)(0x00400004)
                      70   ; #define PortD   *(volatile unsigned char *)(0x00400006)
                      71   ; #define PortE   *(volatile unsigned char *)(0x00400008)
                      72   ; /*********************************************************************************************
                      73   ; **	Hex 7 seg displays port addresses
                      74   ; *********************************************************************************************/
                      75   ; #define HEX_A        *(volatile unsigned char *)(0x00400010)
                      76   ; #define HEX_B        *(volatile unsigned char *)(0x00400012)
                      77   ; #define HEX_C        *(volatile unsigned char *)(0x00400014)    // de2 only
                      78   ; #define HEX_D        *(volatile unsigned char *)(0x00400016)    // de2 only
                      79   ; /**********************************************************************************************
                      80   ; **	LCD display port addresses
                      81   ; **********************************************************************************************/
                      82   ; #define LCDcommand   *(volatile unsigned char *)(0x00400020)
                      83   ; #define LCDdata      *(volatile unsigned char *)(0x00400022)
                      84   ; /********************************************************************************************
                      85   ; **	Timer Port addresses
                      86   ; *********************************************************************************************/
                      87   ; #define Timer1Data      *(volatile unsigned char *)(0x00400030)
                      88   ; #define Timer1Control   *(volatile unsigned char *)(0x00400032)
                      89   ; #define Timer1Status    *(volatile unsigned char *)(0x00400032)
                      90   ; #define Timer2Data      *(volatile unsigned char *)(0x00400034)
                      91   ; #define Timer2Control   *(volatile unsigned char *)(0x00400036)
                      92   ; #define Timer2Status    *(volatile unsigned char *)(0x00400036)
                      93   ; #define Timer3Data      *(volatile unsigned char *)(0x00400038)
                      94   ; #define Timer3Control   *(volatile unsigned char *)(0x0040003A)
                      95   ; #define Timer3Status    *(volatile unsigned char *)(0x0040003A)
                      96   ; #define Timer4Data      *(volatile unsigned char *)(0x0040003C)
                      97   ; #define Timer4Control   *(volatile unsigned char *)(0x0040003E)
                      98   ; #define Timer4Status    *(volatile unsigned char *)(0x0040003E)
                      99   ; /*********************************************************************************************
                     100   ; **	RS232 port addresses
                     101   ; *********************************************************************************************/
                     102   ; #define RS232_Control     *(volatile unsigned char *)(0x00400040)
                     103   ; #define RS232_Status      *(volatile unsigned char *)(0x00400040)
                     104   ; #define RS232_TxData      *(volatile unsigned char *)(0x00400042)
                     105   ; #define RS232_RxData      *(volatile unsigned char *)(0x00400042)
                     106   ; #define RS232_Baud        *(volatile unsigned char *)(0x00400044)
                     107   ; /*********************************************************************************************
                     108   ; **	PIA 1 and 2 port addresses
                     109   ; *********************************************************************************************/
                     110   ; #define PIA1_PortA_Data     *(volatile unsigned char *)(0x00400050)         // combined data and data direction register share same address
                     111   ; #define PIA1_PortA_Control *(volatile unsigned char *)(0x00400052)
                     112   ; #define PIA1_PortB_Data     *(volatile unsigned char *)(0x00400054)         // combined data and data direction register share same address
                     113   ; #define PIA1_PortB_Control *(volatile unsigned char *)(0x00400056)
                     114   ; #define PIA2_PortA_Data     *(volatile unsigned char *)(0x00400060)         // combined data and data direction register share same address
                     115   ; #define PIA2_PortA_Control *(volatile unsigned char *)(0x00400062)
                     116   ; #define PIA2_PortB_data     *(volatile unsigned char *)(0x00400064)         // combined data and data direction register share same address
                     117   ; #define PIA2_PortB_Control *(volatile unsigned char *)(0x00400066)
                     118   ; /*******************************************************************************************
                     119   ; ** I2C address and common commands
                     120   ; *******************************************************************************************/
                     121   ; #define I2C_prescale_reg_L *(volatile unsigned char *) (0x00408000)
                     122   ; #define I2C_prescale_reg_H *(volatile unsigned char *) (0x00408002)
                     123   ; #define I2C_control_reg  *(volatile unsigned char *) (0x00408004)
                     124   ; #define I2C_TX_reg  *(volatile unsigned char *) (0x00408006)
                     125   ; #define I2C_RX_reg  *(volatile unsigned char *) (0x00408006)
                     126   ; #define I2C_command_reg  *(volatile unsigned char *) (0x00408008)
                     127   ; #define I2C_status_reg  *(volatile unsigned char *) (0x00408008)
                     128   ; #define start_write_cmd_I2C (char) (0x91)          // generate start signal and enable write, clear any pending interrupt
                     129   ; #define write_cmd_I2C (char) (0x11)            // send TX byte without generating a start signal
                     130   ; #define stop_write_cmd_I2C (char) (0x51)
                     131   ; #define stop_read_NACK_cmd_I2C (char) (0x69)
                     132   ; #define read_ACK_cmd_I2C (char) (0x21)
                     133   ; /*******************************************************************************************
                     134   ; ** CAN bus
                     135   ; *******************************************************************************************/
                     136   ; #define CAN0_CONTROLLER(i) (*(volatile unsigned char *)(0x00500000 + (i << 1)))
                     137   ; #define CAN1_CONTROLLER(i) (*(volatile unsigned char *)(0x00500200 + (i << 1)))
                     138   ; /* Can 0 register definitions */
                     139   ; #define Can0_ModeControlReg      CAN0_CONTROLLER(0)
                     140   ; #define Can0_CommandReg          CAN0_CONTROLLER(1)
                     141   ; #define Can0_StatusReg           CAN0_CONTROLLER(2)
                     142   ; #define Can0_InterruptReg        CAN0_CONTROLLER(3)
                     143   ; #define Can0_InterruptEnReg      CAN0_CONTROLLER(4) /* PeliCAN mode */
                     144   ; #define Can0_BusTiming0Reg       CAN0_CONTROLLER(6)
                     145   ; #define Can0_BusTiming1Reg       CAN0_CONTROLLER(7)
                     146   ; #define Can0_OutControlReg       CAN0_CONTROLLER(8)
                     147   ; /* address definitions of Other Registers */
                     148   ; #define Can0_ArbLostCapReg       CAN0_CONTROLLER(11)
                     149   ; #define Can0_ErrCodeCapReg       CAN0_CONTROLLER(12)
                     150   ; #define Can0_ErrWarnLimitReg     CAN0_CONTROLLER(13)
                     151   ; #define Can0_RxErrCountReg       CAN0_CONTROLLER(14)
                     152   ; #define Can0_TxErrCountReg       CAN0_CONTROLLER(15)
                     153   ; #define Can0_RxMsgCountReg       CAN0_CONTROLLER(29)
                     154   ; #define Can0_RxBufStartAdr       CAN0_CONTROLLER(30)
                     155   ; #define Can0_ClockDivideReg      CAN0_CONTROLLER(31)
                     156   ; /* address definitions of Acceptance Code & Mask Registers - RESET MODE */
                     157   ; #define Can0_AcceptCode0Reg      CAN0_CONTROLLER(16)
                     158   ; #define Can0_AcceptCode1Reg      CAN0_CONTROLLER(17)
                     159   ; #define Can0_AcceptCode2Reg      CAN0_CONTROLLER(18)
                     160   ; #define Can0_AcceptCode3Reg      CAN0_CONTROLLER(19)
                     161   ; #define Can0_AcceptMask0Reg      CAN0_CONTROLLER(20)
                     162   ; #define Can0_AcceptMask1Reg      CAN0_CONTROLLER(21)
                     163   ; #define Can0_AcceptMask2Reg      CAN0_CONTROLLER(22)
                     164   ; #define Can0_AcceptMask3Reg      CAN0_CONTROLLER(23)
                     165   ; /* address definitions Rx Buffer - OPERATING MODE - Read only register*/
                     166   ; #define Can0_RxFrameInfo         CAN0_CONTROLLER(16)
                     167   ; #define Can0_RxBuffer1           CAN0_CONTROLLER(17)
                     168   ; #define Can0_RxBuffer2           CAN0_CONTROLLER(18)
                     169   ; #define Can0_RxBuffer3           CAN0_CONTROLLER(19)
                     170   ; #define Can0_RxBuffer4           CAN0_CONTROLLER(20)
                     171   ; #define Can0_RxBuffer5           CAN0_CONTROLLER(21)
                     172   ; #define Can0_RxBuffer6           CAN0_CONTROLLER(22)
                     173   ; #define Can0_RxBuffer7           CAN0_CONTROLLER(23)
                     174   ; #define Can0_RxBuffer8           CAN0_CONTROLLER(24)
                     175   ; #define Can0_RxBuffer9           CAN0_CONTROLLER(25)
                     176   ; #define Can0_RxBuffer10          CAN0_CONTROLLER(26)
                     177   ; #define Can0_RxBuffer11          CAN0_CONTROLLER(27)
                     178   ; #define Can0_RxBuffer12          CAN0_CONTROLLER(28)
                     179   ; /* address definitions of the Tx-Buffer - OPERATING MODE - Write only register */
                     180   ; #define Can0_TxFrameInfo         CAN0_CONTROLLER(16)
                     181   ; #define Can0_TxBuffer1           CAN0_CONTROLLER(17)
                     182   ; #define Can0_TxBuffer2           CAN0_CONTROLLER(18)
                     183   ; #define Can0_TxBuffer3           CAN0_CONTROLLER(19)
                     184   ; #define Can0_TxBuffer4           CAN0_CONTROLLER(20)
                     185   ; #define Can0_TxBuffer5           CAN0_CONTROLLER(21)
                     186   ; #define Can0_TxBuffer6           CAN0_CONTROLLER(22)
                     187   ; #define Can0_TxBuffer7           CAN0_CONTROLLER(23)
                     188   ; #define Can0_TxBuffer8           CAN0_CONTROLLER(24)
                     189   ; #define Can0_TxBuffer9           CAN0_CONTROLLER(25)
                     190   ; #define Can0_TxBuffer10          CAN0_CONTROLLER(26)
                     191   ; #define Can0_TxBuffer11          CAN0_CONTROLLER(27)
                     192   ; #define Can0_TxBuffer12          CAN0_CONTROLLER(28)
                     193   ; /* read only addresses */
                     194   ; #define Can0_TxFrameInfoRd       CAN0_CONTROLLER(96)
                     195   ; #define Can0_TxBufferRd1         CAN0_CONTROLLER(97)
                     196   ; #define Can0_TxBufferRd2         CAN0_CONTROLLER(98)
                     197   ; #define Can0_TxBufferRd3         CAN0_CONTROLLER(99)
                     198   ; #define Can0_TxBufferRd4         CAN0_CONTROLLER(100)
                     199   ; #define Can0_TxBufferRd5         CAN0_CONTROLLER(101)
                     200   ; #define Can0_TxBufferRd6         CAN0_CONTROLLER(102)
                     201   ; #define Can0_TxBufferRd7         CAN0_CONTROLLER(103)
                     202   ; #define Can0_TxBufferRd8         CAN0_CONTROLLER(104)
                     203   ; #define Can0_TxBufferRd9         CAN0_CONTROLLER(105)
                     204   ; #define Can0_TxBufferRd10        CAN0_CONTROLLER(106)
                     205   ; #define Can0_TxBufferRd11        CAN0_CONTROLLER(107)
                     206   ; #define Can0_TxBufferRd12        CAN0_CONTROLLER(108)
                     207   ; /* CAN1 Controller register definitions */
                     208   ; #define Can1_ModeControlReg      CAN1_CONTROLLER(0)
                     209   ; #define Can1_CommandReg          CAN1_CONTROLLER(1)
                     210   ; #define Can1_StatusReg           CAN1_CONTROLLER(2)
                     211   ; #define Can1_InterruptReg        CAN1_CONTROLLER(3)
                     212   ; #define Can1_InterruptEnReg      CAN1_CONTROLLER(4) /* PeliCAN mode */
                     213   ; #define Can1_BusTiming0Reg       CAN1_CONTROLLER(6)
                     214   ; #define Can1_BusTiming1Reg       CAN1_CONTROLLER(7)
                     215   ; #define Can1_OutControlReg       CAN1_CONTROLLER(8)
                     216   ; /* address definitions of Other Registers */
                     217   ; #define Can1_ArbLostCapReg       CAN1_CONTROLLER(11)
                     218   ; #define Can1_ErrCodeCapReg       CAN1_CONTROLLER(12)
                     219   ; #define Can1_ErrWarnLimitReg     CAN1_CONTROLLER(13)
                     220   ; #define Can1_RxErrCountReg       CAN1_CONTROLLER(14)
                     221   ; #define Can1_TxErrCountReg       CAN1_CONTROLLER(15)
                     222   ; #define Can1_RxMsgCountReg       CAN1_CONTROLLER(29)
                     223   ; #define Can1_RxBufStartAdr       CAN1_CONTROLLER(30)
                     224   ; #define Can1_ClockDivideReg      CAN1_CONTROLLER(31)
                     225   ; /* address definitions of Acceptance Code & Mask Registers - RESET MODE */
                     226   ; #define Can1_AcceptCode0Reg      CAN1_CONTROLLER(16)
                     227   ; #define Can1_AcceptCode1Reg      CAN1_CONTROLLER(17)
                     228   ; #define Can1_AcceptCode2Reg      CAN1_CONTROLLER(18)
                     229   ; #define Can1_AcceptCode3Reg      CAN1_CONTROLLER(19)
                     230   ; #define Can1_AcceptMask0Reg      CAN1_CONTROLLER(20)
                     231   ; #define Can1_AcceptMask1Reg      CAN1_CONTROLLER(21)
                     232   ; #define Can1_AcceptMask2Reg      CAN1_CONTROLLER(22)
                     233   ; #define Can1_AcceptMask3Reg      CAN1_CONTROLLER(23)
                     234   ; /* address definitions Rx Buffer - OPERATING MODE - Read only register*/
                     235   ; #define Can1_RxFrameInfo         CAN1_CONTROLLER(16)
                     236   ; #define Can1_RxBuffer1           CAN1_CONTROLLER(17)
                     237   ; #define Can1_RxBuffer2           CAN1_CONTROLLER(18)
                     238   ; #define Can1_RxBuffer3           CAN1_CONTROLLER(19)
                     239   ; #define Can1_RxBuffer4           CAN1_CONTROLLER(20)
                     240   ; #define Can1_RxBuffer5           CAN1_CONTROLLER(21)
                     241   ; #define Can1_RxBuffer6           CAN1_CONTROLLER(22)
                     242   ; #define Can1_RxBuffer7           CAN1_CONTROLLER(23)
                     243   ; #define Can1_RxBuffer8           CAN1_CONTROLLER(24)
                     244   ; #define Can1_RxBuffer9           CAN1_CONTROLLER(25)
                     245   ; #define Can1_RxBuffer10          CAN1_CONTROLLER(26)
                     246   ; #define Can1_RxBuffer11          CAN1_CONTROLLER(27)
                     247   ; #define Can1_RxBuffer12          CAN1_CONTROLLER(28)
                     248   ; /* address definitions of the Tx-Buffer - OPERATING MODE - Write only register */
                     249   ; #define Can1_TxFrameInfo         CAN1_CONTROLLER(16)
                     250   ; #define Can1_TxBuffer1           CAN1_CONTROLLER(17)
                     251   ; #define Can1_TxBuffer2           CAN1_CONTROLLER(18)
                     252   ; #define Can1_TxBuffer3           CAN1_CONTROLLER(19)
                     253   ; #define Can1_TxBuffer4           CAN1_CONTROLLER(20)
                     254   ; #define Can1_TxBuffer5           CAN1_CONTROLLER(21)
                     255   ; #define Can1_TxBuffer6           CAN1_CONTROLLER(22)
                     256   ; #define Can1_TxBuffer7           CAN1_CONTROLLER(23)
                     257   ; #define Can1_TxBuffer8           CAN1_CONTROLLER(24)
                     258   ; #define Can1_TxBuffer9           CAN1_CONTROLLER(25)
                     259   ; #define Can1_TxBuffer10          CAN1_CONTROLLER(26)
                     260   ; #define Can1_TxBuffer11          CAN1_CONTROLLER(27)
                     261   ; #define Can1_TxBuffer12          CAN1_CONTROLLER(28)
                     262   ; /* read only addresses */
                     263   ; #define Can1_TxFrameInfoRd       CAN1_CONTROLLER(96)
                     264   ; #define Can1_TxBufferRd1         CAN1_CONTROLLER(97)
                     265   ; #define Can1_TxBufferRd2         CAN1_CONTROLLER(98)
                     266   ; #define Can1_TxBufferRd3         CAN1_CONTROLLER(99)
                     267   ; #define Can1_TxBufferRd4         CAN1_CONTROLLER(100)
                     268   ; #define Can1_TxBufferRd5         CAN1_CONTROLLER(101)
                     269   ; #define Can1_TxBufferRd6         CAN1_CONTROLLER(102)
                     270   ; #define Can1_TxBufferRd7         CAN1_CONTROLLER(103)
                     271   ; #define Can1_TxBufferRd8         CAN1_CONTROLLER(104)
                     272   ; #define Can1_TxBufferRd9         CAN1_CONTROLLER(105)
                     273   ; #define Can1_TxBufferRd10        CAN1_CONTROLLER(106)
                     274   ; #define Can1_TxBufferRd11        CAN1_CONTROLLER(107)
                     275   ; #define Can1_TxBufferRd12        CAN1_CONTROLLER(108)
                     276   ; /* bit definitions for the Mode & Control Register */
                     277   ; #define RM_RR_Bit 0x01 /* reset mode (request) bit */
                     278   ; #define LOM_Bit 0x02 /* listen only mode bit */
                     279   ; #define STM_Bit 0x04 /* self test mode bit */
                     280   ; #define AFM_Bit 0x08 /* acceptance filter mode bit */
                     281   ; #define SM_Bit  0x10 /* enter sleep mode bit */
                     282   ; /* bit definitions for the Interrupt Enable & Control Register */
                     283   ; #define RIE_Bit 0x01 /* receive interrupt enable bit */
                     284   ; #define TIE_Bit 0x02 /* transmit interrupt enable bit */
                     285   ; #define EIE_Bit 0x04 /* error warning interrupt enable bit */
                     286   ; #define DOIE_Bit 0x08 /* data overrun interrupt enable bit */
                     287   ; #define WUIE_Bit 0x10 /* wake-up interrupt enable bit */
                     288   ; #define EPIE_Bit 0x20 /* error passive interrupt enable bit */
                     289   ; #define ALIE_Bit 0x40 /* arbitration lost interr. enable bit*/
                     290   ; #define BEIE_Bit 0x80 /* bus error interrupt enable bit */
                     291   ; /* bit definitions for the Command Register */
                     292   ; #define TR_Bit 0x01 /* transmission request bit */
                     293   ; #define AT_Bit 0x02 /* abort transmission bit */
                     294   ; #define RRB_Bit 0x04 /* release receive buffer bit */
                     295   ; #define CDO_Bit 0x08 /* clear data overrun bit */
                     296   ; #define SRR_Bit 0x10 /* self reception request bit */
                     297   ; /* bit definitions for the Status Register */
                     298   ; #define RBS_Bit 0x01 /* receive buffer status bit */
                     299   ; #define DOS_Bit 0x02 /* data overrun status bit */
                     300   ; #define TBS_Bit 0x04 /* transmit buffer status bit */
                     301   ; #define TCS_Bit 0x08 /* transmission complete status bit */
                     302   ; #define RS_Bit 0x10 /* receive status bit */
                     303   ; #define TS_Bit 0x20 /* transmit status bit */
                     304   ; #define ES_Bit 0x40 /* error status bit */
                     305   ; #define BS_Bit 0x80 /* bus status bit */
                     306   ; /* bit definitions for the Interrupt Register */
                     307   ; #define RI_Bit 0x01 /* receive interrupt bit */
                     308   ; #define TI_Bit 0x02 /* transmit interrupt bit */
                     309   ; #define EI_Bit 0x04 /* error warning interrupt bit */
                     310   ; #define DOI_Bit 0x08 /* data overrun interrupt bit */
                     311   ; #define WUI_Bit 0x10 /* wake-up interrupt bit */
                     312   ; #define EPI_Bit 0x20 /* error passive interrupt bit */
                     313   ; #define ALI_Bit 0x40 /* arbitration lost interrupt bit */
                     314   ; #define BEI_Bit 0x80 /* bus error interrupt bit */
                     315   ; /* bit definitions for the Bus Timing Registers */
                     316   ; #define SAM_Bit 0x80                        /* sample mode bit 1 == the bus is sampled 3 times, 0 == the bus is sampled once */
                     317   ; /* bit definitions for the Output Control Register OCMODE1, OCMODE0 */
                     318   ; #define BiPhaseMode 0x00 /* bi-phase output mode */
                     319   ; #define NormalMode 0x02 /* normal output mode */
                     320   ; #define ClkOutMode 0x03 /* clock output mode */
                     321   ; /* output pin configuration for TX1 */
                     322   ; #define OCPOL1_Bit 0x20 /* output polarity control bit */
                     323   ; #define Tx1Float 0x00 /* configured as float */
                     324   ; #define Tx1PullDn 0x40 /* configured as pull-down */
                     325   ; #define Tx1PullUp 0x80 /* configured as pull-up */
                     326   ; #define Tx1PshPull 0xC0 /* configured as push/pull */
                     327   ; /* output pin configuration for TX0 */
                     328   ; #define OCPOL0_Bit 0x04 /* output polarity control bit */
                     329   ; #define Tx0Float 0x00 /* configured as float */
                     330   ; #define Tx0PullDn 0x08 /* configured as pull-down */
                     331   ; #define Tx0PullUp 0x10 /* configured as pull-up */
                     332   ; #define Tx0PshPull 0x18 /* configured as push/pull */
                     333   ; /* bit definitions for the Clock Divider Register */
                     334   ; #define DivBy1 0x07 /* CLKOUT = oscillator frequency */
                     335   ; #define DivBy2 0x00 /* CLKOUT = 1/2 oscillator frequency */
                     336   ; #define ClkOff_Bit 0x08 /* clock off bit, control of the CLK OUT pin */
                     337   ; #define RXINTEN_Bit 0x20 /* pin TX1 used for receive interrupt */
                     338   ; #define CBP_Bit 0x40 /* CAN comparator bypass control bit */
                     339   ; #define CANMode_Bit 0x80 /* CAN mode definition bit */
                     340   ; /*- definition of used constants ---------------------------------------*/
                     341   ; #define YES 1
                     342   ; #define NO 0
                     343   ; #define ENABLE 1
                     344   ; #define DISABLE 0
                     345   ; #define ENABLE_N 0
                     346   ; #define DISABLE_N 1
                     347   ; #define INTLEVELACT 0
                     348   ; #define INTEDGEACT 1
                     349   ; #define PRIORITY_LOW 0
                     350   ; #define PRIORITY_HIGH 1
                     351   ; /* default (reset) value for register content, clear register */
                     352   ; #define ClrByte 0x00
                     353   ; /* constant: clear Interrupt Enable Register */
                     354   ; #define ClrIntEnSJA ClrByte
                     355   ; /* definitions for the acceptance code and mask register */
                     356   ; #define DontCare 0xFF
                     357   ; /*  bus timing values for
                     358   ; **  bit-rate : 100 kBit/s
                     359   ; **  oscillator frequency : 25 MHz, 1 sample per bit, 0 tolerance %
                     360   ; **  maximum tolerated propagation delay : 4450 ns
                     361   ; **  minimum requested propagation delay : 500 ns
                     362   ; **
                     363   ; **  https://www.kvaser.com/support/calculators/bit-timing-calculator/
                     364   ; **  T1 	T2 	BTQ 	SP% 	SJW 	BIT RATE 	ERR% 	BTR0 	BTR1
                     365   ; **  17	8	25	    68	     1	      100	    0	      04	7f
                     366   ; */
                     367   ; /*************************************************************
                     368   ; ** SPI Controller registers
                     369   ; **************************************************************/
                     370   ; // SPI Registers
                     371   ; #define SPI_Control         (*(volatile unsigned char *)(0x00408020))
                     372   ; #define SPI_Status          (*(volatile unsigned char *)(0x00408022))
                     373   ; #define SPI_Data            (*(volatile unsigned char *)(0x00408024))
                     374   ; #define SPI_Ext             (*(volatile unsigned char *)(0x00408026))
                     375   ; #define SPI_CS              (*(volatile unsigned char *)(0x00408028))
                     376   ; // these two macros enable or disable the flash memory chip enable off SSN_O[7..0]
                     377   ; // in this case we assume there is only 1 device connected to SSN_O[0] so we can
                     378   ; // write hex FE to the SPI_CS to enable it (the enable on the flash chip is active low)
                     379   ; // and write FF to disable it
                     380   ; #define   Enable_SPI_CS()             SPI_CS = 0xFE
                     381   ; #define   Disable_SPI_CS()            SPI_CS = 0xFF
                     382   ; // SPI flash chip commands
                     383   ; #define write_enable_cmd 0x06
                     384   ; #define erasing_cmd  0xc7
                     385   ; #define read_cmd  0x03
                     386   ; #define write_cmd  0x02
                     387   ; #define check_status_cmd 0x05
                     388   ; /*********************************************************************************************************************************
                     389   ; * 
                     390   ; * 
                     391   ; (( DO NOT initialise global variables here, do it main even if you want 0
                     392   ; (( it's a limitation of the compiler
                     393   ; (( YOU HAVE BEEN WARNED
                     394   ; *********************************************************************************************************************************/
                     395   ; unsigned int i, x, y, z, PortA_Count;
                     396   ; unsigned char Timer1Count, Timer2Count, Timer3Count, Timer4Count ;
                     397   ; unsigned char switch_counter, eeprom_counter, flash_counter;
                     398   ; /*******************************************************************************************
                     399   ; ** Function Prototypes
                     400   ; *******************************************************************************************/
                     401   ; int _getch( void );
                     402   ; char xtod(int c);
                     403   ; int Get1HexDigits(char *CheckSumPtr);
                     404   ; int Get2HexDigits(char *CheckSumPtr);
                     405   ; int Get4HexDigits(char *CheckSumPtr);
                     406   ; int Get6HexDigits(char *CheckSumPtr);
                     407   ; void Wait1ms(void);
                     408   ; void Wait3ms(void);
                     409   ; void Wait500ms (void);
                     410   ; void Init_LCD(void) ;
                     411   ; void LCDOutchar(int c);
                     412   ; void LCDOutMess(char *theMessage);
                     413   ; void LCDClearln(void);
                     414   ; void LCDline1Message(char *theMessage);
                     415   ; void LCDline2Message(char *theMessage);
                     416   ; int sprintf(char *out, const char *format, ...) ;
                     417   ; unsigned int ask_EEPROM_internal_addr(void);
                     418   ; unsigned char ask_EEPROM_data(void);
                     419   ; void EEPROM_internal_writting_polling(unsigned char slave_addr_RW);
                     420   ; void I2C_init(void);
                     421   ; void I2C_TX_command_status (char data, char command);
                     422   ; void I2C_byte_write (void);
                     423   ; void I2C_byte_read (void);
                     424   ; unsigned int ask_EEPROM_addr_range(void);
                     425   ; void I2C_multi_write (void);
                     426   ; void I2C_multi_read (void);
                     427   ; int boundry_checker (int intended_page_size, unsigned int current_addr);
                     428   ; void DAC(void);
                     429   ; unsigned char ask_ADC_channel (void);
                     430   ; /*******************************************************************************************
                     431   ; ** CAN bus functions
                     432   ; *******************************************************************************************/
                     433   ; // initialisation for Can controller 0
                     434   ; void Init_CanBus_Controller0(void)
                     435   ; {
                     436   _Init_CanBus_Controller0:
                     437   ; // TODO - put your Canbus initialisation code for CanController 0 here
                     438   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                     439   ; //printf("\r\nInitializing Can controller 0");
                     440   ; while((Can0_ModeControlReg & RM_RR_Bit ) == ClrByte)
                     441   Init_CanBus_Controller0_1:
0800003E  1039 0050  442          move.b    5242880,D0
08000042  0000      
08000044  C03C 0001  443          and.b     #1,D0
08000048  6612       444          bne.s     Init_CanBus_Controller0_3
                     445   ; {
                     446   ; Can0_ModeControlReg = Can0_ModeControlReg | RM_RR_Bit;
0800004A  1039 0050  447          move.b    5242880,D0
0800004E  0000      
08000050  803C 0001  448          or.b      #1,D0
08000054  13C0 0050  449          move.b    D0,5242880
08000058  0000      
0800005A  60E2       450          bra       Init_CanBus_Controller0_1
                     451   Init_CanBus_Controller0_3:
                     452   ; }
                     453   ; Can0_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy1;
0800005C  13FC 00C7  454          move.b    #199,5242942
08000060  0050 003E 
                     455   ; Can0_InterruptEnReg = ClrIntEnSJA;
08000064  4239 0050  456          clr.b     5242888
08000068  0008      
                     457   ; Can0_AcceptCode0Reg = ClrByte;
0800006A  4239 0050  458          clr.b     5242912
0800006E  0020      
                     459   ; Can0_AcceptCode1Reg = ClrByte;
08000070  4239 0050  460          clr.b     5242914
08000074  0022      
                     461   ; Can0_AcceptCode2Reg = ClrByte;
08000076  4239 0050  462          clr.b     5242916
0800007A  0024      
                     463   ; Can0_AcceptCode3Reg = ClrByte;
0800007C  4239 0050  464          clr.b     5242918
08000080  0026      
                     465   ; Can0_AcceptMask0Reg = DontCare;
08000082  13FC 00FF  466          move.b    #255,5242920
08000086  0050 0028 
                     467   ; Can0_AcceptMask1Reg = DontCare;
0800008A  13FC 00FF  468          move.b    #255,5242922
0800008E  0050 002A 
                     469   ; Can0_AcceptMask2Reg = DontCare;
08000092  13FC 00FF  470          move.b    #255,5242924
08000096  0050 002C 
                     471   ; Can0_AcceptMask3Reg = DontCare;
0800009A  13FC 00FF  472          move.b    #255,5242926
0800009E  0050 002E 
                     473   ; // see the comment on line 275
                     474   ; Can0_BusTiming0Reg = 0x04;
080000A2  13FC 0004  475          move.b    #4,5242892
080000A6  0050 000C 
                     476   ; Can0_BusTiming1Reg = 0x7f;
080000AA  13FC 007F  477          move.b    #127,5242894
080000AE  0050 000E 
                     478   ; Can0_OutControlReg = Tx0Float | Tx0PshPull | NormalMode;
080000B2  13FC 001A  479          move.b    #26,5242896
080000B6  0050 0010 
                     480   ; while ((Can0_ModeControlReg & RM_RR_Bit) != ClrByte)
                     481   Init_CanBus_Controller0_4:
080000BA  1039 0050  482          move.b    5242880,D0
080000BE  0000      
080000C0  C03C 0001  483          and.b     #1,D0
080000C4  6708       484          beq.s     Init_CanBus_Controller0_6
                     485   ; {
                     486   ; Can0_ModeControlReg = ClrByte;
080000C6  4239 0050  487          clr.b     5242880
080000CA  0000      
080000CC  60EC       488          bra       Init_CanBus_Controller0_4
                     489   Init_CanBus_Controller0_6:
080000CE  4E75       490          rts
                     491   ; }
                     492   ; }
                     493   ; // initialisation for Can controller 1
                     494   ; void Init_CanBus_Controller1(void)
                     495   ; {
                     496   _Init_CanBus_Controller1:
                     497   ; // TODO - put your Canbus initialisation code for CanController 1 here
                     498   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                     499   ; //printf("\r\nInitializing Can controller 1");
                     500   ; while((Can1_ModeControlReg & RM_RR_Bit ) == ClrByte)
                     501   Init_CanBus_Controller1_1:
080000D0  1039 0050  502          move.b    5243392,D0
080000D4  0200      
080000D6  C03C 0001  503          and.b     #1,D0
080000DA  6612       504          bne.s     Init_CanBus_Controller1_3
                     505   ; {
                     506   ; Can1_ModeControlReg = Can1_ModeControlReg | RM_RR_Bit;
080000DC  1039 0050  507          move.b    5243392,D0
080000E0  0200      
080000E2  803C 0001  508          or.b      #1,D0
080000E6  13C0 0050  509          move.b    D0,5243392
080000EA  0200      
080000EC  60E2       510          bra       Init_CanBus_Controller1_1
                     511   Init_CanBus_Controller1_3:
                     512   ; }
                     513   ; Can1_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy1;
080000EE  13FC 00C7  514          move.b    #199,5243454
080000F2  0050 023E 
                     515   ; Can1_InterruptEnReg = ClrIntEnSJA;
080000F6  4239 0050  516          clr.b     5243400
080000FA  0208      
                     517   ; Can1_AcceptCode0Reg = ClrByte;
080000FC  4239 0050  518          clr.b     5243424
08000100  0220      
                     519   ; Can1_AcceptCode1Reg = ClrByte;
08000102  4239 0050  520          clr.b     5243426
08000106  0222      
                     521   ; Can1_AcceptCode2Reg = ClrByte;
08000108  4239 0050  522          clr.b     5243428
0800010C  0224      
                     523   ; Can1_AcceptCode3Reg = ClrByte;
0800010E  4239 0050  524          clr.b     5243430
08000112  0226      
                     525   ; Can1_AcceptMask0Reg = DontCare;
08000114  13FC 00FF  526          move.b    #255,5243432
08000118  0050 0228 
                     527   ; Can1_AcceptMask1Reg = DontCare;
0800011C  13FC 00FF  528          move.b    #255,5243434
08000120  0050 022A 
                     529   ; Can1_AcceptMask2Reg = DontCare;
08000124  13FC 00FF  530          move.b    #255,5243436
08000128  0050 022C 
                     531   ; Can1_AcceptMask3Reg = DontCare;
0800012C  13FC 00FF  532          move.b    #255,5243438
08000130  0050 022E 
                     533   ; // see the comment on line 275
                     534   ; Can1_BusTiming0Reg = 0x04;
08000134  13FC 0004  535          move.b    #4,5243404
08000138  0050 020C 
                     536   ; Can1_BusTiming1Reg = 0x7f;
0800013C  13FC 007F  537          move.b    #127,5243406
08000140  0050 020E 
                     538   ; Can1_OutControlReg = Tx1Float | Tx1PshPull | NormalMode;
08000144  13FC 00C2  539          move.b    #194,5243408
08000148  0050 0210 
                     540   ; while ((Can1_ModeControlReg & RM_RR_Bit) != ClrByte)
                     541   Init_CanBus_Controller1_4:
0800014C  1039 0050  542          move.b    5243392,D0
08000150  0200      
08000152  C03C 0001  543          and.b     #1,D0
08000156  6708       544          beq.s     Init_CanBus_Controller1_6
                     545   ; {
                     546   ; Can1_ModeControlReg = ClrByte;
08000158  4239 0050  547          clr.b     5243392
0800015C  0200      
0800015E  60EC       548          bra       Init_CanBus_Controller1_4
                     549   Init_CanBus_Controller1_6:
08000160  4E75       550          rts
                     551   ; }
                     552   ; }
                     553   ; // Transmit for sending a message via Can controller 0
                     554   ; void CanBus0_Transmit(unsigned char data)
                     555   ; {
                     556   _CanBus0_Transmit:
08000162  4E56 0000  557          link      A6,#0
                     558   ; // TODO - put your Canbus transmit code for CanController 0 here
                     559   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                     560   ; //printf("\r\nTransmitting Can controller 0");
                     561   ; while((Can0_StatusReg & TBS_Bit ) != TBS_Bit ) {}
                     562   CanBus0_Transmit_1:
08000166  1039 0050  563          move.b    5242884,D0
0800016A  0004      
0800016C  C03C 0004  564          and.b     #4,D0
08000170  0C00 0004  565          cmp.b     #4,D0
08000174  6702       566          beq.s     CanBus0_Transmit_3
08000176  60EE       567          bra       CanBus0_Transmit_1
                     568   CanBus0_Transmit_3:
                     569   ; // frame format = 0 (standard), RTR = 0 (data framee), DLC = b'1000 (8 bytes), see data sheet page 40-41
                     570   ; Can0_TxFrameInfo = 0x08;
08000178  13FC 0008  571          move.b    #8,5242912
0800017C  0050 0020 
                     572   ; // 11 bits identifier, don't care, since we don't have filtering
                     573   ; Can0_TxBuffer1 = 0x00;
08000180  4239 0050  574          clr.b     5242914
08000184  0022      
                     575   ; Can0_TxBuffer2 = 0x00;
08000186  4239 0050  576          clr.b     5242916
0800018A  0024      
                     577   ; // 8 bytes data;
                     578   ; Can0_TxBuffer3 = data;
0800018C  13EE 000B  579          move.b    11(A6),5242918
08000190  0050 0026 
                     580   ; /*Can0_TxBuffer4 = 0x01;
                     581   ; Can0_TxBuffer5 = 0x02;
                     582   ; Can0_TxBuffer6 = 0x03;
                     583   ; Can0_TxBuffer7 = 0x04;
                     584   ; Can0_TxBuffer8 = 0x05;
                     585   ; Can0_TxBuffer9 = 0x06;
                     586   ; Can0_TxBuffer10 = 0x07;*/
                     587   ; Can0_CommandReg = TR_Bit;
08000194  13FC 0001  588          move.b    #1,5242882
08000198  0050 0002 
                     589   ; // wait for the transmission to complete
                     590   ; while((Can0_StatusReg & TCS_Bit ) != TCS_Bit ) {}
                     591   CanBus0_Transmit_4:
0800019C  1039 0050  592          move.b    5242884,D0
080001A0  0004      
080001A2  C03C 0008  593          and.b     #8,D0
080001A6  0C00 0008  594          cmp.b     #8,D0
080001AA  6702       595          beq.s     CanBus0_Transmit_6
080001AC  60EE       596          bra       CanBus0_Transmit_4
                     597   CanBus0_Transmit_6:
080001AE  4E5E       598          unlk      A6
080001B0  4E75       599          rts
                     600   ; }
                     601   ; // Transmit for sending a message via Can controller 1
                     602   ; void CanBus1_Transmit(void)
                     603   ; {
                     604   _CanBus1_Transmit:
                     605   ; // TODO - put your Canbus transmit code for CanController 1 here
                     606   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                     607   ; //printf("\r\nTransmitting Can controller 1");
                     608   ; while((Can1_StatusReg & TBS_Bit ) != TBS_Bit ) {}
                     609   CanBus1_Transmit_1:
080001B2  1039 0050  610          move.b    5243396,D0
080001B6  0204      
080001B8  C03C 0004  611          and.b     #4,D0
080001BC  0C00 0004  612          cmp.b     #4,D0
080001C0  6702       613          beq.s     CanBus1_Transmit_3
080001C2  60EE       614          bra       CanBus1_Transmit_1
                     615   CanBus1_Transmit_3:
                     616   ; // frame format = 0 (standard), RTR = 0 (data framee), DLC = b'1000 (8 bytes), see data sheet page 40-41
                     617   ; Can1_TxFrameInfo = 0x08;
080001C4  13FC 0008  618          move.b    #8,5243424
080001C8  0050 0220 
                     619   ; // 11 bits identifier, don't care, since we don't have filtering
                     620   ; Can1_TxBuffer1 = 0x00;
080001CC  4239 0050  621          clr.b     5243426
080001D0  0222      
                     622   ; Can1_TxBuffer2 = 0x00;
080001D2  4239 0050  623          clr.b     5243428
080001D6  0224      
                     624   ; // 8 bytes data;
                     625   ; Can1_TxBuffer3 = 0x07;
080001D8  13FC 0007  626          move.b    #7,5243430
080001DC  0050 0226 
                     627   ; Can1_TxBuffer4 = 0x06;
080001E0  13FC 0006  628          move.b    #6,5243432
080001E4  0050 0228 
                     629   ; Can1_TxBuffer5 = 0x05;
080001E8  13FC 0005  630          move.b    #5,5243434
080001EC  0050 022A 
                     631   ; Can1_TxBuffer6 = 0x04;
080001F0  13FC 0004  632          move.b    #4,5243436
080001F4  0050 022C 
                     633   ; Can1_TxBuffer7 = 0x03;
080001F8  13FC 0003  634          move.b    #3,5243438
080001FC  0050 022E 
                     635   ; Can1_TxBuffer8 = 0x02;
08000200  13FC 0002  636          move.b    #2,5243440
08000204  0050 0230 
                     637   ; Can1_TxBuffer9 = 0x01;
08000208  13FC 0001  638          move.b    #1,5243442
0800020C  0050 0232 
                     639   ; Can1_TxBuffer10 = 0x00;
08000210  4239 0050  640          clr.b     5243444
08000214  0234      
                     641   ; Can1_CommandReg = TR_Bit;
08000216  13FC 0001  642          move.b    #1,5243394
0800021A  0050 0202 
                     643   ; // wait for the transmission to complete
                     644   ; while((Can1_StatusReg & TCS_Bit ) != TCS_Bit ) {}
                     645   CanBus1_Transmit_4:
0800021E  1039 0050  646          move.b    5243396,D0
08000222  0204      
08000224  C03C 0008  647          and.b     #8,D0
08000228  0C00 0008  648          cmp.b     #8,D0
0800022C  6702       649          beq.s     CanBus1_Transmit_6
0800022E  60EE       650          bra       CanBus1_Transmit_4
                     651   CanBus1_Transmit_6:
08000230  4E75       652          rts
                     653   ; }
                     654   ; // Receive for reading a received message via Can controller 0
                     655   ; void CanBus0_Receive(void)
                     656   ; {
                     657   _CanBus0_Receive:
08000232  2F0A       658          move.l    A2,-(A7)
08000234  45F9 0800  659          lea       _printf.L,A2
08000238  13A8      
                     660   ; // TODO - put your Canbus receive code for CanController 0 here
                     661   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                     662   ; // wait for the receiver buffer to be full
                     663   ; //printf("\r\nReading Can controller 0");
                     664   ; while ((Can0_StatusReg & RBS_Bit) != RBS_Bit) {}
                     665   CanBus0_Receive_1:
0800023A  1039 0050  666          move.b    5242884,D0
0800023E  0004      
08000240  C03C 0001  667          and.b     #1,D0
08000244  0C00 0001  668          cmp.b     #1,D0
08000248  6702       669          beq.s     CanBus0_Receive_3
0800024A  60EE       670          bra       CanBus0_Receive_1
                     671   CanBus0_Receive_3:
                     672   ; printf("\r\n%x",Can0_RxBuffer3);
0800024C  1239 0050  673          move.b    5242918,D1
08000250  0026      
08000252  C2BC 0000  674          and.l     #255,D1
08000256  00FF      
08000258  2F01       675          move.l    D1,-(A7)
0800025A  4879 0800  676          pea       @m68kus~1_1.L
0800025E  1D2E      
08000260  4E92       677          jsr       (A2)
08000262  504F       678          addq.w    #8,A7
                     679   ; printf("\r\n%x",Can0_RxBuffer4);
08000264  1239 0050  680          move.b    5242920,D1
08000268  0028      
0800026A  C2BC 0000  681          and.l     #255,D1
0800026E  00FF      
08000270  2F01       682          move.l    D1,-(A7)
08000272  4879 0800  683          pea       @m68kus~1_1.L
08000276  1D2E      
08000278  4E92       684          jsr       (A2)
0800027A  504F       685          addq.w    #8,A7
                     686   ; printf("\r\n%x",Can0_RxBuffer5);
0800027C  1239 0050  687          move.b    5242922,D1
08000280  002A      
08000282  C2BC 0000  688          and.l     #255,D1
08000286  00FF      
08000288  2F01       689          move.l    D1,-(A7)
0800028A  4879 0800  690          pea       @m68kus~1_1.L
0800028E  1D2E      
08000290  4E92       691          jsr       (A2)
08000292  504F       692          addq.w    #8,A7
                     693   ; printf("\r\n%x",Can0_RxBuffer6);
08000294  1239 0050  694          move.b    5242924,D1
08000298  002C      
0800029A  C2BC 0000  695          and.l     #255,D1
0800029E  00FF      
080002A0  2F01       696          move.l    D1,-(A7)
080002A2  4879 0800  697          pea       @m68kus~1_1.L
080002A6  1D2E      
080002A8  4E92       698          jsr       (A2)
080002AA  504F       699          addq.w    #8,A7
                     700   ; printf("\r\n%x",Can0_RxBuffer7);
080002AC  1239 0050  701          move.b    5242926,D1
080002B0  002E      
080002B2  C2BC 0000  702          and.l     #255,D1
080002B6  00FF      
080002B8  2F01       703          move.l    D1,-(A7)
080002BA  4879 0800  704          pea       @m68kus~1_1.L
080002BE  1D2E      
080002C0  4E92       705          jsr       (A2)
080002C2  504F       706          addq.w    #8,A7
                     707   ; printf("\r\n%x",Can0_RxBuffer8);
080002C4  1239 0050  708          move.b    5242928,D1
080002C8  0030      
080002CA  C2BC 0000  709          and.l     #255,D1
080002CE  00FF      
080002D0  2F01       710          move.l    D1,-(A7)
080002D2  4879 0800  711          pea       @m68kus~1_1.L
080002D6  1D2E      
080002D8  4E92       712          jsr       (A2)
080002DA  504F       713          addq.w    #8,A7
                     714   ; printf("\r\n%x",Can0_RxBuffer9);
080002DC  1239 0050  715          move.b    5242930,D1
080002E0  0032      
080002E2  C2BC 0000  716          and.l     #255,D1
080002E6  00FF      
080002E8  2F01       717          move.l    D1,-(A7)
080002EA  4879 0800  718          pea       @m68kus~1_1.L
080002EE  1D2E      
080002F0  4E92       719          jsr       (A2)
080002F2  504F       720          addq.w    #8,A7
                     721   ; printf("\r\n%x",Can0_RxBuffer10);
080002F4  1239 0050  722          move.b    5242932,D1
080002F8  0034      
080002FA  C2BC 0000  723          and.l     #255,D1
080002FE  00FF      
08000300  2F01       724          move.l    D1,-(A7)
08000302  4879 0800  725          pea       @m68kus~1_1.L
08000306  1D2E      
08000308  4E92       726          jsr       (A2)
0800030A  504F       727          addq.w    #8,A7
                     728   ; Can0_CommandReg = RRB_Bit;
0800030C  13FC 0004  729          move.b    #4,5242882
08000310  0050 0002 
08000314  245F       730          move.l    (A7)+,A2
08000316  4E75       731          rts
                     732   ; }
                     733   ; // Receive for reading a received message via Can controller 1
                     734   ; void CanBus1_Receive(void)
                     735   ; {
                     736   _CanBus1_Receive:
                     737   ; // TODO - put your Canbus receive code for CanController 1 here
                     738   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                     739   ; //printf("\r\nReading Can controller 1");
                     740   ; while ((Can1_StatusReg & RBS_Bit) != RBS_Bit) {}
                     741   CanBus1_Receive_1:
08000318  1039 0050  742          move.b    5243396,D0
0800031C  0204      
0800031E  C03C 0001  743          and.b     #1,D0
08000322  0C00 0001  744          cmp.b     #1,D0
08000326  6702       745          beq.s     CanBus1_Receive_3
08000328  60EE       746          bra       CanBus1_Receive_1
                     747   CanBus1_Receive_3:
                     748   ; printf("\r\n%x",Can1_RxBuffer3);
0800032A  1239 0050  749          move.b    5243430,D1
0800032E  0226      
08000330  C2BC 0000  750          and.l     #255,D1
08000334  00FF      
08000336  2F01       751          move.l    D1,-(A7)
08000338  4879 0800  752          pea       @m68kus~1_1.L
0800033C  1D2E      
0800033E  4EB9 0800  753          jsr       _printf
08000342  13A8      
08000344  504F       754          addq.w    #8,A7
                     755   ; /*printf("\r\n%x",Can1_RxBuffer4);
                     756   ; printf("\r\n%x",Can1_RxBuffer5);
                     757   ; printf("\r\n%x",Can1_RxBuffer6);
                     758   ; printf("\r\n%x",Can1_RxBuffer7);
                     759   ; printf("\r\n%x",Can1_RxBuffer8);
                     760   ; printf("\r\n%x",Can1_RxBuffer9);
                     761   ; printf("\r\n%x",Can1_RxBuffer10);*/
                     762   ; Can1_CommandReg = RRB_Bit;
08000346  13FC 0004  763          move.b    #4,5243394
0800034A  0050 0202 
0800034E  4E75       764          rts
                     765   ; }
                     766   ; void CanBusTest(void)
                     767   ; {
                     768   _CanBusTest:
08000350  2F0A       769          move.l    A2,-(A7)
08000352  45F9 0800  770          lea       _printf.L,A2
08000356  13A8      
                     771   ; // initialise the two Can controllers
                     772   ; Init_CanBus_Controller0();
08000358  4EB9 0800  773          jsr       _Init_CanBus_Controller0
0800035C  003E      
                     774   ; Init_CanBus_Controller1();
0800035E  4EB9 0800  775          jsr       _Init_CanBus_Controller1
08000362  00D0      
                     776   ; printf("\r\n\r\n---- CANBUS Test ----\r\n") ;
08000364  4879 0800  777          pea       @m68kus~1_2.L
08000368  1D34      
0800036A  4E92       778          jsr       (A2)
0800036C  584F       779          addq.w    #4,A7
                     780   ; // simple application to alternately transmit and receive messages from each of two nodes
                     781   ; Wait500ms ();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
0800036E  4EB9 0800  782          jsr       _Wait500ms
08000372  0EFE      
                     783   ; CanBus0_Transmit() ;       // transmit a message via Controller 0
08000374  4EB9 0800  784          jsr       _CanBus0_Transmit
08000378  0162      
                     785   ; CanBus1_Receive() ;        // receive a message via Controller 1 (and display it)
0800037A  4EB9 0800  786          jsr       _CanBus1_Receive
0800037E  0318      
                     787   ; printf("\r\n") ;
08000380  4879 0800  788          pea       @m68kus~1_3.L
08000384  1D50      
08000386  4E92       789          jsr       (A2)
08000388  584F       790          addq.w    #4,A7
                     791   ; Wait500ms ();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
0800038A  4EB9 0800  792          jsr       _Wait500ms
0800038E  0EFE      
                     793   ; CanBus1_Transmit() ;        // transmit a message via Controller 1
08000390  4EB9 0800  794          jsr       _CanBus1_Transmit
08000394  01B2      
                     795   ; CanBus0_Receive() ;         // receive a message via Controller 0 (and display it)
08000396  4EB9 0800  796          jsr       _CanBus0_Receive
0800039A  0232      
                     797   ; printf("\r\n") ;
0800039C  4879 0800  798          pea       @m68kus~1_3.L
080003A0  1D50      
080003A2  4E92       799          jsr       (A2)
080003A4  584F       800          addq.w    #4,A7
080003A6  245F       801          move.l    (A7)+,A2
080003A8  4E75       802          rts
                     803   ; }
                     804   ; /*******************************************************************************************
                     805   ; ** I2C functions
                     806   ; *******************************************************************************************/
                     807   ; unsigned int ask_EEPROM_internal_addr(void){
                     808   _ask_EEPROM_internal_addr:
080003AA  48E7 3000  809          movem.l   D2/D3,-(A7)
                     810   ; // ask the internal EEPROM address, return an array, storing the upper byte at location 0, and the lower byte at 1, the block select at 2
                     811   ; int valid = 0;
080003AE  4283       812          clr.l     D3
                     813   ; unsigned int addr;
                     814   ; printf("\r\nWhat is the internal EEPROM address you want to access? ");
080003B0  4879 0800  815          pea       @m68kus~1_4.L
080003B4  1D54      
080003B6  4EB9 0800  816          jsr       _printf
080003BA  13A8      
080003BC  584F       817          addq.w    #4,A7
                     818   ; while (!valid){
                     819   ask_EEPROM_internal_addr_1:
080003BE  4A83       820          tst.l     D3
080003C0  6628       821          bne.s     ask_EEPROM_internal_addr_3
                     822   ; addr = Get6HexDigits(0);
080003C2  42A7       823          clr.l     -(A7)
080003C4  4EB9 0800  824          jsr       _Get6HexDigits
080003C8  109E      
080003CA  584F       825          addq.w    #4,A7
080003CC  2400       826          move.l    D0,D2
                     827   ; if (addr > 0x01ffff) { // 128k byte memory
080003CE  0C82 0001  828          cmp.l     #131071,D2
080003D2  FFFF      
080003D4  6310       829          bls.s     ask_EEPROM_internal_addr_4
                     830   ; printf("\r\nAddress cannot be greater than 0x01ffff! Input again: ");
080003D6  4879 0800  831          pea       @m68kus~1_5.L
080003DA  1D90      
080003DC  4EB9 0800  832          jsr       _printf
080003E0  13A8      
080003E2  584F       833          addq.w    #4,A7
080003E4  6002       834          bra.s     ask_EEPROM_internal_addr_5
                     835   ask_EEPROM_internal_addr_4:
                     836   ; } else {
                     837   ; valid = 1;
080003E6  7601       838          moveq     #1,D3
                     839   ask_EEPROM_internal_addr_5:
080003E8  60D4       840          bra       ask_EEPROM_internal_addr_1
                     841   ask_EEPROM_internal_addr_3:
                     842   ; }
                     843   ; }
                     844   ; return addr;
080003EA  2002       845          move.l    D2,D0
080003EC  4CDF 000C  846          movem.l   (A7)+,D2/D3
080003F0  4E75       847          rts
                     848   ; }
                     849   ; unsigned char ask_EEPROM_data(void){
                     850   _ask_EEPROM_data:
080003F2  4E56 FFFC  851          link      A6,#-4
                     852   ; // ask the data to be written into the EEPROM
                     853   ; unsigned char data;
                     854   ; printf("\r\nWhat is the data you want to write into the EEPROM? ");
080003F6  4879 0800  855          pea       @m68kus~1_6.L
080003FA  1DCA      
080003FC  4EB9 0800  856          jsr       _printf
08000400  13A8      
08000402  584F       857          addq.w    #4,A7
                     858   ; data = Get2HexDigits(0);
08000404  42A7       859          clr.l     -(A7)
08000406  4EB9 0800  860          jsr       _Get2HexDigits
0800040A  1018      
0800040C  584F       861          addq.w    #4,A7
0800040E  1D40 FFFF  862          move.b    D0,-1(A6)
                     863   ; return data;
08000412  102E FFFF  864          move.b    -1(A6),D0
08000416  4E5E       865          unlk      A6
08000418  4E75       866          rts
                     867   ; }
                     868   ; void EEPROM_internal_writting_polling(unsigned char slave_addr_RW){
                     869   _EEPROM_internal_writting_pollin:
0800041A  4E56 0000  870          link      A6,#0
0800041E  2F02       871          move.l    D2,-(A7)
                     872   ; int flag = 1;
08000420  7401       873          moveq     #1,D2
                     874   ; // EEPROM acknowledge polling, wait for EEPROM's internal writting
                     875   ; // send the writting control byte with a start signal
                     876   ; I2C_TX_reg = slave_addr_RW;
08000422  13EE 000B  877          move.b    11(A6),4227078
08000426  0040 8006 
                     878   ; while (flag) {
                     879   EEPROM_internal_writting_pollin_1:
0800042A  4A82       880          tst.l     D2
0800042C  672A       881          beq.s     EEPROM_internal_writting_pollin_3
                     882   ; I2C_command_reg = start_write_cmd_I2C;
0800042E  13FC 0091  883          move.b    #145,4227080
08000432  0040 8008 
                     884   ; // wait for the master core to finish transmitting
                     885   ; while ((I2C_status_reg & 0x02) != 0){}
                     886   EEPROM_internal_writting_pollin_4:
08000436  1039 0040  887          move.b    4227080,D0
0800043A  8008      
0800043C  C03C 0002  888          and.b     #2,D0
08000440  6702       889          beq.s     EEPROM_internal_writting_pollin_6
08000442  60F2       890          bra       EEPROM_internal_writting_pollin_4
                     891   EEPROM_internal_writting_pollin_6:
                     892   ; // if we didn't get ACK bit, then EEPROM is done writting, quit polling 
                     893   ; if ((I2C_status_reg & 0x80) == 0) {
08000444  1039 0040  894          move.b    4227080,D0
08000448  8008      
0800044A  C07C 00FF  895          and.w     #255,D0
0800044E  C07C 0080  896          and.w     #128,D0
08000452  6602       897          bne.s     EEPROM_internal_writting_pollin_7
                     898   ; flag = 0;
08000454  4282       899          clr.l     D2
                     900   EEPROM_internal_writting_pollin_7:
08000456  60D2       901          bra       EEPROM_internal_writting_pollin_1
                     902   EEPROM_internal_writting_pollin_3:
08000458  241F       903          move.l    (A7)+,D2
0800045A  4E5E       904          unlk      A6
0800045C  4E75       905          rts
                     906   ; }
                     907   ; }
                     908   ; }
                     909   ; void I2C_init (void) {
                     910   _I2C_init:
                     911   ; // disenable the core to allow us to set the prescale registers
                     912   ; I2C_control_reg = 0x00; 
0800045E  4239 0040  913          clr.b     4227076
08000462  8004      
                     914   ; // set prescale registers to 0x0031
                     915   ; I2C_prescale_reg_L = 0x31;
08000464  13FC 0031  916          move.b    #49,4227072
08000468  0040 8000 
                     917   ; I2C_prescale_reg_H = 0x00;
0800046C  4239 0040  918          clr.b     4227074
08000470  8002      
                     919   ; // enable the core, disenable the interrupt
                     920   ; I2C_control_reg = 0x80;
08000472  13FC 0080  921          move.b    #128,4227076
08000476  0040 8004 
0800047A  4E75       922          rts
                     923   ; }
                     924   ; void I2C_TX_command_status (unsigned char data, unsigned char command) {
                     925   _I2C_TX_command_status:
0800047C  4E56 0000  926          link      A6,#0
                     927   ; //printf("\r\ndata: %x", data);
                     928   ; //printf("\r\ncommand: %x", command);
                     929   ; I2C_TX_reg = data;
08000480  13EE 000B  930          move.b    11(A6),4227078
08000484  0040 8006 
                     931   ; I2C_command_reg = command;
08000488  13EE 000F  932          move.b    15(A6),4227080
0800048C  0040 8008 
                     933   ; // check the TIP bit, if it's 1, we wait here
                     934   ; while ((I2C_status_reg & 0x02) != 0){}
                     935   I2C_TX_command_status_1:
08000490  1039 0040  936          move.b    4227080,D0
08000494  8008      
08000496  C03C 0002  937          and.b     #2,D0
0800049A  6702       938          beq.s     I2C_TX_command_status_3
0800049C  60F2       939          bra       I2C_TX_command_status_1
                     940   I2C_TX_command_status_3:
                     941   ; //printf("\r\nTIP done");
                     942   ; // wait for acknowledge from slave
                     943   ; while ((I2C_status_reg & 0x80) != 0){
                     944   I2C_TX_command_status_4:
0800049E  1039 0040  945          move.b    4227080,D0
080004A2  8008      
080004A4  C07C 00FF  946          and.w     #255,D0
080004A8  C07C 0080  947          and.w     #128,D0
080004AC  6702       948          beq.s     I2C_TX_command_status_6
                     949   ; //printf("\r\n%x", I2C_status_reg);
                     950   ; }
080004AE  60EE       951          bra       I2C_TX_command_status_4
                     952   I2C_TX_command_status_6:
080004B0  4E5E       953          unlk      A6
080004B2  4E75       954          rts
                     955   ; //printf("\r\nACK received");
                     956   ; }
                     957   ; void I2C_byte_write (void) {
                     958   _I2C_byte_write:
080004B4  4E56 FFF8  959          link      A6,#-8
080004B8  48E7 3020  960          movem.l   D2/D3/A2,-(A7)
080004BC  45F9 0800  961          lea       _I2C_TX_command_status.L,A2
080004C0  047C      
                     962   ; unsigned char slave_addr_RW;
                     963   ; unsigned char slave_write_data;
                     964   ; unsigned char EEPROM_block_select;
                     965   ; unsigned char EEPROM_internal_addr_H, EEPROM_internal_addr_L;
                     966   ; unsigned int addr;
                     967   ; int EEPROM_polling_flag = 1;
080004C2  2D7C 0000  968          move.l    #1,-4(A6)
080004C6  0001 FFFC 
                     969   ; printf("\r\nRandom EEPROM byte write");
080004CA  4879 0800  970          pea       @m68kus~1_7.L
080004CE  1E02      
080004D0  4EB9 0800  971          jsr       _printf
080004D4  13A8      
080004D6  584F       972          addq.w    #4,A7
                     973   ; // get the internal address
                     974   ; addr = ask_EEPROM_internal_addr();
080004D8  4EB9 0800  975          jsr       _ask_EEPROM_internal_addr
080004DC  03AA      
080004DE  2400       976          move.l    D0,D2
                     977   ; EEPROM_internal_addr_H = (addr & 0x00ff00) >> 8;
080004E0  2002       978          move.l    D2,D0
080004E2  C0BC 0000  979          and.l     #65280,D0
080004E6  FF00      
080004E8  E088       980          lsr.l     #8,D0
080004EA  1D40 FFFA  981          move.b    D0,-6(A6)
                     982   ; EEPROM_internal_addr_L = addr & 0x0000ff;
080004EE  2002       983          move.l    D2,D0
080004F0  C0BC 0000  984          and.l     #255,D0
080004F4  00FF      
080004F6  1D40 FFFB  985          move.b    D0,-5(A6)
                     986   ; EEPROM_block_select = (addr & 0x010000) >> 16;
080004FA  2002       987          move.l    D2,D0
080004FC  C0BC 0001  988          and.l     #65536,D0
08000500  0000      
08000502  E088       989          lsr.l     #8,D0
08000504  E088       990          lsr.l     #8,D0
08000506  1D40 FFF9  991          move.b    D0,-7(A6)
                     992   ; slave_write_data = ask_EEPROM_data();
0800050A  4EB9 0800  993          jsr       _ask_EEPROM_data
0800050E  03F2      
08000510  1D40 FFF8  994          move.b    D0,-8(A6)
                     995   ; // EEPROM tag (b'1010) + chip select ('b00) + block select + write (0)
                     996   ; slave_addr_RW = (0xa0 | (EEPROM_block_select << 1));
08000514  303C 00A0  997          move.w    #160,D0
08000518  122E FFF9  998          move.b    -7(A6),D1
0800051C  E309       999          lsl.b     #1,D1
0800051E  C27C 00FF 1000          and.w     #255,D1
08000522  8041      1001          or.w      D1,D0
08000524  1600      1002          move.b    D0,D3
                    1003   ; // send the control byte and generate a start signal
                    1004   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
08000526  4878 0091 1005          pea       145
0800052A  4883      1006          ext.w     D3
0800052C  48C3      1007          ext.l     D3
0800052E  2F03      1008          move.l    D3,-(A7)
08000530  4E92      1009          jsr       (A2)
08000532  504F      1010          addq.w    #8,A7
                    1011   ; // write EEPROM internal addr (upper and lower byte), no start signal
                    1012   ; I2C_TX_command_status(EEPROM_internal_addr_H, write_cmd_I2C);
08000534  4878 0011 1013          pea       17
08000538  122E FFFA 1014          move.b    -6(A6),D1
0800053C  4881      1015          ext.w     D1
0800053E  48C1      1016          ext.l     D1
08000540  2F01      1017          move.l    D1,-(A7)
08000542  4E92      1018          jsr       (A2)
08000544  504F      1019          addq.w    #8,A7
                    1020   ; I2C_TX_command_status(EEPROM_internal_addr_L, write_cmd_I2C);
08000546  4878 0011 1021          pea       17
0800054A  122E FFFB 1022          move.b    -5(A6),D1
0800054E  4881      1023          ext.w     D1
08000550  48C1      1024          ext.l     D1
08000552  2F01      1025          move.l    D1,-(A7)
08000554  4E92      1026          jsr       (A2)
08000556  504F      1027          addq.w    #8,A7
                    1028   ; // write the actual data, and generate a stop condition after receiving an Acknowledge from the slave
                    1029   ; I2C_TX_command_status(slave_write_data, stop_write_cmd_I2C);
08000558  4878 0051 1030          pea       81
0800055C  122E FFF8 1031          move.b    -8(A6),D1
08000560  4881      1032          ext.w     D1
08000562  48C1      1033          ext.l     D1
08000564  2F01      1034          move.l    D1,-(A7)
08000566  4E92      1035          jsr       (A2)
08000568  504F      1036          addq.w    #8,A7
                    1037   ; EEPROM_internal_writting_polling(slave_addr_RW);
0800056A  C6BC 0000 1038          and.l     #255,D3
0800056E  00FF      
08000570  2F03      1039          move.l    D3,-(A7)
08000572  4EB9 0800 1040          jsr       _EEPROM_internal_writting_pollin
08000576  041A      
08000578  584F      1041          addq.w    #4,A7
                    1042   ; printf("\r\nEEPROM writting done!");
0800057A  4879 0800 1043          pea       @m68kus~1_8.L
0800057E  1E1E      
08000580  4EB9 0800 1044          jsr       _printf
08000584  13A8      
08000586  584F      1045          addq.w    #4,A7
08000588  4CDF 040C 1046          movem.l   (A7)+,D2/D3/A2
0800058C  4E5E      1047          unlk      A6
0800058E  4E75      1048          rts
                    1049   ; }
                    1050   ; void I2C_byte_read (void) {
                    1051   _I2C_byte_read:
08000590  4E56 FFFC 1052          link      A6,#-4
08000594  48E7 3820 1053          movem.l   D2/D3/D4/A2,-(A7)
08000598  45F9 0800 1054          lea       _I2C_TX_command_status.L,A2
0800059C  047C      
                    1055   ; char slave_addr_RW;
                    1056   ; unsigned char slave_read_data;
                    1057   ; unsigned char EEPROM_block_select;
                    1058   ; unsigned int addr;
                    1059   ; unsigned char EEPROM_internal_addr_H, EEPROM_internal_addr_L;
                    1060   ; printf("\r\nRandom EEPROM byte read");
0800059E  4879 0800 1061          pea       @m68kus~1_9.L
080005A2  1E36      
080005A4  4EB9 0800 1062          jsr       _printf
080005A8  13A8      
080005AA  584F      1063          addq.w    #4,A7
                    1064   ; // get the internal address
                    1065   ; addr = ask_EEPROM_internal_addr();
080005AC  4EB9 0800 1066          jsr       _ask_EEPROM_internal_addr
080005B0  03AA      
080005B2  2600      1067          move.l    D0,D3
                    1068   ; EEPROM_internal_addr_H = (addr & 0x00ff00) >> 8;
080005B4  2003      1069          move.l    D3,D0
080005B6  C0BC 0000 1070          and.l     #65280,D0
080005BA  FF00      
080005BC  E088      1071          lsr.l     #8,D0
080005BE  1D40 FFFE 1072          move.b    D0,-2(A6)
                    1073   ; EEPROM_internal_addr_L = addr & 0x0000ff;
080005C2  2003      1074          move.l    D3,D0
080005C4  C0BC 0000 1075          and.l     #255,D0
080005C8  00FF      
080005CA  1D40 FFFF 1076          move.b    D0,-1(A6)
                    1077   ; EEPROM_block_select = (addr & 0x010000) >> 16;
080005CE  2003      1078          move.l    D3,D0
080005D0  C0BC 0001 1079          and.l     #65536,D0
080005D4  0000      
080005D6  E088      1080          lsr.l     #8,D0
080005D8  E088      1081          lsr.l     #8,D0
080005DA  1800      1082          move.b    D0,D4
                    1083   ; // EEPROM tag (b'1010) + chip select ('b00) + block select + write (0)
                    1084   ; slave_addr_RW = (0xa0 | (EEPROM_block_select << 1));
080005DC  303C 00A0 1085          move.w    #160,D0
080005E0  1204      1086          move.b    D4,D1
080005E2  E309      1087          lsl.b     #1,D1
080005E4  C27C 00FF 1088          and.w     #255,D1
080005E8  8041      1089          or.w      D1,D0
080005EA  1400      1090          move.b    D0,D2
                    1091   ; // send the control byte and generate a start signal
                    1092   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
080005EC  4878 0091 1093          pea       145
080005F0  4882      1094          ext.w     D2
080005F2  48C2      1095          ext.l     D2
080005F4  2F02      1096          move.l    D2,-(A7)
080005F6  4E92      1097          jsr       (A2)
080005F8  504F      1098          addq.w    #8,A7
                    1099   ; // write EEPROM internal addr (upper and lower byte), no start signal
                    1100   ; I2C_TX_command_status(EEPROM_internal_addr_H, write_cmd_I2C);
080005FA  4878 0011 1101          pea       17
080005FE  122E FFFE 1102          move.b    -2(A6),D1
08000602  4881      1103          ext.w     D1
08000604  48C1      1104          ext.l     D1
08000606  2F01      1105          move.l    D1,-(A7)
08000608  4E92      1106          jsr       (A2)
0800060A  504F      1107          addq.w    #8,A7
                    1108   ; I2C_TX_command_status(EEPROM_internal_addr_L, write_cmd_I2C);
0800060C  4878 0011 1109          pea       17
08000610  122E FFFF 1110          move.b    -1(A6),D1
08000614  4881      1111          ext.w     D1
08000616  48C1      1112          ext.l     D1
08000618  2F01      1113          move.l    D1,-(A7)
0800061A  4E92      1114          jsr       (A2)
0800061C  504F      1115          addq.w    #8,A7
                    1116   ; // EEPROM tag (b'1010) + chip select ('b00) + block select + read (1)
                    1117   ; slave_addr_RW = (0xa1 | (EEPROM_block_select << 1));
0800061E  303C 00A1 1118          move.w    #161,D0
08000622  1204      1119          move.b    D4,D1
08000624  E309      1120          lsl.b     #1,D1
08000626  C27C 00FF 1121          and.w     #255,D1
0800062A  8041      1122          or.w      D1,D0
0800062C  1400      1123          move.b    D0,D2
                    1124   ; // send the control byte and generate a repeated start signal
                    1125   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
0800062E  4878 0091 1126          pea       145
08000632  4882      1127          ext.w     D2
08000634  48C2      1128          ext.l     D2
08000636  2F02      1129          move.l    D2,-(A7)
08000638  4E92      1130          jsr       (A2)
0800063A  504F      1131          addq.w    #8,A7
                    1132   ; // set STO bit to 1, set RD bit to 1, set ACk to 1 (NACK), set IACK to 1
                    1133   ; I2C_command_reg = stop_read_NACK_cmd_I2C;
0800063C  13FC 0069 1134          move.b    #105,4227080
08000640  0040 8008 
                    1135   ; // polling the IF flag in the status reg
                    1136   ; while ((I2C_status_reg & 0x01) != 1){}
                    1137   I2C_byte_read_1:
08000644  1039 0040 1138          move.b    4227080,D0
08000648  8008      
0800064A  C03C 0001 1139          and.b     #1,D0
0800064E  0C00 0001 1140          cmp.b     #1,D0
08000652  6702      1141          beq.s     I2C_byte_read_3
08000654  60EE      1142          bra       I2C_byte_read_1
                    1143   I2C_byte_read_3:
                    1144   ; slave_read_data = I2C_RX_reg;
08000656  1D79 0040 1145          move.b    4227078,-3(A6)
0800065A  8006 FFFD 
                    1146   ; printf("\r\nEEPROM reading done! %x",slave_read_data);
0800065E  122E FFFD 1147          move.b    -3(A6),D1
08000662  C2BC 0000 1148          and.l     #255,D1
08000666  00FF      
08000668  2F01      1149          move.l    D1,-(A7)
0800066A  4879 0800 1150          pea       @m68kus~1_10.L
0800066E  1E50      
08000670  4EB9 0800 1151          jsr       _printf
08000674  13A8      
08000676  504F      1152          addq.w    #8,A7
08000678  4CDF 041C 1153          movem.l   (A7)+,D2/D3/D4/A2
0800067C  4E5E      1154          unlk      A6
0800067E  4E75      1155          rts
                    1156   ; }
                    1157   ; unsigned int ask_EEPROM_addr_range(void) {
                    1158   _ask_EEPROM_addr_range:
08000680  48E7 3020 1159          movem.l   D2/D3/A2,-(A7)
08000684  45F9 0800 1160          lea       _printf.L,A2
08000688  13A8      
                    1161   ; unsigned int size;
                    1162   ; int valid = 0;
0800068A  4283      1163          clr.l     D3
                    1164   ; printf("\r\nWhat is the EEPROM address range size (in hex) you want to access? ");
0800068C  4879 0800 1165          pea       @m68kus~1_11.L
08000690  1E6A      
08000692  4E92      1166          jsr       (A2)
08000694  584F      1167          addq.w    #4,A7
                    1168   ; while (!valid) {
                    1169   ask_EEPROM_addr_range_1:
08000696  4A83      1170          tst.l     D3
08000698  6600 0036 1171          bne       ask_EEPROM_addr_range_3
                    1172   ; size = Get6HexDigits(0);
0800069C  42A7      1173          clr.l     -(A7)
0800069E  4EB9 0800 1174          jsr       _Get6HexDigits
080006A2  109E      
080006A4  584F      1175          addq.w    #4,A7
080006A6  2400      1176          move.l    D0,D2
                    1177   ; if (size > 0x020000) {
080006A8  0C82 0002 1178          cmp.l     #131072,D2
080006AC  0000      
080006AE  630C      1179          bls.s     ask_EEPROM_addr_range_4
                    1180   ; printf ("\r\nSize cannot be larger than 'h020000 (128K bytes), input again: ");
080006B0  4879 0800 1181          pea       @m68kus~1_12.L
080006B4  1EB0      
080006B6  4E92      1182          jsr       (A2)
080006B8  584F      1183          addq.w    #4,A7
080006BA  6012      1184          bra.s     ask_EEPROM_addr_range_7
                    1185   ask_EEPROM_addr_range_4:
                    1186   ; } else if (size == 0) {
080006BC  4A82      1187          tst.l     D2
080006BE  660C      1188          bne.s     ask_EEPROM_addr_range_6
                    1189   ; printf("\r\nSize cannot be 0, the minimum size is 'h000001 (1 byte), input again: ");
080006C0  4879 0800 1190          pea       @m68kus~1_13.L
080006C4  1EF2      
080006C6  4E92      1191          jsr       (A2)
080006C8  584F      1192          addq.w    #4,A7
080006CA  6002      1193          bra.s     ask_EEPROM_addr_range_7
                    1194   ask_EEPROM_addr_range_6:
                    1195   ; } else {
                    1196   ; valid = 1;
080006CC  7601      1197          moveq     #1,D3
                    1198   ask_EEPROM_addr_range_7:
080006CE  60C6      1199          bra       ask_EEPROM_addr_range_1
                    1200   ask_EEPROM_addr_range_3:
                    1201   ; }
                    1202   ; }
                    1203   ; return size;
080006D0  2002      1204          move.l    D2,D0
080006D2  4CDF 040C 1205          movem.l   (A7)+,D2/D3/A2
080006D6  4E75      1206          rts
                    1207   ; }
                    1208   ; int boundry_checker (int intended_page_size, unsigned int current_addr) {
                    1209   _boundry_checker:
080006D8  4E56 0000 1210          link      A6,#0
080006DC  48E7 3800 1211          movem.l   D2/D3/D4,-(A7)
080006E0  242E 000C 1212          move.l    12(A6),D2
                    1213   ; // check boundry crossing, return the appropriate number of bytes we should write in a page write (page_size)
                    1214   ; unsigned int new_addr;
                    1215   ; int page_size;
                    1216   ; // if we write the intended page size, what's the end address we're gonna be at?
                    1217   ; new_addr = current_addr + intended_page_size - 1;
080006E4  2002      1218          move.l    D2,D0
080006E6  D0AE 0008 1219          add.l     8(A6),D0
080006EA  5380      1220          subq.l    #1,D0
080006EC  2800      1221          move.l    D0,D4
                    1222   ; if (current_addr <= 0xffff && new_addr > 0xffff) {
080006EE  0C82 0000 1223          cmp.l     #65535,D2
080006F2  FFFF      
080006F4  621A      1224          bhi.s     boundry_checker_1
080006F6  0C84 0000 1225          cmp.l     #65535,D4
080006FA  FFFF      
080006FC  6312      1226          bls.s     boundry_checker_1
                    1227   ; // cross the middle boundry
                    1228   ; page_size = 0xffff - current_addr + 1;
080006FE  303C FFFF 1229          move.w    #65535,D0
08000702  C0BC 0000 1230          and.l     #65535,D0
08000706  FFFF      
08000708  9082      1231          sub.l     D2,D0
0800070A  5280      1232          addq.l    #1,D0
0800070C  2600      1233          move.l    D0,D3
0800070E  6022      1234          bra.s     boundry_checker_4
                    1235   boundry_checker_1:
                    1236   ; } else if (current_addr <= 0x1ffff && new_addr > 0x1ffff) {
08000710  0C82 0001 1237          cmp.l     #131071,D2
08000714  FFFF      
08000716  6216      1238          bhi.s     boundry_checker_3
08000718  0C84 0001 1239          cmp.l     #131071,D4
0800071C  FFFF      
0800071E  630E      1240          bls.s     boundry_checker_3
                    1241   ; // cross the end boundry
                    1242   ; page_size = 0x1ffff - current_addr + 1;
08000720  203C 0001 1243          move.l    #131071,D0
08000724  FFFF      
08000726  9082      1244          sub.l     D2,D0
08000728  5280      1245          addq.l    #1,D0
0800072A  2600      1246          move.l    D0,D3
0800072C  6004      1247          bra.s     boundry_checker_4
                    1248   boundry_checker_3:
                    1249   ; } else {
                    1250   ; page_size = intended_page_size;
0800072E  262E 0008 1251          move.l    8(A6),D3
                    1252   boundry_checker_4:
                    1253   ; }
                    1254   ; return page_size;
08000732  2003      1255          move.l    D3,D0
08000734  4CDF 001C 1256          movem.l   (A7)+,D2/D3/D4
08000738  4E5E      1257          unlk      A6
0800073A  4E75      1258          rts
                    1259   ; }
                    1260   ; void I2C_multi_write (void) {
                    1261   _I2C_multi_write:
0800073C  4E56 FFF8 1262          link      A6,#-8
08000740  48E7 3F30 1263          movem.l   D2/D3/D4/D5/D6/D7/A2/A3,-(A7)
08000744  45F9 0800 1264          lea       _I2C_TX_command_status.L,A2
08000748  047C      
0800074A  47F9 0800 1265          lea       _printf.L,A3
0800074E  13A8      
                    1266   ; unsigned int size, addr, page_index;
                    1267   ; unsigned char slave_addr_RW;
                    1268   ; unsigned char EEPROM_block_select, EEPROM_internal_addr_H, EEPROM_internal_addr_L;
                    1269   ; char command;
                    1270   ; int page_size;
                    1271   ; int page_limit = 128;
08000750  2C3C 0000 1272          move.l    #128,D6
08000754  0080      
                    1273   ; unsigned char write_data = 0;
08000756  422E FFFF 1274          clr.b     -1(A6)
                    1275   ; printf("\r\nMultipe bytes EEPROM write");
0800075A  4879 0800 1276          pea       @m68kus~1_14.L
0800075E  1F3C      
08000760  4E93      1277          jsr       (A3)
08000762  584F      1278          addq.w    #4,A7
                    1279   ; // ask the range of the writting
                    1280   ; size = ask_EEPROM_addr_range();
08000764  4EB9 0800 1281          jsr       _ask_EEPROM_addr_range
08000768  0680      
0800076A  2800      1282          move.l    D0,D4
                    1283   ; // ask the start address
                    1284   ; addr = ask_EEPROM_internal_addr();
0800076C  4EB9 0800 1285          jsr       _ask_EEPROM_internal_addr
08000770  03AA      
08000772  2400      1286          move.l    D0,D2
                    1287   ; printf("\r\nWritting...");
08000774  4879 0800 1288          pea       @m68kus~1_15.L
08000778  1F5A      
0800077A  4E93      1289          jsr       (A3)
0800077C  584F      1290          addq.w    #4,A7
                    1291   ; while (size > 0){
                    1292   I2C_multi_write_1:
0800077E  0C84 0000 1293          cmp.l     #0,D4
08000782  0000      
08000784  6300 00EA 1294          bls       I2C_multi_write_3
                    1295   ; command = write_cmd_I2C;
08000788  1D7C 0011 1296          move.b    #17,-2(A6)
0800078C  FFFE      
                    1297   ; if (size <= page_limit) {
0800078E  B886      1298          cmp.l     D6,D4
08000790  6210      1299          bhi.s     I2C_multi_write_4
                    1300   ; page_size = boundry_checker(size, addr);
08000792  2F02      1301          move.l    D2,-(A7)
08000794  2F04      1302          move.l    D4,-(A7)
08000796  4EB9 0800 1303          jsr       _boundry_checker
0800079A  06D8      
0800079C  504F      1304          addq.w    #8,A7
0800079E  2600      1305          move.l    D0,D3
080007A0  6012      1306          bra.s     I2C_multi_write_6
                    1307   I2C_multi_write_4:
                    1308   ; } else if (size > page_limit) {
080007A2  B886      1309          cmp.l     D6,D4
080007A4  630E      1310          bls.s     I2C_multi_write_6
                    1311   ; page_size = boundry_checker(page_limit, addr);
080007A6  2F02      1312          move.l    D2,-(A7)
080007A8  2F06      1313          move.l    D6,-(A7)
080007AA  4EB9 0800 1314          jsr       _boundry_checker
080007AE  06D8      
080007B0  504F      1315          addq.w    #8,A7
080007B2  2600      1316          move.l    D0,D3
                    1317   I2C_multi_write_6:
                    1318   ; }
                    1319   ; EEPROM_internal_addr_H = (addr & 0x00ff00) >> 8;
080007B4  2002      1320          move.l    D2,D0
080007B6  C0BC 0000 1321          and.l     #65280,D0
080007BA  FF00      
080007BC  E088      1322          lsr.l     #8,D0
080007BE  1D40 FFFC 1323          move.b    D0,-4(A6)
                    1324   ; EEPROM_internal_addr_L = addr & 0x0000ff;
080007C2  2002      1325          move.l    D2,D0
080007C4  C0BC 0000 1326          and.l     #255,D0
080007C8  00FF      
080007CA  1D40 FFFD 1327          move.b    D0,-3(A6)
                    1328   ; EEPROM_block_select = (addr & 0x010000) >> 16;
080007CE  2002      1329          move.l    D2,D0
080007D0  C0BC 0001 1330          and.l     #65536,D0
080007D4  0000      
080007D6  E088      1331          lsr.l     #8,D0
080007D8  E088      1332          lsr.l     #8,D0
080007DA  1D40 FFFB 1333          move.b    D0,-5(A6)
                    1334   ; // EEPROM tag (b'1010) + chip select ('b00) + block select + write (0)
                    1335   ; slave_addr_RW = (0xa0 | (EEPROM_block_select << 1));
080007DE  303C 00A0 1336          move.w    #160,D0
080007E2  122E FFFB 1337          move.b    -5(A6),D1
080007E6  E309      1338          lsl.b     #1,D1
080007E8  C27C 00FF 1339          and.w     #255,D1
080007EC  8041      1340          or.w      D1,D0
080007EE  1E00      1341          move.b    D0,D7
                    1342   ; // send the control byte and generate a start signal
                    1343   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
080007F0  4878 0091 1344          pea       145
080007F4  4887      1345          ext.w     D7
080007F6  48C7      1346          ext.l     D7
080007F8  2F07      1347          move.l    D7,-(A7)
080007FA  4E92      1348          jsr       (A2)
080007FC  504F      1349          addq.w    #8,A7
                    1350   ; // write EEPROM internal addr (upper and lower byte), no start signal
                    1351   ; I2C_TX_command_status(EEPROM_internal_addr_H, write_cmd_I2C);
080007FE  4878 0011 1352          pea       17
08000802  122E FFFC 1353          move.b    -4(A6),D1
08000806  4881      1354          ext.w     D1
08000808  48C1      1355          ext.l     D1
0800080A  2F01      1356          move.l    D1,-(A7)
0800080C  4E92      1357          jsr       (A2)
0800080E  504F      1358          addq.w    #8,A7
                    1359   ; I2C_TX_command_status(EEPROM_internal_addr_L, write_cmd_I2C);
08000810  4878 0011 1360          pea       17
08000814  122E FFFD 1361          move.b    -3(A6),D1
08000818  4881      1362          ext.w     D1
0800081A  48C1      1363          ext.l     D1
0800081C  2F01      1364          move.l    D1,-(A7)
0800081E  4E92      1365          jsr       (A2)
08000820  504F      1366          addq.w    #8,A7
                    1367   ; for (page_index = 0; page_index < page_size; page_index++) {
08000822  4285      1368          clr.l     D5
                    1369   I2C_multi_write_8:
08000824  BA83      1370          cmp.l     D3,D5
08000826  6400 0030 1371          bhs       I2C_multi_write_10
                    1372   ; // write the actual data (128 bytes), generate a stop signal at the 128th byte
                    1373   ; if (page_index == page_size - 1) {
0800082A  2003      1374          move.l    D3,D0
0800082C  5380      1375          subq.l    #1,D0
0800082E  BA80      1376          cmp.l     D0,D5
08000830  6606      1377          bne.s     I2C_multi_write_11
                    1378   ; command = stop_write_cmd_I2C;
08000832  1D7C 0051 1379          move.b    #81,-2(A6)
08000836  FFFE      
                    1380   I2C_multi_write_11:
                    1381   ; }
                    1382   ; I2C_TX_command_status(write_data, command);
08000838  122E FFFE 1383          move.b    -2(A6),D1
0800083C  4881      1384          ext.w     D1
0800083E  48C1      1385          ext.l     D1
08000840  2F01      1386          move.l    D1,-(A7)
08000842  122E FFFF 1387          move.b    -1(A6),D1
08000846  4881      1388          ext.w     D1
08000848  48C1      1389          ext.l     D1
0800084A  2F01      1390          move.l    D1,-(A7)
0800084C  4E92      1391          jsr       (A2)
0800084E  504F      1392          addq.w    #8,A7
                    1393   ; write_data ++;
08000850  522E FFFF 1394          addq.b    #1,-1(A6)
08000854  5285      1395          addq.l    #1,D5
08000856  60CC      1396          bra       I2C_multi_write_8
                    1397   I2C_multi_write_10:
                    1398   ; }
                    1399   ; EEPROM_internal_writting_polling(slave_addr_RW);
08000858  CEBC 0000 1400          and.l     #255,D7
0800085C  00FF      
0800085E  2F07      1401          move.l    D7,-(A7)
08000860  4EB9 0800 1402          jsr       _EEPROM_internal_writting_pollin
08000864  041A      
08000866  584F      1403          addq.w    #4,A7
                    1404   ; addr = addr + page_size;
08000868  D483      1405          add.l     D3,D2
                    1406   ; size = size - page_size;
0800086A  9883      1407          sub.l     D3,D4
0800086C  6000 FF10 1408          bra       I2C_multi_write_1
                    1409   I2C_multi_write_3:
                    1410   ; // refresh the writting command to exclude stop signal
                    1411   ; }
                    1412   ; printf("\r\nMultiple bytes writting done");
08000870  4879 0800 1413          pea       @m68kus~1_16.L
08000874  1F68      
08000876  4E93      1414          jsr       (A3)
08000878  584F      1415          addq.w    #4,A7
0800087A  4CDF 0CFC 1416          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3
0800087E  4E5E      1417          unlk      A6
08000880  4E75      1418          rts
                    1419   ; }
                    1420   ; void I2C_multi_read (void) {
                    1421   _I2C_multi_read:
08000882  4E56 FFF8 1422          link      A6,#-8
08000886  48E7 3F30 1423          movem.l   D2/D3/D4/D5/D6/D7/A2/A3,-(A7)
0800088A  45F9 0800 1424          lea       _I2C_TX_command_status.L,A2
0800088E  047C      
                    1425   ; unsigned int size, addr, page_index;
                    1426   ; unsigned char slave_addr_RW;
                    1427   ; unsigned char EEPROM_block_select, EEPROM_internal_addr_H, EEPROM_internal_addr_L;
                    1428   ; char command;
                    1429   ; int page_size;
                    1430   ; unsigned char read_data;
                    1431   ; unsigned int counter = 0;
08000890  7E00      1432          moveq     #0,D7
                    1433   ; unsigned printing_step_size = 1;
08000892  367C 0001 1434          move.w    #1,A3
                    1435   ; printf("\r\nMultiple bytes EEPROM read");
08000896  4879 0800 1436          pea       @m68kus~1_17.L
0800089A  1F88      
0800089C  4EB9 0800 1437          jsr       _printf
080008A0  13A8      
080008A2  584F      1438          addq.w    #4,A7
                    1439   ; // ask the range of the writting
                    1440   ; size = ask_EEPROM_addr_range();
080008A4  4EB9 0800 1441          jsr       _ask_EEPROM_addr_range
080008A8  0680      
080008AA  2600      1442          move.l    D0,D3
                    1443   ; // ask the start address
                    1444   ; addr = ask_EEPROM_internal_addr();
080008AC  4EB9 0800 1445          jsr       _ask_EEPROM_internal_addr
080008B0  03AA      
080008B2  2400      1446          move.l    D0,D2
                    1447   ; // if we have more than 10 items to read, we only print out 10 lines.
                    1448   ; if (size > 10){
080008B4  0C83 0000 1449          cmp.l     #10,D3
080008B8  000A      
080008BA  6312      1450          bls.s     I2C_multi_read_1
                    1451   ; printing_step_size = size/10;
080008BC  2F03      1452          move.l    D3,-(A7)
080008BE  4878 000A 1453          pea       10
080008C2  4EB9 0800 1454          jsr       ULDIV
080008C6  12CA      
080008C8  2017      1455          move.l    (A7),D0
080008CA  504F      1456          addq.w    #8,A7
080008CC  2640      1457          move.l    D0,A3
                    1458   I2C_multi_read_1:
                    1459   ; }
                    1460   ; while (size > 0){
                    1461   I2C_multi_read_3:
080008CE  0C83 0000 1462          cmp.l     #0,D3
080008D2  0000      
080008D4  6300 0124 1463          bls       I2C_multi_read_5
                    1464   ; command = read_ACK_cmd_I2C;
080008D8  1D7C 0021 1465          move.b    #33,-2(A6)
080008DC  FFFE      
                    1466   ; page_size = boundry_checker(size, addr);
080008DE  2F02      1467          move.l    D2,-(A7)
080008E0  2F03      1468          move.l    D3,-(A7)
080008E2  4EB9 0800 1469          jsr       _boundry_checker
080008E6  06D8      
080008E8  504F      1470          addq.w    #8,A7
080008EA  2800      1471          move.l    D0,D4
                    1472   ; EEPROM_internal_addr_H = (addr & 0x00ff00) >> 8;
080008EC  2002      1473          move.l    D2,D0
080008EE  C0BC 0000 1474          and.l     #65280,D0
080008F2  FF00      
080008F4  E088      1475          lsr.l     #8,D0
080008F6  1D40 FFFC 1476          move.b    D0,-4(A6)
                    1477   ; EEPROM_internal_addr_L = addr & 0x0000ff;
080008FA  2002      1478          move.l    D2,D0
080008FC  C0BC 0000 1479          and.l     #255,D0
08000900  00FF      
08000902  1D40 FFFD 1480          move.b    D0,-3(A6)
                    1481   ; EEPROM_block_select = (addr & 0x010000) >> 16;
08000906  2002      1482          move.l    D2,D0
08000908  C0BC 0001 1483          and.l     #65536,D0
0800090C  0000      
0800090E  E088      1484          lsr.l     #8,D0
08000910  E088      1485          lsr.l     #8,D0
08000912  1D40 FFFB 1486          move.b    D0,-5(A6)
                    1487   ; // EEPROM tag (b'1010) + chip select ('b00) + block select + write (0)
                    1488   ; slave_addr_RW = (0xa0 | (EEPROM_block_select << 1));
08000916  303C 00A0 1489          move.w    #160,D0
0800091A  122E FFFB 1490          move.b    -5(A6),D1
0800091E  E309      1491          lsl.b     #1,D1
08000920  C27C 00FF 1492          and.w     #255,D1
08000924  8041      1493          or.w      D1,D0
08000926  1C00      1494          move.b    D0,D6
                    1495   ; // send the control byte and generate a start signal
                    1496   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
08000928  4878 0091 1497          pea       145
0800092C  4886      1498          ext.w     D6
0800092E  48C6      1499          ext.l     D6
08000930  2F06      1500          move.l    D6,-(A7)
08000932  4E92      1501          jsr       (A2)
08000934  504F      1502          addq.w    #8,A7
                    1503   ; // write EEPROM internal addr (upper and lower byte), no start signal
                    1504   ; I2C_TX_command_status(EEPROM_internal_addr_H, write_cmd_I2C);
08000936  4878 0011 1505          pea       17
0800093A  122E FFFC 1506          move.b    -4(A6),D1
0800093E  4881      1507          ext.w     D1
08000940  48C1      1508          ext.l     D1
08000942  2F01      1509          move.l    D1,-(A7)
08000944  4E92      1510          jsr       (A2)
08000946  504F      1511          addq.w    #8,A7
                    1512   ; I2C_TX_command_status(EEPROM_internal_addr_L, write_cmd_I2C);
08000948  4878 0011 1513          pea       17
0800094C  122E FFFD 1514          move.b    -3(A6),D1
08000950  4881      1515          ext.w     D1
08000952  48C1      1516          ext.l     D1
08000954  2F01      1517          move.l    D1,-(A7)
08000956  4E92      1518          jsr       (A2)
08000958  504F      1519          addq.w    #8,A7
                    1520   ; // EEPROM tag (b'1010) + chip select ('b00) + block select + read (1)
                    1521   ; slave_addr_RW = (0xa1 | (EEPROM_block_select << 1));
0800095A  303C 00A1 1522          move.w    #161,D0
0800095E  122E FFFB 1523          move.b    -5(A6),D1
08000962  E309      1524          lsl.b     #1,D1
08000964  C27C 00FF 1525          and.w     #255,D1
08000968  8041      1526          or.w      D1,D0
0800096A  1C00      1527          move.b    D0,D6
                    1528   ; // send the control byte and generate a repeated start signal
                    1529   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
0800096C  4878 0091 1530          pea       145
08000970  4886      1531          ext.w     D6
08000972  48C6      1532          ext.l     D6
08000974  2F06      1533          move.l    D6,-(A7)
08000976  4E92      1534          jsr       (A2)
08000978  504F      1535          addq.w    #8,A7
                    1536   ; for (page_index = 0; page_index < page_size; page_index++) {
0800097A  4285      1537          clr.l     D5
                    1538   I2C_multi_read_6:
0800097C  BA84      1539          cmp.l     D4,D5
0800097E  6400 0072 1540          bhs       I2C_multi_read_8
                    1541   ; if (page_index == page_size - 1) {
08000982  2004      1542          move.l    D4,D0
08000984  5380      1543          subq.l    #1,D0
08000986  BA80      1544          cmp.l     D0,D5
08000988  6606      1545          bne.s     I2C_multi_read_9
                    1546   ; command = stop_read_NACK_cmd_I2C;
0800098A  1D7C 0069 1547          move.b    #105,-2(A6)
0800098E  FFFE      
                    1548   I2C_multi_read_9:
                    1549   ; }
                    1550   ; I2C_command_reg = command;
08000990  13EE FFFE 1551          move.b    -2(A6),4227080
08000994  0040 8008 
                    1552   ; // polling the IF flag in the status reg
                    1553   ; while ((I2C_status_reg & 0x01) != 1){}
                    1554   I2C_multi_read_11:
08000998  1039 0040 1555          move.b    4227080,D0
0800099C  8008      
0800099E  C03C 0001 1556          and.b     #1,D0
080009A2  0C00 0001 1557          cmp.b     #1,D0
080009A6  6702      1558          beq.s     I2C_multi_read_13
080009A8  60EE      1559          bra       I2C_multi_read_11
                    1560   I2C_multi_read_13:
                    1561   ; if (counter % printing_step_size == 0){
080009AA  2F07      1562          move.l    D7,-(A7)
080009AC  2F0B      1563          move.l    A3,-(A7)
080009AE  4EB9 0800 1564          jsr       ULDIV
080009B2  12CA      
080009B4  202F 0004 1565          move.l    4(A7),D0
080009B8  504F      1566          addq.w    #8,A7
080009BA  4A80      1567          tst.l     D0
080009BC  662E      1568          bne.s     I2C_multi_read_14
                    1569   ; read_data = I2C_RX_reg;
080009BE  1D79 0040 1570          move.b    4227078,-1(A6)
080009C2  8006 FFFF 
                    1571   ; printf("\r\nAddress: %x, Read data: %x",counter & 0x01ffff, read_data);
080009C6  122E FFFF 1572          move.b    -1(A6),D1
080009CA  C2BC 0000 1573          and.l     #255,D1
080009CE  00FF      
080009D0  2F01      1574          move.l    D1,-(A7)
080009D2  2207      1575          move.l    D7,D1
080009D4  C2BC 0001 1576          and.l     #131071,D1
080009D8  FFFF      
080009DA  2F01      1577          move.l    D1,-(A7)
080009DC  4879 0800 1578          pea       @m68kus~1_18.L
080009E0  1FA6      
080009E2  4EB9 0800 1579          jsr       _printf
080009E6  13A8      
080009E8  DEFC 000C 1580          add.w     #12,A7
                    1581   I2C_multi_read_14:
                    1582   ; }
                    1583   ; counter ++;
080009EC  5287      1584          addq.l    #1,D7
080009EE  5285      1585          addq.l    #1,D5
080009F0  608A      1586          bra       I2C_multi_read_6
                    1587   I2C_multi_read_8:
                    1588   ; }
                    1589   ; addr = addr + page_size;
080009F2  D484      1590          add.l     D4,D2
                    1591   ; size = size - page_size;        
080009F4  9684      1592          sub.l     D4,D3
080009F6  6000 FED6 1593          bra       I2C_multi_read_3
                    1594   I2C_multi_read_5:
080009FA  4CDF 0CFC 1595          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3
080009FE  4E5E      1596          unlk      A6
08000A00  4E75      1597          rts
                    1598   ; }
                    1599   ; }
                    1600   ; void DAC(void) {
                    1601   _DAC:
08000A02  4E56 FFFC 1602          link      A6,#-4
08000A06  48E7 2020 1603          movem.l   D2/A2,-(A7)
08000A0A  45F9 0800 1604          lea       _I2C_TX_command_status.L,A2
08000A0E  047C      
                    1605   ; unsigned char slave_addr_RW;
                    1606   ; unsigned char control_byte;
                    1607   ; unsigned char command = write_cmd_I2C;
08000A10  7411      1608          moveq     #17,D2
                    1609   ; printf("\r\nUsing DAC to control LED");
08000A12  4879 0800 1610          pea       @m68kus~1_19.L
08000A16  1FC4      
08000A18  4EB9 0800 1611          jsr       _printf
08000A1C  13A8      
08000A1E  584F      1612          addq.w    #4,A7
                    1613   ; // PCF8591 tag (b'1001) + chip select (b'000) + write (0)
                    1614   ; slave_addr_RW = 0x90;
08000A20  1D7C 0090 1615          move.b    #144,-2(A6)
08000A24  FFFE      
                    1616   ; // only enable the analog bit
                    1617   ; control_byte = 0x40;
08000A26  1D7C 0040 1618          move.b    #64,-1(A6)
08000A2A  FFFF      
                    1619   ; // send the slave address byte and generate a start signal
                    1620   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
08000A2C  4878 0091 1621          pea       145
08000A30  122E FFFE 1622          move.b    -2(A6),D1
08000A34  4881      1623          ext.w     D1
08000A36  48C1      1624          ext.l     D1
08000A38  2F01      1625          move.l    D1,-(A7)
08000A3A  4E92      1626          jsr       (A2)
08000A3C  504F      1627          addq.w    #8,A7
                    1628   ; //printf("\r\nslave address sent");
                    1629   ; // send the control byte to PCF8591
                    1630   ; I2C_TX_command_status(control_byte, write_cmd_I2C);
08000A3E  4878 0011 1631          pea       17
08000A42  122E FFFF 1632          move.b    -1(A6),D1
08000A46  4881      1633          ext.w     D1
08000A48  48C1      1634          ext.l     D1
08000A4A  2F01      1635          move.l    D1,-(A7)
08000A4C  4E92      1636          jsr       (A2)
08000A4E  504F      1637          addq.w    #8,A7
                    1638   ; //printf("\r\ncontrol byte sent");
                    1639   ; /*
                    1640   ; for (i = 0; i <2560; i++) {
                    1641   ; // keep writting digital signal
                    1642   ; if (i == 2559) {
                    1643   ; // generate a stop signal at the last byte
                    1644   ; command = stop_write_cmd_I2C;
                    1645   ; }
                    1646   ; I2C_TX_command_status(digital_write_data, command);
                    1647   ; digital_write_data ++;
                    1648   ; }
                    1649   ; */
                    1650   ; while (1){
                    1651   DAC_1:
                    1652   ; I2C_TX_command_status(0xff,command);
08000A50  4882      1653          ext.w     D2
08000A52  48C2      1654          ext.l     D2
08000A54  2F02      1655          move.l    D2,-(A7)
08000A56  4878 00FF 1656          pea       255
08000A5A  4E92      1657          jsr       (A2)
08000A5C  504F      1658          addq.w    #8,A7
                    1659   ; Wait500ms ();
08000A5E  4EB9 0800 1660          jsr       _Wait500ms
08000A62  0EFE      
                    1661   ; I2C_TX_command_status(0x00,command);
08000A64  4882      1662          ext.w     D2
08000A66  48C2      1663          ext.l     D2
08000A68  2F02      1664          move.l    D2,-(A7)
08000A6A  42A7      1665          clr.l     -(A7)
08000A6C  4E92      1666          jsr       (A2)
08000A6E  504F      1667          addq.w    #8,A7
                    1668   ; Wait500ms ();
08000A70  4EB9 0800 1669          jsr       _Wait500ms
08000A74  0EFE      
08000A76  60D8      1670          bra       DAC_1
                    1671   ; }
                    1672   ; }
                    1673   ; void ADC(void) {
                    1674   _ADC:
08000A78  4E56 FFFC 1675          link      A6,#-4
08000A7C  48E7 2020 1676          movem.l   D2/A2,-(A7)
08000A80  45F9 0800 1677          lea       _I2C_TX_command_status.L,A2
08000A84  047C      
                    1678   ; unsigned char slave_addr_RW;
                    1679   ; unsigned char control_byte;
                    1680   ; unsigned char command = read_ACK_cmd_I2C;
08000A86  1D7C 0021 1681          move.b    #33,-2(A6)
08000A8A  FFFE      
                    1682   ; unsigned char read_data;
                    1683   ; printf("\r\nReading values from the ADC");
08000A8C  4879 0800 1684          pea       @m68kus~1_20.L
08000A90  1FE0      
08000A92  4EB9 0800 1685          jsr       _printf
08000A96  13A8      
08000A98  584F      1686          addq.w    #4,A7
                    1687   ; // PCF8591 tag (b'1001) + chip select (b'000) + write (0)
                    1688   ; slave_addr_RW = 0x90;
08000A9A  143C 0090 1689          move.b    #144,D2
                    1690   ; // generate the control byte based on the channel user selected
                    1691   ; control_byte = ask_ADC_channel();
08000A9E  4EB9 0800 1692          jsr       _ask_ADC_channel
08000AA2  0B18      
08000AA4  1D40 FFFD 1693          move.b    D0,-3(A6)
                    1694   ; // send the slave address byte and generate a start signal
                    1695   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
08000AA8  4878 0091 1696          pea       145
08000AAC  4882      1697          ext.w     D2
08000AAE  48C2      1698          ext.l     D2
08000AB0  2F02      1699          move.l    D2,-(A7)
08000AB2  4E92      1700          jsr       (A2)
08000AB4  504F      1701          addq.w    #8,A7
                    1702   ; // send the control byte to PCF8591
                    1703   ; I2C_TX_command_status(control_byte, write_cmd_I2C);
08000AB6  4878 0011 1704          pea       17
08000ABA  122E FFFD 1705          move.b    -3(A6),D1
08000ABE  4881      1706          ext.w     D1
08000AC0  48C1      1707          ext.l     D1
08000AC2  2F01      1708          move.l    D1,-(A7)
08000AC4  4E92      1709          jsr       (A2)
08000AC6  504F      1710          addq.w    #8,A7
                    1711   ; // PCF8591 tag (b'1001) + chip select (b'000) + read (1)
                    1712   ; slave_addr_RW = 0x91;
08000AC8  143C 0091 1713          move.b    #145,D2
                    1714   ; // repeated start
                    1715   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
08000ACC  4878 0091 1716          pea       145
08000AD0  4882      1717          ext.w     D2
08000AD2  48C2      1718          ext.l     D2
08000AD4  2F02      1719          move.l    D2,-(A7)
08000AD6  4E92      1720          jsr       (A2)
08000AD8  504F      1721          addq.w    #8,A7
                    1722   ; // send the slave address byte and generate a repeated start signal
                    1723   ; //I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
                    1724   ; while (1) {
                    1725   ADC_1:
                    1726   ; I2C_command_reg = command;
08000ADA  13EE FFFE 1727          move.b    -2(A6),4227080
08000ADE  0040 8008 
                    1728   ; // polling the IF flag in the status reg
                    1729   ; while ((I2C_status_reg & 0x01) != 1){}
                    1730   ADC_4:
08000AE2  1039 0040 1731          move.b    4227080,D0
08000AE6  8008      
08000AE8  C03C 0001 1732          and.b     #1,D0
08000AEC  0C00 0001 1733          cmp.b     #1,D0
08000AF0  6702      1734          beq.s     ADC_6
08000AF2  60EE      1735          bra       ADC_4
                    1736   ADC_6:
                    1737   ; read_data = I2C_RX_reg;
08000AF4  1D79 0040 1738          move.b    4227078,-1(A6)
08000AF8  8006 FFFF 
                    1739   ; printf("\r\nRead data: %x", read_data);
08000AFC  122E FFFF 1740          move.b    -1(A6),D1
08000B00  C2BC 0000 1741          and.l     #255,D1
08000B04  00FF      
08000B06  2F01      1742          move.l    D1,-(A7)
08000B08  4879 0800 1743          pea       @m68kus~1_21.L
08000B0C  1FFE      
08000B0E  4EB9 0800 1744          jsr       _printf
08000B12  13A8      
08000B14  504F      1745          addq.w    #8,A7
08000B16  60C2      1746          bra       ADC_1
                    1747   ; }
                    1748   ; }
                    1749   ; unsigned char ask_ADC_channel (void){
                    1750   _ask_ADC_channel:
08000B18  48E7 3800 1751          movem.l   D2/D3/D4,-(A7)
                    1752   ; unsigned char channel;
                    1753   ; unsigned char control_byte;
                    1754   ; int valid = 0;
08000B1C  4282      1755          clr.l     D2
                    1756   ; while (!valid){
                    1757   ask_ADC_channel_1:
08000B1E  4A82      1758          tst.l     D2
08000B20  6600 0052 1759          bne       ask_ADC_channel_3
                    1760   ; printf("\r\nWhich channel you want to read? 1. Potentiometer 2.Photoresistor 3.Thermistor ");
08000B24  4879 0800 1761          pea       @m68kus~1_22.L
08000B28  200E      
08000B2A  4EB9 0800 1762          jsr       _printf
08000B2E  13A8      
08000B30  584F      1763          addq.w    #4,A7
                    1764   ; channel = Get1HexDigits(0);
08000B32  42A7      1765          clr.l     -(A7)
08000B34  4EB9 0800 1766          jsr       _Get1HexDigits
08000B38  0FE0      
08000B3A  584F      1767          addq.w    #4,A7
08000B3C  1800      1768          move.b    D0,D4
                    1769   ; if (channel == 1) {
08000B3E  0C04 0001 1770          cmp.b     #1,D4
08000B42  6606      1771          bne.s     ask_ADC_channel_4
                    1772   ; control_byte = 0x01;
08000B44  7601      1773          moveq     #1,D3
                    1774   ; valid = 1;
08000B46  7401      1775          moveq     #1,D2
08000B48  6028      1776          bra.s     ask_ADC_channel_9
                    1777   ask_ADC_channel_4:
                    1778   ; } else if (channel == 2) {
08000B4A  0C04 0002 1779          cmp.b     #2,D4
08000B4E  6606      1780          bne.s     ask_ADC_channel_6
                    1781   ; control_byte = 0x02;
08000B50  7602      1782          moveq     #2,D3
                    1783   ; valid = 1;
08000B52  7401      1784          moveq     #1,D2
08000B54  601C      1785          bra.s     ask_ADC_channel_9
                    1786   ask_ADC_channel_6:
                    1787   ; } else if (channel == 3) {
08000B56  0C04 0003 1788          cmp.b     #3,D4
08000B5A  6606      1789          bne.s     ask_ADC_channel_8
                    1790   ; control_byte = 0x03;
08000B5C  7603      1791          moveq     #3,D3
                    1792   ; valid = 1;
08000B5E  7401      1793          moveq     #1,D2
08000B60  6010      1794          bra.s     ask_ADC_channel_9
                    1795   ask_ADC_channel_8:
                    1796   ; } else {
                    1797   ; printf("\r\nInvalid selection!");
08000B62  4879 0800 1798          pea       @m68kus~1_23.L
08000B66  2060      
08000B68  4EB9 0800 1799          jsr       _printf
08000B6C  13A8      
08000B6E  584F      1800          addq.w    #4,A7
                    1801   ; valid = 0;
08000B70  4282      1802          clr.l     D2
                    1803   ask_ADC_channel_9:
08000B72  60AA      1804          bra       ask_ADC_channel_1
                    1805   ask_ADC_channel_3:
                    1806   ; }
                    1807   ; }
                    1808   ; return control_byte;
08000B74  1003      1809          move.b    D3,D0
08000B76  4CDF 001C 1810          movem.l   (A7)+,D2/D3/D4
08000B7A  4E75      1811          rts
                    1812   ; }
                    1813   ; /******************************************************************************************
                    1814   ; ** The following code is for the SPI controller
                    1815   ; *******************************************************************************************/
                    1816   ; // return true if the SPI has finished transmitting a byte (to say the Flash chip) return false otherwise
                    1817   ; // this can be used in a polling algorithm to know when the controller is busy or idle.
                    1818   ; int TestForSPITransmitDataComplete(void)    {
                    1819   _TestForSPITransmitDataComplete:
08000B7C  4E56 FFF8 1820          link      A6,#-8
                    1821   ; /* TODO replace 0 below with a test for status register SPIF bit and if set, return true */
                    1822   ; int result; 
                    1823   ; int status;
                    1824   ; status = SPI_Status;
08000B80  1039 0040 1825          move.b    4227106,D0
08000B84  8022      
08000B86  C0BC 0000 1826          and.l     #255,D0
08000B8A  00FF      
08000B8C  2D40 FFFC 1827          move.l    D0,-4(A6)
                    1828   ; //printf("\r\nSPI status reg: %d",status); 
                    1829   ; result = status & 0x80; // get the SPIF bit, if SPIF == 1, then transmit is completed, if 0, then not completed. 
08000B90  202E FFFC 1830          move.l    -4(A6),D0
08000B94  C0BC 0000 1831          and.l     #128,D0
08000B98  0080      
08000B9A  2D40 FFF8 1832          move.l    D0,-8(A6)
                    1833   ; return result;
08000B9E  202E FFF8 1834          move.l    -8(A6),D0
08000BA2  4E5E      1835          unlk      A6
08000BA4  4E75      1836          rts
                    1837   ; }
                    1838   ; /************************************************************************************
                    1839   ; ** initialises the SPI controller chip to set speed, interrupt capability etc.
                    1840   ; ************************************************************************************/
                    1841   ; void SPI_Init(void)
                    1842   ; {
                    1843   _SPI_Init:
                    1844   ; //TODO
                    1845   ; //
                    1846   ; // Program the SPI Control, EXT, CS and Status registers to initialise the SPI controller
                    1847   ; // Don't forget to call this routine from main() before you do anything else with SPI
                    1848   ; //
                    1849   ; // Here are some settings we want to create
                    1850   ; //
                    1851   ; // Control Reg     - interrupts disabled, core enabled, Master mode, Polarity and Phase of clock = [0,0], speed =  divide by 32 = approx 700Khz
                    1852   ; // Ext Reg         - in conjunction with control reg, sets speed above and also sets interrupt flag after every completed transfer (each byte)
                    1853   ; // SPI_CS Reg      - control selection of slave SPI chips via their CS# signals
                    1854   ; // Status Reg      - status of SPI controller chip and used to clear any write collision and interrupt on transmit complete flag
                    1855   ; SPI_Control = 0x53;
08000BA6  13FC 0053 1856          move.b    #83,4227104
08000BAA  0040 8020 
                    1857   ; SPI_Ext = 0x00;
08000BAE  4239 0040 1858          clr.b     4227110
08000BB2  8026      
                    1859   ; Disable_SPI_CS(); // Disable the flash chip during initialisation 
08000BB4  13FC 00FF 1860          move.b    #255,4227112
08000BB8  0040 8028 
                    1861   ; SPI_Status = 0xc0;
08000BBC  13FC 00C0 1862          move.b    #192,4227106
08000BC0  0040 8022 
08000BC4  4E75      1863          rts
                    1864   ; }
                    1865   ; /************************************************************************************
                    1866   ; ** return ONLY when the SPI controller has finished transmitting a byte
                    1867   ; ************************************************************************************/
                    1868   ; void WaitForSPITransmitComplete(void)
                    1869   ; {
                    1870   _WaitForSPITransmitComplete:
08000BC6  2F02      1871          move.l    D2,-(A7)
                    1872   ; // TODO : poll the status register SPIF bit looking for completion of transmission
                    1873   ; // once transmission is complete, clear the write collision and interrupt on transmit complete flags in the status register (read documentation)
                    1874   ; // just in case they were set
                    1875   ; int SPITransmitComplete = 0;
08000BC8  4282      1876          clr.l     D2
                    1877   ; while (!SPITransmitComplete)
                    1878   WaitForSPITransmitComplete_1:
08000BCA  4A82      1879          tst.l     D2
08000BCC  660A      1880          bne.s     WaitForSPITransmitComplete_3
                    1881   ; {
                    1882   ; SPITransmitComplete = TestForSPITransmitDataComplete();
08000BCE  4EB9 0800 1883          jsr       _TestForSPITransmitDataComplete
08000BD2  0B7C      
08000BD4  2400      1884          move.l    D0,D2
08000BD6  60F2      1885          bra       WaitForSPITransmitComplete_1
                    1886   WaitForSPITransmitComplete_3:
                    1887   ; //printf("\r\nSPI data transmit complete: %d", SPITransmitComplete);
                    1888   ; }
                    1889   ; SPI_Status = 0xc0;
08000BD8  13FC 00C0 1890          move.b    #192,4227106
08000BDC  0040 8022 
08000BE0  241F      1891          move.l    (A7)+,D2
08000BE2  4E75      1892          rts
                    1893   ; }
                    1894   ; /************************************************************************************
                    1895   ; ** Write a byte to the SPI flash chip via the controller and returns (reads) whatever was
                    1896   ; ** given back by SPI device at the same time (removes the read byte from the FIFO)
                    1897   ; ************************************************************************************/
                    1898   ; int WriteSPIChar(int c)
                    1899   ; {
                    1900   _WriteSPIChar:
08000BE4  4E56 0000 1901          link      A6,#0
08000BE8  2F02      1902          move.l    D2,-(A7)
                    1903   ; // todo - write the byte in parameter 'c' to the SPI data register, this will start it transmitting to the flash device
                    1904   ; // wait for completion of transmission
                    1905   ; // return the received data from Flash chip (which may not be relevent depending upon what we are doing)
                    1906   ; // by reading fom the SPI controller Data Register.
                    1907   ; // note however that in order to get data from an SPI slave device (e.g. flash) chip we have to write a dummy byte to it
                    1908   ; //
                    1909   ; // modify '0' below to return back read byte from data register
                    1910   ; //
                    1911   ; int read_data = 0; 
08000BEA  4282      1912          clr.l     D2
                    1913   ; SPI_Data = c; 
08000BEC  202E 0008 1914          move.l    8(A6),D0
08000BF0  13C0 0040 1915          move.b    D0,4227108
08000BF4  8024      
                    1916   ; WaitForSPITransmitComplete();
08000BF6  4EB9 0800 1917          jsr       _WaitForSPITransmitComplete
08000BFA  0BC6      
                    1918   ; read_data = SPI_Data;
08000BFC  1039 0040 1919          move.b    4227108,D0
08000C00  8024      
08000C02  C0BC 0000 1920          and.l     #255,D0
08000C06  00FF      
08000C08  2400      1921          move.l    D0,D2
                    1922   ; return read_data;                   
08000C0A  2002      1923          move.l    D2,D0
08000C0C  241F      1924          move.l    (A7)+,D2
08000C0E  4E5E      1925          unlk      A6
08000C10  4E75      1926          rts
                    1927   ; }
                    1928   ; // send a command to the flash chip 
                    1929   ; void send_spi_cmd(int c){
                    1930   _send_spi_cmd:
08000C12  4E56 FFFC 1931          link      A6,#-4
                    1932   ; int read_data;
                    1933   ; Enable_SPI_CS();
08000C16  13FC 00FE 1934          move.b    #254,4227112
08000C1A  0040 8028 
                    1935   ; read_data = WriteSPIChar(c);
08000C1E  2F2E 0008 1936          move.l    8(A6),-(A7)
08000C22  4EB9 0800 1937          jsr       _WriteSPIChar
08000C26  0BE4      
08000C28  584F      1938          addq.w    #4,A7
08000C2A  2D40 FFFC 1939          move.l    D0,-4(A6)
                    1940   ; Disable_SPI_CS();
08000C2E  13FC 00FF 1941          move.b    #255,4227112
08000C32  0040 8028 
08000C36  4E5E      1942          unlk      A6
08000C38  4E75      1943          rts
                    1944   ; }
                    1945   ; /*Check the flash chip's status register*/
                    1946   ; void wait_for_flash_status_done(void)
                    1947   ; {
                    1948   _wait_for_flash_status_done:
08000C3A  4E56 FFFC 1949          link      A6,#-4
                    1950   ; int dummy_byte = 0x00;
08000C3E  42AE FFFC 1951          clr.l     -4(A6)
                    1952   ; Enable_SPI_CS();
08000C42  13FC 00FE 1953          move.b    #254,4227112
08000C46  0040 8028 
                    1954   ; WriteSPIChar(check_status_cmd); // send the check flash status register cmd
08000C4A  4878 0005 1955          pea       5
08000C4E  4EB9 0800 1956          jsr       _WriteSPIChar
08000C52  0BE4      
08000C54  584F      1957          addq.w    #4,A7
                    1958   ; while(WriteSPIChar(dummy_byte) & 0x01){
                    1959   wait_for_flash_status_done_1:
08000C56  2F2E FFFC 1960          move.l    -4(A6),-(A7)
08000C5A  4EB9 0800 1961          jsr       _WriteSPIChar
08000C5E  0BE4      
08000C60  584F      1962          addq.w    #4,A7
08000C62  C0BC 0000 1963          and.l     #1,D0
08000C66  0001      
08000C68  6702      1964          beq.s     wait_for_flash_status_done_3
                    1965   ; }
08000C6A  60EA      1966          bra       wait_for_flash_status_done_1
                    1967   wait_for_flash_status_done_3:
                    1968   ; Disable_SPI_CS();
08000C6C  13FC 00FF 1969          move.b    #255,4227112
08000C70  0040 8028 
08000C74  4E5E      1970          unlk      A6
08000C76  4E75      1971          rts
                    1972   ; }
                    1973   ; /*****************************************************************************************
                    1974   ; **	Interrupt service routine for Timers
                    1975   ; **
                    1976   ; **  Timers 1 - 4 share a common IRQ on the CPU  so this function uses polling to figure
                    1977   ; **  out which timer is producing the interrupt
                    1978   ; **
                    1979   ; *****************************************************************************************/
                    1980   ; unsigned char flash_read(unsigned char addr){
                    1981   _flash_read:
08000C78  4E56 FFF0 1982          link      A6,#-16
08000C7C  2F0A      1983          move.l    A2,-(A7)
08000C7E  45F9 0800 1984          lea       _WriteSPIChar.L,A2
08000C82  0BE4      
                    1985   ; int i;
                    1986   ; unsigned char dram_data;
                    1987   ; int flash_data;
                    1988   ; int dummy_byte = 0x00;
08000C84  42AE FFFC 1989          clr.l     -4(A6)
                    1990   ; //volatile unsigned char* current_address;
                    1991   ; //volatile unsigned char* dram_start_address = (volatile unsigned char*) (start_of_dram);
                    1992   ; Enable_SPI_CS();
08000C88  13FC 00FE 1993          move.b    #254,4227112
08000C8C  0040 8028 
                    1994   ; WriteSPIChar(read_cmd); // read cmd
08000C90  4878 0003 1995          pea       3
08000C94  4E92      1996          jsr       (A2)
08000C96  584F      1997          addq.w    #4,A7
                    1998   ; WriteSPIChar(0x00);
08000C98  42A7      1999          clr.l     -(A7)
08000C9A  4E92      2000          jsr       (A2)
08000C9C  584F      2001          addq.w    #4,A7
                    2002   ; WriteSPIChar(0x00);
08000C9E  42A7      2003          clr.l     -(A7)
08000CA0  4E92      2004          jsr       (A2)
08000CA2  584F      2005          addq.w    #4,A7
                    2006   ; WriteSPIChar(addr);
08000CA4  122E 000B 2007          move.b    11(A6),D1
08000CA8  C2BC 0000 2008          and.l     #255,D1
08000CAC  00FF      
08000CAE  2F01      2009          move.l    D1,-(A7)
08000CB0  4E92      2010          jsr       (A2)
08000CB2  584F      2011          addq.w    #4,A7
                    2012   ; flash_data = WriteSPIChar(dummy_byte);
08000CB4  2F2E FFFC 2013          move.l    -4(A6),-(A7)
08000CB8  4E92      2014          jsr       (A2)
08000CBA  584F      2015          addq.w    #4,A7
08000CBC  2D40 FFF8 2016          move.l    D0,-8(A6)
                    2017   ; Disable_SPI_CS();
08000CC0  13FC 00FF 2018          move.b    #255,4227112
08000CC4  0040 8028 
                    2019   ; return flash_data;
08000CC8  202E FFF8 2020          move.l    -8(A6),D0
08000CCC  245F      2021          move.l    (A7)+,A2
08000CCE  4E5E      2022          unlk      A6
08000CD0  4E75      2023          rts
                    2024   ; }
                    2025   ; unsigned char EEPROM_read (unsigned char addr) {
                    2026   _EEPROM_read:
08000CD2  4E56 FFFC 2027          link      A6,#-4
08000CD6  48E7 3820 2028          movem.l   D2/D3/D4/A2,-(A7)
08000CDA  45F9 0800 2029          lea       _I2C_TX_command_status.L,A2
08000CDE  047C      
08000CE0  182E 000B 2030          move.b    11(A6),D4
08000CE4  C87C 00FF 2031          and.w     #255,D4
                    2032   ; char slave_addr_RW;
                    2033   ; unsigned char slave_read_data;
                    2034   ; unsigned char EEPROM_block_select;
                    2035   ; unsigned char EEPROM_internal_addr_H, EEPROM_internal_addr_L;
                    2036   ; EEPROM_internal_addr_H = (addr & 0x00ff00) >> 8;
08000CE8  1004      2037          move.b    D4,D0
08000CEA  C07C 00FF 2038          and.w     #255,D0
08000CEE  C07C FF00 2039          and.w     #65280,D0
08000CF2  E048      2040          lsr.w     #8,D0
08000CF4  1D40 FFFE 2041          move.b    D0,-2(A6)
                    2042   ; EEPROM_internal_addr_L = addr & 0x0000ff;
08000CF8  1004      2043          move.b    D4,D0
08000CFA  C07C 00FF 2044          and.w     #255,D0
08000CFE  C07C 00FF 2045          and.w     #255,D0
08000D02  1D40 FFFF 2046          move.b    D0,-1(A6)
                    2047   ; EEPROM_block_select = (addr & 0x010000) >> 16;
08000D06  1004      2048          move.b    D4,D0
08000D08  C0BC 0000 2049          and.l     #255,D0
08000D0C  00FF      
08000D0E  C0BC 0001 2050          and.l     #65536,D0
08000D12  0000      
08000D14  E080      2051          asr.l     #8,D0
08000D16  E080      2052          asr.l     #8,D0
08000D18  1600      2053          move.b    D0,D3
                    2054   ; // EEPROM tag (b'1010) + chip select ('b00) + block select + write (0)
                    2055   ; slave_addr_RW = (0xa0 | (EEPROM_block_select << 1));
08000D1A  303C 00A0 2056          move.w    #160,D0
08000D1E  1203      2057          move.b    D3,D1
08000D20  E309      2058          lsl.b     #1,D1
08000D22  C27C 00FF 2059          and.w     #255,D1
08000D26  8041      2060          or.w      D1,D0
08000D28  1400      2061          move.b    D0,D2
                    2062   ; // send the control byte and generate a start signal
                    2063   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
08000D2A  4878 0091 2064          pea       145
08000D2E  4882      2065          ext.w     D2
08000D30  48C2      2066          ext.l     D2
08000D32  2F02      2067          move.l    D2,-(A7)
08000D34  4E92      2068          jsr       (A2)
08000D36  504F      2069          addq.w    #8,A7
                    2070   ; // write EEPROM internal addr (upper and lower byte), no start signal
                    2071   ; I2C_TX_command_status(EEPROM_internal_addr_H, write_cmd_I2C);
08000D38  4878 0011 2072          pea       17
08000D3C  122E FFFE 2073          move.b    -2(A6),D1
08000D40  4881      2074          ext.w     D1
08000D42  48C1      2075          ext.l     D1
08000D44  2F01      2076          move.l    D1,-(A7)
08000D46  4E92      2077          jsr       (A2)
08000D48  504F      2078          addq.w    #8,A7
                    2079   ; I2C_TX_command_status(EEPROM_internal_addr_L, write_cmd_I2C);
08000D4A  4878 0011 2080          pea       17
08000D4E  122E FFFF 2081          move.b    -1(A6),D1
08000D52  4881      2082          ext.w     D1
08000D54  48C1      2083          ext.l     D1
08000D56  2F01      2084          move.l    D1,-(A7)
08000D58  4E92      2085          jsr       (A2)
08000D5A  504F      2086          addq.w    #8,A7
                    2087   ; // EEPROM tag (b'1010) + chip select ('b00) + block select + read (1)
                    2088   ; slave_addr_RW = (0xa1 | (EEPROM_block_select << 1));
08000D5C  303C 00A1 2089          move.w    #161,D0
08000D60  1203      2090          move.b    D3,D1
08000D62  E309      2091          lsl.b     #1,D1
08000D64  C27C 00FF 2092          and.w     #255,D1
08000D68  8041      2093          or.w      D1,D0
08000D6A  1400      2094          move.b    D0,D2
                    2095   ; // send the control byte and generate a repeated start signal
                    2096   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
08000D6C  4878 0091 2097          pea       145
08000D70  4882      2098          ext.w     D2
08000D72  48C2      2099          ext.l     D2
08000D74  2F02      2100          move.l    D2,-(A7)
08000D76  4E92      2101          jsr       (A2)
08000D78  504F      2102          addq.w    #8,A7
                    2103   ; // set STO bit to 1, set RD bit to 1, set ACk to 1 (NACK), set IACK to 1
                    2104   ; I2C_command_reg = stop_read_NACK_cmd_I2C;
08000D7A  13FC 0069 2105          move.b    #105,4227080
08000D7E  0040 8008 
                    2106   ; // polling the IF flag in the status reg
                    2107   ; while ((I2C_status_reg & 0x01) != 1){}
                    2108   EEPROM_read_1:
08000D82  1039 0040 2109          move.b    4227080,D0
08000D86  8008      
08000D88  C03C 0001 2110          and.b     #1,D0
08000D8C  0C00 0001 2111          cmp.b     #1,D0
08000D90  6702      2112          beq.s     EEPROM_read_3
08000D92  60EE      2113          bra       EEPROM_read_1
                    2114   EEPROM_read_3:
                    2115   ; slave_read_data = I2C_RX_reg;
08000D94  1D79 0040 2116          move.b    4227078,-3(A6)
08000D98  8006 FFFD 
                    2117   ; return slave_read_data;
08000D9C  102E FFFD 2118          move.b    -3(A6),D0
08000DA0  4CDF 041C 2119          movem.l   (A7)+,D2/D3/D4/A2
08000DA4  4E5E      2120          unlk      A6
08000DA6  4E75      2121          rts
                    2122   ; }
                    2123   ; void Timer_ISR(void)
                    2124   ; {
                    2125   _Timer_ISR:
08000DA8  48E7 0038 2126          movem.l   A2/A3/A4,-(A7)
08000DAC  45F9 0800 2127          lea       _CanBus1_Receive.L,A2
08000DB0  0318      
08000DB2  47F9 0800 2128          lea       _CanBus0_Transmit.L,A3
08000DB6  0162      
08000DB8  49F9 0800 2129          lea       _printf.L,A4
08000DBC  13A8      
                    2130   ; if(Timer2Status == 1) {         // Did Timer 2 produce the Interrupt?
08000DBE  1039 0040 2131          move.b    4194358,D0
08000DC2  0036      
08000DC4  0C00 0001 2132          cmp.b     #1,D0
08000DC8  6600 00F8 2133          bne       Timer_ISR_7
                    2134   ; Timer2Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
08000DCC  13FC 0003 2135          move.b    #3,4194358
08000DD0  0040 0036 
                    2136   ; switch_counter ++;
08000DD4  5239 0800 2137          addq.b    #1,_switch_counter.L
08000DD8  2208      
                    2138   ; eeprom_counter ++;
08000DDA  5239 0800 2139          addq.b    #1,_eeprom_counter.L
08000DDE  220A      
                    2140   ; flash_counter ++;
08000DE0  5239 0800 2141          addq.b    #1,_flash_counter.L
08000DE4  220C      
                    2142   ; if (switch_counter == 1)
08000DE6  1039 0800 2143          move.b    _switch_counter.L,D0
08000DEA  2208      
08000DEC  0C00 0001 2144          cmp.b     #1,D0
08000DF0  6624      2145          bne.s     Timer_ISR_3
                    2146   ; {   
                    2147   ; printf("\r\nReading switches");
08000DF2  4879 0800 2148          pea       @m68kus~1_24.L
08000DF6  2076      
08000DF8  4E94      2149          jsr       (A4)
08000DFA  584F      2150          addq.w    #4,A7
                    2151   ; CanBus0_Transmit(PortA);     // read the value from the switches and broadcast using CANBUS controller 0
08000DFC  1239 0040 2152          move.b    4194304,D1
08000E00  0000      
08000E02  C2BC 0000 2153          and.l     #255,D1
08000E06  00FF      
08000E08  2F01      2154          move.l    D1,-(A7)
08000E0A  4E93      2155          jsr       (A3)
08000E0C  584F      2156          addq.w    #4,A7
                    2157   ; CanBus1_Receive();
08000E0E  4E92      2158          jsr       (A2)
                    2159   ; switch_counter = 0;
08000E10  4239 0800 2160          clr.b     _switch_counter.L
08000E14  2208      
                    2161   Timer_ISR_3:
                    2162   ; }
                    2163   ; if (eeprom_counter == 5)
08000E16  1039 0800 2164          move.b    _eeprom_counter.L,D0
08000E1A  220A      
08000E1C  0C00 0005 2165          cmp.b     #5,D0
08000E20  6600 004A 2166          bne       Timer_ISR_5
                    2167   ; {
                    2168   ; printf("\r\nReading from address %x of EEPROM", PortA);
08000E24  1239 0040 2169          move.b    4194304,D1
08000E28  0000      
08000E2A  C2BC 0000 2170          and.l     #255,D1
08000E2E  00FF      
08000E30  2F01      2171          move.l    D1,-(A7)
08000E32  4879 0800 2172          pea       @m68kus~1_25.L
08000E36  208A      
08000E38  4E94      2173          jsr       (A4)
08000E3A  504F      2174          addq.w    #8,A7
                    2175   ; CanBus0_Transmit(EEPROM_read(PortA));
08000E3C  2F00      2176          move.l    D0,-(A7)
08000E3E  1039 0040 2177          move.b    4194304,D0
08000E42  0000      
08000E44  C0BC 0000 2178          and.l     #255,D0
08000E48  00FF      
08000E4A  2F00      2179          move.l    D0,-(A7)
08000E4C  4EB9 0800 2180          jsr       _EEPROM_read
08000E50  0CD2      
08000E52  584F      2181          addq.w    #4,A7
08000E54  2200      2182          move.l    D0,D1
08000E56  201F      2183          move.l    (A7)+,D0
08000E58  C2BC 0000 2184          and.l     #255,D1
08000E5C  00FF      
08000E5E  2F01      2185          move.l    D1,-(A7)
08000E60  4E93      2186          jsr       (A3)
08000E62  584F      2187          addq.w    #4,A7
                    2188   ; CanBus1_Receive();
08000E64  4E92      2189          jsr       (A2)
                    2190   ; eeprom_counter = 0;
08000E66  4239 0800 2191          clr.b     _eeprom_counter.L
08000E6A  220A      
                    2192   Timer_ISR_5:
                    2193   ; }
                    2194   ; if (flash_counter == 20)
08000E6C  1039 0800 2195          move.b    _flash_counter.L,D0
08000E70  220C      
08000E72  0C00 0014 2196          cmp.b     #20,D0
08000E76  6600 004A 2197          bne       Timer_ISR_7
                    2198   ; {
                    2199   ; printf("\r\nReading from address %x of flash", PortA);
08000E7A  1239 0040 2200          move.b    4194304,D1
08000E7E  0000      
08000E80  C2BC 0000 2201          and.l     #255,D1
08000E84  00FF      
08000E86  2F01      2202          move.l    D1,-(A7)
08000E88  4879 0800 2203          pea       @m68kus~1_26.L
08000E8C  20AE      
08000E8E  4E94      2204          jsr       (A4)
08000E90  504F      2205          addq.w    #8,A7
                    2206   ; CanBus0_Transmit(flash_read(PortA));
08000E92  2F00      2207          move.l    D0,-(A7)
08000E94  1039 0040 2208          move.b    4194304,D0
08000E98  0000      
08000E9A  C0BC 0000 2209          and.l     #255,D0
08000E9E  00FF      
08000EA0  2F00      2210          move.l    D0,-(A7)
08000EA2  4EB9 0800 2211          jsr       _flash_read
08000EA6  0C78      
08000EA8  584F      2212          addq.w    #4,A7
08000EAA  2200      2213          move.l    D0,D1
08000EAC  201F      2214          move.l    (A7)+,D0
08000EAE  C2BC 0000 2215          and.l     #255,D1
08000EB2  00FF      
08000EB4  2F01      2216          move.l    D1,-(A7)
08000EB6  4E93      2217          jsr       (A3)
08000EB8  584F      2218          addq.w    #4,A7
                    2219   ; CanBus1_Receive();
08000EBA  4E92      2220          jsr       (A2)
                    2221   ; flash_counter = 0;
08000EBC  4239 0800 2222          clr.b     _flash_counter.L
08000EC0  220C      
                    2223   Timer_ISR_7:
08000EC2  4CDF 1C00 2224          movem.l   (A7)+,A2/A3/A4
08000EC6  4E75      2225          rts
                    2226   ; }
                    2227   ; }
                    2228   ; /*	if(Timer3Status == 1) {         // Did Timer 3 produce the Interrupt?
                    2229   ; Timer3Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
                    2230   ; HEX_A = Timer3Count++ ;     // increment a HEX count on Port HEX_A with each tick of Timer 3
                    2231   ; }
                    2232   ; if(Timer4Status == 1) {         // Did Timer 4 produce the Interrupt?
                    2233   ; Timer4Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
                    2234   ; HEX_B = Timer4Count++ ;     // increment a HEX count on HEX_B with each tick of Timer 4
                    2235   ; }*/
                    2236   ; }
                    2237   ; /*
                    2238   ; void read_switch_timer8_ISR(void)
                    2239   ; {   
                    2240   ; printf("\r\nRead switch");
                    2241   ; if(Timer2Status == 1) {         // Did Timer 2 produce the Interrupt?
                    2242   ; Timer2Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
                    2243   ; CanBus0_Transmit(PortA);     // read the value from the switches and broadcast using CANBUS controller 0
                    2244   ; CanBus1_Receive();
                    2245   ; }
                    2246   ; }*/
                    2247   ; /*****************************************************************************************
                    2248   ; **	Interrupt service routine for ACIA. This device has it's own dedicate IRQ level
                    2249   ; **  Add your code here to poll Status register and clear interrupt
                    2250   ; *****************************************************************************************/
                    2251   ; void ACIA_ISR()
                    2252   ; {}
                    2253   _ACIA_ISR:
08000EC8  4E75      2254          rts
                    2255   ; /***************************************************************************************
                    2256   ; **	Interrupt service routine for PIAs 1 and 2. These devices share an IRQ level
                    2257   ; **  Add your code here to poll Status register and clear interrupt
                    2258   ; *****************************************************************************************/
                    2259   ; void PIA_ISR()
                    2260   ; {}
                    2261   _PIA_ISR:
08000ECA  4E75      2262          rts
                    2263   ; /***********************************************************************************
                    2264   ; **	Interrupt service routine for Key 2 on DE1 board. Add your own response here
                    2265   ; ************************************************************************************/
                    2266   ; void Key2PressISR()
                    2267   ; {}
                    2268   _Key2PressISR:
08000ECC  4E75      2269          rts
                    2270   ; /***********************************************************************************
                    2271   ; **	Interrupt service routine for Key 1 on DE1 board. Add your own response here
                    2272   ; ************************************************************************************/
                    2273   ; void Key1PressISR()
                    2274   ; {}
                    2275   _Key1PressISR:
08000ECE  4E75      2276          rts
                    2277   ; /************************************************************************************
                    2278   ; **   Delay Subroutine to give the 68000 something useless to do to waste 1 mSec
                    2279   ; ************************************************************************************/
                    2280   ; void Wait1ms(void)
                    2281   ; {
                    2282   _Wait1ms:
08000ED0  2F02      2283          move.l    D2,-(A7)
                    2284   ; int  i ;
                    2285   ; for(i = 0; i < 1000; i ++)
08000ED2  4282      2286          clr.l     D2
                    2287   Wait1ms_1:
08000ED4  0C82 0000 2288          cmp.l     #1000,D2
08000ED8  03E8      
08000EDA  6C04      2289          bge.s     Wait1ms_3
08000EDC  5282      2290          addq.l    #1,D2
08000EDE  60F4      2291          bra       Wait1ms_1
                    2292   Wait1ms_3:
08000EE0  241F      2293          move.l    (A7)+,D2
08000EE2  4E75      2294          rts
                    2295   ; ;
                    2296   ; }
                    2297   ; /************************************************************************************
                    2298   ; **  Subroutine to give the 68000 something useless to do to waste 3 mSec
                    2299   ; **************************************************************************************/
                    2300   ; void Wait3ms(void)
                    2301   ; {
                    2302   _Wait3ms:
08000EE4  2F02      2303          move.l    D2,-(A7)
                    2304   ; int i ;
                    2305   ; for(i = 0; i < 3; i++)
08000EE6  4282      2306          clr.l     D2
                    2307   Wait3ms_1:
08000EE8  0C82 0000 2308          cmp.l     #3,D2
08000EEC  0003      
08000EEE  6C0A      2309          bge.s     Wait3ms_3
                    2310   ; Wait1ms() ;
08000EF0  4EB9 0800 2311          jsr       _Wait1ms
08000EF4  0ED0      
08000EF6  5282      2312          addq.l    #1,D2
08000EF8  60EE      2313          bra       Wait3ms_1
                    2314   Wait3ms_3:
08000EFA  241F      2315          move.l    (A7)+,D2
08000EFC  4E75      2316          rts
                    2317   ; }
                    2318   ; void Wait500ms (void) {
                    2319   _Wait500ms:
08000EFE  2F02      2320          move.l    D2,-(A7)
                    2321   ; int i;
                    2322   ; for (i = 0; i<500; i++){
08000F00  4282      2323          clr.l     D2
                    2324   Wait500ms_1:
08000F02  0C82 0000 2325          cmp.l     #500,D2
08000F06  01F4      
08000F08  6C0A      2326          bge.s     Wait500ms_3
                    2327   ; Wait1ms();
08000F0A  4EB9 0800 2328          jsr       _Wait1ms
08000F0E  0ED0      
08000F10  5282      2329          addq.l    #1,D2
08000F12  60EE      2330          bra       Wait500ms_1
                    2331   Wait500ms_3:
08000F14  241F      2332          move.l    (A7)+,D2
08000F16  4E75      2333          rts
                    2334   ; }
                    2335   ; }
                    2336   ; /*********************************************************************************************
                    2337   ; **  Subroutine to initialise the LCD display by writing some commands to the LCD internal registers
                    2338   ; **  Sets it for parallel port and 2 line display mode (if I recall correctly)
                    2339   ; *********************************************************************************************/
                    2340   ; void Init_LCD(void)
                    2341   ; {
                    2342   _Init_LCD:
                    2343   ; LCDcommand = 0x0c ;
08000F18  13FC 000C 2344          move.b    #12,4194336
08000F1C  0040 0020 
                    2345   ; Wait3ms() ;
08000F20  4EB9 0800 2346          jsr       _Wait3ms
08000F24  0EE4      
                    2347   ; LCDcommand = 0x38 ;
08000F26  13FC 0038 2348          move.b    #56,4194336
08000F2A  0040 0020 
                    2349   ; Wait3ms() ;
08000F2E  4EB9 0800 2350          jsr       _Wait3ms
08000F32  0EE4      
08000F34  4E75      2351          rts
                    2352   ; }
                    2353   ; /*********************************************************************************************
                    2354   ; **  Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                    2355   ; *********************************************************************************************/
                    2356   ; void Init_RS232(void)
                    2357   ; {
                    2358   _Init_RS232:
                    2359   ; RS232_Control = 0x15 ; //  %00010101 set up 6850 uses divide by 16 clock, set RTS low, 8 bits no parity, 1 stop bit, transmitter interrupt disabled
08000F36  13FC 0015 2360          move.b    #21,4194368
08000F3A  0040 0040 
                    2361   ; RS232_Baud = 0x1 ;      // program baud rate generator 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
08000F3E  13FC 0001 2362          move.b    #1,4194372
08000F42  0040 0044 
08000F46  4E75      2363          rts
                    2364   ; }
                    2365   ; /*********************************************************************************************************
                    2366   ; **  Subroutine to provide a low level output function to 6850 ACIA
                    2367   ; **  This routine provides the basic functionality to output a single character to the serial Port
                    2368   ; **  to allow the board to communicate with HyperTerminal Program
                    2369   ; **
                    2370   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                    2371   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                    2372   ; **  call _putch() also
                    2373   ; *********************************************************************************************************/
                    2374   ; int _putch( int c)
                    2375   ; {
                    2376   __putch:
08000F48  4E56 0000 2377          link      A6,#0
                    2378   ; while((RS232_Status & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                    2379   _putch_1:
08000F4C  1039 0040 2380          move.b    4194368,D0
08000F50  0040      
08000F52  C03C 0002 2381          and.b     #2,D0
08000F56  0C00 0002 2382          cmp.b     #2,D0
08000F5A  6702      2383          beq.s     _putch_3
08000F5C  60EE      2384          bra       _putch_1
                    2385   _putch_3:
                    2386   ; ;
                    2387   ; RS232_TxData = (c & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
08000F5E  202E 0008 2388          move.l    8(A6),D0
08000F62  C0BC 0000 2389          and.l     #127,D0
08000F66  007F      
08000F68  13C0 0040 2390          move.b    D0,4194370
08000F6C  0042      
                    2391   ; return c ;                                              // putchar() expects the character to be returned
08000F6E  202E 0008 2392          move.l    8(A6),D0
08000F72  4E5E      2393          unlk      A6
08000F74  4E75      2394          rts
                    2395   ; }
                    2396   ; /*********************************************************************************************************
                    2397   ; **  Subroutine to provide a low level input function to 6850 ACIA
                    2398   ; **  This routine provides the basic functionality to input a single character from the serial Port
                    2399   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                    2400   ; **
                    2401   ; **  NOTE you do not call this function directly, instead you call the normal getchar() function
                    2402   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call getchar() so will
                    2403   ; **  call _getch() also
                    2404   ; *********************************************************************************************************/
                    2405   ; int _getch( void )
                    2406   ; {
                    2407   __getch:
08000F76  2F02      2408          move.l    D2,-(A7)
                    2409   ; char c ;
                    2410   ; while((RS232_Status & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                    2411   _getch_1:
08000F78  1039 0040 2412          move.b    4194368,D0
08000F7C  0040      
08000F7E  C03C 0001 2413          and.b     #1,D0
08000F82  0C00 0001 2414          cmp.b     #1,D0
08000F86  6702      2415          beq.s     _getch_3
08000F88  60EE      2416          bra       _getch_1
                    2417   _getch_3:
                    2418   ; ;
                    2419   ; c = (RS232_RxData & (char)(0x7f));
08000F8A  1039 0040 2420          move.b    4194370,D0
08000F8E  0042      
08000F90  C03C 007F 2421          and.b     #127,D0
08000F94  1400      2422          move.b    D0,D2
                    2423   ; _putch(c);
08000F96  4882      2424          ext.w     D2
08000F98  48C2      2425          ext.l     D2
08000F9A  2F02      2426          move.l    D2,-(A7)
08000F9C  4EB9 0800 2427          jsr       __putch
08000FA0  0F48      
08000FA2  584F      2428          addq.w    #4,A7
                    2429   ; return c;                   // read received character, mask off top bit and return as 7 bit ASCII character
08000FA4  4882      2430          ext.w     D2
08000FA6  48C2      2431          ext.l     D2
08000FA8  2002      2432          move.l    D2,D0
08000FAA  241F      2433          move.l    (A7)+,D2
08000FAC  4E75      2434          rts
                    2435   ; }
                    2436   ; char xtod(int c)
                    2437   ; {
                    2438   _xtod:
08000FAE  4E56 0000 2439          link      A6,#0
08000FB2  2F02      2440          move.l    D2,-(A7)
08000FB4  242E 0008 2441          move.l    8(A6),D2
                    2442   ; if ((char)(c) <= (char)('9'))
08000FB8  0C02 0039 2443          cmp.b     #57,D2
08000FBC  6E08      2444          bgt.s     xtod_1
                    2445   ; return c - (char)(0x30);    // 0 - 9 = 0x30 - 0x39 so convert to number by sutracting 0x30
08000FBE  1002      2446          move.b    D2,D0
08000FC0  0400 0030 2447          sub.b     #48,D0
08000FC4  6014      2448          bra.s     xtod_3
                    2449   xtod_1:
                    2450   ; else if((char)(c) > (char)('F'))    // assume lower case
08000FC6  0C02 0046 2451          cmp.b     #70,D2
08000FCA  6F08      2452          ble.s     xtod_4
                    2453   ; return c - (char)(0x57);    // a-f = 0x61-66 so needs to be converted to 0x0A - 0x0F so subtract 0x57
08000FCC  1002      2454          move.b    D2,D0
08000FCE  0400 0057 2455          sub.b     #87,D0
08000FD2  6006      2456          bra.s     xtod_3
                    2457   xtod_4:
                    2458   ; else
                    2459   ; return c - (char)(0x37);    // A-F = 0x41-46 so needs to be converted to 0x0A - 0x0F so subtract 0x37
08000FD4  1002      2460          move.b    D2,D0
08000FD6  0400 0037 2461          sub.b     #55,D0
                    2462   xtod_3:
08000FDA  241F      2463          move.l    (A7)+,D2
08000FDC  4E5E      2464          unlk      A6
08000FDE  4E75      2465          rts
                    2466   ; }
                    2467   ; int Get1HexDigits(char *CheckSumPtr)
                    2468   ; {
                    2469   _Get1HexDigits:
08000FE0  4E56 0000 2470          link      A6,#0
08000FE4  2F02      2471          move.l    D2,-(A7)
                    2472   ; register int i = xtod(_getch());
08000FE6  2F00      2473          move.l    D0,-(A7)
08000FE8  4EB9 0800 2474          jsr       __getch
08000FEC  0F76      
08000FEE  2200      2475          move.l    D0,D1
08000FF0  201F      2476          move.l    (A7)+,D0
08000FF2  2F01      2477          move.l    D1,-(A7)
08000FF4  4EB9 0800 2478          jsr       _xtod
08000FF8  0FAE      
08000FFA  584F      2479          addq.w    #4,A7
08000FFC  C0BC 0000 2480          and.l     #255,D0
08001000  00FF      
08001002  2400      2481          move.l    D0,D2
                    2482   ; if(CheckSumPtr)
08001004  4AAE 0008 2483          tst.l     8(A6)
08001008  6706      2484          beq.s     Get1HexDigits_1
                    2485   ; *CheckSumPtr += i ;
0800100A  206E 0008 2486          move.l    8(A6),A0
0800100E  D510      2487          add.b     D2,(A0)
                    2488   Get1HexDigits_1:
                    2489   ; return i; 
08001010  2002      2490          move.l    D2,D0
08001012  241F      2491          move.l    (A7)+,D2
08001014  4E5E      2492          unlk      A6
08001016  4E75      2493          rts
                    2494   ; }
                    2495   ; int Get2HexDigits(char *CheckSumPtr)
                    2496   ; {
                    2497   _Get2HexDigits:
08001018  4E56 0000 2498          link      A6,#0
0800101C  2F02      2499          move.l    D2,-(A7)
                    2500   ; register int i = (xtod(_getch()) << 4) | (xtod(_getch()));
0800101E  2F00      2501          move.l    D0,-(A7)
08001020  4EB9 0800 2502          jsr       __getch
08001024  0F76      
08001026  2200      2503          move.l    D0,D1
08001028  201F      2504          move.l    (A7)+,D0
0800102A  2F01      2505          move.l    D1,-(A7)
0800102C  4EB9 0800 2506          jsr       _xtod
08001030  0FAE      
08001032  584F      2507          addq.w    #4,A7
08001034  C0BC 0000 2508          and.l     #255,D0
08001038  00FF      
0800103A  E980      2509          asl.l     #4,D0
0800103C  2F00      2510          move.l    D0,-(A7)
0800103E  2F01      2511          move.l    D1,-(A7)
08001040  4EB9 0800 2512          jsr       __getch
08001044  0F76      
08001046  221F      2513          move.l    (A7)+,D1
08001048  2F00      2514          move.l    D0,-(A7)
0800104A  4EB9 0800 2515          jsr       _xtod
0800104E  0FAE      
08001050  584F      2516          addq.w    #4,A7
08001052  2200      2517          move.l    D0,D1
08001054  201F      2518          move.l    (A7)+,D0
08001056  C2BC 0000 2519          and.l     #255,D1
0800105A  00FF      
0800105C  8081      2520          or.l      D1,D0
0800105E  2400      2521          move.l    D0,D2
                    2522   ; if(CheckSumPtr)
08001060  4AAE 0008 2523          tst.l     8(A6)
08001064  6706      2524          beq.s     Get2HexDigits_1
                    2525   ; *CheckSumPtr += i ;
08001066  206E 0008 2526          move.l    8(A6),A0
0800106A  D510      2527          add.b     D2,(A0)
                    2528   Get2HexDigits_1:
                    2529   ; return i ;
0800106C  2002      2530          move.l    D2,D0
0800106E  241F      2531          move.l    (A7)+,D2
08001070  4E5E      2532          unlk      A6
08001072  4E75      2533          rts
                    2534   ; }
                    2535   ; int Get4HexDigits(char *CheckSumPtr)
                    2536   ; {
                    2537   _Get4HexDigits:
08001074  4E56 0000 2538          link      A6,#0
                    2539   ; return (Get2HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
08001078  2F2E 0008 2540          move.l    8(A6),-(A7)
0800107C  4EB9 0800 2541          jsr       _Get2HexDigits
08001080  1018      
08001082  584F      2542          addq.w    #4,A7
08001084  E180      2543          asl.l     #8,D0
08001086  2F00      2544          move.l    D0,-(A7)
08001088  2F2E 0008 2545          move.l    8(A6),-(A7)
0800108C  4EB9 0800 2546          jsr       _Get2HexDigits
08001090  1018      
08001092  584F      2547          addq.w    #4,A7
08001094  2200      2548          move.l    D0,D1
08001096  201F      2549          move.l    (A7)+,D0
08001098  8081      2550          or.l      D1,D0
0800109A  4E5E      2551          unlk      A6
0800109C  4E75      2552          rts
                    2553   ; }
                    2554   ; int Get6HexDigits(char *CheckSumPtr)
                    2555   ; {
                    2556   _Get6HexDigits:
0800109E  4E56 0000 2557          link      A6,#0
                    2558   ; return (Get4HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
080010A2  2F2E 0008 2559          move.l    8(A6),-(A7)
080010A6  4EB9 0800 2560          jsr       _Get4HexDigits
080010AA  1074      
080010AC  584F      2561          addq.w    #4,A7
080010AE  E180      2562          asl.l     #8,D0
080010B0  2F00      2563          move.l    D0,-(A7)
080010B2  2F2E 0008 2564          move.l    8(A6),-(A7)
080010B6  4EB9 0800 2565          jsr       _Get2HexDigits
080010BA  1018      
080010BC  584F      2566          addq.w    #4,A7
080010BE  2200      2567          move.l    D0,D1
080010C0  201F      2568          move.l    (A7)+,D0
080010C2  8081      2569          or.l      D1,D0
080010C4  4E5E      2570          unlk      A6
080010C6  4E75      2571          rts
                    2572   ; }
                    2573   ; int Get8HexDigits(char *CheckSumPtr)
                    2574   ; {
                    2575   _Get8HexDigits:
080010C8  4E56 0000 2576          link      A6,#0
                    2577   ; return (Get4HexDigits(CheckSumPtr) << 16) | (Get4HexDigits(CheckSumPtr));
080010CC  2F2E 0008 2578          move.l    8(A6),-(A7)
080010D0  4EB9 0800 2579          jsr       _Get4HexDigits
080010D4  1074      
080010D6  584F      2580          addq.w    #4,A7
080010D8  E180      2581          asl.l     #8,D0
080010DA  E180      2582          asl.l     #8,D0
080010DC  2F00      2583          move.l    D0,-(A7)
080010DE  2F2E 0008 2584          move.l    8(A6),-(A7)
080010E2  4EB9 0800 2585          jsr       _Get4HexDigits
080010E6  1074      
080010E8  584F      2586          addq.w    #4,A7
080010EA  2200      2587          move.l    D0,D1
080010EC  201F      2588          move.l    (A7)+,D0
080010EE  8081      2589          or.l      D1,D0
080010F0  4E5E      2590          unlk      A6
080010F2  4E75      2591          rts
                    2592   ; }
                    2593   ; /******************************************************************************
                    2594   ; **  Subroutine to output a single character to the 2 row LCD display
                    2595   ; **  It is assumed the character is an ASCII code and it will be displayed at the
                    2596   ; **  current cursor position
                    2597   ; *******************************************************************************/
                    2598   ; void LCDOutchar(int c)
                    2599   ; {
                    2600   _LCDOutchar:
080010F4  4E56 0000 2601          link      A6,#0
                    2602   ; LCDdata = (char)(c);
080010F8  202E 0008 2603          move.l    8(A6),D0
080010FC  13C0 0040 2604          move.b    D0,4194338
08001100  0022      
                    2605   ; Wait1ms() ;
08001102  4EB9 0800 2606          jsr       _Wait1ms
08001106  0ED0      
08001108  4E5E      2607          unlk      A6
0800110A  4E75      2608          rts
                    2609   ; }
                    2610   ; /**********************************************************************************
                    2611   ; *subroutine to output a message at the current cursor position of the LCD display
                    2612   ; ************************************************************************************/
                    2613   ; void LCDOutMessage(char *theMessage)
                    2614   ; {
                    2615   _LCDOutMessage:
0800110C  4E56 FFFC 2616          link      A6,#-4
                    2617   ; char c ;
                    2618   ; while((c = *theMessage++) != 0)     // output characters from the string until NULL
                    2619   LCDOutMessage_1:
08001110  206E 0008 2620          move.l    8(A6),A0
08001114  52AE 0008 2621          addq.l    #1,8(A6)
08001118  1D50 FFFF 2622          move.b    (A0),-1(A6)
0800111C  1010      2623          move.b    (A0),D0
0800111E  6714      2624          beq.s     LCDOutMessage_3
                    2625   ; LCDOutchar(c) ;
08001120  122E FFFF 2626          move.b    -1(A6),D1
08001124  4881      2627          ext.w     D1
08001126  48C1      2628          ext.l     D1
08001128  2F01      2629          move.l    D1,-(A7)
0800112A  4EB9 0800 2630          jsr       _LCDOutchar
0800112E  10F4      
08001130  584F      2631          addq.w    #4,A7
08001132  60DC      2632          bra       LCDOutMessage_1
                    2633   LCDOutMessage_3:
08001134  4E5E      2634          unlk      A6
08001136  4E75      2635          rts
                    2636   ; }
                    2637   ; /******************************************************************************
                    2638   ; *subroutine to clear the line by issuing 24 space characters
                    2639   ; *******************************************************************************/
                    2640   ; void LCDClearln(void)
                    2641   ; {
                    2642   _LCDClearln:
08001138  2F02      2643          move.l    D2,-(A7)
                    2644   ; int i ;
                    2645   ; for(i = 0; i < 24; i ++)
0800113A  4282      2646          clr.l     D2
                    2647   LCDClearln_1:
0800113C  0C82 0000 2648          cmp.l     #24,D2
08001140  0018      
08001142  6C10      2649          bge.s     LCDClearln_3
                    2650   ; LCDOutchar(' ') ;       // write a space char to the LCD display
08001144  4878 0020 2651          pea       32
08001148  4EB9 0800 2652          jsr       _LCDOutchar
0800114C  10F4      
0800114E  584F      2653          addq.w    #4,A7
08001150  5282      2654          addq.l    #1,D2
08001152  60E8      2655          bra       LCDClearln_1
                    2656   LCDClearln_3:
08001154  241F      2657          move.l    (A7)+,D2
08001156  4E75      2658          rts
                    2659   ; }
                    2660   ; /******************************************************************************
                    2661   ; **  Subroutine to move the LCD cursor to the start of line 1 and clear that line
                    2662   ; *******************************************************************************/
                    2663   ; void LCDLine1Message(char *theMessage)
                    2664   ; {
                    2665   _LCDLine1Message:
08001158  4E56 0000 2666          link      A6,#0
                    2667   ; LCDcommand = 0x80 ;
0800115C  13FC 0080 2668          move.b    #128,4194336
08001160  0040 0020 
                    2669   ; Wait3ms();
08001164  4EB9 0800 2670          jsr       _Wait3ms
08001168  0EE4      
                    2671   ; LCDClearln() ;
0800116A  4EB9 0800 2672          jsr       _LCDClearln
0800116E  1138      
                    2673   ; LCDcommand = 0x80 ;
08001170  13FC 0080 2674          move.b    #128,4194336
08001174  0040 0020 
                    2675   ; Wait3ms() ;
08001178  4EB9 0800 2676          jsr       _Wait3ms
0800117C  0EE4      
                    2677   ; LCDOutMessage(theMessage) ;
0800117E  2F2E 0008 2678          move.l    8(A6),-(A7)
08001182  4EB9 0800 2679          jsr       _LCDOutMessage
08001186  110C      
08001188  584F      2680          addq.w    #4,A7
0800118A  4E5E      2681          unlk      A6
0800118C  4E75      2682          rts
                    2683   ; }
                    2684   ; /******************************************************************************
                    2685   ; **  Subroutine to move the LCD cursor to the start of line 2 and clear that line
                    2686   ; *******************************************************************************/
                    2687   ; void LCDLine2Message(char *theMessage)
                    2688   ; {
                    2689   _LCDLine2Message:
0800118E  4E56 0000 2690          link      A6,#0
                    2691   ; LCDcommand = 0xC0 ;
08001192  13FC 00C0 2692          move.b    #192,4194336
08001196  0040 0020 
                    2693   ; Wait3ms();
0800119A  4EB9 0800 2694          jsr       _Wait3ms
0800119E  0EE4      
                    2695   ; LCDClearln() ;
080011A0  4EB9 0800 2696          jsr       _LCDClearln
080011A4  1138      
                    2697   ; LCDcommand = 0xC0 ;
080011A6  13FC 00C0 2698          move.b    #192,4194336
080011AA  0040 0020 
                    2699   ; Wait3ms() ;
080011AE  4EB9 0800 2700          jsr       _Wait3ms
080011B2  0EE4      
                    2701   ; LCDOutMessage(theMessage) ;
080011B4  2F2E 0008 2702          move.l    8(A6),-(A7)
080011B8  4EB9 0800 2703          jsr       _LCDOutMessage
080011BC  110C      
080011BE  584F      2704          addq.w    #4,A7
080011C0  4E5E      2705          unlk      A6
080011C2  4E75      2706          rts
                    2707   ; }
                    2708   ; /*********************************************************************************************************************************
                    2709   ; **  IMPORTANT FUNCTION
                    2710   ; **  This function install an exception handler so you can capture and deal with any 68000 exception in your program
                    2711   ; **  You pass it the name of a function in your code that will get called in response to the exception (as the 1st parameter)
                    2712   ; **  and in the 2nd parameter, you pass it the exception number that you want to take over (see 68000 exceptions for details)
                    2713   ; **  Calling this function allows you to deal with Interrupts for example
                    2714   ; ***********************************************************************************************************************************/
                    2715   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                    2716   ; {
                    2717   _InstallExceptionHandler:
080011C4  4E56 FFFC 2718          link      A6,#-4
                    2719   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
080011C8  2D7C 0B00 2720          move.l    #184549376,-4(A6)
080011CC  0000 FFFC 
                    2721   ; RamVectorAddress[level] = (long int *)(function_ptr);                       // install the address of our function into the exception table
080011D0  206E FFFC 2722          move.l    -4(A6),A0
080011D4  202E 000C 2723          move.l    12(A6),D0
080011D8  E588      2724          lsl.l     #2,D0
080011DA  21AE 0008 2725          move.l    8(A6),0(A0,D0.L)
080011DE  0800      
080011E0  4E5E      2726          unlk      A6
080011E2  4E75      2727          rts
                    2728   ; }
                    2729   ; /******************************************************************************************************************************
                    2730   ; * Start of user program
                    2731   ; ******************************************************************************************************************************/
                    2732   ; void main()
                    2733   ; {   
                    2734   _main:
080011E4  4E56 FF4C 2735          link      A6,#-180
080011E8  2F0A      2736          move.l    A2,-(A7)
080011EA  45F9 0800 2737          lea       _InstallExceptionHandler.L,A2
080011EE  11C4      
                    2738   ; unsigned int row, i=0, count=0, counter1=1;
080011F0  42AE FF50 2739          clr.l     -176(A6)
080011F4  42AE FF54 2740          clr.l     -172(A6)
080011F8  2D7C 0000 2741          move.l    #1,-168(A6)
080011FC  0001 FF58 
                    2742   ; char c, text[150] ;
                    2743   ; int f;
                    2744   ; int valid;
                    2745   ; int PassFailFlag = 1 ;
08001200  2D7C 0000 2746          move.l    #1,-4(A6)
08001204  0001 FFFC 
                    2747   ; i = x = y = z = PortA_Count =0;
08001208  42B9 0800 2748          clr.l     _PortA_Count.L
0800120C  21FC      
0800120E  42B9 0800 2749          clr.l     _z.L
08001212  21F8      
08001214  42B9 0800 2750          clr.l     _y.L
08001218  21F4      
0800121A  42B9 0800 2751          clr.l     _x.L
0800121E  21F0      
08001220  42AE FF50 2752          clr.l     -176(A6)
                    2753   ; Timer1Count = Timer2Count = Timer3Count = Timer4Count = 0;
08001224  4239 0800 2754          clr.b     _Timer4Count.L
08001228  2206      
0800122A  4239 0800 2755          clr.b     _Timer3Count.L
0800122E  2204      
08001230  4239 0800 2756          clr.b     _Timer2Count.L
08001234  2202      
08001236  4239 0800 2757          clr.b     _Timer1Count.L
0800123A  2200      
                    2758   ; switch_counter = 0;
0800123C  4239 0800 2759          clr.b     _switch_counter.L
08001240  2208      
                    2760   ; eeprom_counter = 0;
08001242  4239 0800 2761          clr.b     _eeprom_counter.L
08001246  220A      
                    2762   ; flash_counter = 0;
08001248  4239 0800 2763          clr.b     _flash_counter.L
0800124C  220C      
                    2764   ; Init_CanBus_Controller0();
0800124E  4EB9 0800 2765          jsr       _Init_CanBus_Controller0
08001252  003E      
                    2766   ; Init_CanBus_Controller1();
08001254  4EB9 0800 2767          jsr       _Init_CanBus_Controller1
08001258  00D0      
                    2768   ; I2C_init (); // initialise the I2C controller
0800125A  4EB9 0800 2769          jsr       _I2C_init
0800125E  045E      
                    2770   ; SPI_Init(); // initialise the SPI controller
08001260  4EB9 0800 2771          jsr       _SPI_Init
08001264  0BA6      
                    2772   ; //I2C_multi_write();
                    2773   ; InstallExceptionHandler(PIA_ISR, 25) ;          // install interrupt handler for PIAs 1 and 2 on level 1 IRQ
08001266  4878 0019 2774          pea       25
0800126A  4879 0800 2775          pea       _PIA_ISR.L
0800126E  0ECA      
08001270  4E92      2776          jsr       (A2)
08001272  504F      2777          addq.w    #8,A7
                    2778   ; InstallExceptionHandler(ACIA_ISR, 26) ;		    // install interrupt handler for ACIA on level 2 IRQ
08001274  4878 001A 2779          pea       26
08001278  4879 0800 2780          pea       _ACIA_ISR.L
0800127C  0EC8      
0800127E  4E92      2781          jsr       (A2)
08001280  504F      2782          addq.w    #8,A7
                    2783   ; //InstallExceptionHandler(Timer_ISR, 27) ;		// install interrupt handler for Timers 1-4 on level 3 IRQ
                    2784   ; InstallExceptionHandler(Key2PressISR, 28) ;	    // install interrupt handler for Key Press 2 on DE1 board for level 4 IRQ
08001282  4878 001C 2785          pea       28
08001286  4879 0800 2786          pea       _Key2PressISR.L
0800128A  0ECC      
0800128C  4E92      2787          jsr       (A2)
0800128E  504F      2788          addq.w    #8,A7
                    2789   ; InstallExceptionHandler(Key1PressISR, 29) ;	    // install interrupt handler for Key Press 1 on DE1 board for level 5 IRQ
08001290  4878 001D 2790          pea       29
08001294  4879 0800 2791          pea       _Key1PressISR.L
08001298  0ECE      
0800129A  4E92      2792          jsr       (A2)
0800129C  504F      2793          addq.w    #8,A7
                    2794   ; InstallExceptionHandler(Timer_ISR, 30); // install interruot handler for Timer 2 on level 6 IRQ
0800129E  4878 001E 2795          pea       30
080012A2  4879 0800 2796          pea       _Timer_ISR.L
080012A6  0DA8      
080012A8  4E92      2797          jsr       (A2)
080012AA  504F      2798          addq.w    #8,A7
                    2799   ; //Timer1Data = 0x10;		// program time delay into timers 1-4
                    2800   ; Timer2Data = 0x25; // 100ms
080012AC  13FC 0025 2801          move.b    #37,4194356
080012B0  0040 0034 
                    2802   ; //Timer3Data = 0xbd; // 500ms
                    2803   ; //Timer4Data = 0x25; //
                    2804   ; //Timer1Control = 3;		// write 3 to control register to Bit0 = 1 (enable interrupt from timers) 1 - 4 and allow them to count Bit 1 = 1
                    2805   ; Timer2Control = 3;
080012B4  13FC 0003 2806          move.b    #3,4194358
080012B8  0040 0036 
                    2807   ; //Timer3Control = 3;
                    2808   ; //Timer4Control = 3;
                    2809   ; Init_LCD();             // initialise the LCD display to use a parallel data interface and 2 lines of display
080012BC  4EB9 0800 2810          jsr       _Init_LCD
080012C0  0F18      
                    2811   ; Init_RS232() ;          // initialise the RS232 port for use with hyper terminal
080012C2  4EB9 0800 2812          jsr       _Init_RS232
080012C6  0F36      
                    2813   ; /************************************************************************************************
                    2814   ; **  Test of scanf function
                    2815   ; ************************************************************************************************/
                    2816   ; /*scanflush() ;                       // flush any text that may have been typed ahead
                    2817   ; printf("\r\nEnter Integer: ") ;
                    2818   ; scanf("%d", &i) ;
                    2819   ; printf("You entered %d", i) ;
                    2820   ; sprintf(text, "Hello CPEN 412 Student") ;
                    2821   ; LCDLine1Message(text) ;
                    2822   ; printf("\r\nHello CPEN 412 Student\r\nYour LEDs should be Flashing") ;
                    2823   ; printf("\r\nYour LCD should be displaying") ;
                    2824   ; while(1)
                    2825   ; ;*/
                    2826   ; //printf("\r\nBig Brother is watching you");
                    2827   ; //I2C_byte_write();
                    2828   ; //I2C_byte_write();
                    2829   ; //I2C_multi_write();
                    2830   ; //I2C_byte_read();
                    2831   ; /*I2C_byte_read();
                    2832   ; I2C_byte_read();
                    2833   ; I2C_byte_read();
                    2834   ; I2C_byte_read();*/
                    2835   ; //I2C_multi_read();
                    2836   ; //DAC();
                    2837   ; //ADC();
                    2838   ; /*while(1) {
                    2839   ; valid = 0;
                    2840   ; while (!valid) {
                    2841   ; printf("\r\nWhich function you want to run?\n1.EEPROM single byte write\n2.EEPROM single byte read\n3.EEPROM page write\n4.EEPROM page read\n5.DAC->LED\n6.ADC<-sensors ");
                    2842   ; f = Get1HexDigits(0);
                    2843   ; if (f >= 1 && f <= 6) {
                    2844   ; valid = 1;
                    2845   ; } else {
                    2846   ; printf("\r\nInvalid selection! ");
                    2847   ; valid = 0;
                    2848   ; }
                    2849   ; }
                    2850   ; if (f == 1){
                    2851   ; I2C_byte_write();
                    2852   ; } else if (f == 2){
                    2853   ; I2C_byte_read();
                    2854   ; } else if (f == 3){
                    2855   ; I2C_multi_write();
                    2856   ; } else if (f == 4){
                    2857   ; I2C_multi_read();
                    2858   ; } else if (f == 5){
                    2859   ; DAC();
                    2860   ; } else if (f == 6){
                    2861   ; ADC();
                    2862   ; }
                    2863   ; }*/
                    2864   ; while (1){}
                    2865   main_1:
080012C8  60FE      2866          bra       main_1
                    2867   ; // programs should NOT exit as there is nothing to Exit TO !!!!!!
                    2868   ; // There is no OS - just press the reset button to end program and call debug
                    2869   ; }
                    2870   ULDIV:
080012CA  4E56 0000 2871          link    A6,#0
080012CE  48E7 C000 2872          movem.l D0/D1,-(A7)
080012D2  222E 0008 2873          move.l  8(A6),D1
080012D6  202E 000C 2874          move.l  12(A6),D0
080012DA  6036      2875          bra.s   ldiv_3
                    2876   LDIV:
080012DC  4E56 0000 2877          link    A6,#0
080012E0  48E7 C000 2878          movem.l D0/D1,-(A7)
080012E4  222E 0008 2879          move.l  8(A6),D1
080012E8  202E 000C 2880          move.l  12(A6),D0
080012EC  4A80      2881          tst.l   D0
080012EE  6A0E      2882          bpl.s   ldiv_1
080012F0  4480      2883          neg.l   D0
080012F2  4A81      2884          tst.l   D1
080012F4  6A14      2885          bpl.s   ldiv_2
080012F6  4481      2886          neg.l   D1
080012F8  612A      2887          bsr.s   dodiv
080012FA  4481      2888          neg.l   D1
080012FC  6016      2889          bra.s   ldiv_4
                    2890   ldiv_1:
080012FE  4A81      2891          tst.l   D1
08001300  6A10      2892          bpl.s   ldiv_3
08001302  4481      2893          neg.l   D1
08001304  611E      2894          bsr.s   dodiv
08001306  4480      2895          neg.l   D0
08001308  600A      2896          bra.s   ldiv_4
                    2897   ldiv_2:
0800130A  6118      2898          bsr.s   dodiv
0800130C  4480      2899          neg.l   D0
0800130E  4481      2900          neg.l   D1
08001310  6002      2901          bra.s   ldiv_4
                    2902   ldiv_3:
08001312  6110      2903          bsr.s   dodiv
                    2904   ldiv_4:
08001314  2D40 0008 2905          move.l  D0,8(A6)
08001318  2D41 000C 2906          move.l  D1,12(A6)
0800131C  4CDF 0003 2907          movem.l (A7)+,D0/D1
08001320  4E5E      2908          unlk    A6
08001322  4E75      2909          rts
                    2910   dodiv:
08001324  0C81 0000 2911          cmpi.l  #$FFFF,D1
08001328  FFFF      
0800132A  6236      2912          bhi.s   dodiv_2
0800132C  0C80 0000 2913          cmpi.l  #$FFFF,D0
08001330  FFFF      
08001332  6210      2914          bhi.s   dodiv_1
08001334  80C1      2915          divu    D1,D0
08001336  2200      2916          move.l  D0,D1
08001338  4241      2917          clr.w   D1
0800133A  4841      2918          swap    D1
0800133C  0280 0000 2919          andi.l  #$FFFF,D0
08001340  FFFF      
08001342  4E75      2920          rts
                    2921   dodiv_1:
08001344  48A7 A000 2922          movem.w D0/D2,-(A7)
08001348  4240      2923          clr.w   D0
0800134A  4840      2924          swap    D0
0800134C  80C1      2925          divu    D1,D0
0800134E  3400      2926          move.w  D0,D2
08001350  301F      2927          move.w  (A7)+,D0
08001352  80C1      2928          divu    D1,D0
08001354  4840      2929          swap    D0
08001356  4281      2930          clr.l   D1
08001358  3200      2931          move.w  D0,D1
0800135A  3002      2932          move.w  D2,D0
0800135C  4840      2933          swap    D0
0800135E  341F      2934          move.w  (A7)+,D2
08001360  4E75      2935          rts
                    2936   dodiv_2:
08001362  48E7 3800 2937          movem.l D2/D3/D4,-(A7)
08001366  2401      2938          move.l  D1,D2
08001368  4242      2939          clr.w   D2
0800136A  4842      2940          swap    D2
0800136C  5282      2941          addq.l  #1,D2
0800136E  2600      2942          move.l  D0,D3
08001370  2801      2943          move.l  D1,D4
08001372  2202      2944          move.l  D2,D1
08001374  61CE      2945          bsr.s   dodiv_1
08001376  2204      2946          move.l  D4,D1
08001378  82C2      2947          divu    D2,D1
0800137A  80C1      2948          divu    D1,D0
0800137C  0280 0000 2949          andi.l  #$FFFF,D0
08001380  FFFF      
                    2950   dodiv_3:
08001382  2204      2951          move.l  D4,D1
08001384  2404      2952          move.l  D4,D2
08001386  4842      2953          swap    D2
08001388  C2C0      2954          mulu    D0,D1
0800138A  C4C0      2955          mulu    D0,D2
0800138C  4842      2956          swap    D2
0800138E  D282      2957          add.l   D2,D1
08001390  9283      2958          sub.l   D3,D1
08001392  620A      2959          bhi.s   dodiv_4
08001394  4481      2960          neg.l   D1
08001396  B881      2961          cmp.l   D1,D4
08001398  6208      2962          bhi.s   dodiv_5
0800139A  5280      2963          addq.l  #1,D0
0800139C  60E4      2964          bra.s   dodiv_3
                    2965   dodiv_4:
0800139E  5380      2966          subq.l  #1,D0
080013A0  60E0      2967          bra.s   dodiv_3
                    2968   dodiv_5:
080013A2  4CDF 001C 2969          movem.l (A7)+,D2/D3/D4
080013A6  4E75      2970          rts
                    2971   _printf:
080013A8  4E56 FFFC 2972          link      A6,#-4
080013AC  2F02      2973          move.l    D2,-(A7)
080013AE  41EE 0008 2974          lea       8(A6),A0
080013B2  5848      2975          addq.w    #4,A0
080013B4  2408      2976          move.l    A0,D2
080013B6  2F02      2977          move.l    D2,-(A7)
080013B8  2F2E 0008 2978          move.l    8(A6),-(A7)
080013BC  42A7      2979          clr.l     -(A7)
080013BE  4EB9 0800 2980          jsr       _doprint
080013C2  1480      
080013C4  DEFC 000C 2981          add.w     #12,A7
080013C8  2D40 FFFC 2982          move.l    D0,-4(A6)
080013CC  4282      2983          clr.l     D2
080013CE  202E FFFC 2984          move.l    -4(A6),D0
080013D2  241F      2985          move.l    (A7)+,D2
080013D4  4E5E      2986          unlk      A6
080013D6  4E75      2987          rts
                    2988   @doprint_copy:
080013D8  4E56 0000 2989          link      A6,#0
080013DC  206E 0008 2990          move.l    8(A6),A0
080013E0  4A90      2991          tst.l     (A0)
080013E2  6710      2992          beq.s     @doprint_copy_1
080013E4  202E 000C 2993          move.l    12(A6),D0
080013E8  206E 0008 2994          move.l    8(A6),A0
080013EC  2250      2995          move.l    (A0),A1
080013EE  5290      2996          addq.l    #1,(A0)
080013F0  1280      2997          move.b    D0,(A1)
080013F2  600C      2998          bra.s     @doprint_copy_2
                    2999   @doprint_copy_1:
080013F4  2F2E 000C 3000          move.l    12(A6),-(A7)
080013F8  4EB9 0800 3001          jsr       _putch
080013FC  1CD2      
080013FE  584F      3002          addq.w    #4,A7
                    3003   @doprint_copy_2:
08001400  4E5E      3004          unlk      A6
08001402  4E75      3005          rts
                    3006   @doprint_getval:
08001404  4E56 0000 3007          link      A6,#0
08001408  48E7 3000 3008          movem.l   D2/D3,-(A7)
0800140C  262E 0008 3009          move.l    8(A6),D3
08001410  4282      3010          clr.l     D2
08001412  2043      3011          move.l    D3,A0
08001414  2050      3012          move.l    (A0),A0
08001416  1010      3013          move.b    (A0),D0
08001418  0C00 002A 3014          cmp.b     #42,D0
0800141C  6612      3015          bne.s     @doprint_getval_1
0800141E  206E 000C 3016          move.l    12(A6),A0
08001422  2250      3017          move.l    (A0),A1
08001424  5890      3018          addq.l    #4,(A0)
08001426  2411      3019          move.l    (A1),D2
08001428  2043      3020          move.l    D3,A0
0800142A  5290      3021          addq.l    #1,(A0)
0800142C  6000 0048 3022          bra       @doprint_getval_5
                    3023   @doprint_getval_1:
08001430  7001      3024          moveq     #1,D0
08001432  2043      3025          move.l    D3,A0
08001434  2050      3026          move.l    (A0),A0
08001436  1210      3027          move.b    (A0),D1
08001438  4881      3028          ext.w     D1
0800143A  48C1      3029          ext.l     D1
0800143C  D081      3030          add.l     D1,D0
0800143E  41F9 0800 3031          lea       __ctype.L,A0
08001442  20DE      
08001444  1030 0800 3032          move.b    0(A0,D0.L),D0
08001448  C03C 0004 3033          and.b     #4,D0
0800144C  6728      3034          beq.s     @doprint_getval_5
0800144E  2F02      3035          move.l    D2,-(A7)
08001450  4878 000A 3036          pea       10
08001454  4EB9 0800 3037          jsr       LMUL
08001458  1C32      
0800145A  2017      3038          move.l    (A7),D0
0800145C  504F      3039          addq.w    #8,A7
0800145E  2043      3040          move.l    D3,A0
08001460  2250      3041          move.l    (A0),A1
08001462  5290      3042          addq.l    #1,(A0)
08001464  1211      3043          move.b    (A1),D1
08001466  4881      3044          ext.w     D1
08001468  48C1      3045          ext.l     D1
0800146A  D081      3046          add.l     D1,D0
0800146C  0480 0000 3047          sub.l     #48,D0
08001470  0030      
08001472  2400      3048          move.l    D0,D2
08001474  60BA      3049          bra       @doprint_getval_1
                    3050   @doprint_getval_5:
08001476  2002      3051          move.l    D2,D0
08001478  4CDF 000C 3052          movem.l   (A7)+,D2/D3
0800147C  4E5E      3053          unlk      A6
0800147E  4E75      3054          rts
                    3055   _doprint:
08001480  4E56 FFCC 3056          link      A6,#-52
08001484  48E7 3F3C 3057          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
08001488  45EE 0008 3058          lea       8(A6),A2
0800148C  47F9 0800 3059          lea       @doprint_copy.L,A3
08001490  13D8      
08001492  49F9 0800 3060          lea       _ultoa.L,A4
08001496  1BBA      
08001498  4286      3061          clr.l     D6
                    3062   doprint_1:
0800149A  206E 000C 3063          move.l    12(A6),A0
0800149E  4A10      3064          tst.b     (A0)
080014A0  6700 05F0 3065          beq       doprint_3
080014A4  206E 000C 3066          move.l    12(A6),A0
080014A8  1010      3067          move.b    (A0),D0
080014AA  0C00 0025 3068          cmp.b     #37,D0
080014AE  671C      3069          beq.s     doprint_4
080014B0  206E 000C 3070          move.l    12(A6),A0
080014B4  52AE 000C 3071          addq.l    #1,12(A6)
080014B8  1210      3072          move.b    (A0),D1
080014BA  4881      3073          ext.w     D1
080014BC  48C1      3074          ext.l     D1
080014BE  2F01      3075          move.l    D1,-(A7)
080014C0  2F0A      3076          move.l    A2,-(A7)
080014C2  4E93      3077          jsr       (A3)
080014C4  504F      3078          addq.w    #8,A7
080014C6  5286      3079          addq.l    #1,D6
080014C8  6000 05C4 3080          bra       doprint_2
                    3081   doprint_4:
080014CC  52AE 000C 3082          addq.l    #1,12(A6)
080014D0  422E FFD3 3083          clr.b     -45(A6)
080014D4  422E FFD2 3084          clr.b     -46(A6)
080014D8  422E FFD0 3085          clr.b     -48(A6)
080014DC  422E FFCF 3086          clr.b     -49(A6)
080014E0  422E FFCE 3087          clr.b     -50(A6)
080014E4  422E FFCD 3088          clr.b     -51(A6)
080014E8  42AE FFFC 3089          clr.l     -4(A6)
080014EC  7AFF      3090          moveq     #-1,D5
080014EE  41EE FFDC 3091          lea       -36(A6),A0
080014F2  2608      3092          move.l    A0,D3
080014F4  2408      3093          move.l    A0,D2
                    3094   doprint_6:
080014F6  206E 000C 3095          move.l    12(A6),A0
080014FA  1010      3096          move.b    (A0),D0
080014FC  4880      3097          ext.w     D0
080014FE  48C0      3098          ext.l     D0
08001500  0C80 0000 3099          cmp.l     #43,D0
08001504  002B      
08001506  6730      3100          beq.s     doprint_12
08001508  6E18      3101          bgt.s     doprint_15
0800150A  0C80 0000 3102          cmp.l     #35,D0
0800150E  0023      
08001510  6700 003E 3103          beq       doprint_14
08001514  6E00 0046 3104          bgt       doprint_9
08001518  0C80 0000 3105          cmp.l     #32,D0
0800151C  0020      
0800151E  6724      3106          beq.s     doprint_13
08001520  603A      3107          bra.s     doprint_9
                    3108   doprint_15:
08001522  0C80 0000 3109          cmp.l     #45,D0
08001526  002D      
08001528  6702      3110          beq.s     doprint_11
0800152A  6030      3111          bra.s     doprint_9
                    3112   doprint_11:
0800152C  1D7C 0001 3113          move.b    #1,-51(A6)
08001530  FFCD      
08001532  52AE 000C 3114          addq.l    #1,12(A6)
08001536  6026      3115          bra.s     doprint_7
                    3116   doprint_12:
08001538  1D7C 0001 3117          move.b    #1,-50(A6)
0800153C  FFCE      
0800153E  52AE 000C 3118          addq.l    #1,12(A6)
08001542  601A      3119          bra.s     doprint_7
                    3120   doprint_13:
08001544  1D7C 0001 3121          move.b    #1,-49(A6)
08001548  FFCF      
0800154A  52AE 000C 3122          addq.l    #1,12(A6)
0800154E  600E      3123          bra.s     doprint_7
                    3124   doprint_14:
08001550  1D7C 0001 3125          move.b    #1,-48(A6)
08001554  FFD0      
08001556  52AE 000C 3126          addq.l    #1,12(A6)
0800155A  6002      3127          bra.s     doprint_7
                    3128   doprint_9:
0800155C  6002      3129          bra.s     doprint_8
                    3130   doprint_7:
0800155E  6096      3131          bra       doprint_6
                    3132   doprint_8:
08001560  206E 000C 3133          move.l    12(A6),A0
08001564  1010      3134          move.b    (A0),D0
08001566  0C00 0030 3135          cmp.b     #48,D0
0800156A  660A      3136          bne.s     doprint_16
0800156C  52AE 000C 3137          addq.l    #1,12(A6)
08001570  1D7C 0001 3138          move.b    #1,-46(A6)
08001574  FFD2      
                    3139   doprint_16:
08001576  486E 0010 3140          pea       16(A6)
0800157A  486E 000C 3141          pea       12(A6)
0800157E  4EB9 0800 3142          jsr       @doprint_getval
08001582  1404      
08001584  504F      3143          addq.w    #8,A7
08001586  2A40      3144          move.l    D0,A5
08001588  206E 000C 3145          move.l    12(A6),A0
0800158C  1010      3146          move.b    (A0),D0
0800158E  0C00 002E 3147          cmp.b     #46,D0
08001592  6616      3148          bne.s     doprint_18
08001594  52AE 000C 3149          addq.l    #1,12(A6)
08001598  486E 0010 3150          pea       16(A6)
0800159C  486E 000C 3151          pea       12(A6)
080015A0  4EB9 0800 3152          jsr       @doprint_getval
080015A4  1404      
080015A6  504F      3153          addq.w    #8,A7
080015A8  2A00      3154          move.l    D0,D5
                    3155   doprint_18:
080015AA  206E 000C 3156          move.l    12(A6),A0
080015AE  1010      3157          move.b    (A0),D0
080015B0  0C00 006C 3158          cmp.b     #108,D0
080015B4  660A      3159          bne.s     doprint_20
080015B6  52AE 000C 3160          addq.l    #1,12(A6)
080015BA  1D7C 0001 3161          move.b    #1,-45(A6)
080015BE  FFD3      
                    3162   doprint_20:
080015C0  206E 000C 3163          move.l    12(A6),A0
080015C4  1010      3164          move.b    (A0),D0
080015C6  4880      3165          ext.w     D0
080015C8  48C0      3166          ext.l     D0
080015CA  0C80 0000 3167          cmp.l     #111,D0
080015CE  006F      
080015D0  6700 00D8 3168          beq       doprint_27
080015D4  6E34      3169          bgt.s     doprint_33
080015D6  0C80 0000 3170          cmp.l     #100,D0
080015DA  0064      
080015DC  6700 0054 3171          beq       doprint_24
080015E0  6E1C      3172          bgt.s     doprint_34
080015E2  0C80 0000 3173          cmp.l     #99,D0
080015E6  0063      
080015E8  6700 0130 3174          beq       doprint_30
080015EC  6E00 0174 3175          bgt       doprint_22
080015F0  0C80 0000 3176          cmp.l     #88,D0
080015F4  0058      
080015F6  6700 00EA 3177          beq       doprint_28
080015FA  6000 0166 3178          bra       doprint_22
                    3179   doprint_34:
080015FE  0C80 0000 3180          cmp.l     #105,D0
08001602  0069      
08001604  672C      3181          beq.s     doprint_24
08001606  6000 015A 3182          bra       doprint_22
                    3183   doprint_33:
0800160A  0C80 0000 3184          cmp.l     #117,D0
0800160E  0075      
08001610  6700 0060 3185          beq       doprint_26
08001614  6E0E      3186          bgt.s     doprint_35
08001616  0C80 0000 3187          cmp.l     #115,D0
0800161A  0073      
0800161C  6700 0124 3188          beq       doprint_31
08001620  6000 0140 3189          bra       doprint_22
                    3190   doprint_35:
08001624  0C80 0000 3191          cmp.l     #120,D0
08001628  0078      
0800162A  6700 00B6 3192          beq       doprint_28
0800162E  6000 0132 3193          bra       doprint_22
                    3194   doprint_24:
08001632  4A2E FFD3 3195          tst.b     -45(A6)
08001636  671C      3196          beq.s     doprint_36
08001638  4878 000A 3197          pea       10
0800163C  2F03      3198          move.l    D3,-(A7)
0800163E  206E 0010 3199          move.l    16(A6),A0
08001642  58AE 0010 3200          addq.l    #4,16(A6)
08001646  2F10      3201          move.l    (A0),-(A7)
08001648  4EB9 0800 3202          jsr       _ltoa
0800164C  1B32      
0800164E  DEFC 000C 3203          add.w     #12,A7
08001652  601A      3204          bra.s     doprint_37
                    3205   doprint_36:
08001654  4878 000A 3206          pea       10
08001658  2F03      3207          move.l    D3,-(A7)
0800165A  206E 0010 3208          move.l    16(A6),A0
0800165E  58AE 0010 3209          addq.l    #4,16(A6)
08001662  2F10      3210          move.l    (A0),-(A7)
08001664  4EB9 0800 3211          jsr       _ltoa
08001668  1B32      
0800166A  DEFC 000C 3212          add.w     #12,A7
                    3213   doprint_37:
0800166E  6000 0100 3214          bra       doprint_23
                    3215   doprint_26:
08001672  4A2E FFD3 3216          tst.b     -45(A6)
08001676  6718      3217          beq.s     doprint_38
08001678  4878 000A 3218          pea       10
0800167C  2F03      3219          move.l    D3,-(A7)
0800167E  206E 0010 3220          move.l    16(A6),A0
08001682  58AE 0010 3221          addq.l    #4,16(A6)
08001686  2F10      3222          move.l    (A0),-(A7)
08001688  4E94      3223          jsr       (A4)
0800168A  DEFC 000C 3224          add.w     #12,A7
0800168E  6016      3225          bra.s     doprint_39
                    3226   doprint_38:
08001690  4878 000A 3227          pea       10
08001694  2F03      3228          move.l    D3,-(A7)
08001696  206E 0010 3229          move.l    16(A6),A0
0800169A  58AE 0010 3230          addq.l    #4,16(A6)
0800169E  2F10      3231          move.l    (A0),-(A7)
080016A0  4E94      3232          jsr       (A4)
080016A2  DEFC 000C 3233          add.w     #12,A7
                    3234   doprint_39:
080016A6  6000 00C8 3235          bra       doprint_23
                    3236   doprint_27:
080016AA  4A2E FFD3 3237          tst.b     -45(A6)
080016AE  6718      3238          beq.s     doprint_40
080016B0  4878 0008 3239          pea       8
080016B4  2F03      3240          move.l    D3,-(A7)
080016B6  206E 0010 3241          move.l    16(A6),A0
080016BA  58AE 0010 3242          addq.l    #4,16(A6)
080016BE  2F10      3243          move.l    (A0),-(A7)
080016C0  4E94      3244          jsr       (A4)
080016C2  DEFC 000C 3245          add.w     #12,A7
080016C6  6016      3246          bra.s     doprint_41
                    3247   doprint_40:
080016C8  4878 0008 3248          pea       8
080016CC  2F03      3249          move.l    D3,-(A7)
080016CE  206E 0010 3250          move.l    16(A6),A0
080016D2  58AE 0010 3251          addq.l    #4,16(A6)
080016D6  2F10      3252          move.l    (A0),-(A7)
080016D8  4E94      3253          jsr       (A4)
080016DA  DEFC 000C 3254          add.w     #12,A7
                    3255   doprint_41:
080016DE  6000 0090 3256          bra       doprint_23
                    3257   doprint_28:
080016E2  4A2E FFD3 3258          tst.b     -45(A6)
080016E6  6718      3259          beq.s     doprint_42
080016E8  4878 0010 3260          pea       16
080016EC  2F03      3261          move.l    D3,-(A7)
080016EE  206E 0010 3262          move.l    16(A6),A0
080016F2  58AE 0010 3263          addq.l    #4,16(A6)
080016F6  2F10      3264          move.l    (A0),-(A7)
080016F8  4E94      3265          jsr       (A4)
080016FA  DEFC 000C 3266          add.w     #12,A7
080016FE  6016      3267          bra.s     doprint_43
                    3268   doprint_42:
08001700  4878 0010 3269          pea       16
08001704  2F03      3270          move.l    D3,-(A7)
08001706  206E 0010 3271          move.l    16(A6),A0
0800170A  58AE 0010 3272          addq.l    #4,16(A6)
0800170E  2F10      3273          move.l    (A0),-(A7)
08001710  4E94      3274          jsr       (A4)
08001712  DEFC 000C 3275          add.w     #12,A7
                    3276   doprint_43:
08001716  6000 0058 3277          bra       doprint_23
                    3278   doprint_30:
0800171A  206E 0010 3279          move.l    16(A6),A0
0800171E  58AE 0010 3280          addq.l    #4,16(A6)
08001722  2010      3281          move.l    (A0),D0
08001724  2042      3282          move.l    D2,A0
08001726  5282      3283          addq.l    #1,D2
08001728  1080      3284          move.b    D0,(A0)
0800172A  2042      3285          move.l    D2,A0
0800172C  4210      3286          clr.b     (A0)
0800172E  200D      3287          move.l    A5,D0
08001730  6704      3288          beq.s     doprint_44
08001732  200D      3289          move.l    A5,D0
08001734  6006      3290          bra.s     doprint_45
                    3291   doprint_44:
08001736  7001      3292          moveq     #1,D0
08001738  4880      3293          ext.w     D0
0800173A  48C0      3294          ext.l     D0
                    3295   doprint_45:
0800173C  2A00      3296          move.l    D0,D5
0800173E  6000 0030 3297          bra       doprint_23
                    3298   doprint_31:
08001742  206E 0010 3299          move.l    16(A6),A0
08001746  58AE 0010 3300          addq.l    #4,16(A6)
0800174A  2610      3301          move.l    (A0),D3
0800174C  0C85 FFFF 3302          cmp.l     #-1,D5
08001750  FFFF      
08001752  660C      3303          bne.s     doprint_46
08001754  2F03      3304          move.l    D3,-(A7)
08001756  4EB9 0800 3305          jsr       _strlen
0800175A  1CC0      
0800175C  584F      3306          addq.w    #4,A7
0800175E  2A00      3307          move.l    D0,D5
                    3308   doprint_46:
08001760  600E      3309          bra.s     doprint_23
                    3310   doprint_22:
08001762  206E 000C 3311          move.l    12(A6),A0
08001766  2242      3312          move.l    D2,A1
08001768  5282      3313          addq.l    #1,D2
0800176A  1290      3314          move.b    (A0),(A1)
0800176C  2042      3315          move.l    D2,A0
0800176E  4210      3316          clr.b     (A0)
                    3317   doprint_23:
08001770  2F03      3318          move.l    D3,-(A7)
08001772  4EB9 0800 3319          jsr       _strlen
08001776  1CC0      
08001778  584F      3320          addq.w    #4,A7
0800177A  1800      3321          move.b    D0,D4
0800177C  206E 000C 3322          move.l    12(A6),A0
08001780  1010      3323          move.b    (A0),D0
08001782  0C00 0073 3324          cmp.b     #115,D0
08001786  661C      3325          bne.s     doprint_48
08001788  0C85 0000 3326          cmp.l     #0,D5
0800178C  0000      
0800178E  6D14      3327          blt.s     doprint_48
08001790  4884      3328          ext.w     D4
08001792  48C4      3329          ext.l     D4
08001794  B885      3330          cmp.l     D5,D4
08001796  6F04      3331          ble.s     doprint_50
08001798  2005      3332          move.l    D5,D0
0800179A  6006      3333          bra.s     doprint_51
                    3334   doprint_50:
0800179C  1004      3335          move.b    D4,D0
0800179E  4880      3336          ext.w     D0
080017A0  48C0      3337          ext.l     D0
                    3338   doprint_51:
080017A2  1800      3339          move.b    D0,D4
                    3340   doprint_48:
080017A4  206E 000C 3341          move.l    12(A6),A0
080017A8  1010      3342          move.b    (A0),D0
080017AA  0C00 0058 3343          cmp.b     #88,D0
080017AE  6600 0028 3344          bne       doprint_56
080017B2  41EE FFDC 3345          lea       -36(A6),A0
080017B6  2408      3346          move.l    A0,D2
                    3347   doprint_54:
080017B8  2042      3348          move.l    D2,A0
080017BA  4A10      3349          tst.b     (A0)
080017BC  671A      3350          beq.s     doprint_56
080017BE  2042      3351          move.l    D2,A0
080017C0  1210      3352          move.b    (A0),D1
080017C2  4881      3353          ext.w     D1
080017C4  48C1      3354          ext.l     D1
080017C6  2F01      3355          move.l    D1,-(A7)
080017C8  4EB9 0800 3356          jsr       _toupper
080017CC  1D02      
080017CE  584F      3357          addq.w    #4,A7
080017D0  2042      3358          move.l    D2,A0
080017D2  1080      3359          move.b    D0,(A0)
080017D4  5282      3360          addq.l    #1,D2
080017D6  60E0      3361          bra       doprint_54
                    3362   doprint_56:
080017D8  7E00      3363          moveq     #0,D7
080017DA  41EE FFD4 3364          lea       -44(A6),A0
080017DE  2408      3365          move.l    A0,D2
080017E0  206E 000C 3366          move.l    12(A6),A0
080017E4  1010      3367          move.b    (A0),D0
080017E6  0C00 0064 3368          cmp.b     #100,D0
080017EA  670E      3369          beq.s     doprint_59
080017EC  206E 000C 3370          move.l    12(A6),A0
080017F0  1010      3371          move.b    (A0),D0
080017F2  0C00 0069 3372          cmp.b     #105,D0
080017F6  6600 0068 3373          bne       doprint_65
                    3374   doprint_59:
080017FA  102E FFCE 3375          move.b    -50(A6),D0
080017FE  4880      3376          ext.w     D0
08001800  48C0      3377          ext.l     D0
08001802  4A80      3378          tst.l     D0
08001804  660C      3379          bne.s     doprint_62
08001806  2043      3380          move.l    D3,A0
08001808  1010      3381          move.b    (A0),D0
0800180A  0C00 002D 3382          cmp.b     #45,D0
0800180E  6600 0028 3383          bne       doprint_60
                    3384   doprint_62:
08001812  2043      3385          move.l    D3,A0
08001814  1010      3386          move.b    (A0),D0
08001816  0C00 002D 3387          cmp.b     #45,D0
0800181A  660E      3388          bne.s     doprint_63
0800181C  2043      3389          move.l    D3,A0
0800181E  5283      3390          addq.l    #1,D3
08001820  2242      3391          move.l    D2,A1
08001822  5282      3392          addq.l    #1,D2
08001824  1290      3393          move.b    (A0),(A1)
08001826  5304      3394          subq.b    #1,D4
08001828  6008      3395          bra.s     doprint_64
                    3396   doprint_63:
0800182A  2042      3397          move.l    D2,A0
0800182C  5282      3398          addq.l    #1,D2
0800182E  10BC 002B 3399          move.b    #43,(A0)
                    3400   doprint_64:
08001832  5287      3401          addq.l    #1,D7
08001834  6000 002A 3402          bra       doprint_65
                    3403   doprint_60:
08001838  4A2E FFCF 3404          tst.b     -49(A6)
0800183C  6722      3405          beq.s     doprint_65
0800183E  2043      3406          move.l    D3,A0
08001840  1010      3407          move.b    (A0),D0
08001842  0C00 002D 3408          cmp.b     #45,D0
08001846  660E      3409          bne.s     doprint_67
08001848  2043      3410          move.l    D3,A0
0800184A  5283      3411          addq.l    #1,D3
0800184C  2242      3412          move.l    D2,A1
0800184E  5282      3413          addq.l    #1,D2
08001850  1290      3414          move.b    (A0),(A1)
08001852  5304      3415          subq.b    #1,D4
08001854  6008      3416          bra.s     doprint_68
                    3417   doprint_67:
08001856  2042      3418          move.l    D2,A0
08001858  5282      3419          addq.l    #1,D2
0800185A  10BC 0020 3420          move.b    #32,(A0)
                    3421   doprint_68:
0800185E  5287      3422          addq.l    #1,D7
                    3423   doprint_65:
08001860  4A2E FFD0 3424          tst.b     -48(A6)
08001864  6700 005A 3425          beq       doprint_77
08001868  206E 000C 3426          move.l    12(A6),A0
0800186C  1010      3427          move.b    (A0),D0
0800186E  4880      3428          ext.w     D0
08001870  48C0      3429          ext.l     D0
08001872  0C80 0000 3430          cmp.l     #111,D0
08001876  006F      
08001878  671A      3431          beq.s     doprint_73
0800187A  6E0C      3432          bgt.s     doprint_76
0800187C  0C80 0000 3433          cmp.l     #88,D0
08001880  0058      
08001882  6710      3434          beq.s     doprint_73
08001884  6000 003A 3435          bra       doprint_77
                    3436   doprint_76:
08001888  0C80 0000 3437          cmp.l     #120,D0
0800188C  0078      
0800188E  6704      3438          beq.s     doprint_73
08001890  6000 002E 3439          bra       doprint_77
                    3440   doprint_73:
08001894  2042      3441          move.l    D2,A0
08001896  5282      3442          addq.l    #1,D2
08001898  10BC 0030 3443          move.b    #48,(A0)
0800189C  5287      3444          addq.l    #1,D7
0800189E  206E 000C 3445          move.l    12(A6),A0
080018A2  1010      3446          move.b    (A0),D0
080018A4  0C00 0078 3447          cmp.b     #120,D0
080018A8  670C      3448          beq.s     doprint_79
080018AA  206E 000C 3449          move.l    12(A6),A0
080018AE  1010      3450          move.b    (A0),D0
080018B0  0C00 0058 3451          cmp.b     #88,D0
080018B4  660A      3452          bne.s     doprint_77
                    3453   doprint_79:
080018B6  2042      3454          move.l    D2,A0
080018B8  5282      3455          addq.l    #1,D2
080018BA  10BC 0078 3456          move.b    #120,(A0)
080018BE  5287      3457          addq.l    #1,D7
                    3458   doprint_77:
080018C0  2042      3459          move.l    D2,A0
080018C2  4210      3460          clr.b     (A0)
080018C4  206E 000C 3461          move.l    12(A6),A0
080018C8  1010      3462          move.b    (A0),D0
080018CA  4880      3463          ext.w     D0
080018CC  48C0      3464          ext.l     D0
080018CE  0C80 0000 3465          cmp.l     #105,D0
080018D2  0069      
080018D4  6700 0076 3466          beq       doprint_82
080018D8  6E42      3467          bgt.s     doprint_93
080018DA  0C80 0000 3468          cmp.l     #99,D0
080018DE  0063      
080018E0  6700 0084 3469          beq       doprint_96
080018E4  6E1C      3470          bgt.s     doprint_94
080018E6  0C80 0000 3471          cmp.l     #88,D0
080018EA  0058      
080018EC  6700 005E 3472          beq       doprint_82
080018F0  6E00 0184 3473          bgt       doprint_80
080018F4  0C80 0000 3474          cmp.l     #69,D0
080018F8  0045      
080018FA  6700 0050 3475          beq       doprint_82
080018FE  6000 0176 3476          bra       doprint_80
                    3477   doprint_94:
08001902  0C80 0000 3478          cmp.l     #101,D0
08001906  0065      
08001908  6700 0042 3479          beq       doprint_82
0800190C  6E00 0168 3480          bgt       doprint_80
08001910  0C80 0000 3481          cmp.l     #100,D0
08001914  0064      
08001916  6734      3482          beq.s     doprint_82
08001918  6000 015C 3483          bra       doprint_80
                    3484   doprint_93:
0800191C  0C80 0000 3485          cmp.l     #117,D0
08001920  0075      
08001922  6728      3486          beq.s     doprint_82
08001924  6E1A      3487          bgt.s     doprint_95
08001926  0C80 0000 3488          cmp.l     #115,D0
0800192A  0073      
0800192C  6700 0038 3489          beq       doprint_96
08001930  6E00 0144 3490          bgt       doprint_80
08001934  0C80 0000 3491          cmp.l     #111,D0
08001938  006F      
0800193A  6710      3492          beq.s     doprint_82
0800193C  6000 0138 3493          bra       doprint_80
                    3494   doprint_95:
08001940  0C80 0000 3495          cmp.l     #120,D0
08001944  0078      
08001946  6704      3496          beq.s     doprint_82
08001948  6000 012C 3497          bra       doprint_80
                    3498   doprint_82:
0800194C  4A2E FFD2 3499          tst.b     -46(A6)
08001950  6714      3500          beq.s     doprint_96
08001952  4A2E FFCD 3501          tst.b     -51(A6)
08001956  660E      3502          bne.s     doprint_96
08001958  200D      3503          move.l    A5,D0
0800195A  9087      3504          sub.l     D7,D0
0800195C  4884      3505          ext.w     D4
0800195E  48C4      3506          ext.l     D4
08001960  9084      3507          sub.l     D4,D0
08001962  2D40 FFFC 3508          move.l    D0,-4(A6)
                    3509   doprint_96:
08001966  202E FFFC 3510          move.l    -4(A6),D0
0800196A  0C80 0000 3511          cmp.l     #0,D0
0800196E  0000      
08001970  6C04      3512          bge.s     doprint_98
08001972  42AE FFFC 3513          clr.l     -4(A6)
                    3514   doprint_98:
08001976  4A2E FFCD 3515          tst.b     -51(A6)
0800197A  6600 0030 3516          bne       doprint_104
0800197E  1004      3517          move.b    D4,D0
08001980  4880      3518          ext.w     D0
08001982  48C0      3519          ext.l     D0
08001984  D0AE FFFC 3520          add.l     -4(A6),D0
08001988  D087      3521          add.l     D7,D0
0800198A  1D40 FFD1 3522          move.b    D0,-47(A6)
                    3523   doprint_102:
0800198E  102E FFD1 3524          move.b    -47(A6),D0
08001992  4880      3525          ext.w     D0
08001994  48C0      3526          ext.l     D0
08001996  220D      3527          move.l    A5,D1
08001998  534D      3528          subq.w    #1,A5
0800199A  B081      3529          cmp.l     D1,D0
0800199C  6C0E      3530          bge.s     doprint_104
0800199E  4878 0020 3531          pea       32
080019A2  2F0A      3532          move.l    A2,-(A7)
080019A4  4E93      3533          jsr       (A3)
080019A6  504F      3534          addq.w    #8,A7
080019A8  5286      3535          addq.l    #1,D6
080019AA  60E2      3536          bra       doprint_102
                    3537   doprint_104:
080019AC  41EE FFD4 3538          lea       -44(A6),A0
080019B0  2408      3539          move.l    A0,D2
                    3540   doprint_105:
080019B2  2042      3541          move.l    D2,A0
080019B4  4A10      3542          tst.b     (A0)
080019B6  6716      3543          beq.s     doprint_107
080019B8  2042      3544          move.l    D2,A0
080019BA  5282      3545          addq.l    #1,D2
080019BC  1210      3546          move.b    (A0),D1
080019BE  4881      3547          ext.w     D1
080019C0  48C1      3548          ext.l     D1
080019C2  2F01      3549          move.l    D1,-(A7)
080019C4  2F0A      3550          move.l    A2,-(A7)
080019C6  4E93      3551          jsr       (A3)
080019C8  504F      3552          addq.w    #8,A7
080019CA  5286      3553          addq.l    #1,D6
080019CC  60E4      3554          bra       doprint_105
                    3555   doprint_107:
080019CE  202E FFFC 3556          move.l    -4(A6),D0
080019D2  1D40 FFD1 3557          move.b    D0,-47(A6)
                    3558   doprint_108:
080019D6  102E FFD1 3559          move.b    -47(A6),D0
080019DA  532E FFD1 3560          subq.b    #1,-47(A6)
080019DE  4A00      3561          tst.b     D0
080019E0  670E      3562          beq.s     doprint_110
080019E2  4878 0030 3563          pea       48
080019E6  2F0A      3564          move.l    A2,-(A7)
080019E8  4E93      3565          jsr       (A3)
080019EA  504F      3566          addq.w    #8,A7
080019EC  5286      3567          addq.l    #1,D6
080019EE  60E6      3568          bra       doprint_108
                    3569   doprint_110:
080019F0  2043      3570          move.l    D3,A0
080019F2  4A10      3571          tst.b     (A0)
080019F4  6700 0048 3572          beq       doprint_113
080019F8  206E 000C 3573          move.l    12(A6),A0
080019FC  1010      3574          move.b    (A0),D0
080019FE  4880      3575          ext.w     D0
08001A00  48C0      3576          ext.l     D0
08001A02  0C80 0000 3577          cmp.l     #115,D0
08001A06  0073      
08001A08  670C      3578          beq.s     doprint_116
08001A0A  6E18      3579          bgt.s     doprint_119
08001A0C  0C80 0000 3580          cmp.l     #99,D0
08001A10  0063      
08001A12  6702      3581          beq.s     doprint_116
08001A14  600E      3582          bra.s     doprint_119
                    3583   doprint_116:
08001A16  2005      3584          move.l    D5,D0
08001A18  5385      3585          subq.l    #1,D5
08001A1A  0C80 0000 3586          cmp.l     #0,D0
08001A1E  0000      
08001A20  6E02      3587          bgt.s     doprint_119
08001A22  6016      3588          bra.s     doprint_115
                    3589   doprint_119:
08001A24  2043      3590          move.l    D3,A0
08001A26  5283      3591          addq.l    #1,D3
08001A28  1210      3592          move.b    (A0),D1
08001A2A  4881      3593          ext.w     D1
08001A2C  48C1      3594          ext.l     D1
08001A2E  2F01      3595          move.l    D1,-(A7)
08001A30  2F0A      3596          move.l    A2,-(A7)
08001A32  4E93      3597          jsr       (A3)
08001A34  504F      3598          addq.w    #8,A7
08001A36  5286      3599          addq.l    #1,D6
08001A38  6002      3600          bra.s     doprint_112
                    3601   doprint_115:
08001A3A  6002      3602          bra.s     doprint_113
                    3603   doprint_112:
08001A3C  60B2      3604          bra       doprint_110
                    3605   doprint_113:
08001A3E  4A2E FFCD 3606          tst.b     -51(A6)
08001A42  6700 0030 3607          beq       doprint_125
08001A46  1004      3608          move.b    D4,D0
08001A48  4880      3609          ext.w     D0
08001A4A  48C0      3610          ext.l     D0
08001A4C  D0AE FFFC 3611          add.l     -4(A6),D0
08001A50  D087      3612          add.l     D7,D0
08001A52  1D40 FFD1 3613          move.b    D0,-47(A6)
                    3614   doprint_123:
08001A56  102E FFD1 3615          move.b    -47(A6),D0
08001A5A  4880      3616          ext.w     D0
08001A5C  48C0      3617          ext.l     D0
08001A5E  220D      3618          move.l    A5,D1
08001A60  534D      3619          subq.w    #1,A5
08001A62  B081      3620          cmp.l     D1,D0
08001A64  6C0E      3621          bge.s     doprint_125
08001A66  4878 0020 3622          pea       32
08001A6A  2F0A      3623          move.l    A2,-(A7)
08001A6C  4E93      3624          jsr       (A3)
08001A6E  504F      3625          addq.w    #8,A7
08001A70  5386      3626          subq.l    #1,D6
08001A72  60E2      3627          bra       doprint_123
                    3628   doprint_125:
08001A74  6014      3629          bra.s     doprint_81
                    3630   doprint_80:
08001A76  206E 000C 3631          move.l    12(A6),A0
08001A7A  1210      3632          move.b    (A0),D1
08001A7C  4881      3633          ext.w     D1
08001A7E  48C1      3634          ext.l     D1
08001A80  2F01      3635          move.l    D1,-(A7)
08001A82  2F0A      3636          move.l    A2,-(A7)
08001A84  4E93      3637          jsr       (A3)
08001A86  504F      3638          addq.w    #8,A7
08001A88  5286      3639          addq.l    #1,D6
                    3640   doprint_81:
08001A8A  52AE 000C 3641          addq.l    #1,12(A6)
                    3642   doprint_2:
08001A8E  6000 FA0A 3643          bra       doprint_1
                    3644   doprint_3:
08001A92  4A92      3645          tst.l     (A2)
08001A94  6710      3646          beq.s     doprint_126
08001A96  4201      3647          clr.b     D1
08001A98  C2BC 0000 3648          and.l     #255,D1
08001A9C  00FF      
08001A9E  2F01      3649          move.l    D1,-(A7)
08001AA0  2F0A      3650          move.l    A2,-(A7)
08001AA2  4E93      3651          jsr       (A3)
08001AA4  504F      3652          addq.w    #8,A7
                    3653   doprint_126:
08001AA6  2006      3654          move.l    D6,D0
08001AA8  4CDF 3CFC 3655          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
08001AAC  4E5E      3656          unlk      A6
08001AAE  4E75      3657          rts
                    3658   @itoa_convert:
08001AB0  4E56 0000 3659          link      A6,#0
08001AB4  48E7 3C00 3660          movem.l   D2/D3/D4/D5,-(A7)
08001AB8  242E 0008 3661          move.l    8(A6),D2
08001ABC  262E 0010 3662          move.l    16(A6),D3
08001AC0  2A2E 000C 3663          move.l    12(A6),D5
08001AC4  2F05      3664          move.l    D5,-(A7)
08001AC6  2F03      3665          move.l    D3,-(A7)
08001AC8  4EB9 0800 3666          jsr       ULDIV
08001ACC  12CA      
08001ACE  202F 0004 3667          move.l    4(A7),D0
08001AD2  504F      3668          addq.w    #8,A7
08001AD4  2800      3669          move.l    D0,D4
08001AD6  BA83      3670          cmp.l     D3,D5
08001AD8  6520      3671          blo.s     @itoa_convert_1
08001ADA  2F03      3672          move.l    D3,-(A7)
08001ADC  2F05      3673          move.l    D5,-(A7)
08001ADE  2F03      3674          move.l    D3,-(A7)
08001AE0  4EB9 0800 3675          jsr       ULDIV
08001AE4  12CA      
08001AE6  2217      3676          move.l    (A7),D1
08001AE8  504F      3677          addq.w    #8,A7
08001AEA  2F01      3678          move.l    D1,-(A7)
08001AEC  2F02      3679          move.l    D2,-(A7)
08001AEE  4EB9 0800 3680          jsr       @itoa_convert
08001AF2  1AB0      
08001AF4  DEFC 000C 3681          add.w     #12,A7
08001AF8  2400      3682          move.l    D0,D2
                    3683   @itoa_convert_1:
08001AFA  0C84 0000 3684          cmp.l     #9,D4
08001AFE  0009      
08001B00  6E0E      3685          bgt.s     @itoa_convert_3
08001B02  2004      3686          move.l    D4,D0
08001B04  7230      3687          moveq     #48,D1
08001B06  C2BC 0000 3688          and.l     #255,D1
08001B0A  00FF      
08001B0C  D081      3689          add.l     D1,D0
08001B0E  6012      3690          bra.s     @itoa_convert_4
                    3691   @itoa_convert_3:
08001B10  2004      3692          move.l    D4,D0
08001B12  7261      3693          moveq     #97,D1
08001B14  C2BC 0000 3694          and.l     #255,D1
08001B18  00FF      
08001B1A  D081      3695          add.l     D1,D0
08001B1C  0480 0000 3696          sub.l     #10,D0
08001B20  000A      
                    3697   @itoa_convert_4:
08001B22  2042      3698          move.l    D2,A0
08001B24  1080      3699          move.b    D0,(A0)
08001B26  2002      3700          move.l    D2,D0
08001B28  5280      3701          addq.l    #1,D0
08001B2A  4CDF 003C 3702          movem.l   (A7)+,D2/D3/D4/D5
08001B2E  4E5E      3703          unlk      A6
08001B30  4E75      3704          rts
                    3705   _ltoa:
08001B32  4E56 0000 3706          link      A6,#0
08001B36  48E7 3C00 3707          movem.l   D2/D3/D4/D5,-(A7)
08001B3A  242E 0008 3708          move.l    8(A6),D2
08001B3E  262E 000C 3709          move.l    12(A6),D3
08001B42  2A2E 0010 3710          move.l    16(A6),D5
08001B46  2803      3711          move.l    D3,D4
08001B48  0C85 0000 3712          cmp.l     #2,D5
08001B4C  0002      
08001B4E  6D08      3713          blt.s     ltoa_3
08001B50  0C85 0000 3714          cmp.l     #36,D5
08001B54  0024      
08001B56  6F06      3715          ble.s     ltoa_1
                    3716   ltoa_3:
08001B58  2003      3717          move.l    D3,D0
08001B5A  6000 0056 3718          bra       ltoa_4
                    3719   ltoa_1:
08001B5E  0C85 0000 3720          cmp.l     #10,D5
08001B62  000A      
08001B64  6600 0034 3721          bne       ltoa_5
08001B68  0C82 0000 3722          cmp.l     #0,D2
08001B6C  0000      
08001B6E  6C2A      3723          bge.s     ltoa_5
08001B70  2002      3724          move.l    D2,D0
08001B72  4480      3725          neg.l     D0
08001B74  2400      3726          move.l    D0,D2
08001B76  0C82 0000 3727          cmp.l     #0,D2
08001B7A  0000      
08001B7C  6C14      3728          bge.s     ltoa_7
08001B7E  4879 0800 3729          pea       @itoa_1.L
08001B82  20D2      
08001B84  2F03      3730          move.l    D3,-(A7)
08001B86  4EB9 0800 3731          jsr       _strcpy
08001B8A  1D1E      
08001B8C  504F      3732          addq.w    #8,A7
08001B8E  2003      3733          move.l    D3,D0
08001B90  6020      3734          bra.s     ltoa_4
                    3735   ltoa_7:
08001B92  2044      3736          move.l    D4,A0
08001B94  5284      3737          addq.l    #1,D4
08001B96  10BC 002D 3738          move.b    #45,(A0)
                    3739   ltoa_5:
08001B9A  2F05      3740          move.l    D5,-(A7)
08001B9C  2F02      3741          move.l    D2,-(A7)
08001B9E  2F04      3742          move.l    D4,-(A7)
08001BA0  4EB9 0800 3743          jsr       @itoa_convert
08001BA4  1AB0      
08001BA6  DEFC 000C 3744          add.w     #12,A7
08001BAA  2800      3745          move.l    D0,D4
08001BAC  2044      3746          move.l    D4,A0
08001BAE  4210      3747          clr.b     (A0)
08001BB0  2003      3748          move.l    D3,D0
                    3749   ltoa_4:
08001BB2  4CDF 003C 3750          movem.l   (A7)+,D2/D3/D4/D5
08001BB6  4E5E      3751          unlk      A6
08001BB8  4E75      3752          rts
                    3753   _ultoa:
08001BBA  4E56 0000 3754          link      A6,#0
08001BBE  48E7 3800 3755          movem.l   D2/D3/D4,-(A7)
08001BC2  262E 0010 3756          move.l    16(A6),D3
08001BC6  282E 000C 3757          move.l    12(A6),D4
08001BCA  2404      3758          move.l    D4,D2
08001BCC  0C83 0000 3759          cmp.l     #2,D3
08001BD0  0002      
08001BD2  6D08      3760          blt.s     ultoa_3
08001BD4  0C83 0000 3761          cmp.l     #36,D3
08001BD8  0024      
08001BDA  6F04      3762          ble.s     ultoa_1
                    3763   ultoa_3:
08001BDC  2004      3764          move.l    D4,D0
08001BDE  601A      3765          bra.s     ultoa_4
                    3766   ultoa_1:
08001BE0  2F03      3767          move.l    D3,-(A7)
08001BE2  2F2E 0008 3768          move.l    8(A6),-(A7)
08001BE6  2F02      3769          move.l    D2,-(A7)
08001BE8  4EB9 0800 3770          jsr       @itoa_convert
08001BEC  1AB0      
08001BEE  DEFC 000C 3771          add.w     #12,A7
08001BF2  2400      3772          move.l    D0,D2
08001BF4  2042      3773          move.l    D2,A0
08001BF6  4210      3774          clr.b     (A0)
08001BF8  2004      3775          move.l    D4,D0
                    3776   ultoa_4:
08001BFA  4CDF 001C 3777          movem.l   (A7)+,D2/D3/D4
08001BFE  4E5E      3778          unlk      A6
08001C00  4E75      3779          rts
                    3780   _itoa:
08001C02  4E56 0000 3781          link      A6,#0
08001C06  2F2E 0010 3782          move.l    16(A6),-(A7)
08001C0A  2F2E 000C 3783          move.l    12(A6),-(A7)
08001C0E  2F2E 0008 3784          move.l    8(A6),-(A7)
08001C12  4EB9 0800 3785          jsr       _ltoa
08001C16  1B32      
08001C18  DEFC 000C 3786          add.w     #12,A7
08001C1C  4E5E      3787          unlk      A6
08001C1E  4E75      3788          rts
                    3789   ULMUL:
08001C20  4E56 0000 3790          link    A6,#0
08001C24  48E7 C000 3791          movem.l D0/D1,-(A7)
08001C28  222E 0008 3792          move.l  8(A6),D1
08001C2C  202E 000C 3793          move.l  12(A6),D0
08001C30  602C      3794          bra.s   lmul_3
                    3795   LMUL:
08001C32  4E56 0000 3796          link    A6,#0
08001C36  48E7 C000 3797          movem.l D0/D1,-(A7)
08001C3A  222E 0008 3798          move.l  8(A6),D1
08001C3E  202E 000C 3799          move.l  12(A6),D0
08001C42  4A80      3800          tst.l   D0
08001C44  6A0A      3801          bpl.s   lmul_1
08001C46  4480      3802          neg.l   D0
08001C48  4A81      3803          tst.l   D1
08001C4A  6A0A      3804          bpl.s   lmul_2
08001C4C  4481      3805          neg.l   D1
08001C4E  600E      3806          bra.s   lmul_3
                    3807   lmul_1:
08001C50  4A81      3808          tst.l   D1
08001C52  6A0A      3809          bpl.s   lmul_3
08001C54  4481      3810          neg.l   D1
                    3811   lmul_2:
08001C56  6114      3812          bsr.s   domul
08001C58  4481      3813          neg.l   D1
08001C5A  4080      3814          negx.l  D0
08001C5C  6002      3815          bra.s   lmul_4
                    3816   lmul_3:
08001C5E  610C      3817          bsr.s   domul
                    3818   lmul_4:
08001C60  2D41 0008 3819          move.l  D1,8(A6)
08001C64  4CDF 0003 3820          movem.l (A7)+,D0/D1
08001C68  4E5E      3821          unlk    A6
08001C6A  4E75      3822          rts
                    3823   domul:
08001C6C  0C81 0000 3824          cmpi.l  #$FFFF,D1
08001C70  FFFF      
08001C72  620C      3825          bhi.s   domul_1
08001C74  0C80 0000 3826          cmpi.l  #$FFFF,D0
08001C78  FFFF      
08001C7A  620E      3827          bhi.s   domul_2
08001C7C  C2C0      3828          mulu    D0,D1
08001C7E  4E75      3829          rts
                    3830   domul_1:
08001C80  0C80 0000 3831          cmpi.l  #$FFFF,D0
08001C84  FFFF      
08001C86  6218      3832          bhi.s   domul_4
08001C88  6002      3833          bra.s   domul_3
                    3834   domul_2
08001C8A  C141      3835          exg     D0,D1
                    3836   domul_3:
08001C8C  2F02      3837          move.l  D2,-(A7)
08001C8E  2401      3838          move.l  D1,D2
08001C90  4842      3839          swap    D2
08001C92  C2C0      3840          mulu    D0,D1
08001C94  C4C0      3841          mulu    D0,D2
08001C96  4842      3842          swap    D2
08001C98  4242      3843          clr.w   D2
08001C9A  D282      3844          add.l   D2,D1
08001C9C  241F      3845          move.l  (A7)+,D2
08001C9E  4E75      3846          rts
                    3847   domul_4:
08001CA0  48E7 3000 3848          movem.l D2/D3,-(A7)
08001CA4  2401      3849          move.l  D1,D2
08001CA6  2601      3850          move.l  D1,D3
08001CA8  C2C0      3851          mulu    D0,D1
08001CAA  4842      3852          swap    D2
08001CAC  C4C0      3853          mulu    D0,D2
08001CAE  4840      3854          swap    D0
08001CB0  C6C0      3855          mulu    D0,D3
08001CB2  D483      3856          add.l   D3,D2
08001CB4  4842      3857          swap    D2
08001CB6  4242      3858          clr.w   D2
08001CB8  D282      3859          add.l   D2,D1
08001CBA  4CDF 000C 3860          movem.l (A7)+,D2/D3
08001CBE  4E75      3861          rts
                    3862   _strlen:
08001CC0  206F 0004 3863          move.l    (4,A7),A0
08001CC4  2248      3864          move.l    A0,A1
                    3865   strlen_1:
08001CC6  4A19      3866          tst.b     (A1)+
08001CC8  66FC      3867          bne       strlen_1
08001CCA  2009      3868          move.l    A1,D0
08001CCC  9088      3869          sub.l     A0,D0
08001CCE  5380      3870          subq.l    #1,D0
08001CD0  4E75      3871          rts
                    3872   _putch:
08001CD2  4E56 0000 3873          link      A6,#0
08001CD6  2F02      3874          move.l    D2,-(A7)
08001CD8  242E 0008 3875          move.l    8(A6),D2
08001CDC  0C82 0000 3876          cmp.l     #10,D2
08001CE0  000A      
08001CE2  660C      3877          bne.s     putch_1
08001CE4  4878 000D 3878          pea       13
08001CE8  4EB9 0800 3879          jsr       __putch
08001CEC  0F48      
08001CEE  584F      3880          addq.w    #4,A7
                    3881   putch_1:
08001CF0  2F02      3882          move.l    D2,-(A7)
08001CF2  4EB9 0800 3883          jsr       __putch
08001CF6  0F48      
08001CF8  584F      3884          addq.w    #4,A7
08001CFA  2002      3885          move.l    D2,D0
08001CFC  241F      3886          move.l    (A7)+,D2
08001CFE  4E5E      3887          unlk      A6
08001D00  4E75      3888          rts
                    3889   _toupper:
08001D02  202F 0004 3890          move.l    4(A7),D0
08001D06  0C80 0000 3891          cmp.l     #'a',D0
08001D0A  0061      
08001D0C  6D0E      3892          blt.s     toupper_1
08001D0E  0C80 0000 3893          cmp.l     #'z',D0
08001D12  007A      
08001D14  6E06      3894          bgt.s     toupper_1
08001D16  0480 0000 3895          sub.l     #$20,D0
08001D1A  0020      
                    3896   toupper_1:
08001D1C  4E75      3897          rts
                    3898   _strcpy:
08001D1E  206F 0004 3899          move.l    (4,A7),A0
08001D22  226F 0008 3900          move.l    (8,A7),A1
08001D26  2008      3901          move.l    A0,D0
                    3902   strcpy_1:
08001D28  10D9      3903          move.b    (A1)+,(A0)+
08001D2A  66FC      3904          bne.s     strcpy_1
08001D2C  4E75      3905          rts
                    3906          section   const
08001D2E            3907                   align
                    3908   
                    3909   
                    3910   @m68kus~1_1:
08001D2E  0D0A 2578 3911          dc.b      13,10,37,120,0
08001D32  00        
                    3912   @m68kus~1_2:
08001D34  0D0A 0D0A 3913          dc.b      13,10,13,10,45,45,45,45,32,67,65,78,66,85,83
08001D38  2D2D 2D2D 
08001D3C  2043 414E 
08001D40  4255 53   
08001D43  2054 6573 3914          dc.b      32,84,101,115,116,32,45,45,45,45,13,10,0
08001D47  7420 2D2D 
08001D4B  2D2D 0D0A 
08001D4F  00        
                    3915   @m68kus~1_3:
08001D50  0D0A 00   3916          dc.b      13,10,0
                    3917   @m68kus~1_4:
08001D54  0D0A 5768 3918          dc.b      13,10,87,104,97,116,32,105,115,32,116,104,101
08001D58  6174 2069 
08001D5C  7320 7468 
08001D60  65        
08001D61  2069 6E74 3919          dc.b      32,105,110,116,101,114,110,97,108,32,69,69,80
08001D65  6572 6E61 
08001D69  6C20 4545 
08001D6D  50        
08001D6E  524F 4D20 3920          dc.b      82,79,77,32,97,100,100,114,101,115,115,32,121
08001D72  6164 6472 
08001D76  6573 7320 
08001D7A  79        
08001D7B  6F75 2077 3921          dc.b      111,117,32,119,97,110,116,32,116,111,32,97,99
08001D7F  616E 7420 
08001D83  746F 2061 
08001D87  63        
08001D88  6365 7373 3922          dc.b      99,101,115,115,63,32,0
08001D8C  3F20 00   
                    3923   @m68kus~1_5:
08001D90  0D0A 4164 3924          dc.b      13,10,65,100,100,114,101,115,115,32,99,97,110
08001D94  6472 6573 
08001D98  7320 6361 
08001D9C  6E        
08001D9D  6E6F 7420 3925          dc.b      110,111,116,32,98,101,32,103,114,101,97,116
08001DA1  6265 2067 
08001DA5  7265 6174 
08001DA9  6572 2074 3926          dc.b      101,114,32,116,104,97,110,32,48,120,48,49,102
08001DAD  6861 6E20 
08001DB1  3078 3031 
08001DB5  66        
08001DB6  6666 6621 3927          dc.b      102,102,102,33,32,73,110,112,117,116,32,97,103
08001DBA  2049 6E70 
08001DBE  7574 2061 
08001DC2  67        
08001DC3  6169 6E3A 3928          dc.b      97,105,110,58,32,0
08001DC7  2000      
                    3929   @m68kus~1_6:
08001DCA  0D0A 5768 3930          dc.b      13,10,87,104,97,116,32,105,115,32,116,104,101
08001DCE  6174 2069 
08001DD2  7320 7468 
08001DD6  65        
08001DD7  2064 6174 3931          dc.b      32,100,97,116,97,32,121,111,117,32,119,97,110
08001DDB  6120 796F 
08001DDF  7520 7761 
08001DE3  6E        
08001DE4  7420 746F 3932          dc.b      116,32,116,111,32,119,114,105,116,101,32,105
08001DE8  2077 7269 
08001DEC  7465 2069 
08001DF0  6E74 6F20 3933          dc.b      110,116,111,32,116,104,101,32,69,69,80,82,79
08001DF4  7468 6520 
08001DF8  4545 5052 
08001DFC  4F        
08001DFD  4D3F 2000 3934          dc.b      77,63,32,0
                    3935   @m68kus~1_7:
08001E02  0D0A 5261 3936          dc.b      13,10,82,97,110,100,111,109,32,69,69,80,82,79
08001E06  6E64 6F6D 
08001E0A  2045 4550 
08001E0E  524F      
08001E10  4D20 6279 3937          dc.b      77,32,98,121,116,101,32,119,114,105,116,101
08001E14  7465 2077 
08001E18  7269 7465 
08001E1C  00        3938          dc.b      0
                    3939   @m68kus~1_8:
08001E1E  0D0A 4545 3940          dc.b      13,10,69,69,80,82,79,77,32,119,114,105,116,116
08001E22  5052 4F4D 
08001E26  2077 7269 
08001E2A  7474      
08001E2C  696E 6720 3941          dc.b      105,110,103,32,100,111,110,101,33,0
08001E30  646F 6E65 
08001E34  2100      
                    3942   @m68kus~1_9:
08001E36  0D0A 5261 3943          dc.b      13,10,82,97,110,100,111,109,32,69,69,80,82,79
08001E3A  6E64 6F6D 
08001E3E  2045 4550 
08001E42  524F      
08001E44  4D20 6279 3944          dc.b      77,32,98,121,116,101,32,114,101,97,100,0
08001E48  7465 2072 
08001E4C  6561 6400 
                    3945   @m68kus~1_10:
08001E50  0D0A 4545 3946          dc.b      13,10,69,69,80,82,79,77,32,114,101,97,100,105
08001E54  5052 4F4D 
08001E58  2072 6561 
08001E5C  6469      
08001E5E  6E67 2064 3947          dc.b      110,103,32,100,111,110,101,33,32,37,120,0
08001E62  6F6E 6521 
08001E66  2025 7800 
                    3948   @m68kus~1_11:
08001E6A  0D0A 5768 3949          dc.b      13,10,87,104,97,116,32,105,115,32,116,104,101
08001E6E  6174 2069 
08001E72  7320 7468 
08001E76  65        
08001E77  2045 4550 3950          dc.b      32,69,69,80,82,79,77,32,97,100,100,114,101,115
08001E7B  524F 4D20 
08001E7F  6164 6472 
08001E83  6573      
08001E85  7320 7261 3951          dc.b      115,32,114,97,110,103,101,32,115,105,122,101
08001E89  6E67 6520 
08001E8D  7369 7A65 
08001E91  2028 696E 3952          dc.b      32,40,105,110,32,104,101,120,41,32,121,111,117
08001E95  2068 6578 
08001E99  2920 796F 
08001E9D  75        
08001E9E  2077 616E 3953          dc.b      32,119,97,110,116,32,116,111,32,97,99,99,101
08001EA2  7420 746F 
08001EA6  2061 6363 
08001EAA  65        
08001EAB  7373 3F20 3954          dc.b      115,115,63,32,0
08001EAF  00        
                    3955   @m68kus~1_12:
08001EB0  0D0A 5369 3956          dc.b      13,10,83,105,122,101,32,99,97,110,110,111,116
08001EB4  7A65 2063 
08001EB8  616E 6E6F 
08001EBC  74        
08001EBD  2062 6520 3957          dc.b      32,98,101,32,108,97,114,103,101,114,32,116,104
08001EC1  6C61 7267 
08001EC5  6572 2074 
08001EC9  68        
08001ECA  616E 2027 3958          dc.b      97,110,32,39,104,48,50,48,48,48,48,32,40,49
08001ECE  6830 3230 
08001ED2  3030 3020 
08001ED6  2831      
08001ED8  3238 4B20 3959          dc.b      50,56,75,32,98,121,116,101,115,41,44,32,105
08001EDC  6279 7465 
08001EE0  7329 2C20 
08001EE4  69        
08001EE5  6E70 7574 3960          dc.b      110,112,117,116,32,97,103,97,105,110,58,32,0
08001EE9  2061 6761 
08001EED  696E 3A20 
08001EF1  00        
                    3961   @m68kus~1_13:
08001EF2  0D0A 5369 3962          dc.b      13,10,83,105,122,101,32,99,97,110,110,111,116
08001EF6  7A65 2063 
08001EFA  616E 6E6F 
08001EFE  74        
08001EFF  2062 6520 3963          dc.b      32,98,101,32,48,44,32,116,104,101,32,109,105
08001F03  302C 2074 
08001F07  6865 206D 
08001F0B  69        
08001F0C  6E69 6D75 3964          dc.b      110,105,109,117,109,32,115,105,122,101,32,105
08001F10  6D20 7369 
08001F14  7A65 2069 
08001F18  7320 2768 3965          dc.b      115,32,39,104,48,48,48,48,48,49,32,40,49,32
08001F1C  3030 3030 
08001F20  3031 2028 
08001F24  3120      
08001F26  6279 7465 3966          dc.b      98,121,116,101,41,44,32,105,110,112,117,116
08001F2A  292C 2069 
08001F2E  6E70 7574 
08001F32  2061 6761 3967          dc.b      32,97,103,97,105,110,58,32,0
08001F36  696E 3A20 
08001F3A  00        
                    3968   @m68kus~1_14:
08001F3C  0D0A 4D75 3969          dc.b      13,10,77,117,108,116,105,112,101,32,98,121,116
08001F40  6C74 6970 
08001F44  6520 6279 
08001F48  74        
08001F49  6573 2045 3970          dc.b      101,115,32,69,69,80,82,79,77,32,119,114,105
08001F4D  4550 524F 
08001F51  4D20 7772 
08001F55  69        
08001F56  7465 00   3971          dc.b      116,101,0
                    3972   @m68kus~1_15:
08001F5A  0D0A 5772 3973          dc.b      13,10,87,114,105,116,116,105,110,103,46,46,46
08001F5E  6974 7469 
08001F62  6E67 2E2E 
08001F66  2E        
08001F67  00        3974          dc.b      0
                    3975   @m68kus~1_16:
08001F68  0D0A 4D75 3976          dc.b      13,10,77,117,108,116,105,112,108,101,32,98,121
08001F6C  6C74 6970 
08001F70  6C65 2062 
08001F74  79        
08001F75  7465 7320 3977          dc.b      116,101,115,32,119,114,105,116,116,105,110,103
08001F79  7772 6974 
08001F7D  7469 6E67 
08001F81  2064 6F6E 3978          dc.b      32,100,111,110,101,0
08001F85  6500      
                    3979   @m68kus~1_17:
08001F88  0D0A 4D75 3980          dc.b      13,10,77,117,108,116,105,112,108,101,32,98,121
08001F8C  6C74 6970 
08001F90  6C65 2062 
08001F94  79        
08001F95  7465 7320 3981          dc.b      116,101,115,32,69,69,80,82,79,77,32,114,101
08001F99  4545 5052 
08001F9D  4F4D 2072 
08001FA1  65        
08001FA2  6164 00   3982          dc.b      97,100,0
                    3983   @m68kus~1_18:
08001FA6  0D0A 4164 3984          dc.b      13,10,65,100,100,114,101,115,115,58,32,37,120
08001FAA  6472 6573 
08001FAE  733A 2025 
08001FB2  78        
08001FB3  2C20 5265 3985          dc.b      44,32,82,101,97,100,32,100,97,116,97,58,32,37
08001FB7  6164 2064 
08001FBB  6174 613A 
08001FBF  2025      
08001FC1  7800      3986          dc.b      120,0
                    3987   @m68kus~1_19:
08001FC4  0D0A 5573 3988          dc.b      13,10,85,115,105,110,103,32,68,65,67,32,116
08001FC8  696E 6720 
08001FCC  4441 4320 
08001FD0  74        
08001FD1  6F20 636F 3989          dc.b      111,32,99,111,110,116,114,111,108,32,76,69,68
08001FD5  6E74 726F 
08001FD9  6C20 4C45 
08001FDD  44        
08001FDE  00        3990          dc.b      0
                    3991   @m68kus~1_20:
08001FE0  0D0A 5265 3992          dc.b      13,10,82,101,97,100,105,110,103,32,118,97,108
08001FE4  6164 696E 
08001FE8  6720 7661 
08001FEC  6C        
08001FED  7565 7320 3993          dc.b      117,101,115,32,102,114,111,109,32,116,104,101
08001FF1  6672 6F6D 
08001FF5  2074 6865 
08001FF9  2041 4443 3994          dc.b      32,65,68,67,0
08001FFD  00        
                    3995   @m68kus~1_21:
08001FFE  0D0A 5265 3996          dc.b      13,10,82,101,97,100,32,100,97,116,97,58,32,37
08002002  6164 2064 
08002006  6174 613A 
0800200A  2025      
0800200C  7800      3997          dc.b      120,0
                    3998   @m68kus~1_22:
0800200E  0D0A 5768 3999          dc.b      13,10,87,104,105,99,104,32,99,104,97,110,110
08002012  6963 6820 
08002016  6368 616E 
0800201A  6E        
0800201B  656C 2079 4000          dc.b      101,108,32,121,111,117,32,119,97,110,116,32
0800201F  6F75 2077 
08002023  616E 7420 
08002027  746F 2072 4001          dc.b      116,111,32,114,101,97,100,63,32,49,46,32,80
0800202B  6561 643F 
0800202F  2031 2E20 
08002033  50        
08002034  6F74 656E 4002          dc.b      111,116,101,110,116,105,111,109,101,116,101
08002038  7469 6F6D 
0800203C  6574 65   
0800203F  7220 322E 4003          dc.b      114,32,50,46,80,104,111,116,111,114,101,115
08002043  5068 6F74 
08002047  6F72 6573 
0800204B  6973 746F 4004          dc.b      105,115,116,111,114,32,51,46,84,104,101,114
0800204F  7220 332E 
08002053  5468 6572 
08002057  6D69 7374 4005          dc.b      109,105,115,116,111,114,32,0
0800205B  6F72 2000 
                    4006   @m68kus~1_23:
08002060  0D0A 496E 4007          dc.b      13,10,73,110,118,97,108,105,100,32,115,101,108
08002064  7661 6C69 
08002068  6420 7365 
0800206C  6C        
0800206D  6563 7469 4008          dc.b      101,99,116,105,111,110,33,0
08002071  6F6E 2100 
                    4009   @m68kus~1_24:
08002076  0D0A 5265 4010          dc.b      13,10,82,101,97,100,105,110,103,32,115,119,105
0800207A  6164 696E 
0800207E  6720 7377 
08002082  69        
08002083  7463 6865 4011          dc.b      116,99,104,101,115,0
08002087  7300      
                    4012   @m68kus~1_25:
0800208A  0D0A 5265 4013          dc.b      13,10,82,101,97,100,105,110,103,32,102,114,111
0800208E  6164 696E 
08002092  6720 6672 
08002096  6F        
08002097  6D20 6164 4014          dc.b      109,32,97,100,100,114,101,115,115,32,37,120
0800209B  6472 6573 
0800209F  7320 2578 
080020A3  206F 6620 4015          dc.b      32,111,102,32,69,69,80,82,79,77,0
080020A7  4545 5052 
080020AB  4F4D 00   
                    4016   @m68kus~1_26:
080020AE  0D0A 5265 4017          dc.b      13,10,82,101,97,100,105,110,103,32,102,114,111
080020B2  6164 696E 
080020B6  6720 6672 
080020BA  6F        
080020BB  6D20 6164 4018          dc.b      109,32,97,100,100,114,101,115,115,32,37,120
080020BF  6472 6573 
080020C3  7320 2578 
080020C7  206F 6620 4019          dc.b      32,111,102,32,102,108,97,115,104,0
080020CB  666C 6173 
080020CF  6800      
                    4020   @itoa_1:
080020D2  2D32 3134 4021          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
080020D6  3734 3833 
080020DA  3634 3800 
                    4022   __ctype:
080020DE  0040 4040 4023          dc.b      0,64,64,64,64,64,64,64,64,64,80,80,80,80,80
080020E2  4040 4040 
080020E6  4040 5050 
080020EA  5050 50   
080020ED  4040 4040 4024          dc.b      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
080020F1  4040 4040 
080020F5  4040 4040 
080020F9  4040 40   
080020FC  4040 40D0 4025          dc.b      64,64,64,208,160,160,160,160,160,160,160,160
08002100  A0A0 A0A0 
08002104  A0A0 A0A0 
08002108  A0A0 A0A0 4026          dc.b      160,160,160,160,160,160,160,140,140,140,140
0800210C  A0A0 A08C 
08002110  8C8C 8C   
08002113  8C8C 8C8C 4027          dc.b      140,140,140,140,140,140,160,160,160,160,160
08002117  8C8C A0A0 
0800211B  A0A0 A0   
0800211E  A0A0 8A8A 4028          dc.b      160,160,138,138,138,138,138,138,130,130,130
08002122  8A8A 8A8A 
08002126  8282 82   
08002129  8282 8282 4029          dc.b      130,130,130,130,130,130,130,130,130,130,130
0800212D  8282 8282 
08002131  8282 82   
08002134  8282 8282 4030          dc.b      130,130,130,130,130,130,160,160,160,160,160
08002138  8282 A0A0 
0800213C  A0A0 A0   
0800213F  A089 8989 4031          dc.b      160,137,137,137,137,137,137,129,129,129,129
08002143  8989 8981 
08002147  8181 81   
0800214A  8181 8181 4032          dc.b      129,129,129,129,129,129,129,129,129,129,129
0800214E  8181 8181 
08002152  8181 81   
08002155  8181 8181 4033          dc.b      129,129,129,129,129,160,160,160,160,64,0,0,0
08002159  81A0 A0A0 
0800215D  A040 0000 
08002161  00        
08002162  0000 0000 4034          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
08002166  0000 0000 
0800216A  0000 0000 
0800216E  0000 0000 
08002172  0000 0000 
08002176  0000      
08002178  0000 0000 4035          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0800217C  0000 0000 
08002180  0000 0000 
08002184  0000 0000 
08002188  0000 0000 
0800218C  0000      
0800218E  0000 0000 4036          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
08002192  0000 0000 
08002196  0000 0000 
0800219A  0000 0000 
0800219E  0000 0000 
080021A2  0000      
080021A4  0000 0000 4037          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
080021A8  0000 0000 
080021AC  0000 0000 
080021B0  0000 0000 
080021B4  0000 0000 
080021B8  0000      
080021BA  0000 0000 4038          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
080021BE  0000 0000 
080021C2  0000 0000 
080021C6  0000 0000 
080021CA  0000 0000 
080021CE  0000      
080021D0  0000 0000 4039          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
080021D4  0000 0000 
080021D8  0000 0000 
080021DC  0000 00   
                    4040          section   data
080021E0            4041                   align
                    4042   
                    4043   *********************************************************************************************************************************************************
                    4044   * Section for Initialised Data (in theory should be copied to Ram at startup) but is part of program code as we copy whole program to ram at startup
                    4045   ********************************************************************************************************************************************************
                    4046   
          0800 21E0 4047   DataStart       equ       *
080021E0            4048   __ungetbuf:     ds.l      1                    ungetbuffer for stdio functions
080021E4            4049   __allocp:       ds.l      1                    start of free memory block list
080021E8            4050   __heap:         ds.l      1                    begin of free memory
                    4051   
                    4052   
                    4053          section   bss
080021EC            4054                   align
                    4055   
          0800 21EC 4056   DataEnd         equ       *                    this label will equate to the address of the last byte of global variable in it
          0000 000C 4057   DataLength      equ       DataEnd-DataStart    length of data needed to copy to Ram on bootup
                    4058   
                    4059   *********************************************************************************************************
                    4060   * Section for uninitialised Data which is set to zero, i.e. we should set this space to zero at starup
                    4061   *********************************************************************************************************
          0800 21EC 4062   BssStart       equ       *
                    4063   
                    4064   _i:
080021EC            4065          ds.b      4
                    4066   _x:
080021F0            4067          ds.b      4
                    4068   _y:
080021F4            4069          ds.b      4
                    4070   _z:
080021F8            4071          ds.b      4
                    4072   _PortA_Count:
080021FC            4073          ds.b      4
                    4074   _Timer1Count:
08002200            4075          ds.b      1
                    4076   _Timer2Count:
08002202            4077          ds.b      1
                    4078   _Timer3Count:
08002204            4079          ds.b      1
                    4080   _Timer4Count:
08002206            4081          ds.b      1
                    4082   _switch_counter:
08002208            4083          ds.b      1
                    4084   _eeprom_counter:
0800220A            4085          ds.b      1
                    4086   _flash_counter:
0800220C            4087          ds.b      1
                    4088          section   heap
0800220E            4089                  align
                    4090   
          0800 220E 4091   BssEnd         equ       *
          0000 0022 4092   BssLength      equ       BssEnd-BssStart       length of zeroed data needed to copy to Ram on bootup
                    4093   
                    4094   *********************************************************************************************************
                    4095   * Section for Heap
                    4096   *********************************************************************************************************
                    4097   
          0800 220E 4098   heap           equ       *
0800220E            4099                  align
          0800 0000

Assembly errors: 0
