680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 25 Feb 2023      Time: 09:39:20          Source: C:\M68KV6.0-800BY480\PROGRAMS\DEBUGMONITORCODE\M68KDEBUGMONITOR.SRC

                       1          section   code
                       2   ; for initial stack use $08040000 if your system uses SRAM for main memory (top of 256kbyte SRAM space)
                       3   ; When your system is converted to use DRAM for main memory set this constant to $0C000000 (top of 64MByte DRAM space
                       4   
                       5   ;StackPointerVal     equ $08040000      when using sram
          0C00 0000    6   StackPointerVal     equ $0C000000      when using dram
                       7   
                       8   ; define RamVectorTable as $0803000 if your system uses SRAM for main memory
                       9   ; When your system is converted to use DRAM for main memory define RamVectorTable constant as $0B000000 (top of 64MByte DRAM space)
                      10   
                      11   ;RamVectorTable      equ $08030000      when using sram
          0B00 0000   12   RamVectorTable      equ $0B000000      when using dram
                      13   
                      14   
                      15   
                      16   ; CSTART.ASM  -  C startup-code for Debug Monitor
00000000              17                   align
                      18   
00000000              19                   org $00000000          ;start of rom based vector table, 68k hard wired to expect this at $0
                      20   
00000000  0C00 0000   21   InitialSP       dc.l StackPointerVal   ;initial supervisor state stack pointer(stack decrements first before being used)
00000004  0000 0400   22   InitialPC       dc.l start             ;address of 1st instruction of program after a reset
00000008  0000 0802   23   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 0814   24   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 0826   25   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0838   26   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 084A   27   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 085C   28   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 086E   29   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0880   30   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0892   31   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 08A4   32   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 08B6   33   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 08B6   34   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 08B6   35   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 08B6   36   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 08B6   37   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 08B6   38   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 08B6   39   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 08B6   40   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 08B6   41   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 08B6   42   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 08B6   43   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 08B6   44   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 08B6   45   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      46   *
                      47   *
00000064  0000 049A   48   Level1IRQ       dc.l Level1RamISR
00000068  0000 04AC   49   Level2IRQ       dc.l Level2RamISR
0000006C  0000 04BE   50   Level3IRQ       dc.l Level3RamISR
00000070  0000 04D0   51   Level4IRQ       dc.l Level4RamISR
00000074  0000 04E2   52   Level5IRQ       dc.l Level5RamISR
00000078  0000 05EC   53   Level6IRQ       dc.l Level6RamISR
0000007C  0000 05FE   54   Level7IRQ       dc.l Level7RamISR
                      55   *
                      56   *
00000080  0000 0610   57   Trap0           dc.l Trap0RamISR        ; User installed trap handler
00000084  0000 0622   58   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 0634   59   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 0646   60   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 0658   61   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 066A   62   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 067C   63   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 068E   64   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 06A0   65   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 06B2   66   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 06C4   67   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 06D6   68   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 06E8   69   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 06FA   70   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 070C   71   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 07FC   72   Trap15          dc.l Trap15RamISR       ; User installed trap handler
                      73   
                      74   *
                      75   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                      76   *
                      77   
00000400              78                   org       $00000400 
                      79   
00000400  46FC 2700   80   start:          move.w     #$2700,SR             set interrupts to disable until later
                      81   
                      82   *************************************************************************************
                      83   ** add some 68000 instruction to read and write to memory, IO etc. This doesn't do anything
                      84   ** important, it just creates read and write bus cycles to specific addresses which
                      85   ** help with debugging hardware in Quartus simulations
                      86   **************************************************************************************
                      87   
                      88                   ; perform some dummy read/write of 32 bit values to memory to see waveforms during a simulation
                      89   
00000404  23FC 1122   90                   move.l     #$11223344,$08060000 write 32 bits, to memory
00000408  3344 0806 
0000040C  0000      
0000040E  2039 0806   91                   move.l     $08060000,d0         read 32 bits back
00000412  0000      
00000414  13FC 0000   92                   move.b     #$00,$00400000         write to the output ports
00000418  0040 0000 
0000041C  13FC 0000   93                   move.b     #$00,$00400002         write to the output ports
00000420  0040 0002 
00000424  13FC 0000   94                   move.b     #$00,$00400004         write to the output ports
00000428  0040 0004 
0000042C  13FC 0000   95                   move.b     #$00,$00400006         write to the output ports
00000430  0040 0006 
00000434  13FC 0000   96                   move.b     #$00,$00400008         write to the output ports
00000438  0040 0008 
0000043C  13FC 0000   97                   move.b     #$00,$00400010         write to the hex display ports
00000440  0040 0010 
00000444  13FC 0000   98                   move.b     #$00,$00400012         write to the hex display ports
00000448  0040 0012 
0000044C  13FC 0000   99                   move.b     #$00,$00400014         write to the hex display ports
00000450  0040 0014 
00000454  13FC 0000  100                   move.b     #0,$00400020         write to the LCD
00000458  0040 0020 
0000045C  13FC 0000  101                   move.b     #0,$00400022         write to the LCD
00000460  0040 0022 
00000464  13FC 0000  102                   move.b     #0,$00400030         write to the Timer1 Data
00000468  0040 0030 
0000046C  13FC 0000  103                   move.b     #0,$00400032         write to the Timer1 Control
00000470  0040 0032 
                     104   
                     105                   ; some important initialisation do not modify
00000474  23FC FFFF  106                   move.l    #-1,__ungetbuf  ; unget-buffer for keyboard input
00000478  FFFF 0B00 
0000047C  00C0      
0000047E  23FC 0000  107                   move.l    #0,__allocp     ; pointer to allocated memory for malloc-function
00000482  0000 0B00 
00000486  00C4      
00000488  23FC 0B00  108                   move.l    #heap,__heap    ; pointer to free memory
0000048C  0546 0B00 
00000490  00C4      
                     109   
                     110   
00000492  4EB9 0000  111   mainloop        jsr       _main
00000496  2F74      
00000498  60F8       112                   bra       mainloop
                     113   
                     114   *********************************************************************************************************
                     115   * Code to call Ram Based Interrupt handler and other exeception handler code
                     116   *********************************************************************************************************
0000049A  48E7 FFFE  117   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000049E  2079 0B00  118                   move.l    VL1IRQ,a0               get ram based address into a0
000004A2  0064      
000004A4  4E90       119                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004A6  4CDF 7FFF  120                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004AA  4E73       121                   rte
000004AC  48E7 FFFE  122   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B0  2079 0B00  123                   move.l    VL2IRQ,a0               get ram based address into a0
000004B4  0068      
000004B6  4E90       124                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004B8  4CDF 7FFF  125                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004BC  4E73       126                   rte
000004BE  48E7 FFFE  127   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C2  2079 0B00  128                   move.l    VL3IRQ,a0               get ram based address into a0
000004C6  006C      
000004C8  4E90       129                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004CA  4CDF 7FFF  130                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004CE  4E73       131                   rte
000004D0  48E7 FFFE  132   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004D4  2079 0B00  133                   move.l    VL4IRQ,a0               get ram based address into a0
000004D8  0070      
000004DA  4E90       134                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004DC  4CDF 7FFF  135                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E0  4E73       136                   rte
                     137   
                     138   * Trace trap Handler
                     139   
                     140   Level5RamISR
                     141   *
                     142   **         Copy 68000 registers from debug monitor Variables,
                     143   *
                     144   *
000004E2  23FC 0000  145                   move.l    #1,_Trace              switch on Trace Mode
000004E6  0001 0B00 
000004EA  00D8      
000004EC  13FC 0000  146                   move.b    #$0,$0040000A          turn off a trace exception so we don't when generate a trace when disassembling instruction in the register dump (disassembling causes access to use program)
000004F0  0040 000A 
000004F4  33DF 0B00  147                   move.w    (sp)+,_SR              get at the users status register pointed to by stack pointer and copy
000004F8  012C      
000004FA  23DF 0B00  148                   move.l    (sp)+,_PC              get at the users program counter and copy
000004FE  0120      
                     149   *
00000500  23CF 0B00  150                   move.l    SP,_SSP                copy system stack pointer to debug monitor variable
00000504  0124      
00000506  23C0 0B00  151                   move.l    d0,_d0
0000050A  00E4      
0000050C  23C1 0B00  152                   move.l    d1,_d1
00000510  00E8      
00000512  23C2 0B00  153                   move.l    d2,_d2
00000516  00EC      
00000518  23C3 0B00  154                   move.l    d3,_d3
0000051C  00F0      
0000051E  23C4 0B00  155                   move.l    d4,_d4
00000522  00F4      
00000524  23C5 0B00  156                   move.l    d5,_d5
00000528  00F8      
0000052A  23C6 0B00  157                   move.l    d6,_d6
0000052E  00FC      
00000530  23C7 0B00  158                   move.l    d7,_d7
00000534  0100      
                     159   *
00000536  23C8 0B00  160                   move.l    a0,_a0
0000053A  0104      
0000053C  23C9 0B00  161                   move.l    a1,_a1
00000540  0108      
00000542  23CA 0B00  162                   move.l    a2,_a2
00000546  010C      
00000548  23CB 0B00  163                   move.l    a3,_a3
0000054C  0110      
0000054E  23CC 0B00  164                   move.l    a4,_a4
00000552  0114      
00000554  23CD 0B00  165                   move.l    a5,_a5
00000558  0118      
0000055A  23CE 0B00  166                   move.l    a6,_a6
0000055E  011C      
00000560  4E68       167                   move.l    usp,a0
00000562  23C8 0B00  168                   move.l    a0,_USP
00000566  0128      
                     169   *
00000568  2079 0B00  170                   move.l    VL5IRQ,a0              get ram based address into a0, trace exception for next instruction will be generated in Menu SPACE command
0000056C  0074      
0000056E  4E90       171                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     172   
                     173   ** After trace, reload 68000 registers with new values before continuing
                     174   
00000570  2039 0B00  175                   move.l   _d0,d0
00000574  00E4      
00000576  2239 0B00  176                   move.l   _d1,d1
0000057A  00E8      
0000057C  2439 0B00  177                   move.l   _d2,d2
00000580  00EC      
00000582  2639 0B00  178                   move.l   _d3,d3
00000586  00F0      
00000588  2839 0B00  179                   move.l   _d4,d4
0000058C  00F4      
0000058E  2A39 0B00  180                   move.l   _d5,d5
00000592  00F8      
00000594  2C39 0B00  181                   move.l   _d6,d6
00000598  00FC      
0000059A  2E39 0B00  182                   move.l   _d7,d7
0000059E  0100      
                     183   
000005A0  2079 0B00  184                   move.l   _USP,a0
000005A4  0128      
000005A6  4E60       185                   move.l   a0,USP                     load user stack pointer
000005A8  2079 0B00  186                   move.l   _a0,a0
000005AC  0104      
000005AE  2279 0B00  187                   move.l   _a1,a1
000005B2  0108      
000005B4  2479 0B00  188                   move.l   _a2,a2
000005B8  010C      
000005BA  2679 0B00  189                   move.l   _a3,a3
000005BE  0110      
000005C0  2879 0B00  190                   move.l   _a4,a4
000005C4  0114      
000005C6  2A79 0B00  191                   move.l   _a5,a5
000005CA  0118      
000005CC  2C79 0B00  192                   move.l   _a6,a6
000005D0  011C      
                     193   
000005D2  2E79 0B00  194                   move.l   _SSP,sp
000005D6  0124      
000005D8  2F39 0B00  195                   move.l   _PC,-(sp)
000005DC  0120      
000005DE  3F39 0B00  196                   move.w   _SR,-(sp)
000005E2  012C      
000005E4  11F8 0074  197                   move.b    $00000074,$0	          read trace exception vector after accessing disassembly to reset the trace request causes by disassembling program above
000005E8  0000      
000005EA  4E73       198                   rte
                     199   
                     200   * address trap handler
                     201   
000005EC  48E7 FFFE  202   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005F0  2079 0B00  203                   move.l    VL6IRQ,a0               get ram based address into a0
000005F4  0078      
000005F6  4E90       204                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000005F8  4CDF 7FFF  205                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005FC  4E73       206                   rte
                     207   
000005FE  48E7 FFFE  208   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000602  2079 0B00  209                   move.l    VL7IRQ,a0               get ram based address into a0
00000606  007C      
00000608  4E90       210                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000060A  4CDF 7FFF  211                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000060E  4E73       212                   rte
                     213   
                     214   
                     215   ********************************************************************************************************
                     216   * Ram based Trap handler and other exeception handler code
                     217   *********************************************************************************************************
                     218   
00000610  48E7 FFFE  219   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000614  2079 0B00  220                   move.l    VTrap0,a0                get ram based address into a0
00000618  0080      
0000061A  4E90       221                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000061C  4CDF 7FFF  222                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000620  4E73       223                   rte
                     224   
00000622  48E7 FFFE  225   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000626  2079 0B00  226                   move.l    VTrap1,a0                get ram based address into a0
0000062A  0084      
0000062C  4E90       227                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000062E  4CDF 7FFF  228                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000632  4E73       229                   rte
                     230   
00000634  48E7 FFFE  231   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000638  2079 0B00  232                   move.l    VTrap2,a0                get ram based address into a0
0000063C  0088      
0000063E  4E90       233                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000640  4CDF 7FFF  234                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000644  4E73       235                   rte
                     236   
00000646  48E7 FFFE  237   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000064A  2079 0B00  238                   move.l    VTrap3,a0                get ram based address into a0
0000064E  008C      
00000650  4E90       239                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000652  4CDF 7FFF  240                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000656  4E73       241                   rte
                     242   
00000658  48E7 FFFE  243   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000065C  2079 0B00  244                   move.l    VTrap4,a0                get ram based address into a0
00000660  0090      
00000662  4E90       245                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000664  4CDF 7FFF  246                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000668  4E73       247                   rte
                     248   
0000066A  48E7 FFFE  249   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000066E  2079 0B00  250                   move.l    VTrap5,a0                get ram based address into a0
00000672  0094      
00000674  4E90       251                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000676  4CDF 7FFF  252                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000067A  4E73       253                   rte
                     254   
0000067C  48E7 FFFE  255   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000680  2079 0B00  256                   move.l    VTrap6,a0                get ram based address into a0
00000684  0098      
00000686  4E90       257                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000688  4CDF 7FFF  258                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000068C  4E73       259                   rte
                     260   
0000068E  48E7 FFFE  261   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000692  2079 0B00  262                   move.l    VTrap7,a0                get ram based address into a0
00000696  009C      
00000698  4E90       263                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000069A  4CDF 7FFF  264                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000069E  4E73       265                   rte
                     266   
000006A0  48E7 FFFE  267   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006A4  2079 0B00  268                   move.l    VTrap8,a0                get ram based address into a0
000006A8  00A0      
000006AA  4E90       269                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006AC  4CDF 7FFF  270                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006B0  4E73       271                   rte
                     272   
000006B2  48E7 FFFE  273   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006B6  2079 0B00  274                   move.l    VTrap9,a0                get ram based address into a0
000006BA  00A4      
000006BC  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006BE  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006C2  4E73       277                   rte
                     278   
000006C4  48E7 FFFE  279   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006C8  2079 0B00  280                   move.l    VTrap10,a0                get ram based address into a0
000006CC  00A8      
000006CE  4E90       281                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006D0  4CDF 7FFF  282                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006D4  4E73       283                   rte
                     284   
000006D6  48E7 FFFE  285   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006DA  2079 0B00  286                   move.l    VTrap11,a0                get ram based address into a0
000006DE  00AC      
000006E0  4E90       287                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006E2  4CDF 7FFF  288                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006E6  4E73       289                   rte
                     290   
000006E8  48E7 FFFE  291   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006EC  2079 0B00  292                   move.l    VTrap12,a0                get ram based address into a0
000006F0  00B0      
000006F2  4E90       293                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006F4  4CDF 7FFF  294                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006F8  4E73       295                   rte
                     296   
000006FA  48E7 FFFE  297   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006FE  2079 0B00  298                   move.l    VTrap13,a0                get ram based address into a0
00000702  00B4      
00000704  4E90       299                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000706  4CDF 7FFF  300                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000070A  4E73       301                   rte
                     302   
                     303   Trap14RamISR    ;Break Point Handler
                     304   *
                     305   **         Copy 68000 registers from debug monitor Variables
                     306   *
0000070C  23FC 0000  307                   move.l    #1,_Trace      switch on Trace Mode
00000710  0001 0B00 
00000714  00D8      
00000716  33DF 0B00  308                   move.w    (sp)+,_SR       get at the users status register pointed to by stack pointer and copy
0000071A  012C      
0000071C  23DF 0B00  309                   move.l    (sp)+,_PC      get at the users program counter and copy
00000720  0120      
                     310   *
00000722  23C0 0B00  311                   move.l    d0,_d0
00000726  00E4      
00000728  23C1 0B00  312                   move.l    d1,_d1
0000072C  00E8      
0000072E  23C2 0B00  313                   move.l    d2,_d2
00000732  00EC      
00000734  23C3 0B00  314                   move.l    d3,_d3
00000738  00F0      
0000073A  23C4 0B00  315                   move.l    d4,_d4
0000073E  00F4      
00000740  23C5 0B00  316                   move.l    d5,_d5
00000744  00F8      
00000746  23C6 0B00  317                   move.l    d6,_d6
0000074A  00FC      
0000074C  23C7 0B00  318                   move.l    d7,_d7
00000750  0100      
                     319   *
00000752  23C8 0B00  320                   move.l    a0,_a0
00000756  0104      
00000758  23C9 0B00  321                   move.l    a1,_a1
0000075C  0108      
0000075E  23CA 0B00  322                   move.l    a2,_a2
00000762  010C      
00000764  23CB 0B00  323                   move.l    a3,_a3
00000768  0110      
0000076A  23CC 0B00  324                   move.l    a4,_a4
0000076E  0114      
00000770  23CD 0B00  325                   move.l    a5,_a5
00000774  0118      
00000776  23CE 0B00  326                   move.l    a6,_a6
0000077A  011C      
0000077C  4E68       327                   move.l    USP,a0
0000077E  23C8 0B00  328                   move.l    a0,_USP
00000782  0128      
                     329   *
00000784  2079 0B00  330                   move.l    VTrap14,a0             get ram based address into a0
00000788  00B8      
0000078A  4E90       331                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     332   
                     333   ** After breakpoint reload 68000 registers with new values before continuing
                     334   
                     335   *                move.b    #$ff,$0040000A     generate a trace exception for the next instruction
0000078C  2039 0B00  336                   move.l   _d0,d0
00000790  00E4      
00000792  2239 0B00  337                   move.l   _d1,d1
00000796  00E8      
00000798  2439 0B00  338                   move.l   _d2,d2
0000079C  00EC      
0000079E  2639 0B00  339                   move.l   _d3,d3
000007A2  00F0      
000007A4  2839 0B00  340                   move.l   _d4,d4
000007A8  00F4      
000007AA  2A39 0B00  341                   move.l   _d5,d5
000007AE  00F8      
000007B0  2C39 0B00  342                   move.l   _d6,d6
000007B4  00FC      
000007B6  2E39 0B00  343                   move.l   _d7,d7
000007BA  0100      
                     344   
000007BC  2079 0B00  345                   move.l   _USP,a0
000007C0  0128      
000007C2  4E60       346                   move.l   a0,USP        load user stack pointer A7
000007C4  2079 0B00  347                   move.l   _a0,a0
000007C8  0104      
000007CA  2279 0B00  348                   move.l   _a1,a1
000007CE  0108      
000007D0  2479 0B00  349                   move.l   _a2,a2
000007D4  010C      
000007D6  2679 0B00  350                   move.l   _a3,a3
000007DA  0110      
000007DC  2879 0B00  351                   move.l   _a4,a4
000007E0  0114      
000007E2  2A79 0B00  352                   move.l   _a5,a5
000007E6  0118      
000007E8  2C79 0B00  353                   move.l   _a6,a6
000007EC  011C      
                     354   
000007EE  2F39 0B00  355                   move.l   _PC,-(sp)
000007F2  0120      
000007F4  3F39 0B00  356                   move.w   _SR,-(sp)
000007F8  012C      
000007FA  4E73       357                   rte
                     358   
000007FC  4EF9 0000  359   Trap15RamISR    jmp     _CallDebugMonitor
00000800  22FC      
                     360   *                movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                     361   *                move.l    VTrap15,a0                get ram based address into a0
                     362   *                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                     363   *                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                     364   *                rte
                     365   
                     366   *********************************************************************************************************
                     367   *Default exception handler for everything without a specific handler
                     368   *********************************************************************************************************
                     369   
                     370   *
                     371   **              Jump here for each unhandled exception
                     372   **              If you need to, MAKE SURE YOU SAVE ALL IMPORTANT REGISTERS AND RESTORE THEM BEFORE RETURNING (IF APPROPRIATE)
                     373   *
                     374   
00000802  48E7 FFFE  375   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000806  2079 0B00  376                   move.l    VBusError,a0            get ram based address into a0
0000080A  0008      
0000080C  4E90       377                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000080E  4CDF 7FFF  378                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000812  4E73       379                   rte
00000814  48E7 FFFE  380   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000818  2079 0B00  381                   move.l    VAddressError,a0        get ram based address into a0
0000081C  000C      
0000081E  4E90       382                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000820  4CDF 7FFF  383                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000824  4E73       384                   rte
00000826  48E7 FFFE  385   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000082A  2079 0B00  386                   move.l    VIllegalInstr,a0        get ram based address into a0
0000082E  0010      
00000830  4E90       387                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000832  4CDF 7FFF  388                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000836  4E73       389                   rte
00000838  48E7 FFFE  390   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000083C  2079 0B00  391                   move.l    VDividebyZero,a0        get ram based address into a0
00000840  0014      
00000842  4E90       392                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000844  4CDF 7FFF  393                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000848  4E73       394                   rte
0000084A  48E7 FFFE  395   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000084E  2079 0B00  396                   move.l    VCheck,a0               get ram based address into a0
00000852  0018      
00000854  4E90       397                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000856  4CDF 7FFF  398                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000085A  4E73       399                   rte
0000085C  48E7 FFFE  400   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000860  2079 0B00  401                   move.l    VTrapV,a0               get ram based address into a0
00000864  001C      
00000866  4E90       402                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000868  4CDF 7FFF  403                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000086C  4E73       404                   rte
0000086E  48E7 FFFE  405   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000872  2079 0B00  406                   move.l    VPrivilege,a0           get ram based address into a0
00000876  0020      
00000878  4E90       407                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000087A  4CDF 7FFF  408                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000087E  4E73       409                   rte
00000880  48E7 FFFE  410   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000884  2079 0B00  411                   move.l    VTrace,a0               get ram based address into a0
00000888  0024      
0000088A  4E90       412                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000088C  4CDF 7FFF  413                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000890  4E73       414                   rte
00000892  48E7 FFFE  415   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000896  2079 0B00  416                   move.l    VLine1010emul,a0        get ram based address into a0
0000089A  0028      
0000089C  4E90       417                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000089E  4CDF 7FFF  418                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008A2  4E73       419                   rte
000008A4  48E7 FFFE  420   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000008A8  2079 0B00  421                   move.l    VLine1111emul,a0        get ram based address into a0
000008AC  002C      
000008AE  4E90       422                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000008B0  4CDF 7FFF  423                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008B4  4E73       424                   rte
                     425   E_Unnas1
                     426   E_Unnas2
                     427   E_Unnas3
                     428   E_UnitI
                     429   E_Unnas4
                     430   E_Unnas5
                     431   E_Unnas6
                     432   E_Unnas7
                     433   E_Unnas8
                     434   E_Unnas9
                     435   E_Unnas10
                     436   E_Unnas11
                     437   E_Spuri
000008B6  60FE       438   _stop            bra _stop                         stop
                     439   ***************************************************************************************************
                     440   * Go() function in debug monitor
                     441   ***************************************************************************************************
                     442   _go
000008B8  2E79 0B00  443                   move.l   _SSP,a7        load system stack pointer (remember we are in supervisor mode when running this so a7 is the System stack pointer)
000008BC  0124      
000008BE  2F39 0B00  444                   move.l   _PC,-(sp)      copy debug monitor PC variable to the stack
000008C2  0120      
000008C4  3F39 0B00  445                   move.w   _SR,-(sp)      copy debug monitor status reg to the stack
000008C8  012C      
                     446   
000008CA  1038 0078  447                   move.b   $00000078,d0  remove any spurious address exception arising after power on
000008CE  2039 0B00  448                   move.l   _d0,d0
000008D2  00E4      
000008D4  2239 0B00  449                   move.l   _d1,d1
000008D8  00E8      
000008DA  2439 0B00  450                   move.l   _d2,d2
000008DE  00EC      
000008E0  2639 0B00  451                   move.l   _d3,d3
000008E4  00F0      
000008E6  2839 0B00  452                   move.l   _d4,d4
000008EA  00F4      
000008EC  2A39 0B00  453                   move.l   _d5,d5
000008F0  00F8      
000008F2  2C39 0B00  454                   move.l   _d6,d6
000008F6  00FC      
000008F8  2E39 0B00  455                   move.l   _d7,d7
000008FC  0100      
                     456   
000008FE  2079 0B00  457                   move.l   _USP,a0
00000902  0128      
00000904  4E60       458                   move.l   a0,USP        load user stack pointer (remember we are in supervisor mode when running this, so a7 is the System stack pointer)
00000906  2079 0B00  459                   move.l   _a0,a0
0000090A  0104      
0000090C  2279 0B00  460                   move.l   _a1,a1
00000910  0108      
00000912  2479 0B00  461                   move.l   _a2,a2
00000916  010C      
00000918  2679 0B00  462                   move.l   _a3,a3
0000091C  0110      
0000091E  2879 0B00  463                   move.l   _a4,a4
00000922  0114      
00000924  2A79 0B00  464                   move.l   _a5,a5
00000928  0118      
0000092A  2C79 0B00  465                   move.l   _a6,a6
0000092E  011C      
00000930  4E73       466                   rte                    load the status reg and PC from the stack and commence running
                     467                                          *used to be rte but this didn't load the status byte
                     468   
                     469   ; C:\M68KV6.0-800BY480\PROGRAMS\DEBUGMONITORCODE\M68KDEBUG (NO DISASSEMBLER).C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     470   ; #include "DebugMonitor.h"
                     471   ; // use 08030000 for a system running from sram or 0B000000 for system running from dram
                     472   ; //#define StartOfExceptionVectorTable 0x08030000
                     473   ; #define StartOfExceptionVectorTable 0x0B000000
                     474   ; // use 0C000000 for dram or hex 08040000 for sram
                     475   ; //#define TopOfStack 0x08040000
                     476   ; #define TopOfStack 0x0C000000
                     477   ; // the start address of the sdram
                     478   ; #define start_of_dram 0x08000000
                     479   ; /*************************************************************
                     480   ; ** SPI Controller registers
                     481   ; **************************************************************/
                     482   ; // SPI Registers
                     483   ; #define SPI_Control         (*(volatile unsigned char *)(0x00408020))
                     484   ; #define SPI_Status          (*(volatile unsigned char *)(0x00408022))
                     485   ; #define SPI_Data            (*(volatile unsigned char *)(0x00408024))
                     486   ; #define SPI_Ext             (*(volatile unsigned char *)(0x00408026))
                     487   ; #define SPI_CS              (*(volatile unsigned char *)(0x00408028))
                     488   ; // these two macros enable or disable the flash memory chip enable off SSN_O[7..0]
                     489   ; // in this case we assume there is only 1 device connected to SSN_O[0] so we can
                     490   ; // write hex FE to the SPI_CS to enable it (the enable on the flash chip is active low)
                     491   ; // and write FF to disable it
                     492   ; #define   Enable_SPI_CS()             SPI_CS = 0xFE
                     493   ; #define   Disable_SPI_CS()            SPI_CS = 0xFF
                     494   ; // SPI flash chip commands
                     495   ; #define write_enable_cmd 0x06
                     496   ; #define erasing_cmd  0xc7
                     497   ; #define read_cmd  0x03
                     498   ; #define write_cmd  0x02
                     499   ; #define check_status_cmd 0x05
                     500   ; /* DO NOT INITIALISE GLOBAL VARIABLES - DO IT in MAIN() */
                     501   ; unsigned int i, x, y, z, PortA_Count;
                     502   ; int     Trace, GoFlag, Echo;                       // used in tracing/single stepping
                     503   ; // 68000 register dump and preintialise value (these can be changed by the user program when it is running, e.g. stack pointer, registers etc
                     504   ; unsigned int d0,d1,d2,d3,d4,d5,d6,d7 ;
                     505   ; unsigned int a0,a1,a2,a3,a4,a5,a6 ;
                     506   ; unsigned int PC, SSP, USP ;
                     507   ; unsigned short int SR;
                     508   ; // Breakpoint variables
                     509   ; unsigned int BreakPointAddress[8];                      //array of 8 breakpoint addresses
                     510   ; unsigned short int BreakPointInstruction[8] ;           // to hold the instruction opcode at the breakpoint
                     511   ; unsigned int BreakPointSetOrCleared[8] ;
                     512   ; unsigned int InstructionSize ;
                     513   ; // watchpoint variables
                     514   ; unsigned int WatchPointAddress[8];                      //array of 8 breakpoint addresses
                     515   ; unsigned int WatchPointSetOrCleared[8] ;
                     516   ; char WatchPointString[8][100] ;
                     517   ; char    TempString[100] ; 
                     518   ; /************************************************************************************
                     519   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                     520   ; ************************************************************************************/
                     521   ; void Wait1ms(void)
                     522   ; {
                     523   _Wait1ms:
00000932  2F02       524          move.l    D2,-(A7)
                     525   ; long int  i ;
                     526   ; for(i = 0; i < 1000; i ++)
00000934  4282       527          clr.l     D2
                     528   Wait1ms_1:
00000936  0C82 0000  529          cmp.l     #1000,D2
0000093A  03E8      
0000093C  6C04       530          bge.s     Wait1ms_3
0000093E  5282       531          addq.l    #1,D2
00000940  60F4       532          bra       Wait1ms_1
                     533   Wait1ms_3:
00000942  241F       534          move.l    (A7)+,D2
00000944  4E75       535          rts
                     536   ; ;
                     537   ; }
                     538   ; /************************************************************************************
                     539   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                     540   ; **************************************************************************************/
                     541   ; void Wait3ms(void)
                     542   ; {
                     543   _Wait3ms:
00000946  2F02       544          move.l    D2,-(A7)
                     545   ; int i ;
                     546   ; for(i = 0; i < 3; i++)
00000948  4282       547          clr.l     D2
                     548   Wait3ms_1:
0000094A  0C82 0000  549          cmp.l     #3,D2
0000094E  0003      
00000950  6C08       550          bge.s     Wait3ms_3
                     551   ; Wait1ms() ;
00000952  4EB8 0932  552          jsr       _Wait1ms
00000956  5282       553          addq.l    #1,D2
00000958  60F0       554          bra       Wait3ms_1
                     555   Wait3ms_3:
0000095A  241F       556          move.l    (A7)+,D2
0000095C  4E75       557          rts
                     558   ; }
                     559   ; /*********************************************************************************************
                     560   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                     561   ; *********************************************************************************************/
                     562   ; void Init_LCD(void)
                     563   ; {
                     564   _Init_LCD:
                     565   ; LCDcommand = (char)(0x0c) ;
0000095E  13FC 000C  566          move.b    #12,4194336
00000962  0040 0020 
                     567   ; Wait3ms() ;
00000966  4EB8 0946  568          jsr       _Wait3ms
                     569   ; LCDcommand = (char)(0x38) ;
0000096A  13FC 0038  570          move.b    #56,4194336
0000096E  0040 0020 
                     571   ; Wait3ms() ;
00000972  4EB8 0946  572          jsr       _Wait3ms
00000976  4E75       573          rts
                     574   ; }
                     575   ; /******************************************************************************
                     576   ; *subroutine to output a single character held in d1 to the LCD display
                     577   ; *it is assumed the character is an ASCII code and it will be displayed at the
                     578   ; *current cursor position
                     579   ; *******************************************************************************/
                     580   ; void Outchar(int c)
                     581   ; {
                     582   _Outchar:
00000978  4E56 0000  583          link      A6,#0
                     584   ; LCDdata = (char)(c);
0000097C  202E 0008  585          move.l    8(A6),D0
00000980  13C0 0040  586          move.b    D0,4194338
00000984  0022      
                     587   ; Wait1ms() ;
00000986  4EB8 0932  588          jsr       _Wait1ms
0000098A  4E5E       589          unlk      A6
0000098C  4E75       590          rts
                     591   ; }
                     592   ; /**********************************************************************************
                     593   ; *subroutine to output a message at the current cursor position of the LCD display
                     594   ; ************************************************************************************/
                     595   ; void OutMess(char *theMessage)
                     596   ; {
                     597   _OutMess:
0000098E  4E56 FFFC  598          link      A6,#-4
                     599   ; char c ;
                     600   ; while((c = *theMessage++) != (char)(0))
                     601   OutMess_1:
00000992  206E 0008  602          move.l    8(A6),A0
00000996  52AE 0008  603          addq.l    #1,8(A6)
0000099A  1D50 FFFF  604          move.b    (A0),-1(A6)
0000099E  1010       605          move.b    (A0),D0
000009A0  6712       606          beq.s     OutMess_3
                     607   ; Outchar(c) ;
000009A2  122E FFFF  608          move.b    -1(A6),D1
000009A6  4881       609          ext.w     D1
000009A8  48C1       610          ext.l     D1
000009AA  2F01       611          move.l    D1,-(A7)
000009AC  4EB8 0978  612          jsr       _Outchar
000009B0  584F       613          addq.w    #4,A7
000009B2  60DE       614          bra       OutMess_1
                     615   OutMess_3:
000009B4  4E5E       616          unlk      A6
000009B6  4E75       617          rts
                     618   ; }
                     619   ; /******************************************************************************
                     620   ; *subroutine to clear the line by issuing 24 space characters
                     621   ; *******************************************************************************/
                     622   ; void Clearln(void)
                     623   ; {
                     624   _Clearln:
000009B8  2F02       625          move.l    D2,-(A7)
                     626   ; unsigned char i ;
                     627   ; for(i = 0; i < 24; i ++)
000009BA  4202       628          clr.b     D2
                     629   Clearln_1:
000009BC  0C02 0018  630          cmp.b     #24,D2
000009C0  640E       631          bhs.s     Clearln_3
                     632   ; Outchar(' ') ;  /* write a space char to the LCD display */
000009C2  4878 0020  633          pea       32
000009C6  4EB8 0978  634          jsr       _Outchar
000009CA  584F       635          addq.w    #4,A7
000009CC  5202       636          addq.b    #1,D2
000009CE  60EC       637          bra       Clearln_1
                     638   Clearln_3:
000009D0  241F       639          move.l    (A7)+,D2
000009D2  4E75       640          rts
                     641   ; }
                     642   ; /******************************************************************************
                     643   ; *subroutine to move the cursor to the start of line 1 and clear that line
                     644   ; *******************************************************************************/
                     645   ; void Oline0(char *theMessage)
                     646   ; {
                     647   _Oline0:
000009D4  4E56 0000  648          link      A6,#0
                     649   ; LCDcommand = (char)(0x80) ;
000009D8  13FC 0080  650          move.b    #128,4194336
000009DC  0040 0020 
                     651   ; Wait3ms();
000009E0  4EB8 0946  652          jsr       _Wait3ms
                     653   ; Clearln() ;
000009E4  4EB8 09B8  654          jsr       _Clearln
                     655   ; LCDcommand = (char)(0x80) ;
000009E8  13FC 0080  656          move.b    #128,4194336
000009EC  0040 0020 
                     657   ; Wait3ms() ;
000009F0  4EB8 0946  658          jsr       _Wait3ms
                     659   ; OutMess(theMessage) ;
000009F4  2F2E 0008  660          move.l    8(A6),-(A7)
000009F8  4EB8 098E  661          jsr       _OutMess
000009FC  584F       662          addq.w    #4,A7
000009FE  4E5E       663          unlk      A6
00000A00  4E75       664          rts
                     665   ; }
                     666   ; /******************************************************************************
                     667   ; *subroutine to move the cursor to the start of line 2 and clear that line
                     668   ; *******************************************************************************/
                     669   ; void Oline1(char *theMessage)
                     670   ; {
                     671   _Oline1:
00000A02  4E56 0000  672          link      A6,#0
                     673   ; LCDcommand = (char)(0xC0) ;
00000A06  13FC 00C0  674          move.b    #192,4194336
00000A0A  0040 0020 
                     675   ; Wait3ms();
00000A0E  4EB8 0946  676          jsr       _Wait3ms
                     677   ; Clearln() ;
00000A12  4EB8 09B8  678          jsr       _Clearln
                     679   ; LCDcommand = (char)(0xC0) ;
00000A16  13FC 00C0  680          move.b    #192,4194336
00000A1A  0040 0020 
                     681   ; Wait3ms() ;
00000A1E  4EB8 0946  682          jsr       _Wait3ms
                     683   ; OutMess(theMessage) ;
00000A22  2F2E 0008  684          move.l    8(A6),-(A7)
00000A26  4EB8 098E  685          jsr       _OutMess
00000A2A  584F       686          addq.w    #4,A7
00000A2C  4E5E       687          unlk      A6
00000A2E  4E75       688          rts
                     689   ; }
                     690   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                     691   ; {
                     692   _InstallExceptionHandler:
00000A30  4E56 FFFC  693          link      A6,#-4
                     694   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
00000A34  2D7C 0B00  695          move.l    #184549376,-4(A6)
00000A38  0000 FFFC 
                     696   ; RamVectorAddress[level] = (long int *)(function_ptr);
00000A3C  206E FFFC  697          move.l    -4(A6),A0
00000A40  202E 000C  698          move.l    12(A6),D0
00000A44  E588       699          lsl.l     #2,D0
00000A46  21AE 0008  700          move.l    8(A6),0(A0,D0.L)
00000A4A  0800      
00000A4C  4E5E       701          unlk      A6
00000A4E  4E75       702          rts
                     703   ; }
                     704   ; void TestLEDS(void)
                     705   ; {
                     706   _TestLEDS:
00000A50  48E7 3000  707          movem.l   D2/D3,-(A7)
                     708   ; int delay ;
                     709   ; unsigned char count = 0 ;
00000A54  4202       710          clr.b     D2
                     711   ; while(1)    {
                     712   TestLEDS_1:
                     713   ; PortA = PortB = PortC = PortD = HEX_A = HEX_B = HEX_C = HEX_D = ((count << 4) + (count & 0x0f)) ;
00000A56  1002       714          move.b    D2,D0
00000A58  E908       715          lsl.b     #4,D0
00000A5A  1202       716          move.b    D2,D1
00000A5C  C23C 000F  717          and.b     #15,D1
00000A60  D001       718          add.b     D1,D0
00000A62  13C0 0040  719          move.b    D0,4194326
00000A66  0016      
00000A68  13C0 0040  720          move.b    D0,4194324
00000A6C  0014      
00000A6E  13C0 0040  721          move.b    D0,4194322
00000A72  0012      
00000A74  13C0 0040  722          move.b    D0,4194320
00000A78  0010      
00000A7A  13C0 0040  723          move.b    D0,4194310
00000A7E  0006      
00000A80  13C0 0040  724          move.b    D0,4194308
00000A84  0004      
00000A86  13C0 0040  725          move.b    D0,4194306
00000A8A  0002      
00000A8C  13C0 0040  726          move.b    D0,4194304
00000A90  0000      
                     727   ; for(delay = 0; delay < 200000; delay ++)
00000A92  4283       728          clr.l     D3
                     729   TestLEDS_4:
00000A94  0C83 0003  730          cmp.l     #200000,D3
00000A98  0D40      
00000A9A  6C04       731          bge.s     TestLEDS_6
00000A9C  5283       732          addq.l    #1,D3
00000A9E  60F4       733          bra       TestLEDS_4
                     734   TestLEDS_6:
                     735   ; ;
                     736   ; count ++;
00000AA0  5202       737          addq.b    #1,D2
00000AA2  60B2       738          bra       TestLEDS_1
                     739   ; }
                     740   ; }
                     741   ; void SwitchTest(void)
                     742   ; {
                     743   _SwitchTest:
00000AA4  48E7 3020  744          movem.l   D2/D3/A2,-(A7)
00000AA8  45F9 0000  745          lea       _printf.L,A2
00000AAC  3434      
                     746   ; int i, switches = 0 ;
00000AAE  4283       747          clr.l     D3
                     748   ; printf("\r\n") ;
00000AB0  4879 0000  749          pea       @m68kde~1_1.L
00000AB4  3D84      
00000AB6  4E92       750          jsr       (A2)
00000AB8  584F       751          addq.w    #4,A7
                     752   ; while(1)    {
                     753   SwitchTest_1:
                     754   ; switches = (PortB << 8) | (PortA) ;
00000ABA  1039 0040  755          move.b    4194306,D0
00000ABE  0002      
00000AC0  C0BC 0000  756          and.l     #255,D0
00000AC4  00FF      
00000AC6  E188       757          lsl.l     #8,D0
00000AC8  1239 0040  758          move.b    4194304,D1
00000ACC  0000      
00000ACE  C2BC 0000  759          and.l     #255,D1
00000AD2  00FF      
00000AD4  8081       760          or.l      D1,D0
00000AD6  2600       761          move.l    D0,D3
                     762   ; printf("\rSwitches SW[7-0] = ") ;
00000AD8  4879 0000  763          pea       @m68kde~1_2.L
00000ADC  3D88      
00000ADE  4E92       764          jsr       (A2)
00000AE0  584F       765          addq.w    #4,A7
                     766   ; for( i = (int)(0x00000080); i > 0; i = i >> 1)  {
00000AE2  243C 0000  767          move.l    #128,D2
00000AE6  0080      
                     768   SwitchTest_4:
00000AE8  0C82 0000  769          cmp.l     #0,D2
00000AEC  0000      
00000AEE  6F20       770          ble.s     SwitchTest_6
                     771   ; if((switches & i) == 0)
00000AF0  2003       772          move.l    D3,D0
00000AF2  C082       773          and.l     D2,D0
00000AF4  660C       774          bne.s     SwitchTest_7
                     775   ; printf("0") ;
00000AF6  4879 0000  776          pea       @m68kde~1_3.L
00000AFA  3D9E      
00000AFC  4E92       777          jsr       (A2)
00000AFE  584F       778          addq.w    #4,A7
00000B00  600A       779          bra.s     SwitchTest_8
                     780   SwitchTest_7:
                     781   ; else
                     782   ; printf("1") ;
00000B02  4879 0000  783          pea       @m68kde~1_4.L
00000B06  3DA0      
00000B08  4E92       784          jsr       (A2)
00000B0A  584F       785          addq.w    #4,A7
                     786   SwitchTest_8:
00000B0C  E282       787          asr.l     #1,D2
00000B0E  60D8       788          bra       SwitchTest_4
                     789   SwitchTest_6:
00000B10  60A8       790          bra       SwitchTest_1
                     791   ; }
                     792   ; }
                     793   ; }
                     794   ; /*********************************************************************************************
                     795   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                     796   ; *********************************************************************************************/
                     797   ; void Init_RS232(void)
                     798   ; {
                     799   _Init_RS232:
                     800   ; RS232_Control = (char)(0x15) ; //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00000B12  13FC 0015  801          move.b    #21,4194368
00000B16  0040 0040 
                     802   ; RS232_Baud = (char)(0x1) ;      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00000B1A  13FC 0001  803          move.b    #1,4194372
00000B1E  0040 0044 
00000B22  4E75       804          rts
                     805   ; }
                     806   ; int kbhit(void)
                     807   ; {
                     808   _kbhit:
                     809   ; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // wait for Rx bit in status register to be '1'
00000B24  1039 0040  810          move.b    4194368,D0
00000B28  0040      
00000B2A  C03C 0001  811          and.b     #1,D0
00000B2E  0C00 0001  812          cmp.b     #1,D0
00000B32  6604       813          bne.s     kbhit_1
                     814   ; return 1 ;
00000B34  7001       815          moveq     #1,D0
00000B36  6002       816          bra.s     kbhit_3
                     817   kbhit_1:
                     818   ; else
                     819   ; return 0 ;
00000B38  4280       820          clr.l     D0
                     821   kbhit_3:
00000B3A  4E75       822          rts
                     823   ; }
                     824   ; /*********************************************************************************************************
                     825   ; **  Subroutine to provide a low level output function to 6850 ACIA
                     826   ; **  This routine provides the basic functionality to output a single character to the serial Port
                     827   ; **  to allow the board to communicate with HyperTerminal Program
                     828   ; **
                     829   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                     830   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                     831   ; **  call _putch() also
                     832   ; *********************************************************************************************************/
                     833   ; int _putch( int c)
                     834   ; {
                     835   __putch:
00000B3C  4E56 0000  836          link      A6,#0
                     837   ; while(((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                     838   _putch_1:
00000B40  1039 0040  839          move.b    4194368,D0
00000B44  0040      
00000B46  C03C 0002  840          and.b     #2,D0
00000B4A  0C00 0002  841          cmp.b     #2,D0
00000B4E  6702       842          beq.s     _putch_3
00000B50  60EE       843          bra       _putch_1
                     844   _putch_3:
                     845   ; ;
                     846   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00000B52  202E 0008  847          move.l    8(A6),D0
00000B56  C03C 007F  848          and.b     #127,D0
00000B5A  13C0 0040  849          move.b    D0,4194370
00000B5E  0042      
                     850   ; return c ;                                              // putchar() expects the character to be returned
00000B60  202E 0008  851          move.l    8(A6),D0
00000B64  4E5E       852          unlk      A6
00000B66  4E75       853          rts
                     854   ; }
                     855   ; /*********************************************************************************************************
                     856   ; **  Subroutine to provide a low level input function to 6850 ACIA
                     857   ; **  This routine provides the basic functionality to input a single character from the serial Port
                     858   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                     859   ; **
                     860   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                     861   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                     862   ; **  call _getch() also
                     863   ; *********************************************************************************************************/
                     864   ; int _getch( void )
                     865   ; {
                     866   __getch:
00000B68  2F02       867          move.l    D2,-(A7)
                     868   ; int c ;
                     869   ; while(((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                     870   _getch_1:
00000B6A  1039 0040  871          move.b    4194368,D0
00000B6E  0040      
00000B70  C03C 0001  872          and.b     #1,D0
00000B74  0C00 0001  873          cmp.b     #1,D0
00000B78  6702       874          beq.s     _getch_3
00000B7A  60EE       875          bra       _getch_1
                     876   _getch_3:
                     877   ; ;
                     878   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00000B7C  1039 0040  879          move.b    4194370,D0
00000B80  0042      
00000B82  C0BC 0000  880          and.l     #255,D0
00000B86  00FF      
00000B88  C0BC 0000  881          and.l     #127,D0
00000B8C  007F      
00000B8E  2400       882          move.l    D0,D2
                     883   ; // shall we echo the character? Echo is set to TRUE at reset, but for speed we don't want to echo when downloading code with the 'L' debugger command
                     884   ; if(Echo)
00000B90  4AB9 0B00  885          tst.l     _Echo.L
00000B94  00E0      
00000B96  6708       886          beq.s     _getch_4
                     887   ; _putch(c);
00000B98  2F02       888          move.l    D2,-(A7)
00000B9A  4EB8 0B3C  889          jsr       __putch
00000B9E  584F       890          addq.w    #4,A7
                     891   _getch_4:
                     892   ; return c ;
00000BA0  2002       893          move.l    D2,D0
00000BA2  241F       894          move.l    (A7)+,D2
00000BA4  4E75       895          rts
                     896   ; }
                     897   ; // flush the input stream for any unread characters
                     898   ; void FlushKeyboard(void)
                     899   ; {
                     900   _FlushKeyboard:
00000BA6  4E56 FFFC  901          link      A6,#-4
                     902   ; char c ;
                     903   ; while(1)    {
                     904   FlushKeyboard_1:
                     905   ; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // if Rx bit in status register is '1'
00000BAA  1039 0040  906          move.b    4194368,D0
00000BAE  0040      
00000BB0  C03C 0001  907          and.b     #1,D0
00000BB4  0C00 0001  908          cmp.b     #1,D0
00000BB8  6610       909          bne.s     FlushKeyboard_4
                     910   ; c = ((char)(RS232_RxData) & (char)(0x7f)) ;
00000BBA  1039 0040  911          move.b    4194370,D0
00000BBE  0042      
00000BC0  C03C 007F  912          and.b     #127,D0
00000BC4  1D40 FFFF  913          move.b    D0,-1(A6)
00000BC8  6002       914          bra.s     FlushKeyboard_5
                     915   FlushKeyboard_4:
                     916   ; else
                     917   ; return ;
00000BCA  6002       918          bra.s     FlushKeyboard_6
                     919   FlushKeyboard_5:
00000BCC  60DC       920          bra       FlushKeyboard_1
                     921   FlushKeyboard_6:
00000BCE  4E5E       922          unlk      A6
00000BD0  4E75       923          rts
                     924   ; }
                     925   ; }
                     926   ; // converts hex char to 4 bit binary equiv in range 0000-1111 (0-F)
                     927   ; // char assumed to be a valid hex char 0-9, a-f, A-F
                     928   ; char xtod(int c)
                     929   ; {
                     930   _xtod:
00000BD2  4E56 0000  931          link      A6,#0
00000BD6  2F02       932          move.l    D2,-(A7)
00000BD8  242E 0008  933          move.l    8(A6),D2
                     934   ; if ((char)(c) <= (char)('9'))
00000BDC  0C02 0039  935          cmp.b     #57,D2
00000BE0  6E08       936          bgt.s     xtod_1
                     937   ; return c - (char)(0x30);    // 0 - 9 = 0x30 - 0x39 so convert to number by sutracting 0x30
00000BE2  1002       938          move.b    D2,D0
00000BE4  0400 0030  939          sub.b     #48,D0
00000BE8  6014       940          bra.s     xtod_3
                     941   xtod_1:
                     942   ; else if((char)(c) > (char)('F'))    // assume lower case
00000BEA  0C02 0046  943          cmp.b     #70,D2
00000BEE  6F08       944          ble.s     xtod_4
                     945   ; return c - (char)(0x57);    // a-f = 0x61-66 so needs to be converted to 0x0A - 0x0F so subtract 0x57
00000BF0  1002       946          move.b    D2,D0
00000BF2  0400 0057  947          sub.b     #87,D0
00000BF6  6006       948          bra.s     xtod_3
                     949   xtod_4:
                     950   ; else
                     951   ; return c - (char)(0x37);    // A-F = 0x41-46 so needs to be converted to 0x0A - 0x0F so subtract 0x37
00000BF8  1002       952          move.b    D2,D0
00000BFA  0400 0037  953          sub.b     #55,D0
                     954   xtod_3:
00000BFE  241F       955          move.l    (A7)+,D2
00000C00  4E5E       956          unlk      A6
00000C02  4E75       957          rts
                     958   ; }
                     959   ; int Get1HexDigits(char *CheckSumPtr)
                     960   ; {
                     961   _Get1HexDigits:
00000C04  4E56 0000  962          link      A6,#0
00000C08  2F02       963          move.l    D2,-(A7)
                     964   ; register int i = xtod(_getch());
00000C0A  2F00       965          move.l    D0,-(A7)
00000C0C  4EB8 0B68  966          jsr       __getch
00000C10  2200       967          move.l    D0,D1
00000C12  201F       968          move.l    (A7)+,D0
00000C14  2F01       969          move.l    D1,-(A7)
00000C16  4EB8 0BD2  970          jsr       _xtod
00000C1A  584F       971          addq.w    #4,A7
00000C1C  C0BC 0000  972          and.l     #255,D0
00000C20  00FF      
00000C22  2400       973          move.l    D0,D2
                     974   ; if(CheckSumPtr)
00000C24  4AAE 0008  975          tst.l     8(A6)
00000C28  6706       976          beq.s     Get1HexDigits_1
                     977   ; *CheckSumPtr += i ;
00000C2A  206E 0008  978          move.l    8(A6),A0
00000C2E  D510       979          add.b     D2,(A0)
                     980   Get1HexDigits_1:
                     981   ; return i; 
00000C30  2002       982          move.l    D2,D0
00000C32  241F       983          move.l    (A7)+,D2
00000C34  4E5E       984          unlk      A6
00000C36  4E75       985          rts
                     986   ; }
                     987   ; int Get2HexDigits(char *CheckSumPtr)
                     988   ; {
                     989   _Get2HexDigits:
00000C38  4E56 0000  990          link      A6,#0
00000C3C  2F02       991          move.l    D2,-(A7)
                     992   ; register int i = (xtod(_getch()) << 4) | (xtod(_getch()));
00000C3E  2F00       993          move.l    D0,-(A7)
00000C40  4EB8 0B68  994          jsr       __getch
00000C44  2200       995          move.l    D0,D1
00000C46  201F       996          move.l    (A7)+,D0
00000C48  2F01       997          move.l    D1,-(A7)
00000C4A  4EB8 0BD2  998          jsr       _xtod
00000C4E  584F       999          addq.w    #4,A7
00000C50  C0BC 0000 1000          and.l     #255,D0
00000C54  00FF      
00000C56  E980      1001          asl.l     #4,D0
00000C58  2F00      1002          move.l    D0,-(A7)
00000C5A  2F01      1003          move.l    D1,-(A7)
00000C5C  4EB8 0B68 1004          jsr       __getch
00000C60  221F      1005          move.l    (A7)+,D1
00000C62  2F00      1006          move.l    D0,-(A7)
00000C64  4EB8 0BD2 1007          jsr       _xtod
00000C68  584F      1008          addq.w    #4,A7
00000C6A  2200      1009          move.l    D0,D1
00000C6C  201F      1010          move.l    (A7)+,D0
00000C6E  C2BC 0000 1011          and.l     #255,D1
00000C72  00FF      
00000C74  8081      1012          or.l      D1,D0
00000C76  2400      1013          move.l    D0,D2
                    1014   ; if(CheckSumPtr)
00000C78  4AAE 0008 1015          tst.l     8(A6)
00000C7C  6706      1016          beq.s     Get2HexDigits_1
                    1017   ; *CheckSumPtr += i ;
00000C7E  206E 0008 1018          move.l    8(A6),A0
00000C82  D510      1019          add.b     D2,(A0)
                    1020   Get2HexDigits_1:
                    1021   ; return i ;
00000C84  2002      1022          move.l    D2,D0
00000C86  241F      1023          move.l    (A7)+,D2
00000C88  4E5E      1024          unlk      A6
00000C8A  4E75      1025          rts
                    1026   ; }
                    1027   ; int Get4HexDigits(char *CheckSumPtr)
                    1028   ; {
                    1029   _Get4HexDigits:
00000C8C  4E56 0000 1030          link      A6,#0
                    1031   ; return (Get2HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000C90  2F2E 0008 1032          move.l    8(A6),-(A7)
00000C94  4EB8 0C38 1033          jsr       _Get2HexDigits
00000C98  584F      1034          addq.w    #4,A7
00000C9A  E180      1035          asl.l     #8,D0
00000C9C  2F00      1036          move.l    D0,-(A7)
00000C9E  2F2E 0008 1037          move.l    8(A6),-(A7)
00000CA2  4EB8 0C38 1038          jsr       _Get2HexDigits
00000CA6  584F      1039          addq.w    #4,A7
00000CA8  2200      1040          move.l    D0,D1
00000CAA  201F      1041          move.l    (A7)+,D0
00000CAC  8081      1042          or.l      D1,D0
00000CAE  4E5E      1043          unlk      A6
00000CB0  4E75      1044          rts
                    1045   ; }
                    1046   ; int Get6HexDigits(char *CheckSumPtr)
                    1047   ; {
                    1048   _Get6HexDigits:
00000CB2  4E56 0000 1049          link      A6,#0
                    1050   ; return (Get4HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000CB6  2F2E 0008 1051          move.l    8(A6),-(A7)
00000CBA  4EB8 0C8C 1052          jsr       _Get4HexDigits
00000CBE  584F      1053          addq.w    #4,A7
00000CC0  E180      1054          asl.l     #8,D0
00000CC2  2F00      1055          move.l    D0,-(A7)
00000CC4  2F2E 0008 1056          move.l    8(A6),-(A7)
00000CC8  4EB8 0C38 1057          jsr       _Get2HexDigits
00000CCC  584F      1058          addq.w    #4,A7
00000CCE  2200      1059          move.l    D0,D1
00000CD0  201F      1060          move.l    (A7)+,D0
00000CD2  8081      1061          or.l      D1,D0
00000CD4  4E5E      1062          unlk      A6
00000CD6  4E75      1063          rts
                    1064   ; }
                    1065   ; int Get8HexDigits(char *CheckSumPtr)
                    1066   ; {
                    1067   _Get8HexDigits:
00000CD8  4E56 0000 1068          link      A6,#0
                    1069   ; return (Get4HexDigits(CheckSumPtr) << 16) | (Get4HexDigits(CheckSumPtr));
00000CDC  2F2E 0008 1070          move.l    8(A6),-(A7)
00000CE0  4EB8 0C8C 1071          jsr       _Get4HexDigits
00000CE4  584F      1072          addq.w    #4,A7
00000CE6  E180      1073          asl.l     #8,D0
00000CE8  E180      1074          asl.l     #8,D0
00000CEA  2F00      1075          move.l    D0,-(A7)
00000CEC  2F2E 0008 1076          move.l    8(A6),-(A7)
00000CF0  4EB8 0C8C 1077          jsr       _Get4HexDigits
00000CF4  584F      1078          addq.w    #4,A7
00000CF6  2200      1079          move.l    D0,D1
00000CF8  201F      1080          move.l    (A7)+,D0
00000CFA  8081      1081          or.l      D1,D0
00000CFC  4E5E      1082          unlk      A6
00000CFE  4E75      1083          rts
                    1084   ; }
                    1085   ; void DumpMemory(void)   // simple dump memory fn
                    1086   ; {
                    1087   _DumpMemory:
00000D00  48E7 3C30 1088          movem.l   D2/D3/D4/D5/A2/A3,-(A7)
00000D04  45F9 0000 1089          lea       _printf.L,A2
00000D08  3434      
00000D0A  47F9 0000 1090          lea       _putch.L,A3
00000D0E  3326      
                    1091   ; int i, j ;
                    1092   ; unsigned char *RamPtr,c ; // pointer to where the program is download (assumed)
                    1093   ; printf("\r\nDump Memory Block: <ESC> to Abort, <SPACE> to Continue") ;
00000D10  4879 0000 1094          pea       @m68kde~1_5.L
00000D14  3DA2      
00000D16  4E92      1095          jsr       (A2)
00000D18  584F      1096          addq.w    #4,A7
                    1097   ; printf("\r\nEnter Start Address: ") ;
00000D1A  4879 0000 1098          pea       @m68kde~1_6.L
00000D1E  3DDC      
00000D20  4E92      1099          jsr       (A2)
00000D22  584F      1100          addq.w    #4,A7
                    1101   ; RamPtr = Get8HexDigits(0) ;
00000D24  42A7      1102          clr.l     -(A7)
00000D26  4EB8 0CD8 1103          jsr       _Get8HexDigits
00000D2A  584F      1104          addq.w    #4,A7
00000D2C  2600      1105          move.l    D0,D3
                    1106   ; while(1)    {
                    1107   DumpMemory_1:
                    1108   ; for(i = 0; i < 16; i ++)    {
00000D2E  4285      1109          clr.l     D5
                    1110   DumpMemory_4:
00000D30  0C85 0000 1111          cmp.l     #16,D5
00000D34  0010      
00000D36  6C00 0096 1112          bge       DumpMemory_6
                    1113   ; printf("\r\n%08x ", RamPtr) ;
00000D3A  2F03      1114          move.l    D3,-(A7)
00000D3C  4879 0000 1115          pea       @m68kde~1_7.L
00000D40  3DF4      
00000D42  4E92      1116          jsr       (A2)
00000D44  504F      1117          addq.w    #8,A7
                    1118   ; for(j=0; j < 16; j ++)  {
00000D46  4282      1119          clr.l     D2
                    1120   DumpMemory_7:
00000D48  0C82 0000 1121          cmp.l     #16,D2
00000D4C  0010      
00000D4E  6C24      1122          bge.s     DumpMemory_9
                    1123   ; printf("%02X",RamPtr[j]) ;
00000D50  2043      1124          move.l    D3,A0
00000D52  1230 2800 1125          move.b    0(A0,D2.L),D1
00000D56  C2BC 0000 1126          and.l     #255,D1
00000D5A  00FF      
00000D5C  2F01      1127          move.l    D1,-(A7)
00000D5E  4879 0000 1128          pea       @m68kde~1_8.L
00000D62  3DFC      
00000D64  4E92      1129          jsr       (A2)
00000D66  504F      1130          addq.w    #8,A7
                    1131   ; putchar(' ') ;
00000D68  4878 0020 1132          pea       32
00000D6C  4E93      1133          jsr       (A3)
00000D6E  584F      1134          addq.w    #4,A7
00000D70  5282      1135          addq.l    #1,D2
00000D72  60D4      1136          bra       DumpMemory_7
                    1137   DumpMemory_9:
                    1138   ; }
                    1139   ; // now display the data as ASCII at the end
                    1140   ; printf("  ") ;
00000D74  4879 0000 1141          pea       @m68kde~1_9.L
00000D78  3E02      
00000D7A  4E92      1142          jsr       (A2)
00000D7C  584F      1143          addq.w    #4,A7
                    1144   ; for(j = 0; j < 16; j++) {
00000D7E  4282      1145          clr.l     D2
                    1146   DumpMemory_10:
00000D80  0C82 0000 1147          cmp.l     #16,D2
00000D84  0010      
00000D86  6C00 003A 1148          bge       DumpMemory_12
                    1149   ; c = ((char)(RamPtr[j]) & 0x7f) ;
00000D8A  2043      1150          move.l    D3,A0
00000D8C  1030 2800 1151          move.b    0(A0,D2.L),D0
00000D90  C03C 007F 1152          and.b     #127,D0
00000D94  1800      1153          move.b    D0,D4
                    1154   ; if((c > (char)(0x7f)) || (c < ' '))
00000D96  0C04 007F 1155          cmp.b     #127,D4
00000D9A  6206      1156          bhi.s     DumpMemory_15
00000D9C  0C04 0020 1157          cmp.b     #32,D4
00000DA0  640A      1158          bhs.s     DumpMemory_13
                    1159   DumpMemory_15:
                    1160   ; putchar('.') ;
00000DA2  4878 002E 1161          pea       46
00000DA6  4E93      1162          jsr       (A3)
00000DA8  584F      1163          addq.w    #4,A7
00000DAA  6012      1164          bra.s     DumpMemory_14
                    1165   DumpMemory_13:
                    1166   ; else
                    1167   ; putchar(RamPtr[j]) ;
00000DAC  2043      1168          move.l    D3,A0
00000DAE  1230 2800 1169          move.b    0(A0,D2.L),D1
00000DB2  C2BC 0000 1170          and.l     #255,D1
00000DB6  00FF      
00000DB8  2F01      1171          move.l    D1,-(A7)
00000DBA  4E93      1172          jsr       (A3)
00000DBC  584F      1173          addq.w    #4,A7
                    1174   DumpMemory_14:
00000DBE  5282      1175          addq.l    #1,D2
00000DC0  60BE      1176          bra       DumpMemory_10
                    1177   DumpMemory_12:
                    1178   ; }
                    1179   ; RamPtr = RamPtr + 16 ;
00000DC2  0683 0000 1180          add.l     #16,D3
00000DC6  0010      
00000DC8  5285      1181          addq.l    #1,D5
00000DCA  6000 FF64 1182          bra       DumpMemory_4
                    1183   DumpMemory_6:
                    1184   ; }
                    1185   ; printf("\r\n") ;
00000DCE  4879 0000 1186          pea       @m68kde~1_1.L
00000DD2  3D84      
00000DD4  4E92      1187          jsr       (A2)
00000DD6  584F      1188          addq.w    #4,A7
                    1189   ; c = _getch() ;
00000DD8  4EB8 0B68 1190          jsr       __getch
00000DDC  1800      1191          move.b    D0,D4
                    1192   ; if(c == 0x1b)          // break on ESC
00000DDE  0C04 001B 1193          cmp.b     #27,D4
00000DE2  6602      1194          bne.s     DumpMemory_16
                    1195   ; break ;
00000DE4  6004      1196          bra.s     DumpMemory_3
                    1197   DumpMemory_16:
00000DE6  6000 FF46 1198          bra       DumpMemory_1
                    1199   DumpMemory_3:
00000DEA  4CDF 0C3C 1200          movem.l   (A7)+,D2/D3/D4/D5/A2/A3
00000DEE  4E75      1201          rts
                    1202   ; }
                    1203   ; }
                    1204   ; void FillMemory()
                    1205   ; {
                    1206   _FillMemory:
00000DF0  48E7 3820 1207          movem.l   D2/D3/D4/A2,-(A7)
00000DF4  45F9 0000 1208          lea       _printf.L,A2
00000DF8  3434      
                    1209   ; char *StartRamPtr, *EndRamPtr ;
                    1210   ; unsigned char FillData ;
                    1211   ; printf("\r\nFill Memory Block") ;
00000DFA  4879 0000 1212          pea       @m68kde~1_10.L
00000DFE  3E06      
00000E00  4E92      1213          jsr       (A2)
00000E02  584F      1214          addq.w    #4,A7
                    1215   ; printf("\r\nEnter Start Address: ") ;
00000E04  4879 0000 1216          pea       @m68kde~1_6.L
00000E08  3DDC      
00000E0A  4E92      1217          jsr       (A2)
00000E0C  584F      1218          addq.w    #4,A7
                    1219   ; StartRamPtr = Get8HexDigits(0) ;
00000E0E  42A7      1220          clr.l     -(A7)
00000E10  4EB8 0CD8 1221          jsr       _Get8HexDigits
00000E14  584F      1222          addq.w    #4,A7
00000E16  2400      1223          move.l    D0,D2
                    1224   ; printf("\r\nEnter End Address: ") ;
00000E18  4879 0000 1225          pea       @m68kde~1_11.L
00000E1C  3E1A      
00000E1E  4E92      1226          jsr       (A2)
00000E20  584F      1227          addq.w    #4,A7
                    1228   ; EndRamPtr = Get8HexDigits(0) ;
00000E22  42A7      1229          clr.l     -(A7)
00000E24  4EB8 0CD8 1230          jsr       _Get8HexDigits
00000E28  584F      1231          addq.w    #4,A7
00000E2A  2800      1232          move.l    D0,D4
                    1233   ; printf("\r\nEnter Fill Data: ") ;
00000E2C  4879 0000 1234          pea       @m68kde~1_12.L
00000E30  3E30      
00000E32  4E92      1235          jsr       (A2)
00000E34  584F      1236          addq.w    #4,A7
                    1237   ; FillData = Get2HexDigits(0) ;
00000E36  42A7      1238          clr.l     -(A7)
00000E38  4EB8 0C38 1239          jsr       _Get2HexDigits
00000E3C  584F      1240          addq.w    #4,A7
00000E3E  1600      1241          move.b    D0,D3
                    1242   ; printf("\r\nFilling Addresses [$%08X - $%08X] with $%02X", StartRamPtr, EndRamPtr, FillData) ;
00000E40  C6BC 0000 1243          and.l     #255,D3
00000E44  00FF      
00000E46  2F03      1244          move.l    D3,-(A7)
00000E48  2F04      1245          move.l    D4,-(A7)
00000E4A  2F02      1246          move.l    D2,-(A7)
00000E4C  4879 0000 1247          pea       @m68kde~1_13.L
00000E50  3E44      
00000E52  4E92      1248          jsr       (A2)
00000E54  DEFC 0010 1249          add.w     #16,A7
                    1250   ; while(StartRamPtr < EndRamPtr)
                    1251   FillMemory_1:
00000E58  B484      1252          cmp.l     D4,D2
00000E5A  6408      1253          bhs.s     FillMemory_3
                    1254   ; *StartRamPtr++ = FillData ;
00000E5C  2042      1255          move.l    D2,A0
00000E5E  5282      1256          addq.l    #1,D2
00000E60  1083      1257          move.b    D3,(A0)
00000E62  60F4      1258          bra       FillMemory_1
                    1259   FillMemory_3:
00000E64  4CDF 041C 1260          movem.l   (A7)+,D2/D3/D4/A2
00000E68  4E75      1261          rts
                    1262   ; }
                    1263   ; void Load_SRecordFile()
                    1264   ; {
                    1265   _Load_SRecordFile:
00000E6A  4E56 FFDC 1266          link      A6,#-36
00000E6E  48E7 3F3C 1267          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00000E72  45EE FFFA 1268          lea       -6(A6),A2
00000E76  47F8 0C38 1269          lea       _Get2HexDigits.L,A3
00000E7A  49F9 0000 1270          lea       _printf.L,A4
00000E7E  3434      
                    1271   ; int i, Address, AddressSize, DataByte, NumDataBytesToRead, LoadFailed, FailedAddress, AddressFail, SRecordCount = 0, ByteTotal = 0 ;
00000E80  42AE FFEE 1272          clr.l     -18(A6)
00000E84  3A7C 0000 1273          move.w    #0,A5
                    1274   ; int result, ByteCount ;
                    1275   ; char c, CheckSum, ReadCheckSum, HeaderType ;
                    1276   ; char *RamPtr ;                          // pointer to Memory where downloaded program will be stored
                    1277   ; LoadFailed = 0 ;                        //assume LOAD operation will pass
00000E88  7E00      1278          moveq     #0,D7
                    1279   ; AddressFail = 0 ;
00000E8A  42AE FFEA 1280          clr.l     -22(A6)
                    1281   ; Echo = 0 ;                              // don't echo S records during download
00000E8E  42B9 0B00 1282          clr.l     _Echo.L
00000E92  00E0      
                    1283   ; printf("\r\nUse HyperTerminal to Send Text File (.hex)\r\n") ;
00000E94  4879 0000 1284          pea       @m68kde~1_14.L
00000E98  3E74      
00000E9A  4E94      1285          jsr       (A4)
00000E9C  584F      1286          addq.w    #4,A7
                    1287   ; while(1)    {
                    1288   Load_SRecordFile_1:
                    1289   ; CheckSum = 0 ;
00000E9E  4212      1290          clr.b     (A2)
                    1291   ; do {
                    1292   Load_SRecordFile_4:
                    1293   ; c = toupper(_getch()) ;
00000EA0  2F00      1294          move.l    D0,-(A7)
00000EA2  4EB8 0B68 1295          jsr       __getch
00000EA6  2200      1296          move.l    D0,D1
00000EA8  201F      1297          move.l    (A7)+,D0
00000EAA  2F01      1298          move.l    D1,-(A7)
00000EAC  4EB9 0000 1299          jsr       _toupper
00000EB0  3408      
00000EB2  584F      1300          addq.w    #4,A7
00000EB4  1C00      1301          move.b    D0,D6
                    1302   ; if(c == 0x1b )      // if break
00000EB6  0C06 001B 1303          cmp.b     #27,D6
00000EBA  6604      1304          bne.s     Load_SRecordFile_6
                    1305   ; return;
00000EBC  6000 0132 1306          bra       Load_SRecordFile_8
                    1307   Load_SRecordFile_6:
00000EC0  0C06 0053 1308          cmp.b     #83,D6
00000EC4  66DA      1309          bne       Load_SRecordFile_4
                    1310   ; }while(c != (char)('S'));   // wait for S start of header
                    1311   ; HeaderType = _getch() ;
00000EC6  4EB8 0B68 1312          jsr       __getch
00000ECA  1600      1313          move.b    D0,D3
                    1314   ; if(HeaderType == (char)('0') || HeaderType == (char)('5'))       // ignore s0, s5 records
00000ECC  0C03 0030 1315          cmp.b     #48,D3
00000ED0  6706      1316          beq.s     Load_SRecordFile_11
00000ED2  0C03 0035 1317          cmp.b     #53,D3
00000ED6  6604      1318          bne.s     Load_SRecordFile_9
                    1319   Load_SRecordFile_11:
                    1320   ; continue ;
00000ED8  6000 00D2 1321          bra       Load_SRecordFile_23
                    1322   Load_SRecordFile_9:
                    1323   ; if(HeaderType >= (char)('7'))
00000EDC  0C03 0037 1324          cmp.b     #55,D3
00000EE0  6D04      1325          blt.s     Load_SRecordFile_12
                    1326   ; break ;                 // end load on s7,s8,s9 records
00000EE2  6000 00CC 1327          bra       Load_SRecordFile_3
                    1328   Load_SRecordFile_12:
                    1329   ; // get the bytecount
                    1330   ; ByteCount = Get2HexDigits(&CheckSum) ;
00000EE6  2F0A      1331          move.l    A2,-(A7)
00000EE8  4E93      1332          jsr       (A3)
00000EEA  584F      1333          addq.w    #4,A7
00000EEC  2D40 FFF6 1334          move.l    D0,-10(A6)
                    1335   ; // get the address, 4 digits for s1, 6 digits for s2, and 8 digits for s3 record
                    1336   ; if(HeaderType == (char)('1')) {
00000EF0  0C03 0031 1337          cmp.b     #49,D3
00000EF4  660E      1338          bne.s     Load_SRecordFile_14
                    1339   ; AddressSize = 2 ;       // 2 byte address
00000EF6  7A02      1340          moveq     #2,D5
                    1341   ; Address = Get4HexDigits(&CheckSum);
00000EF8  2F0A      1342          move.l    A2,-(A7)
00000EFA  4EB8 0C8C 1343          jsr       _Get4HexDigits
00000EFE  584F      1344          addq.w    #4,A7
00000F00  2800      1345          move.l    D0,D4
00000F02  6020      1346          bra.s     Load_SRecordFile_17
                    1347   Load_SRecordFile_14:
                    1348   ; }
                    1349   ; else if (HeaderType == (char)('2')) {
00000F04  0C03 0032 1350          cmp.b     #50,D3
00000F08  660E      1351          bne.s     Load_SRecordFile_16
                    1352   ; AddressSize = 3 ;       // 3 byte address
00000F0A  7A03      1353          moveq     #3,D5
                    1354   ; Address = Get6HexDigits(&CheckSum) ;
00000F0C  2F0A      1355          move.l    A2,-(A7)
00000F0E  4EB8 0CB2 1356          jsr       _Get6HexDigits
00000F12  584F      1357          addq.w    #4,A7
00000F14  2800      1358          move.l    D0,D4
00000F16  600C      1359          bra.s     Load_SRecordFile_17
                    1360   Load_SRecordFile_16:
                    1361   ; }
                    1362   ; else    {
                    1363   ; AddressSize = 4 ;       // 4 byte address
00000F18  7A04      1364          moveq     #4,D5
                    1365   ; Address = Get8HexDigits(&CheckSum) ;
00000F1A  2F0A      1366          move.l    A2,-(A7)
00000F1C  4EB8 0CD8 1367          jsr       _Get8HexDigits
00000F20  584F      1368          addq.w    #4,A7
00000F22  2800      1369          move.l    D0,D4
                    1370   Load_SRecordFile_17:
                    1371   ; }
                    1372   ; RamPtr = (char *)(Address) ;                            // point to download area
00000F24  2D44 FFFC 1373          move.l    D4,-4(A6)
                    1374   ; NumDataBytesToRead = ByteCount - AddressSize - 1 ;
00000F28  202E FFF6 1375          move.l    -10(A6),D0
00000F2C  9085      1376          sub.l     D5,D0
00000F2E  5380      1377          subq.l    #1,D0
00000F30  2D40 FFE2 1378          move.l    D0,-30(A6)
                    1379   ; for(i = 0; i < NumDataBytesToRead; i ++) {     // read in remaining data bytes (ignore address and checksum at the end
00000F34  4282      1380          clr.l     D2
                    1381   Load_SRecordFile_18:
00000F36  B4AE FFE2 1382          cmp.l     -30(A6),D2
00000F3A  6C1E      1383          bge.s     Load_SRecordFile_20
                    1384   ; DataByte = Get2HexDigits(&CheckSum) ;
00000F3C  2F0A      1385          move.l    A2,-(A7)
00000F3E  4E93      1386          jsr       (A3)
00000F40  584F      1387          addq.w    #4,A7
00000F42  2D40 FFDE 1388          move.l    D0,-34(A6)
                    1389   ; *RamPtr++ = DataByte ;                      // store downloaded byte in Ram at specified address
00000F46  202E FFDE 1390          move.l    -34(A6),D0
00000F4A  206E FFFC 1391          move.l    -4(A6),A0
00000F4E  52AE FFFC 1392          addq.l    #1,-4(A6)
00000F52  1080      1393          move.b    D0,(A0)
                    1394   ; ByteTotal++;
00000F54  524D      1395          addq.w    #1,A5
00000F56  5282      1396          addq.l    #1,D2
00000F58  60DC      1397          bra       Load_SRecordFile_18
                    1398   Load_SRecordFile_20:
                    1399   ; }
                    1400   ; // checksum is the 1's complement of the sum of all data pairs following the bytecount, i.e. it includes the address and the data itself
                    1401   ; ReadCheckSum = Get2HexDigits(0) ;
00000F5A  42A7      1402          clr.l     -(A7)
00000F5C  4E93      1403          jsr       (A3)
00000F5E  584F      1404          addq.w    #4,A7
00000F60  1D40 FFFB 1405          move.b    D0,-5(A6)
                    1406   ; if((~CheckSum&0Xff) != (ReadCheckSum&0Xff))   {
00000F64  1012      1407          move.b    (A2),D0
00000F66  4600      1408          not.b     D0
00000F68  4880      1409          ext.w     D0
00000F6A  C07C 00FF 1410          and.w     #255,D0
00000F6E  122E FFFB 1411          move.b    -5(A6),D1
00000F72  4881      1412          ext.w     D1
00000F74  C27C 00FF 1413          and.w     #255,D1
00000F78  B041      1414          cmp.w     D1,D0
00000F7A  6708      1415          beq.s     Load_SRecordFile_21
                    1416   ; LoadFailed = 1 ;
00000F7C  7E01      1417          moveq     #1,D7
                    1418   ; FailedAddress = Address ;
00000F7E  2D44 FFE6 1419          move.l    D4,-26(A6)
                    1420   ; break;
00000F82  602C      1421          bra.s     Load_SRecordFile_3
                    1422   Load_SRecordFile_21:
                    1423   ; }
                    1424   ; SRecordCount++ ;
00000F84  52AE FFEE 1425          addq.l    #1,-18(A6)
                    1426   ; // display feedback on progress
                    1427   ; if(SRecordCount % 25 == 0)
00000F88  2F2E FFEE 1428          move.l    -18(A6),-(A7)
00000F8C  4878 0019 1429          pea       25
00000F90  4EB9 0000 1430          jsr       LDIV
00000F94  325A      
00000F96  202F 0004 1431          move.l    4(A7),D0
00000F9A  504F      1432          addq.w    #8,A7
00000F9C  4A80      1433          tst.l     D0
00000F9E  660C      1434          bne.s     Load_SRecordFile_23
                    1435   ; putchar('.') ;
00000FA0  4878 002E 1436          pea       46
00000FA4  4EB9 0000 1437          jsr       _putch
00000FA8  3326      
00000FAA  584F      1438          addq.w    #4,A7
                    1439   Load_SRecordFile_23:
00000FAC  6000 FEF0 1440          bra       Load_SRecordFile_1
                    1441   Load_SRecordFile_3:
                    1442   ; }
                    1443   ; if(LoadFailed == 1) {
00000FB0  0C87 0000 1444          cmp.l     #1,D7
00000FB4  0001      
00000FB6  6610      1445          bne.s     Load_SRecordFile_25
                    1446   ; printf("\r\nLoad Failed at Address = [$%08X]\r\n", FailedAddress) ;
00000FB8  2F2E FFE6 1447          move.l    -26(A6),-(A7)
00000FBC  4879 0000 1448          pea       @m68kde~1_15.L
00000FC0  3EA4      
00000FC2  4E94      1449          jsr       (A4)
00000FC4  504F      1450          addq.w    #8,A7
00000FC6  600C      1451          bra.s     Load_SRecordFile_26
                    1452   Load_SRecordFile_25:
                    1453   ; }
                    1454   ; else
                    1455   ; printf("\r\nSuccess: Downloaded %d bytes\r\n", ByteTotal) ;
00000FC8  2F0D      1456          move.l    A5,-(A7)
00000FCA  4879 0000 1457          pea       @m68kde~1_16.L
00000FCE  3ECA      
00000FD0  4E94      1458          jsr       (A4)
00000FD2  504F      1459          addq.w    #8,A7
                    1460   Load_SRecordFile_26:
                    1461   ; // pause at the end to wait for download to finish transmitting at the end of S8 etc
                    1462   ; for(i = 0; i < 400000; i ++)
00000FD4  4282      1463          clr.l     D2
                    1464   Load_SRecordFile_27:
00000FD6  0C82 0006 1465          cmp.l     #400000,D2
00000FDA  1A80      
00000FDC  6C04      1466          bge.s     Load_SRecordFile_29
00000FDE  5282      1467          addq.l    #1,D2
00000FE0  60F4      1468          bra       Load_SRecordFile_27
                    1469   Load_SRecordFile_29:
                    1470   ; ;
                    1471   ; FlushKeyboard() ;
00000FE2  4EB8 0BA6 1472          jsr       _FlushKeyboard
                    1473   ; Echo = 1;
00000FE6  23FC 0000 1474          move.l    #1,_Echo.L
00000FEA  0001 0B00 
00000FEE  00E0      
                    1475   Load_SRecordFile_8:
00000FF0  4CDF 3CFC 1476          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00000FF4  4E5E      1477          unlk      A6
00000FF6  4E75      1478          rts
                    1479   ; }
                    1480   ; void MemoryChange(void)
                    1481   ; {
                    1482   _MemoryChange:
00000FF8  48E7 3820 1483          movem.l   D2/D3/D4/A2,-(A7)
00000FFC  45F9 0000 1484          lea       _printf.L,A2
00001000  3434      
                    1485   ; unsigned char *RamPtr,c ; // pointer to memory
                    1486   ; int Data ;
                    1487   ; printf("\r\nExamine and Change Memory") ;
00001002  4879 0000 1488          pea       @m68kde~1_17.L
00001006  3EEC      
00001008  4E92      1489          jsr       (A2)
0000100A  584F      1490          addq.w    #4,A7
                    1491   ; printf("\r\n<ESC> to Stop, <SPACE> to Advance, '-' to Go Back, <DATA> to change") ;
0000100C  4879 0000 1492          pea       @m68kde~1_18.L
00001010  3F08      
00001012  4E92      1493          jsr       (A2)
00001014  584F      1494          addq.w    #4,A7
                    1495   ; printf("\r\nEnter Address: ") ;
00001016  4879 0000 1496          pea       @m68kde~1_19.L
0000101A  3F4E      
0000101C  4E92      1497          jsr       (A2)
0000101E  584F      1498          addq.w    #4,A7
                    1499   ; RamPtr = Get8HexDigits(0) ;
00001020  42A7      1500          clr.l     -(A7)
00001022  4EB8 0CD8 1501          jsr       _Get8HexDigits
00001026  584F      1502          addq.w    #4,A7
00001028  2600      1503          move.l    D0,D3
                    1504   ; while(1)    {
                    1505   MemoryChange_1:
                    1506   ; printf("\r\n[%08x] : %02x  ", RamPtr, *RamPtr) ;
0000102A  2043      1507          move.l    D3,A0
0000102C  1210      1508          move.b    (A0),D1
0000102E  C2BC 0000 1509          and.l     #255,D1
00001032  00FF      
00001034  2F01      1510          move.l    D1,-(A7)
00001036  2F03      1511          move.l    D3,-(A7)
00001038  4879 0000 1512          pea       @m68kde~1_20.L
0000103C  3F60      
0000103E  4E92      1513          jsr       (A2)
00001040  DEFC 000C 1514          add.w     #12,A7
                    1515   ; c = tolower(_getch()) ;
00001044  2F00      1516          move.l    D0,-(A7)
00001046  4EB8 0B68 1517          jsr       __getch
0000104A  2200      1518          move.l    D0,D1
0000104C  201F      1519          move.l    (A7)+,D0
0000104E  2F01      1520          move.l    D1,-(A7)
00001050  4EB9 0000 1521          jsr       _tolower
00001054  3392      
00001056  584F      1522          addq.w    #4,A7
00001058  1400      1523          move.b    D0,D2
                    1524   ; if(c == (char)(0x1b))
0000105A  0C02 001B 1525          cmp.b     #27,D2
0000105E  6604      1526          bne.s     MemoryChange_4
                    1527   ; return ;                                // abort on escape
00001060  6000 0090 1528          bra       MemoryChange_6
                    1529   MemoryChange_4:
                    1530   ; else if((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {  // are we trying to change data at this location by entering a hex char
00001064  0C02 0030 1531          cmp.b     #48,D2
00001068  6506      1532          blo.s     MemoryChange_10
0000106A  0C02 0039 1533          cmp.b     #57,D2
0000106E  6310      1534          bls.s     MemoryChange_9
                    1535   MemoryChange_10:
00001070  0C02 0061 1536          cmp.b     #97,D2
00001074  6500 006E 1537          blo       MemoryChange_7
00001078  0C02 0066 1538          cmp.b     #102,D2
0000107C  6200 0066 1539          bhi       MemoryChange_7
                    1540   MemoryChange_9:
                    1541   ; Data = (xtod(c) << 4) | (xtod(_getch()));
00001080  C4BC 0000 1542          and.l     #255,D2
00001084  00FF      
00001086  2F02      1543          move.l    D2,-(A7)
00001088  4EB8 0BD2 1544          jsr       _xtod
0000108C  584F      1545          addq.w    #4,A7
0000108E  C0BC 0000 1546          and.l     #255,D0
00001092  00FF      
00001094  E980      1547          asl.l     #4,D0
00001096  2F00      1548          move.l    D0,-(A7)
00001098  2F01      1549          move.l    D1,-(A7)
0000109A  4EB8 0B68 1550          jsr       __getch
0000109E  221F      1551          move.l    (A7)+,D1
000010A0  2F00      1552          move.l    D0,-(A7)
000010A2  4EB8 0BD2 1553          jsr       _xtod
000010A6  584F      1554          addq.w    #4,A7
000010A8  2200      1555          move.l    D0,D1
000010AA  201F      1556          move.l    (A7)+,D0
000010AC  C2BC 0000 1557          and.l     #255,D1
000010B0  00FF      
000010B2  8081      1558          or.l      D1,D0
000010B4  2800      1559          move.l    D0,D4
                    1560   ; *RamPtr = (char)(Data) ;
000010B6  2043      1561          move.l    D3,A0
000010B8  1084      1562          move.b    D4,(A0)
                    1563   ; if(*RamPtr != Data) {
000010BA  2043      1564          move.l    D3,A0
000010BC  1010      1565          move.b    (A0),D0
000010BE  C0BC 0000 1566          and.l     #255,D0
000010C2  00FF      
000010C4  B084      1567          cmp.l     D4,D0
000010C6  671A      1568          beq.s     MemoryChange_11
                    1569   ; printf("\r\nWarning Change Failed: Wrote [%02x], Read [%02x]", Data, *RamPtr) ;
000010C8  2043      1570          move.l    D3,A0
000010CA  1210      1571          move.b    (A0),D1
000010CC  C2BC 0000 1572          and.l     #255,D1
000010D0  00FF      
000010D2  2F01      1573          move.l    D1,-(A7)
000010D4  2F04      1574          move.l    D4,-(A7)
000010D6  4879 0000 1575          pea       @m68kde~1_21.L
000010DA  3F72      
000010DC  4E92      1576          jsr       (A2)
000010DE  DEFC 000C 1577          add.w     #12,A7
                    1578   MemoryChange_11:
000010E2  6008      1579          bra.s     MemoryChange_13
                    1580   MemoryChange_7:
                    1581   ; }
                    1582   ; }
                    1583   ; else if(c == (char)('-'))
000010E4  0C02 002D 1584          cmp.b     #45,D2
000010E8  6602      1585          bne.s     MemoryChange_13
                    1586   ; RamPtr -= 2 ; ;
000010EA  5583      1587          subq.l    #2,D3
                    1588   MemoryChange_13:
                    1589   ; RamPtr ++ ;
000010EC  5283      1590          addq.l    #1,D3
000010EE  6000 FF3A 1591          bra       MemoryChange_1
                    1592   MemoryChange_6:
000010F2  4CDF 041C 1593          movem.l   (A7)+,D2/D3/D4/A2
000010F6  4E75      1594          rts
                    1595   ; }
                    1596   ; }
                    1597   ; /******************************************************************************************
                    1598   ; ** The following code is for the SPI controller
                    1599   ; *******************************************************************************************/
                    1600   ; // return true if the SPI has finished transmitting a byte (to say the Flash chip) return false otherwise
                    1601   ; // this can be used in a polling algorithm to know when the controller is busy or idle.
                    1602   ; int TestForSPITransmitDataComplete(void)    {
                    1603   _TestForSPITransmitDataComplete:
000010F8  4E56 FFF8 1604          link      A6,#-8
                    1605   ; /* TODO replace 0 below with a test for status register SPIF bit and if set, return true */
                    1606   ; int result; 
                    1607   ; int status;
                    1608   ; status = SPI_Status;
000010FC  1039 0040 1609          move.b    4227106,D0
00001100  8022      
00001102  C0BC 0000 1610          and.l     #255,D0
00001106  00FF      
00001108  2D40 FFFC 1611          move.l    D0,-4(A6)
                    1612   ; //printf("\r\nSPI status reg: %d",status); 
                    1613   ; result = status & 0x80; // get the SPIF bit, if SPIF == 1, then transmit is completed, if 0, then not completed. 
0000110C  202E FFFC 1614          move.l    -4(A6),D0
00001110  C0BC 0000 1615          and.l     #128,D0
00001114  0080      
00001116  2D40 FFF8 1616          move.l    D0,-8(A6)
                    1617   ; return result;
0000111A  202E FFF8 1618          move.l    -8(A6),D0
0000111E  4E5E      1619          unlk      A6
00001120  4E75      1620          rts
                    1621   ; }
                    1622   ; /************************************************************************************
                    1623   ; ** initialises the SPI controller chip to set speed, interrupt capability etc.
                    1624   ; ************************************************************************************/
                    1625   ; void SPI_Init(void)
                    1626   ; {
                    1627   _SPI_Init:
                    1628   ; //TODO
                    1629   ; //
                    1630   ; // Program the SPI Control, EXT, CS and Status registers to initialise the SPI controller
                    1631   ; // Don't forget to call this routine from main() before you do anything else with SPI
                    1632   ; //
                    1633   ; // Here are some settings we want to create
                    1634   ; //
                    1635   ; // Control Reg     - interrupts disabled, core enabled, Master mode, Polarity and Phase of clock = [0,0], speed =  divide by 32 = approx 700Khz
                    1636   ; // Ext Reg         - in conjunction with control reg, sets speed above and also sets interrupt flag after every completed transfer (each byte)
                    1637   ; // SPI_CS Reg      - control selection of slave SPI chips via their CS# signals
                    1638   ; // Status Reg      - status of SPI controller chip and used to clear any write collision and interrupt on transmit complete flag
                    1639   ; SPI_Control = 0x53;
00001122  13FC 0053 1640          move.b    #83,4227104
00001126  0040 8020 
                    1641   ; SPI_Ext = 0x00;
0000112A  4239 0040 1642          clr.b     4227110
0000112E  8026      
                    1643   ; Disable_SPI_CS(); // Disable the flash chip during initialisation 
00001130  13FC 00FF 1644          move.b    #255,4227112
00001134  0040 8028 
                    1645   ; SPI_Status = 0xc0;
00001138  13FC 00C0 1646          move.b    #192,4227106
0000113C  0040 8022 
00001140  4E75      1647          rts
                    1648   ; }
                    1649   ; /************************************************************************************
                    1650   ; ** return ONLY when the SPI controller has finished transmitting a byte
                    1651   ; ************************************************************************************/
                    1652   ; void WaitForSPITransmitComplete(void)
                    1653   ; {
                    1654   _WaitForSPITransmitComplete:
00001142  2F02      1655          move.l    D2,-(A7)
                    1656   ; // TODO : poll the status register SPIF bit looking for completion of transmission
                    1657   ; // once transmission is complete, clear the write collision and interrupt on transmit complete flags in the status register (read documentation)
                    1658   ; // just in case they were set
                    1659   ; int SPITransmitComplete = 0;
00001144  4282      1660          clr.l     D2
                    1661   ; while (!SPITransmitComplete)
                    1662   WaitForSPITransmitComplete_1:
00001146  4A82      1663          tst.l     D2
00001148  6608      1664          bne.s     WaitForSPITransmitComplete_3
                    1665   ; {
                    1666   ; SPITransmitComplete = TestForSPITransmitDataComplete();
0000114A  4EB8 10F8 1667          jsr       _TestForSPITransmitDataComplete
0000114E  2400      1668          move.l    D0,D2
00001150  60F4      1669          bra       WaitForSPITransmitComplete_1
                    1670   WaitForSPITransmitComplete_3:
                    1671   ; //printf("\r\nSPI data transmit complete: %d", SPITransmitComplete);
                    1672   ; }
                    1673   ; SPI_Status = 0xc0;
00001152  13FC 00C0 1674          move.b    #192,4227106
00001156  0040 8022 
0000115A  241F      1675          move.l    (A7)+,D2
0000115C  4E75      1676          rts
                    1677   ; }
                    1678   ; /************************************************************************************
                    1679   ; ** Write a byte to the SPI flash chip via the controller and returns (reads) whatever was
                    1680   ; ** given back by SPI device at the same time (removes the read byte from the FIFO)
                    1681   ; ************************************************************************************/
                    1682   ; int WriteSPIChar(int c)
                    1683   ; {
                    1684   _WriteSPIChar:
0000115E  4E56 0000 1685          link      A6,#0
00001162  2F02      1686          move.l    D2,-(A7)
                    1687   ; // todo - write the byte in parameter 'c' to the SPI data register, this will start it transmitting to the flash device
                    1688   ; // wait for completion of transmission
                    1689   ; // return the received data from Flash chip (which may not be relevent depending upon what we are doing)
                    1690   ; // by reading fom the SPI controller Data Register.
                    1691   ; // note however that in order to get data from an SPI slave device (e.g. flash) chip we have to write a dummy byte to it
                    1692   ; //
                    1693   ; // modify '0' below to return back read byte from data register
                    1694   ; //
                    1695   ; int read_data = 0; 
00001164  4282      1696          clr.l     D2
                    1697   ; SPI_Data = c; 
00001166  202E 0008 1698          move.l    8(A6),D0
0000116A  13C0 0040 1699          move.b    D0,4227108
0000116E  8024      
                    1700   ; WaitForSPITransmitComplete();
00001170  4EB8 1142 1701          jsr       _WaitForSPITransmitComplete
                    1702   ; read_data = SPI_Data;
00001174  1039 0040 1703          move.b    4227108,D0
00001178  8024      
0000117A  C0BC 0000 1704          and.l     #255,D0
0000117E  00FF      
00001180  2400      1705          move.l    D0,D2
                    1706   ; return read_data;                   
00001182  2002      1707          move.l    D2,D0
00001184  241F      1708          move.l    (A7)+,D2
00001186  4E5E      1709          unlk      A6
00001188  4E75      1710          rts
                    1711   ; }
                    1712   ; // send a command to the flash chip 
                    1713   ; void send_spi_cmd(int c){
                    1714   _send_spi_cmd:
0000118A  4E56 FFFC 1715          link      A6,#-4
                    1716   ; int read_data;
                    1717   ; Enable_SPI_CS();
0000118E  13FC 00FE 1718          move.b    #254,4227112
00001192  0040 8028 
                    1719   ; read_data = WriteSPIChar(c);
00001196  2F2E 0008 1720          move.l    8(A6),-(A7)
0000119A  4EB8 115E 1721          jsr       _WriteSPIChar
0000119E  584F      1722          addq.w    #4,A7
000011A0  2D40 FFFC 1723          move.l    D0,-4(A6)
                    1724   ; Disable_SPI_CS();
000011A4  13FC 00FF 1725          move.b    #255,4227112
000011A8  0040 8028 
000011AC  4E5E      1726          unlk      A6
000011AE  4E75      1727          rts
                    1728   ; }
                    1729   ; /*Check the flash chip's status register*/
                    1730   ; void wait_for_flash_status_done(void)
                    1731   ; {
                    1732   _wait_for_flash_status_done:
000011B0  4E56 FFFC 1733          link      A6,#-4
                    1734   ; int dummy_byte = 0x00;
000011B4  42AE FFFC 1735          clr.l     -4(A6)
                    1736   ; Enable_SPI_CS();
000011B8  13FC 00FE 1737          move.b    #254,4227112
000011BC  0040 8028 
                    1738   ; WriteSPIChar(check_status_cmd); // send the check flash status register cmd
000011C0  4878 0005 1739          pea       5
000011C4  4EB8 115E 1740          jsr       _WriteSPIChar
000011C8  584F      1741          addq.w    #4,A7
                    1742   ; while(WriteSPIChar(dummy_byte) & 0x01){
                    1743   wait_for_flash_status_done_1:
000011CA  2F2E FFFC 1744          move.l    -4(A6),-(A7)
000011CE  4EB8 115E 1745          jsr       _WriteSPIChar
000011D2  584F      1746          addq.w    #4,A7
000011D4  C0BC 0000 1747          and.l     #1,D0
000011D8  0001      
000011DA  6702      1748          beq.s     wait_for_flash_status_done_3
                    1749   ; }
000011DC  60EC      1750          bra       wait_for_flash_status_done_1
                    1751   wait_for_flash_status_done_3:
                    1752   ; Disable_SPI_CS();
000011DE  13FC 00FF 1753          move.b    #255,4227112
000011E2  0040 8028 
000011E6  4E5E      1754          unlk      A6
000011E8  4E75      1755          rts
                    1756   ; }
                    1757   ; void write_256_bytes(int spi_start_address)
                    1758   ; {
                    1759   _write_256_bytes:
000011EA  4E56 FFF4 1760          link      A6,#-12
000011EE  48E7 3020 1761          movem.l   D2/D3/A2,-(A7)
000011F2  45F8 115E 1762          lea       _WriteSPIChar.L,A2
000011F6  262E 0008 1763          move.l    8(A6),D3
                    1764   ; int i;
                    1765   ; unsigned char write_data;
                    1766   ; volatile unsigned char* current_address;
                    1767   ; volatile unsigned char* dram_start_address = (volatile unsigned char*) (start_of_dram);
000011FA  2D7C 0800 1768          move.l    #134217728,-4(A6)
000011FE  0000 FFFC 
                    1769   ; send_spi_cmd(write_enable_cmd);
00001202  4878 0006 1770          pea       6
00001206  4EB8 118A 1771          jsr       _send_spi_cmd
0000120A  584F      1772          addq.w    #4,A7
                    1773   ; Enable_SPI_CS();
0000120C  13FC 00FE 1774          move.b    #254,4227112
00001210  0040 8028 
                    1775   ; WriteSPIChar(write_cmd); // write cmd
00001214  4878 0002 1776          pea       2
00001218  4E92      1777          jsr       (A2)
0000121A  584F      1778          addq.w    #4,A7
                    1779   ; // 24 bit address, send the upper 8 bits first, then middle 8 bits, then lower 8 bits
                    1780   ; WriteSPIChar(spi_start_address >> 8); 
0000121C  2203      1781          move.l    D3,D1
0000121E  E081      1782          asr.l     #8,D1
00001220  2F01      1783          move.l    D1,-(A7)
00001222  4E92      1784          jsr       (A2)
00001224  584F      1785          addq.w    #4,A7
                    1786   ; WriteSPIChar(spi_start_address & 0xff); // make sure it's 8 bits
00001226  2203      1787          move.l    D3,D1
00001228  C2BC 0000 1788          and.l     #255,D1
0000122C  00FF      
0000122E  2F01      1789          move.l    D1,-(A7)
00001230  4E92      1790          jsr       (A2)
00001232  584F      1791          addq.w    #4,A7
                    1792   ; WriteSPIChar(0x00); // keep lower 8 bits 0 as required by flash chip's data sheet
00001234  42A7      1793          clr.l     -(A7)
00001236  4E92      1794          jsr       (A2)
00001238  584F      1795          addq.w    #4,A7
                    1796   ; for (i=0;i<256;i++){
0000123A  4282      1797          clr.l     D2
                    1798   write_256_bytes_1:
0000123C  0C82 0000 1799          cmp.l     #256,D2
00001240  0100      
00001242  6C2C      1800          bge.s     write_256_bytes_3
                    1801   ; current_address = dram_start_address + (spi_start_address << 8) + i;
00001244  202E FFFC 1802          move.l    -4(A6),D0
00001248  2203      1803          move.l    D3,D1
0000124A  E181      1804          asl.l     #8,D1
0000124C  D081      1805          add.l     D1,D0
0000124E  D082      1806          add.l     D2,D0
00001250  2D40 FFF8 1807          move.l    D0,-8(A6)
                    1808   ; write_data = *current_address; 
00001254  206E FFF8 1809          move.l    -8(A6),A0
00001258  1D50 FFF7 1810          move.b    (A0),-9(A6)
                    1811   ; WriteSPIChar((int)(write_data)); // write 256 bytes (1 page) to the flash
0000125C  122E FFF7 1812          move.b    -9(A6),D1
00001260  C2BC 0000 1813          and.l     #255,D1
00001264  00FF      
00001266  2F01      1814          move.l    D1,-(A7)
00001268  4E92      1815          jsr       (A2)
0000126A  584F      1816          addq.w    #4,A7
0000126C  5282      1817          addq.l    #1,D2
0000126E  60CC      1818          bra       write_256_bytes_1
                    1819   write_256_bytes_3:
                    1820   ; }
                    1821   ; Disable_SPI_CS();
00001270  13FC 00FF 1822          move.b    #255,4227112
00001274  0040 8028 
                    1823   ; // check if the writting is completed
                    1824   ; wait_for_flash_status_done();
00001278  4EB8 11B0 1825          jsr       _wait_for_flash_status_done
0000127C  4CDF 040C 1826          movem.l   (A7)+,D2/D3/A2
00001280  4E5E      1827          unlk      A6
00001282  4E75      1828          rts
                    1829   ; }
                    1830   ; int read_256k_bytes(void){
                    1831   _read_256k_bytes:
00001284  4E56 FFF8 1832          link      A6,#-8
00001288  48E7 3C20 1833          movem.l   D2/D3/D4/D5/A2,-(A7)
0000128C  45F8 115E 1834          lea       _WriteSPIChar.L,A2
                    1835   ; int i;
                    1836   ; unsigned char dram_data;
                    1837   ; int flash_data;
                    1838   ; int dummy_byte = 0x00;
00001290  42AE FFF8 1839          clr.l     -8(A6)
                    1840   ; volatile unsigned char* current_address;
                    1841   ; volatile unsigned char* dram_start_address = (volatile unsigned char*) (start_of_dram);
00001294  2D7C 0800 1842          move.l    #134217728,-4(A6)
00001298  0000 FFFC 
                    1843   ; Enable_SPI_CS();
0000129C  13FC 00FE 1844          move.b    #254,4227112
000012A0  0040 8028 
                    1845   ; WriteSPIChar(read_cmd); // read cmd
000012A4  4878 0003 1846          pea       3
000012A8  4E92      1847          jsr       (A2)
000012AA  584F      1848          addq.w    #4,A7
                    1849   ; WriteSPIChar(0x00); // read from 0 address of the flash
000012AC  42A7      1850          clr.l     -(A7)
000012AE  4E92      1851          jsr       (A2)
000012B0  584F      1852          addq.w    #4,A7
                    1853   ; WriteSPIChar(0x00);
000012B2  42A7      1854          clr.l     -(A7)
000012B4  4E92      1855          jsr       (A2)
000012B6  584F      1856          addq.w    #4,A7
                    1857   ; WriteSPIChar(0x00);
000012B8  42A7      1858          clr.l     -(A7)
000012BA  4E92      1859          jsr       (A2)
000012BC  584F      1860          addq.w    #4,A7
                    1861   ; // 256*1024 = 262144 
                    1862   ; for (i=0;i<262144;i++){
000012BE  4282      1863          clr.l     D2
                    1864   read_256k_bytes_1:
000012C0  0C82 0004 1865          cmp.l     #262144,D2
000012C4  0000      
000012C6  6C00 006C 1866          bge       read_256k_bytes_3
                    1867   ; current_address = dram_start_address + i;
000012CA  202E FFFC 1868          move.l    -4(A6),D0
000012CE  D082      1869          add.l     D2,D0
000012D0  2A00      1870          move.l    D0,D5
                    1871   ; dram_data = *current_address; 
000012D2  2045      1872          move.l    D5,A0
000012D4  1810      1873          move.b    (A0),D4
                    1874   ; flash_data = WriteSPIChar(dummy_byte); // read 256k bytes from the flash
000012D6  2F2E FFF8 1875          move.l    -8(A6),-(A7)
000012DA  4E92      1876          jsr       (A2)
000012DC  584F      1877          addq.w    #4,A7
000012DE  2600      1878          move.l    D0,D3
                    1879   ; if (dram_data != flash_data) {
000012E0  C8BC 0000 1880          and.l     #255,D4
000012E4  00FF      
000012E6  B883      1881          cmp.l     D3,D4
000012E8  6720      1882          beq.s     read_256k_bytes_4
                    1883   ; printf("\r\nData discrepancy at location: %x SDRAM data: %x Flash data: %x",current_address, dram_data, flash_data);
000012EA  2F03      1884          move.l    D3,-(A7)
000012EC  C8BC 0000 1885          and.l     #255,D4
000012F0  00FF      
000012F2  2F04      1886          move.l    D4,-(A7)
000012F4  2F05      1887          move.l    D5,-(A7)
000012F6  4879 0000 1888          pea       @m68kde~1_22.L
000012FA  3FA6      
000012FC  4EB9 0000 1889          jsr       _printf
00001300  3434      
00001302  DEFC 0010 1890          add.w     #16,A7
                    1891   ; return 0;
00001306  4280      1892          clr.l     D0
00001308  6034      1893          bra.s     read_256k_bytes_6
                    1894   read_256k_bytes_4:
                    1895   ; } else if (i%65536 == 0) { // if no data discrepancy, print the progress every 16^4 address
0000130A  2002      1896          move.l    D2,D0
0000130C  C0BC 0000 1897          and.l     #65535,D0
00001310  FFFF      
00001312  661C      1898          bne.s     read_256k_bytes_7
                    1899   ; printf("\r\nlocation: %x SDRAM data: %x Flash data: %x",current_address, dram_data, flash_data);
00001314  2F03      1900          move.l    D3,-(A7)
00001316  C8BC 0000 1901          and.l     #255,D4
0000131A  00FF      
0000131C  2F04      1902          move.l    D4,-(A7)
0000131E  2F05      1903          move.l    D5,-(A7)
00001320  4879 0000 1904          pea       @m68kde~1_23.L
00001324  3FE8      
00001326  4EB9 0000 1905          jsr       _printf
0000132A  3434      
0000132C  DEFC 0010 1906          add.w     #16,A7
                    1907   read_256k_bytes_7:
00001330  5282      1908          addq.l    #1,D2
00001332  608C      1909          bra       read_256k_bytes_1
                    1910   read_256k_bytes_3:
                    1911   ; } 
                    1912   ; }
                    1913   ; Disable_SPI_CS();
00001334  13FC 00FF 1914          move.b    #255,4227112
00001338  0040 8028 
                    1915   ; return 1;
0000133C  7001      1916          moveq     #1,D0
                    1917   read_256k_bytes_6:
0000133E  4CDF 043C 1918          movem.l   (A7)+,D2/D3/D4/D5/A2
00001342  4E5E      1919          unlk      A6
00001344  4E75      1920          rts
                    1921   ; }
                    1922   ; void load_sdram_from_spi_flash(void){
                    1923   _load_sdram_from_spi_flash:
00001346  4E56 FFF0 1924          link      A6,#-16
0000134A  48E7 2020 1925          movem.l   D2/A2,-(A7)
0000134E  45F8 115E 1926          lea       _WriteSPIChar.L,A2
                    1927   ; int i;
                    1928   ; int dummy_byte = 0x00;
00001352  42AE FFF0 1929          clr.l     -16(A6)
                    1930   ; int data;
                    1931   ; volatile unsigned char* current_address;
                    1932   ; volatile unsigned char* dram_start_address = (volatile unsigned char*) (start_of_dram);
00001356  2D7C 0800 1933          move.l    #134217728,-4(A6)
0000135A  0000 FFFC 
                    1934   ; Enable_SPI_CS();
0000135E  13FC 00FE 1935          move.b    #254,4227112
00001362  0040 8028 
                    1936   ; WriteSPIChar(read_cmd); // read cmd
00001366  4878 0003 1937          pea       3
0000136A  4E92      1938          jsr       (A2)
0000136C  584F      1939          addq.w    #4,A7
                    1940   ; WriteSPIChar(0x00); // read from 0 address of the flash
0000136E  42A7      1941          clr.l     -(A7)
00001370  4E92      1942          jsr       (A2)
00001372  584F      1943          addq.w    #4,A7
                    1944   ; WriteSPIChar(0x00);
00001374  42A7      1945          clr.l     -(A7)
00001376  4E92      1946          jsr       (A2)
00001378  584F      1947          addq.w    #4,A7
                    1948   ; WriteSPIChar(0x00);
0000137A  42A7      1949          clr.l     -(A7)
0000137C  4E92      1950          jsr       (A2)
0000137E  584F      1951          addq.w    #4,A7
                    1952   ; // 256*1024 = 262144 
                    1953   ; for (i=0;i<262144;i++){
00001380  4282      1954          clr.l     D2
                    1955   load_sdram_from_spi_flash_1:
00001382  0C82 0004 1956          cmp.l     #262144,D2
00001386  0000      
00001388  6C24      1957          bge.s     load_sdram_from_spi_flash_3
                    1958   ; current_address = dram_start_address + i; 
0000138A  202E FFFC 1959          move.l    -4(A6),D0
0000138E  D082      1960          add.l     D2,D0
00001390  2D40 FFF8 1961          move.l    D0,-8(A6)
                    1962   ; data = WriteSPIChar(dummy_byte); // read a byte from spi flash and write to sdram
00001394  2F2E FFF0 1963          move.l    -16(A6),-(A7)
00001398  4E92      1964          jsr       (A2)
0000139A  584F      1965          addq.w    #4,A7
0000139C  2D40 FFF4 1966          move.l    D0,-12(A6)
                    1967   ; //printf("\r\nread from SPI flash: %x", data);
                    1968   ; *current_address =  data;
000013A0  202E FFF4 1969          move.l    -12(A6),D0
000013A4  206E FFF8 1970          move.l    -8(A6),A0
000013A8  1080      1971          move.b    D0,(A0)
000013AA  5282      1972          addq.l    #1,D2
000013AC  60D4      1973          bra       load_sdram_from_spi_flash_1
                    1974   load_sdram_from_spi_flash_3:
                    1975   ; //printf("\r\nread from dram: %x", *current_address);
                    1976   ; }
                    1977   ; Disable_SPI_CS();
000013AE  13FC 00FF 1978          move.b    #255,4227112
000013B2  0040 8028 
000013B6  4CDF 0404 1979          movem.l   (A7)+,D2/A2
000013BA  4E5E      1980          unlk      A6
000013BC  4E75      1981          rts
                    1982   ; }
                    1983   ; /*******************************************************************
                    1984   ; ** Write a program to SPI Flash Chip from memory and verify by reading back
                    1985   ; ********************************************************************/
                    1986   ; void ProgramFlashChip(void)
                    1987   ; {
                    1988   _ProgramFlashChip:
000013BE  4E56 FFE4 1989          link      A6,#-28
000013C2  48E7 2020 1990          movem.l   D2/A2,-(A7)
000013C6  45F9 0000 1991          lea       _printf.L,A2
000013CA  3434      
                    1992   ; //
                    1993   ; // TODO : put your code here to program the 1st 256k of ram (where user program is held at hex 08000000) to SPI flash chip
                    1994   ; // TODO : then verify by reading it back and comparing to memory
                    1995   ; //
                    1996   ; int read_data; 
                    1997   ; int dummy_byte = 0x00;
000013CC  42AE FFEA 1998          clr.l     -22(A6)
                    1999   ; int i, j; 
                    2000   ; volatile unsigned char* current_address;
                    2001   ; volatile unsigned char* dram_start_address = (volatile unsigned char*) (start_of_dram);
000013D0  2D7C 0800 2002          move.l    #134217728,-6(A6)
000013D4  0000 FFFA 
                    2003   ; int address_counter;
                    2004   ; unsigned char write_data;
                    2005   ; SPI_Init(); // initialise the SPI controller
000013D8  4EB8 1122 2006          jsr       _SPI_Init
                    2007   ; // send write enble command to the flash chip
                    2008   ; send_spi_cmd(write_enable_cmd);
000013DC  4878 0006 2009          pea       6
000013E0  4EB8 118A 2010          jsr       _send_spi_cmd
000013E4  584F      2011          addq.w    #4,A7
                    2012   ; // erasing the flash chip
                    2013   ; printf("\r\nErasing SPI flash....");
000013E6  4879 0000 2014          pea       @m68kde~1_24.L
000013EA  4016      
000013EC  4E92      2015          jsr       (A2)
000013EE  584F      2016          addq.w    #4,A7
                    2017   ; send_spi_cmd(erasing_cmd);
000013F0  4878 00C7 2018          pea       199
000013F4  4EB8 118A 2019          jsr       _send_spi_cmd
000013F8  584F      2020          addq.w    #4,A7
                    2021   ; // check if the erasing is completed
                    2022   ; wait_for_flash_status_done();
000013FA  4EB8 11B0 2023          jsr       _wait_for_flash_status_done
                    2024   ; // send write enble command to the flash chip
                    2025   ; // write
                    2026   ; printf("\r\nWritting the SPI flash using SDRAM data....");
000013FE  4879 0000 2027          pea       @m68kde~1_25.L
00001402  402E      
00001404  4E92      2028          jsr       (A2)
00001406  584F      2029          addq.w    #4,A7
                    2030   ; for (address_counter=0; address_counter<1024; address_counter++) {
00001408  4282      2031          clr.l     D2
                    2032   ProgramFlashChip_1:
0000140A  0C82 0000 2033          cmp.l     #1024,D2
0000140E  0400      
00001410  6C0C      2034          bge.s     ProgramFlashChip_3
                    2035   ; write_256_bytes(address_counter);
00001412  2F02      2036          move.l    D2,-(A7)
00001414  4EB8 11EA 2037          jsr       _write_256_bytes
00001418  584F      2038          addq.w    #4,A7
0000141A  5282      2039          addq.l    #1,D2
0000141C  60EC      2040          bra       ProgramFlashChip_1
                    2041   ProgramFlashChip_3:
                    2042   ; } 
                    2043   ; // TO DO: write a read program similar to the write program, print results every 16^4 address
                    2044   ; printf("\r\nReading the SPI flash data and comparing to SDRAM....") ;
0000141E  4879 0000 2045          pea       @m68kde~1_26.L
00001422  405C      
00001424  4E92      2046          jsr       (A2)
00001426  584F      2047          addq.w    #4,A7
                    2048   ; read_256k_bytes();
00001428  4EB8 1284 2049          jsr       _read_256k_bytes
0000142C  4CDF 0404 2050          movem.l   (A7)+,D2/A2
00001430  4E5E      2051          unlk      A6
00001432  4E75      2052          rts
                    2053   ; }
                    2054   ; /*************************************************************************
                    2055   ; ** Load a program from SPI Flash Chip and copy to Dram
                    2056   ; **************************************************************************/
                    2057   ; void LoadFromFlashChip(void)
                    2058   ; {
                    2059   _LoadFromFlashChip:
                    2060   ; printf("\r\nLoading Program From SPI Flash....") ;
00001434  4879 0000 2061          pea       @m68kde~1_27.L
00001438  4094      
0000143A  4EB9 0000 2062          jsr       _printf
0000143E  3434      
00001440  584F      2063          addq.w    #4,A7
                    2064   ; SPI_Init(); // initialise the SPI controller
00001442  4EB8 1122 2065          jsr       _SPI_Init
                    2066   ; load_sdram_from_spi_flash(); 
00001446  4EB8 1346 2067          jsr       _load_sdram_from_spi_flash
0000144A  4E75      2068          rts
                    2069   ; //
                    2070   ; // TODO : put your code here to read 256k of data from SPI flash chip and store in user ram starting at hex 08000000
                    2071   ; //
                    2072   ; }
                    2073   ; //////////////////////////////////////////////////////////////////////////////////////////////////
                    2074   ; // IMPORTANT
                    2075   ; // TG68 does not support the Native Trace mode of the original 68000 so tracing
                    2076   ; // has to be done with an interrupt (IRQ Level 6)
                    2077   ; //
                    2078   ; // To allow the 68000 to execute one more instruction after each pseudo trace (IRQ6)
                    2079   ; // the IRQ is removed in hardware once the TG68 reads the IRQ autovector (i.e. acknowledges the IRQ)
                    2080   ; //
                    2081   ; // on return from the IRQ service handler, the first access to the user memory program space
                    2082   ; // generates a fresh IRQ (in hardware) to generate a new trace, this allows the tg68 to
                    2083   ; // execute one more new instruction (without it the TG68 would trace on the same instruction
                    2084   ; // each time and not after the next one). It also means it doesn't simgle step outside the user
                    2085   ; // program area
                    2086   ; //
                    2087   ; // The bottom line is the Trace handler, which includes the Dump registers below
                    2088   ; // cannot access the user memory to display for example the Instruction Opcode or to disassemble etc
                    2089   ; // as this would lead to a new IRQ being reset and the TG68 would trace on same instruction
                    2090   ; // NOT SURE THIS IS TRUE NOW THAT TRACE HANDLER HAS BEEN MODIVIED TO NOT AUTOMATICALLY GENERATE A TRACE EXCEPTION
                    2091   ; // INSTEAD IT IS DONE IN THE 'N' COMMAND FOR NEXT
                    2092   ; /////////////////////////////////////////////////////////////////////////////////////////////////////
                    2093   ; void DumpRegisters()
                    2094   ; {
                    2095   _DumpRegisters:
0000144C  48E7 3F3C 2096          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00001450  45F9 0000 2097          lea       _putch.L,A2
00001454  3326      
00001456  47F9 0000 2098          lea       _printf.L,A3
0000145A  3434      
0000145C  49F9 0B00 2099          lea       _SR.L,A4
00001460  012C      
00001462  4BF9 0B00 2100          lea       _WatchPointString.L,A5
00001466  01C2      
                    2101   ; short i, x, j, k ;
                    2102   ; unsigned char c, *BytePointer;
                    2103   ; // buld up strings for displaying watchpoints
                    2104   ; for(x = 0; x < (short)(8); x++)
00001468  4242      2105          clr.w     D2
                    2106   DumpRegisters_1:
0000146A  0C42 0008 2107          cmp.w     #8,D2
0000146E  6C00 01C6 2108          bge       DumpRegisters_3
                    2109   ; {
                    2110   ; if(WatchPointSetOrCleared[x] == 1)
00001472  48C2      2111          ext.l     D2
00001474  2002      2112          move.l    D2,D0
00001476  E588      2113          lsl.l     #2,D0
00001478  41F9 0B00 2114          lea       _WatchPointSetOrCleared.L,A0
0000147C  01A2      
0000147E  2030 0800 2115          move.l    0(A0,D0.L),D0
00001482  0C80 0000 2116          cmp.l     #1,D0
00001486  0001      
00001488  6600 0186 2117          bne       DumpRegisters_4
                    2118   ; {
                    2119   ; sprintf(WatchPointString[x], "$%08X  ", WatchPointAddress[x]) ;
0000148C  48C2      2120          ext.l     D2
0000148E  2202      2121          move.l    D2,D1
00001490  E589      2122          lsl.l     #2,D1
00001492  41F9 0B00 2123          lea       _WatchPointAddress.L,A0
00001496  0182      
00001498  2F30 1800 2124          move.l    0(A0,D1.L),-(A7)
0000149C  4879 0000 2125          pea       @m68kde~1_28.L
000014A0  40BA      
000014A2  220D      2126          move.l    A5,D1
000014A4  48C2      2127          ext.l     D2
000014A6  2F00      2128          move.l    D0,-(A7)
000014A8  2002      2129          move.l    D2,D0
000014AA  C1FC 0064 2130          muls      #100,D0
000014AE  D280      2131          add.l     D0,D1
000014B0  201F      2132          move.l    (A7)+,D0
000014B2  2F01      2133          move.l    D1,-(A7)
000014B4  4EB9 0000 2134          jsr       _sprintf
000014B8  33BE      
000014BA  DEFC 000C 2135          add.w     #12,A7
                    2136   ; BytePointer = (char *)(WatchPointAddress[x]) ;
000014BE  48C2      2137          ext.l     D2
000014C0  2002      2138          move.l    D2,D0
000014C2  E588      2139          lsl.l     #2,D0
000014C4  41F9 0B00 2140          lea       _WatchPointAddress.L,A0
000014C8  0182      
000014CA  2A30 0800 2141          move.l    0(A0,D0.L),D5
                    2142   ; for(j = 0; j < (short)(16); j+=2)
000014CE  4243      2143          clr.w     D3
                    2144   DumpRegisters_6:
000014D0  0C43 0010 2145          cmp.w     #16,D3
000014D4  6C00 0082 2146          bge       DumpRegisters_8
                    2147   ; {
                    2148   ; for(k = 0; k < (short)(2); k++)
000014D8  4246      2149          clr.w     D6
                    2150   DumpRegisters_9:
000014DA  0C46 0002 2151          cmp.w     #2,D6
000014DE  6C00 0052 2152          bge       DumpRegisters_11
                    2153   ; {
                    2154   ; sprintf(TempString, "%02X", BytePointer[j+k]) ;
000014E2  2045      2155          move.l    D5,A0
000014E4  48C3      2156          ext.l     D3
000014E6  2203      2157          move.l    D3,D1
000014E8  48C6      2158          ext.l     D6
000014EA  D286      2159          add.l     D6,D1
000014EC  1230 1800 2160          move.b    0(A0,D1.L),D1
000014F0  C2BC 0000 2161          and.l     #255,D1
000014F4  00FF      
000014F6  2F01      2162          move.l    D1,-(A7)
000014F8  4879 0000 2163          pea       @m68kde~1_8.L
000014FC  3DFC      
000014FE  4879 0B00 2164          pea       _TempString.L
00001502  04E2      
00001504  4EB9 0000 2165          jsr       _sprintf
00001508  33BE      
0000150A  DEFC 000C 2166          add.w     #12,A7
                    2167   ; strcat(WatchPointString[x], TempString) ;
0000150E  4879 0B00 2168          pea       _TempString.L
00001512  04E2      
00001514  220D      2169          move.l    A5,D1
00001516  48C2      2170          ext.l     D2
00001518  2F00      2171          move.l    D0,-(A7)
0000151A  2002      2172          move.l    D2,D0
0000151C  C1FC 0064 2173          muls      #100,D0
00001520  D280      2174          add.l     D0,D1
00001522  201F      2175          move.l    (A7)+,D0
00001524  2F01      2176          move.l    D1,-(A7)
00001526  4EB9 0000 2177          jsr       _strcat
0000152A  33F2      
0000152C  504F      2178          addq.w    #8,A7
0000152E  5246      2179          addq.w    #1,D6
00001530  60A8      2180          bra       DumpRegisters_9
                    2181   DumpRegisters_11:
                    2182   ; }
                    2183   ; strcat(WatchPointString[x]," ") ;
00001532  4879 0000 2184          pea       @m68kde~1_29.L
00001536  40C2      
00001538  220D      2185          move.l    A5,D1
0000153A  48C2      2186          ext.l     D2
0000153C  2F00      2187          move.l    D0,-(A7)
0000153E  2002      2188          move.l    D2,D0
00001540  C1FC 0064 2189          muls      #100,D0
00001544  D280      2190          add.l     D0,D1
00001546  201F      2191          move.l    (A7)+,D0
00001548  2F01      2192          move.l    D1,-(A7)
0000154A  4EB9 0000 2193          jsr       _strcat
0000154E  33F2      
00001550  504F      2194          addq.w    #8,A7
00001552  5443      2195          addq.w    #2,D3
00001554  6000 FF7A 2196          bra       DumpRegisters_6
                    2197   DumpRegisters_8:
                    2198   ; }
                    2199   ; strcat(WatchPointString[x], "  ") ;
00001558  4879 0000 2200          pea       @m68kde~1_9.L
0000155C  3E02      
0000155E  220D      2201          move.l    A5,D1
00001560  48C2      2202          ext.l     D2
00001562  2F00      2203          move.l    D0,-(A7)
00001564  2002      2204          move.l    D2,D0
00001566  C1FC 0064 2205          muls      #100,D0
0000156A  D280      2206          add.l     D0,D1
0000156C  201F      2207          move.l    (A7)+,D0
0000156E  2F01      2208          move.l    D1,-(A7)
00001570  4EB9 0000 2209          jsr       _strcat
00001574  33F2      
00001576  504F      2210          addq.w    #8,A7
                    2211   ; BytePointer = (char *)(WatchPointAddress[x]) ;
00001578  48C2      2212          ext.l     D2
0000157A  2002      2213          move.l    D2,D0
0000157C  E588      2214          lsl.l     #2,D0
0000157E  41F9 0B00 2215          lea       _WatchPointAddress.L,A0
00001582  0182      
00001584  2A30 0800 2216          move.l    0(A0,D0.L),D5
                    2217   ; for(j = 0; j < (short)(16); j++)
00001588  4243      2218          clr.w     D3
                    2219   DumpRegisters_12:
0000158A  0C43 0010 2220          cmp.w     #16,D3
0000158E  6C00 007E 2221          bge       DumpRegisters_14
                    2222   ; {
                    2223   ; c = ((char)(BytePointer[j]) & 0x7f) ;
00001592  2045      2224          move.l    D5,A0
00001594  48C3      2225          ext.l     D3
00001596  1030 3800 2226          move.b    0(A0,D3.L),D0
0000159A  C03C 007F 2227          and.b     #127,D0
0000159E  1E00      2228          move.b    D0,D7
                    2229   ; if((c > (char)(0x7f)) || (c < (char)(' ')))
000015A0  0C07 007F 2230          cmp.b     #127,D7
000015A4  6206      2231          bhi.s     DumpRegisters_17
000015A6  0C07 0020 2232          cmp.b     #32,D7
000015AA  6416      2233          bhs.s     DumpRegisters_15
                    2234   DumpRegisters_17:
                    2235   ; sprintf(TempString, ".") ;
000015AC  4879 0000 2236          pea       @m68kde~1_30.L
000015B0  40C4      
000015B2  4879 0B00 2237          pea       _TempString.L
000015B6  04E2      
000015B8  4EB9 0000 2238          jsr       _sprintf
000015BC  33BE      
000015BE  504F      2239          addq.w    #8,A7
000015C0  6026      2240          bra.s     DumpRegisters_16
                    2241   DumpRegisters_15:
                    2242   ; else
                    2243   ; sprintf(TempString, "%c", BytePointer[j]) ;
000015C2  2045      2244          move.l    D5,A0
000015C4  48C3      2245          ext.l     D3
000015C6  1230 3800 2246          move.b    0(A0,D3.L),D1
000015CA  C2BC 0000 2247          and.l     #255,D1
000015CE  00FF      
000015D0  2F01      2248          move.l    D1,-(A7)
000015D2  4879 0000 2249          pea       @m68kde~1_31.L
000015D6  40C6      
000015D8  4879 0B00 2250          pea       _TempString.L
000015DC  04E2      
000015DE  4EB9 0000 2251          jsr       _sprintf
000015E2  33BE      
000015E4  DEFC 000C 2252          add.w     #12,A7
                    2253   DumpRegisters_16:
                    2254   ; strcat(WatchPointString[x], TempString) ;
000015E8  4879 0B00 2255          pea       _TempString.L
000015EC  04E2      
000015EE  220D      2256          move.l    A5,D1
000015F0  48C2      2257          ext.l     D2
000015F2  2F00      2258          move.l    D0,-(A7)
000015F4  2002      2259          move.l    D2,D0
000015F6  C1FC 0064 2260          muls      #100,D0
000015FA  D280      2261          add.l     D0,D1
000015FC  201F      2262          move.l    (A7)+,D0
000015FE  2F01      2263          move.l    D1,-(A7)
00001600  4EB9 0000 2264          jsr       _strcat
00001604  33F2      
00001606  504F      2265          addq.w    #8,A7
00001608  5243      2266          addq.w    #1,D3
0000160A  6000 FF7E 2267          bra       DumpRegisters_12
                    2268   DumpRegisters_14:
0000160E  6020      2269          bra.s     DumpRegisters_5
                    2270   DumpRegisters_4:
                    2271   ; }
                    2272   ; }
                    2273   ; else
                    2274   ; strcpy(WatchPointString[x], "") ;
00001610  4879 0000 2275          pea       @m68kde~1_32.L
00001614  40CA      
00001616  220D      2276          move.l    A5,D1
00001618  48C2      2277          ext.l     D2
0000161A  2F00      2278          move.l    D0,-(A7)
0000161C  2002      2279          move.l    D2,D0
0000161E  C1FC 0064 2280          muls      #100,D0
00001622  D280      2281          add.l     D0,D1
00001624  201F      2282          move.l    (A7)+,D0
00001626  2F01      2283          move.l    D1,-(A7)
00001628  4EB9 0000 2284          jsr       _strcpy
0000162C  3238      
0000162E  504F      2285          addq.w    #8,A7
                    2286   DumpRegisters_5:
00001630  5242      2287          addq.w    #1,D2
00001632  6000 FE36 2288          bra       DumpRegisters_1
                    2289   DumpRegisters_3:
                    2290   ; }
                    2291   ; printf("\r\n\r\n D0 = $%08X  A0 = $%08X",d0,a0) ;
00001636  2F39 0B00 2292          move.l    _a0.L,-(A7)
0000163A  0104      
0000163C  2F39 0B00 2293          move.l    _d0.L,-(A7)
00001640  00E4      
00001642  4879 0000 2294          pea       @m68kde~1_33.L
00001646  40CC      
00001648  4E93      2295          jsr       (A3)
0000164A  DEFC 000C 2296          add.w     #12,A7
                    2297   ; printf("\r\n D1 = $%08X  A1 = $%08X",d1,a1) ;
0000164E  2F39 0B00 2298          move.l    _a1.L,-(A7)
00001652  0108      
00001654  2F39 0B00 2299          move.l    _d1.L,-(A7)
00001658  00E8      
0000165A  4879 0000 2300          pea       @m68kde~1_34.L
0000165E  40E8      
00001660  4E93      2301          jsr       (A3)
00001662  DEFC 000C 2302          add.w     #12,A7
                    2303   ; printf("\r\n D2 = $%08X  A2 = $%08X",d2,a2) ;
00001666  2F39 0B00 2304          move.l    _a2.L,-(A7)
0000166A  010C      
0000166C  2F39 0B00 2305          move.l    _d2.L,-(A7)
00001670  00EC      
00001672  4879 0000 2306          pea       @m68kde~1_35.L
00001676  4102      
00001678  4E93      2307          jsr       (A3)
0000167A  DEFC 000C 2308          add.w     #12,A7
                    2309   ; printf("\r\n D3 = $%08X  A3 = $%08X",d3,a3) ;
0000167E  2F39 0B00 2310          move.l    _a3.L,-(A7)
00001682  0110      
00001684  2F39 0B00 2311          move.l    _d3.L,-(A7)
00001688  00F0      
0000168A  4879 0000 2312          pea       @m68kde~1_36.L
0000168E  411C      
00001690  4E93      2313          jsr       (A3)
00001692  DEFC 000C 2314          add.w     #12,A7
                    2315   ; printf("\r\n D4 = $%08X  A4 = $%08X",d4,a4) ;
00001696  2F39 0B00 2316          move.l    _a4.L,-(A7)
0000169A  0114      
0000169C  2F39 0B00 2317          move.l    _d4.L,-(A7)
000016A0  00F4      
000016A2  4879 0000 2318          pea       @m68kde~1_37.L
000016A6  4136      
000016A8  4E93      2319          jsr       (A3)
000016AA  DEFC 000C 2320          add.w     #12,A7
                    2321   ; printf("\r\n D5 = $%08X  A5 = $%08X",d5,a5) ;
000016AE  2F39 0B00 2322          move.l    _a5.L,-(A7)
000016B2  0118      
000016B4  2F39 0B00 2323          move.l    _d5.L,-(A7)
000016B8  00F8      
000016BA  4879 0000 2324          pea       @m68kde~1_38.L
000016BE  4150      
000016C0  4E93      2325          jsr       (A3)
000016C2  DEFC 000C 2326          add.w     #12,A7
                    2327   ; printf("\r\n D6 = $%08X  A6 = $%08X",d6,a6) ;
000016C6  2F39 0B00 2328          move.l    _a6.L,-(A7)
000016CA  011C      
000016CC  2F39 0B00 2329          move.l    _d6.L,-(A7)
000016D0  00FC      
000016D2  4879 0000 2330          pea       @m68kde~1_39.L
000016D6  416A      
000016D8  4E93      2331          jsr       (A3)
000016DA  DEFC 000C 2332          add.w     #12,A7
                    2333   ; printf("\r\n D7 = $%08X  A7 = $%08X",d7,((SR & (unsigned short int)(0x2000)) == ((unsigned short int)(0x2000))) ? SSP : USP) ;
000016DE  3214      2334          move.w    (A4),D1
000016E0  C27C 2000 2335          and.w     #8192,D1
000016E4  0C41 2000 2336          cmp.w     #8192,D1
000016E8  6608      2337          bne.s     DumpRegisters_18
000016EA  2239 0B00 2338          move.l    _SSP.L,D1
000016EE  0124      
000016F0  6006      2339          bra.s     DumpRegisters_19
                    2340   DumpRegisters_18:
000016F2  2239 0B00 2341          move.l    _USP.L,D1
000016F6  0128      
                    2342   DumpRegisters_19:
000016F8  2F01      2343          move.l    D1,-(A7)
000016FA  2F39 0B00 2344          move.l    _d7.L,-(A7)
000016FE  0100      
00001700  4879 0000 2345          pea       @m68kde~1_40.L
00001704  4184      
00001706  4E93      2346          jsr       (A3)
00001708  DEFC 000C 2347          add.w     #12,A7
                    2348   ; printf("\r\n\r\nUSP = $%08X  (A7) User SP", USP ) ;
0000170C  2F39 0B00 2349          move.l    _USP.L,-(A7)
00001710  0128      
00001712  4879 0000 2350          pea       @m68kde~1_41.L
00001716  419E      
00001718  4E93      2351          jsr       (A3)
0000171A  504F      2352          addq.w    #8,A7
                    2353   ; printf("\r\nSSP = $%08X  (A7) Supervisor SP", SSP) ;
0000171C  2F39 0B00 2354          move.l    _SSP.L,-(A7)
00001720  0124      
00001722  4879 0000 2355          pea       @m68kde~1_42.L
00001726  41BC      
00001728  4E93      2356          jsr       (A3)
0000172A  504F      2357          addq.w    #8,A7
                    2358   ; printf("\r\n SR = $%04X   ",SR) ;
0000172C  3214      2359          move.w    (A4),D1
0000172E  C2BC 0000 2360          and.l     #65535,D1
00001732  FFFF      
00001734  2F01      2361          move.l    D1,-(A7)
00001736  4879 0000 2362          pea       @m68kde~1_43.L
0000173A  41DE      
0000173C  4E93      2363          jsr       (A3)
0000173E  504F      2364          addq.w    #8,A7
                    2365   ; // display the status word in characters etc.
                    2366   ; printf("   [") ;
00001740  4879 0000 2367          pea       @m68kde~1_44.L
00001744  41F0      
00001746  4E93      2368          jsr       (A3)
00001748  584F      2369          addq.w    #4,A7
                    2370   ; if((SR & (unsigned short int)(0x8000)) == (unsigned short int)(0x8000)) putchar('T') ; else putchar('-') ;      // Trace bit(bit 15)
0000174A  3014      2371          move.w    (A4),D0
0000174C  C07C 8000 2372          and.w     #32768,D0
00001750  0C40 8000 2373          cmp.w     #32768,D0
00001754  660A      2374          bne.s     DumpRegisters_20
00001756  4878 0054 2375          pea       84
0000175A  4E92      2376          jsr       (A2)
0000175C  584F      2377          addq.w    #4,A7
0000175E  6008      2378          bra.s     DumpRegisters_21
                    2379   DumpRegisters_20:
00001760  4878 002D 2380          pea       45
00001764  4E92      2381          jsr       (A2)
00001766  584F      2382          addq.w    #4,A7
                    2383   DumpRegisters_21:
                    2384   ; if((SR & (unsigned short int)(0x2000)) == (unsigned short int)(0x2000)) putchar('S') ; else putchar('U') ;      // supervisor bit  (bit 13)
00001768  3014      2385          move.w    (A4),D0
0000176A  C07C 2000 2386          and.w     #8192,D0
0000176E  0C40 2000 2387          cmp.w     #8192,D0
00001772  660A      2388          bne.s     DumpRegisters_22
00001774  4878 0053 2389          pea       83
00001778  4E92      2390          jsr       (A2)
0000177A  584F      2391          addq.w    #4,A7
0000177C  6008      2392          bra.s     DumpRegisters_23
                    2393   DumpRegisters_22:
0000177E  4878 0055 2394          pea       85
00001782  4E92      2395          jsr       (A2)
00001784  584F      2396          addq.w    #4,A7
                    2397   DumpRegisters_23:
                    2398   ; if((SR & (unsigned short int)(0x0400)) == (unsigned short int)(0x0400)) putchar('1') ; else putchar('0') ;      // IRQ2 Bit (bit 10)
00001786  3014      2399          move.w    (A4),D0
00001788  C07C 0400 2400          and.w     #1024,D0
0000178C  0C40 0400 2401          cmp.w     #1024,D0
00001790  660A      2402          bne.s     DumpRegisters_24
00001792  4878 0031 2403          pea       49
00001796  4E92      2404          jsr       (A2)
00001798  584F      2405          addq.w    #4,A7
0000179A  6008      2406          bra.s     DumpRegisters_25
                    2407   DumpRegisters_24:
0000179C  4878 0030 2408          pea       48
000017A0  4E92      2409          jsr       (A2)
000017A2  584F      2410          addq.w    #4,A7
                    2411   DumpRegisters_25:
                    2412   ; if((SR & (unsigned short int)(0x0200)) == (unsigned short int)(0x0200)) putchar('1') ; else putchar('0') ;      // IRQ1 Bit (bit 9)
000017A4  3014      2413          move.w    (A4),D0
000017A6  C07C 0200 2414          and.w     #512,D0
000017AA  0C40 0200 2415          cmp.w     #512,D0
000017AE  660A      2416          bne.s     DumpRegisters_26
000017B0  4878 0031 2417          pea       49
000017B4  4E92      2418          jsr       (A2)
000017B6  584F      2419          addq.w    #4,A7
000017B8  6008      2420          bra.s     DumpRegisters_27
                    2421   DumpRegisters_26:
000017BA  4878 0030 2422          pea       48
000017BE  4E92      2423          jsr       (A2)
000017C0  584F      2424          addq.w    #4,A7
                    2425   DumpRegisters_27:
                    2426   ; if((SR & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100)) putchar('1') ; else putchar('0') ;      // IRQ0 Bit (bit 8)
000017C2  3014      2427          move.w    (A4),D0
000017C4  C07C 0100 2428          and.w     #256,D0
000017C8  0C40 0100 2429          cmp.w     #256,D0
000017CC  660A      2430          bne.s     DumpRegisters_28
000017CE  4878 0031 2431          pea       49
000017D2  4E92      2432          jsr       (A2)
000017D4  584F      2433          addq.w    #4,A7
000017D6  6008      2434          bra.s     DumpRegisters_29
                    2435   DumpRegisters_28:
000017D8  4878 0030 2436          pea       48
000017DC  4E92      2437          jsr       (A2)
000017DE  584F      2438          addq.w    #4,A7
                    2439   DumpRegisters_29:
                    2440   ; if((SR & (unsigned short int)(0x0010)) == (unsigned short int)(0x0010)) putchar('X') ; else putchar('-') ;      // X Bit (bit 4)
000017E0  3014      2441          move.w    (A4),D0
000017E2  C07C 0010 2442          and.w     #16,D0
000017E6  0C40 0010 2443          cmp.w     #16,D0
000017EA  660A      2444          bne.s     DumpRegisters_30
000017EC  4878 0058 2445          pea       88
000017F0  4E92      2446          jsr       (A2)
000017F2  584F      2447          addq.w    #4,A7
000017F4  6008      2448          bra.s     DumpRegisters_31
                    2449   DumpRegisters_30:
000017F6  4878 002D 2450          pea       45
000017FA  4E92      2451          jsr       (A2)
000017FC  584F      2452          addq.w    #4,A7
                    2453   DumpRegisters_31:
                    2454   ; if((SR & (unsigned short int)(0x0008)) == (unsigned short int)(0x0008)) putchar('N') ; else putchar('-') ;      // N Bit (bit 3)
000017FE  3014      2455          move.w    (A4),D0
00001800  C07C 0008 2456          and.w     #8,D0
00001804  0C40 0008 2457          cmp.w     #8,D0
00001808  660A      2458          bne.s     DumpRegisters_32
0000180A  4878 004E 2459          pea       78
0000180E  4E92      2460          jsr       (A2)
00001810  584F      2461          addq.w    #4,A7
00001812  6008      2462          bra.s     DumpRegisters_33
                    2463   DumpRegisters_32:
00001814  4878 002D 2464          pea       45
00001818  4E92      2465          jsr       (A2)
0000181A  584F      2466          addq.w    #4,A7
                    2467   DumpRegisters_33:
                    2468   ; if((SR & (unsigned short int)(0x0004)) == (unsigned short int)(0x0004)) putchar('Z') ; else putchar('-') ;      // Z Bit (bit 2)
0000181C  3014      2469          move.w    (A4),D0
0000181E  C07C 0004 2470          and.w     #4,D0
00001822  0C40 0004 2471          cmp.w     #4,D0
00001826  660A      2472          bne.s     DumpRegisters_34
00001828  4878 005A 2473          pea       90
0000182C  4E92      2474          jsr       (A2)
0000182E  584F      2475          addq.w    #4,A7
00001830  6008      2476          bra.s     DumpRegisters_35
                    2477   DumpRegisters_34:
00001832  4878 002D 2478          pea       45
00001836  4E92      2479          jsr       (A2)
00001838  584F      2480          addq.w    #4,A7
                    2481   DumpRegisters_35:
                    2482   ; if((SR & (unsigned short int)(0x0002)) == (unsigned short int)(0x0002)) putchar('V') ; else putchar('-') ;      // V Bit (bit 1)
0000183A  3014      2483          move.w    (A4),D0
0000183C  C07C 0002 2484          and.w     #2,D0
00001840  0C40 0002 2485          cmp.w     #2,D0
00001844  660A      2486          bne.s     DumpRegisters_36
00001846  4878 0056 2487          pea       86
0000184A  4E92      2488          jsr       (A2)
0000184C  584F      2489          addq.w    #4,A7
0000184E  6008      2490          bra.s     DumpRegisters_37
                    2491   DumpRegisters_36:
00001850  4878 002D 2492          pea       45
00001854  4E92      2493          jsr       (A2)
00001856  584F      2494          addq.w    #4,A7
                    2495   DumpRegisters_37:
                    2496   ; if((SR & (unsigned short int)(0x0001)) == (unsigned short int)(0x0001)) putchar('C') ; else putchar('-') ;      // C Bit (bit 0)
00001858  3014      2497          move.w    (A4),D0
0000185A  C07C 0001 2498          and.w     #1,D0
0000185E  0C40 0001 2499          cmp.w     #1,D0
00001862  660A      2500          bne.s     DumpRegisters_38
00001864  4878 0043 2501          pea       67
00001868  4E92      2502          jsr       (A2)
0000186A  584F      2503          addq.w    #4,A7
0000186C  6008      2504          bra.s     DumpRegisters_39
                    2505   DumpRegisters_38:
0000186E  4878 002D 2506          pea       45
00001872  4E92      2507          jsr       (A2)
00001874  584F      2508          addq.w    #4,A7
                    2509   DumpRegisters_39:
                    2510   ; putchar(']') ;
00001876  4878 005D 2511          pea       93
0000187A  4E92      2512          jsr       (A2)
0000187C  584F      2513          addq.w    #4,A7
                    2514   ; printf("\r\n PC = $%08X  ", PC) ;
0000187E  2F39 0B00 2515          move.l    _PC.L,-(A7)
00001882  0120      
00001884  4879 0000 2516          pea       @m68kde~1_45.L
00001888  41F6      
0000188A  4E93      2517          jsr       (A3)
0000188C  504F      2518          addq.w    #8,A7
                    2519   ; if(*(unsigned short int *)(PC) == 0x4e4e)
0000188E  2039 0B00 2520          move.l    _PC.L,D0
00001892  0120      
00001894  2040      2521          move.l    D0,A0
00001896  3010      2522          move.w    (A0),D0
00001898  0C40 4E4E 2523          cmp.w     #20046,D0
0000189C  660A      2524          bne.s     DumpRegisters_40
                    2525   ; printf("[@ BREAKPOINT]") ;
0000189E  4879 0000 2526          pea       @m68kde~1_46.L
000018A2  4206      
000018A4  4E93      2527          jsr       (A3)
000018A6  584F      2528          addq.w    #4,A7
                    2529   DumpRegisters_40:
                    2530   ; printf("\r\n") ;
000018A8  4879 0000 2531          pea       @m68kde~1_1.L
000018AC  3D84      
000018AE  4E93      2532          jsr       (A3)
000018B0  584F      2533          addq.w    #4,A7
                    2534   ; for(i=0; i < 8; i++)    {
000018B2  4244      2535          clr.w     D4
                    2536   DumpRegisters_42:
000018B4  0C44 0008 2537          cmp.w     #8,D4
000018B8  6C00 0040 2538          bge       DumpRegisters_44
                    2539   ; if(WatchPointSetOrCleared[i] == 1)
000018BC  48C4      2540          ext.l     D4
000018BE  2004      2541          move.l    D4,D0
000018C0  E588      2542          lsl.l     #2,D0
000018C2  41F9 0B00 2543          lea       _WatchPointSetOrCleared.L,A0
000018C6  01A2      
000018C8  2030 0800 2544          move.l    0(A0,D0.L),D0
000018CC  0C80 0000 2545          cmp.l     #1,D0
000018D0  0001      
000018D2  6622      2546          bne.s     DumpRegisters_45
                    2547   ; printf("\r\nWP%d = %s", i, WatchPointString[i]) ;
000018D4  220D      2548          move.l    A5,D1
000018D6  48C4      2549          ext.l     D4
000018D8  2F00      2550          move.l    D0,-(A7)
000018DA  2004      2551          move.l    D4,D0
000018DC  C1FC 0064 2552          muls      #100,D0
000018E0  D280      2553          add.l     D0,D1
000018E2  201F      2554          move.l    (A7)+,D0
000018E4  2F01      2555          move.l    D1,-(A7)
000018E6  48C4      2556          ext.l     D4
000018E8  2F04      2557          move.l    D4,-(A7)
000018EA  4879 0000 2558          pea       @m68kde~1_47.L
000018EE  4216      
000018F0  4E93      2559          jsr       (A3)
000018F2  DEFC 000C 2560          add.w     #12,A7
                    2561   DumpRegisters_45:
000018F6  5244      2562          addq.w    #1,D4
000018F8  60BA      2563          bra       DumpRegisters_42
                    2564   DumpRegisters_44:
000018FA  4CDF 3CFC 2565          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
000018FE  4E75      2566          rts
                    2567   ; }
                    2568   ; }
                    2569   ; // Trace Exception Handler
                    2570   ; void DumpRegistersandPause(void)
                    2571   ; {
                    2572   _DumpRegistersandPause:
00001900  2F0A      2573          move.l    A2,-(A7)
00001902  45F9 0000 2574          lea       _printf.L,A2
00001906  3434      
                    2575   ; printf("\r\n\r\n\r\n\r\n\r\n\r\nSingle Step  :[ON]") ;
00001908  4879 0000 2576          pea       @m68kde~1_48.L
0000190C  4222      
0000190E  4E92      2577          jsr       (A2)
00001910  584F      2578          addq.w    #4,A7
                    2579   ; printf("\r\nBreak Points :[Disabled]") ;
00001912  4879 0000 2580          pea       @m68kde~1_49.L
00001916  4242      
00001918  4E92      2581          jsr       (A2)
0000191A  584F      2582          addq.w    #4,A7
                    2583   ; DumpRegisters() ;
0000191C  4EB8 144C 2584          jsr       _DumpRegisters
                    2585   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
00001920  4879 0000 2586          pea       @m68kde~1_50.L
00001924  425E      
00001926  4E92      2587          jsr       (A2)
00001928  584F      2588          addq.w    #4,A7
                    2589   ; printf("\r\nPress <ESC> to Resume Program") ;
0000192A  4879 0000 2590          pea       @m68kde~1_51.L
0000192E  428A      
00001930  4E92      2591          jsr       (A2)
00001932  584F      2592          addq.w    #4,A7
                    2593   ; menu() ;
00001934  4EB9 0000 2594          jsr       _menu
00001938  24E4      
0000193A  245F      2595          move.l    (A7)+,A2
0000193C  4E75      2596          rts
                    2597   ; }
                    2598   ; void ChangeRegisters(void)
                    2599   ; {
                    2600   _ChangeRegisters:
0000193E  4E56 FFFC 2601          link      A6,#-4
00001942  48E7 303C 2602          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
00001946  45F9 0000 2603          lea       _printf.L,A2
0000194A  3434      
0000194C  47EE FFFC 2604          lea       -4(A6),A3
00001950  49F8 0CD8 2605          lea       _Get8HexDigits.L,A4
00001954  4BF8 0B68 2606          lea       __getch.L,A5
                    2607   ; // get register name d0-d7, a0-a7, up, sp, sr, pc
                    2608   ; int reg_val ;
                    2609   ; char c, reg[3] ;
                    2610   ; reg[0] = tolower(_getch()) ;
00001958  2F00      2611          move.l    D0,-(A7)
0000195A  4E95      2612          jsr       (A5)
0000195C  2200      2613          move.l    D0,D1
0000195E  201F      2614          move.l    (A7)+,D0
00001960  2F01      2615          move.l    D1,-(A7)
00001962  4EB9 0000 2616          jsr       _tolower
00001966  3392      
00001968  584F      2617          addq.w    #4,A7
0000196A  1680      2618          move.b    D0,(A3)
                    2619   ; reg[1] = c = tolower(_getch()) ;
0000196C  2F00      2620          move.l    D0,-(A7)
0000196E  4E95      2621          jsr       (A5)
00001970  2200      2622          move.l    D0,D1
00001972  201F      2623          move.l    (A7)+,D0
00001974  2F01      2624          move.l    D1,-(A7)
00001976  4EB9 0000 2625          jsr       _tolower
0000197A  3392      
0000197C  584F      2626          addq.w    #4,A7
0000197E  1400      2627          move.b    D0,D2
00001980  1740 0001 2628          move.b    D0,1(A3)
                    2629   ; if(reg[0] == (char)('d'))  {    // change data register
00001984  1013      2630          move.b    (A3),D0
00001986  0C00 0064 2631          cmp.b     #100,D0
0000198A  6600 00AE 2632          bne       ChangeRegisters_1
                    2633   ; if((reg[1] > (char)('7')) || (reg[1] < (char)('0'))) {
0000198E  102B 0001 2634          move.b    1(A3),D0
00001992  0C00 0037 2635          cmp.b     #55,D0
00001996  6E0A      2636          bgt.s     ChangeRegisters_5
00001998  102B 0001 2637          move.b    1(A3),D0
0000199C  0C00 0030 2638          cmp.b     #48,D0
000019A0  6C0E      2639          bge.s     ChangeRegisters_3
                    2640   ChangeRegisters_5:
                    2641   ; printf("\r\nIllegal Data Register : Use D0-D7.....\r\n") ;
000019A2  4879 0000 2642          pea       @m68kde~1_52.L
000019A6  42AA      
000019A8  4E92      2643          jsr       (A2)
000019AA  584F      2644          addq.w    #4,A7
                    2645   ; return ;
000019AC  6000 0244 2646          bra       ChangeRegisters_6
                    2647   ChangeRegisters_3:
                    2648   ; }
                    2649   ; else {
                    2650   ; printf("\r\nD%c = ", c) ;
000019B0  4882      2651          ext.w     D2
000019B2  48C2      2652          ext.l     D2
000019B4  2F02      2653          move.l    D2,-(A7)
000019B6  4879 0000 2654          pea       @m68kde~1_53.L
000019BA  42D6      
000019BC  4E92      2655          jsr       (A2)
000019BE  504F      2656          addq.w    #8,A7
                    2657   ; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
000019C0  42A7      2658          clr.l     -(A7)
000019C2  4E94      2659          jsr       (A4)
000019C4  584F      2660          addq.w    #4,A7
000019C6  2600      2661          move.l    D0,D3
                    2662   ; }
                    2663   ; // bit cludgy but d0-d7 not stored as an array for good reason
                    2664   ; if(c == (char)('0'))
000019C8  0C02 0030 2665          cmp.b     #48,D2
000019CC  660A      2666          bne.s     ChangeRegisters_7
                    2667   ; d0 = reg_val ;
000019CE  23C3 0B00 2668          move.l    D3,_d0.L
000019D2  00E4      
000019D4  6000 0060 2669          bra       ChangeRegisters_20
                    2670   ChangeRegisters_7:
                    2671   ; else if(c == (char)('1'))
000019D8  0C02 0031 2672          cmp.b     #49,D2
000019DC  660A      2673          bne.s     ChangeRegisters_9
                    2674   ; d1 = reg_val ;
000019DE  23C3 0B00 2675          move.l    D3,_d1.L
000019E2  00E8      
000019E4  6000 0050 2676          bra       ChangeRegisters_20
                    2677   ChangeRegisters_9:
                    2678   ; else if(c == (char)('2'))
000019E8  0C02 0032 2679          cmp.b     #50,D2
000019EC  660A      2680          bne.s     ChangeRegisters_11
                    2681   ; d2 = reg_val ;
000019EE  23C3 0B00 2682          move.l    D3,_d2.L
000019F2  00EC      
000019F4  6000 0040 2683          bra       ChangeRegisters_20
                    2684   ChangeRegisters_11:
                    2685   ; else if(c == (char)('3'))
000019F8  0C02 0033 2686          cmp.b     #51,D2
000019FC  6608      2687          bne.s     ChangeRegisters_13
                    2688   ; d3 = reg_val ;
000019FE  23C3 0B00 2689          move.l    D3,_d3.L
00001A02  00F0      
00001A04  6030      2690          bra.s     ChangeRegisters_20
                    2691   ChangeRegisters_13:
                    2692   ; else if(c == (char)('4'))
00001A06  0C02 0034 2693          cmp.b     #52,D2
00001A0A  6608      2694          bne.s     ChangeRegisters_15
                    2695   ; d4 = reg_val ;
00001A0C  23C3 0B00 2696          move.l    D3,_d4.L
00001A10  00F4      
00001A12  6022      2697          bra.s     ChangeRegisters_20
                    2698   ChangeRegisters_15:
                    2699   ; else if(c == (char)('5'))
00001A14  0C02 0035 2700          cmp.b     #53,D2
00001A18  6608      2701          bne.s     ChangeRegisters_17
                    2702   ; d5 = reg_val ;
00001A1A  23C3 0B00 2703          move.l    D3,_d5.L
00001A1E  00F8      
00001A20  6014      2704          bra.s     ChangeRegisters_20
                    2705   ChangeRegisters_17:
                    2706   ; else if(c == (char)('6'))
00001A22  0C02 0036 2707          cmp.b     #54,D2
00001A26  6608      2708          bne.s     ChangeRegisters_19
                    2709   ; d6 = reg_val ;
00001A28  23C3 0B00 2710          move.l    D3,_d6.L
00001A2C  00FC      
00001A2E  6006      2711          bra.s     ChangeRegisters_20
                    2712   ChangeRegisters_19:
                    2713   ; else
                    2714   ; d7 = reg_val ;
00001A30  23C3 0B00 2715          move.l    D3,_d7.L
00001A34  0100      
                    2716   ChangeRegisters_20:
00001A36  6000 01B6 2717          bra       ChangeRegisters_51
                    2718   ChangeRegisters_1:
                    2719   ; }
                    2720   ; else if(reg[0] == (char)('a'))  {    // change address register, a7 is the user stack pointer, sp is the system stack pointer
00001A3A  1013      2721          move.b    (A3),D0
00001A3C  0C00 0061 2722          cmp.b     #97,D0
00001A40  6600 00A6 2723          bne       ChangeRegisters_21
                    2724   ; if((c > (char)('7')) || (c < (char)('0'))) {
00001A44  0C02 0037 2725          cmp.b     #55,D2
00001A48  6E06      2726          bgt.s     ChangeRegisters_25
00001A4A  0C02 0030 2727          cmp.b     #48,D2
00001A4E  6C0E      2728          bge.s     ChangeRegisters_23
                    2729   ChangeRegisters_25:
                    2730   ; printf("\r\nIllegal Address Register : Use A0-A7.....\r\n") ;
00001A50  4879 0000 2731          pea       @m68kde~1_54.L
00001A54  42E0      
00001A56  4E92      2732          jsr       (A2)
00001A58  584F      2733          addq.w    #4,A7
                    2734   ; return ;
00001A5A  6000 0196 2735          bra       ChangeRegisters_6
                    2736   ChangeRegisters_23:
                    2737   ; }
                    2738   ; else {
                    2739   ; printf("\r\nA%c = ", c) ;
00001A5E  4882      2740          ext.w     D2
00001A60  48C2      2741          ext.l     D2
00001A62  2F02      2742          move.l    D2,-(A7)
00001A64  4879 0000 2743          pea       @m68kde~1_55.L
00001A68  430E      
00001A6A  4E92      2744          jsr       (A2)
00001A6C  504F      2745          addq.w    #8,A7
                    2746   ; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001A6E  42A7      2747          clr.l     -(A7)
00001A70  4E94      2748          jsr       (A4)
00001A72  584F      2749          addq.w    #4,A7
00001A74  2600      2750          move.l    D0,D3
                    2751   ; }
                    2752   ; // bit cludgy but a0-a7 not stored as an array for good reason
                    2753   ; if(c == (char)('0'))
00001A76  0C02 0030 2754          cmp.b     #48,D2
00001A7A  660A      2755          bne.s     ChangeRegisters_26
                    2756   ; a0 = reg_val ;
00001A7C  23C3 0B00 2757          move.l    D3,_a0.L
00001A80  0104      
00001A82  6000 0060 2758          bra       ChangeRegisters_39
                    2759   ChangeRegisters_26:
                    2760   ; else if(c == (char)('1'))
00001A86  0C02 0031 2761          cmp.b     #49,D2
00001A8A  660A      2762          bne.s     ChangeRegisters_28
                    2763   ; a1 = reg_val ;
00001A8C  23C3 0B00 2764          move.l    D3,_a1.L
00001A90  0108      
00001A92  6000 0050 2765          bra       ChangeRegisters_39
                    2766   ChangeRegisters_28:
                    2767   ; else if(c == (char)('2'))
00001A96  0C02 0032 2768          cmp.b     #50,D2
00001A9A  660A      2769          bne.s     ChangeRegisters_30
                    2770   ; a2 = reg_val ;
00001A9C  23C3 0B00 2771          move.l    D3,_a2.L
00001AA0  010C      
00001AA2  6000 0040 2772          bra       ChangeRegisters_39
                    2773   ChangeRegisters_30:
                    2774   ; else if(c == (char)('3'))
00001AA6  0C02 0033 2775          cmp.b     #51,D2
00001AAA  6608      2776          bne.s     ChangeRegisters_32
                    2777   ; a3 = reg_val ;
00001AAC  23C3 0B00 2778          move.l    D3,_a3.L
00001AB0  0110      
00001AB2  6030      2779          bra.s     ChangeRegisters_39
                    2780   ChangeRegisters_32:
                    2781   ; else if(c == (char)('4'))
00001AB4  0C02 0034 2782          cmp.b     #52,D2
00001AB8  6608      2783          bne.s     ChangeRegisters_34
                    2784   ; a4 = reg_val ;
00001ABA  23C3 0B00 2785          move.l    D3,_a4.L
00001ABE  0114      
00001AC0  6022      2786          bra.s     ChangeRegisters_39
                    2787   ChangeRegisters_34:
                    2788   ; else if(c == (char)('5'))
00001AC2  0C02 0035 2789          cmp.b     #53,D2
00001AC6  6608      2790          bne.s     ChangeRegisters_36
                    2791   ; a5 = reg_val ;
00001AC8  23C3 0B00 2792          move.l    D3,_a5.L
00001ACC  0118      
00001ACE  6014      2793          bra.s     ChangeRegisters_39
                    2794   ChangeRegisters_36:
                    2795   ; else if(c == (char)('6'))
00001AD0  0C02 0036 2796          cmp.b     #54,D2
00001AD4  6608      2797          bne.s     ChangeRegisters_38
                    2798   ; a6 = reg_val ;
00001AD6  23C3 0B00 2799          move.l    D3,_a6.L
00001ADA  011C      
00001ADC  6006      2800          bra.s     ChangeRegisters_39
                    2801   ChangeRegisters_38:
                    2802   ; else
                    2803   ; USP = reg_val ;
00001ADE  23C3 0B00 2804          move.l    D3,_USP.L
00001AE2  0128      
                    2805   ChangeRegisters_39:
00001AE4  6000 0108 2806          bra       ChangeRegisters_51
                    2807   ChangeRegisters_21:
                    2808   ; }
                    2809   ; else if((reg[0] == (char)('u')) && (c == (char)('s')))  {
00001AE8  1013      2810          move.b    (A3),D0
00001AEA  0C00 0075 2811          cmp.b     #117,D0
00001AEE  6600 004E 2812          bne       ChangeRegisters_40
00001AF2  0C02 0073 2813          cmp.b     #115,D2
00001AF6  6600 0046 2814          bne       ChangeRegisters_40
                    2815   ; if(tolower(_getch()) == 'p')  {    // change user stack pointer
00001AFA  2F00      2816          move.l    D0,-(A7)
00001AFC  4E95      2817          jsr       (A5)
00001AFE  2200      2818          move.l    D0,D1
00001B00  201F      2819          move.l    (A7)+,D0
00001B02  2F01      2820          move.l    D1,-(A7)
00001B04  4EB9 0000 2821          jsr       _tolower
00001B08  3392      
00001B0A  584F      2822          addq.w    #4,A7
00001B0C  0C80 0000 2823          cmp.l     #112,D0
00001B10  0070      
00001B12  6618      2824          bne.s     ChangeRegisters_42
                    2825   ; printf("\r\nUser SP = ") ;
00001B14  4879 0000 2826          pea       @m68kde~1_56.L
00001B18  4318      
00001B1A  4E92      2827          jsr       (A2)
00001B1C  584F      2828          addq.w    #4,A7
                    2829   ; USP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001B1E  42A7      2830          clr.l     -(A7)
00001B20  4E94      2831          jsr       (A4)
00001B22  584F      2832          addq.w    #4,A7
00001B24  23C0 0B00 2833          move.l    D0,_USP.L
00001B28  0128      
00001B2A  600E      2834          bra.s     ChangeRegisters_43
                    2835   ChangeRegisters_42:
                    2836   ; }
                    2837   ; else {
                    2838   ; printf("\r\nIllegal Register....") ;
00001B2C  4879 0000 2839          pea       @m68kde~1_57.L
00001B30  4326      
00001B32  4E92      2840          jsr       (A2)
00001B34  584F      2841          addq.w    #4,A7
                    2842   ; return ;
00001B36  6000 00BA 2843          bra       ChangeRegisters_6
                    2844   ChangeRegisters_43:
00001B3A  6000 00B2 2845          bra       ChangeRegisters_51
                    2846   ChangeRegisters_40:
                    2847   ; }
                    2848   ; }
                    2849   ; else if((reg[0] == (char)('s')) && (c == (char)('s')))  {
00001B3E  1013      2850          move.b    (A3),D0
00001B40  0C00 0073 2851          cmp.b     #115,D0
00001B44  6600 004E 2852          bne       ChangeRegisters_44
00001B48  0C02 0073 2853          cmp.b     #115,D2
00001B4C  6600 0046 2854          bne       ChangeRegisters_44
                    2855   ; if(tolower(_getch()) == 'p')  {    // change system stack pointer
00001B50  2F00      2856          move.l    D0,-(A7)
00001B52  4E95      2857          jsr       (A5)
00001B54  2200      2858          move.l    D0,D1
00001B56  201F      2859          move.l    (A7)+,D0
00001B58  2F01      2860          move.l    D1,-(A7)
00001B5A  4EB9 0000 2861          jsr       _tolower
00001B5E  3392      
00001B60  584F      2862          addq.w    #4,A7
00001B62  0C80 0000 2863          cmp.l     #112,D0
00001B66  0070      
00001B68  6618      2864          bne.s     ChangeRegisters_46
                    2865   ; printf("\r\nSystem SP = ") ;
00001B6A  4879 0000 2866          pea       @m68kde~1_58.L
00001B6E  433E      
00001B70  4E92      2867          jsr       (A2)
00001B72  584F      2868          addq.w    #4,A7
                    2869   ; SSP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001B74  42A7      2870          clr.l     -(A7)
00001B76  4E94      2871          jsr       (A4)
00001B78  584F      2872          addq.w    #4,A7
00001B7A  23C0 0B00 2873          move.l    D0,_SSP.L
00001B7E  0124      
00001B80  600E      2874          bra.s     ChangeRegisters_47
                    2875   ChangeRegisters_46:
                    2876   ; }
                    2877   ; else {
                    2878   ; printf("\r\nIllegal Register....") ;
00001B82  4879 0000 2879          pea       @m68kde~1_57.L
00001B86  4326      
00001B88  4E92      2880          jsr       (A2)
00001B8A  584F      2881          addq.w    #4,A7
                    2882   ; return ;
00001B8C  6000 0064 2883          bra       ChangeRegisters_6
                    2884   ChangeRegisters_47:
00001B90  6000 005C 2885          bra       ChangeRegisters_51
                    2886   ChangeRegisters_44:
                    2887   ; }
                    2888   ; }
                    2889   ; else if((reg[0] == (char)('p')) && (c == (char)('c')))  {    // change program counter
00001B94  1013      2890          move.b    (A3),D0
00001B96  0C00 0070 2891          cmp.b     #112,D0
00001B9A  6620      2892          bne.s     ChangeRegisters_48
00001B9C  0C02 0063 2893          cmp.b     #99,D2
00001BA0  661A      2894          bne.s     ChangeRegisters_48
                    2895   ; printf("\r\nPC = ") ;
00001BA2  4879 0000 2896          pea       @m68kde~1_59.L
00001BA6  434E      
00001BA8  4E92      2897          jsr       (A2)
00001BAA  584F      2898          addq.w    #4,A7
                    2899   ; PC = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001BAC  42A7      2900          clr.l     -(A7)
00001BAE  4E94      2901          jsr       (A4)
00001BB0  584F      2902          addq.w    #4,A7
00001BB2  23C0 0B00 2903          move.l    D0,_PC.L
00001BB6  0120      
00001BB8  6000 0034 2904          bra       ChangeRegisters_51
                    2905   ChangeRegisters_48:
                    2906   ; }
                    2907   ; else if((reg[0] == (char)('s')) && (c == (char)('r')))  {    // change status register
00001BBC  1013      2908          move.b    (A3),D0
00001BBE  0C00 0073 2909          cmp.b     #115,D0
00001BC2  6620      2910          bne.s     ChangeRegisters_50
00001BC4  0C02 0072 2911          cmp.b     #114,D2
00001BC8  661A      2912          bne.s     ChangeRegisters_50
                    2913   ; printf("\r\nSR = ") ;
00001BCA  4879 0000 2914          pea       @m68kde~1_60.L
00001BCE  4356      
00001BD0  4E92      2915          jsr       (A2)
00001BD2  584F      2916          addq.w    #4,A7
                    2917   ; SR = Get4HexDigits(0) ;    // read 16 bit value from user keyboard
00001BD4  42A7      2918          clr.l     -(A7)
00001BD6  4EB8 0C8C 2919          jsr       _Get4HexDigits
00001BDA  584F      2920          addq.w    #4,A7
00001BDC  33C0 0B00 2921          move.w    D0,_SR.L
00001BE0  012C      
00001BE2  600A      2922          bra.s     ChangeRegisters_51
                    2923   ChangeRegisters_50:
                    2924   ; }
                    2925   ; else
                    2926   ; printf("\r\nIllegal Register: Use A0-A7, D0-D7, SSP, USP, PC or SR\r\n") ;
00001BE4  4879 0000 2927          pea       @m68kde~1_61.L
00001BE8  435E      
00001BEA  4E92      2928          jsr       (A2)
00001BEC  584F      2929          addq.w    #4,A7
                    2930   ChangeRegisters_51:
                    2931   ; DumpRegisters() ;
00001BEE  4EB8 144C 2932          jsr       _DumpRegisters
                    2933   ChangeRegisters_6:
00001BF2  4CDF 3C0C 2934          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00001BF6  4E5E      2935          unlk      A6
00001BF8  4E75      2936          rts
                    2937   ; }
                    2938   ; void BreakPointDisplay(void)
                    2939   ; {
                    2940   _BreakPointDisplay:
00001BFA  48E7 3030 2941          movem.l   D2/D3/A2/A3,-(A7)
00001BFE  45F9 0000 2942          lea       _printf.L,A2
00001C02  3434      
00001C04  47F9 0B00 2943          lea       _BreakPointAddress.L,A3
00001C08  012E      
                    2944   ; int i, BreakPointsSet = 0 ;
00001C0A  4283      2945          clr.l     D3
                    2946   ; // any break points  set
                    2947   ; for(i = 0; i < 8; i++)  {
00001C0C  4282      2948          clr.l     D2
                    2949   BreakPointDisplay_1:
00001C0E  0C82 0000 2950          cmp.l     #8,D2
00001C12  0008      
00001C14  6C1C      2951          bge.s     BreakPointDisplay_3
                    2952   ; if(BreakPointSetOrCleared[i] == 1)
00001C16  2002      2953          move.l    D2,D0
00001C18  E588      2954          lsl.l     #2,D0
00001C1A  41F9 0B00 2955          lea       _BreakPointSetOrCleared.L,A0
00001C1E  015E      
00001C20  2030 0800 2956          move.l    0(A0,D0.L),D0
00001C24  0C80 0000 2957          cmp.l     #1,D0
00001C28  0001      
00001C2A  6602      2958          bne.s     BreakPointDisplay_4
                    2959   ; BreakPointsSet = 1;
00001C2C  7601      2960          moveq     #1,D3
                    2961   BreakPointDisplay_4:
00001C2E  5282      2962          addq.l    #1,D2
00001C30  60DC      2963          bra       BreakPointDisplay_1
                    2964   BreakPointDisplay_3:
                    2965   ; }
                    2966   ; if(BreakPointsSet == 1) {
00001C32  0C83 0000 2967          cmp.l     #1,D3
00001C36  0001      
00001C38  6616      2968          bne.s     BreakPointDisplay_6
                    2969   ; printf("\r\n\r\nNum     Address      Instruction") ;
00001C3A  4879 0000 2970          pea       @m68kde~1_62.L
00001C3E  439A      
00001C40  4E92      2971          jsr       (A2)
00001C42  584F      2972          addq.w    #4,A7
                    2973   ; printf("\r\n---     ---------    -----------") ;
00001C44  4879 0000 2974          pea       @m68kde~1_63.L
00001C48  43C0      
00001C4A  4E92      2975          jsr       (A2)
00001C4C  584F      2976          addq.w    #4,A7
00001C4E  600A      2977          bra.s     BreakPointDisplay_7
                    2978   BreakPointDisplay_6:
                    2979   ; }
                    2980   ; else
                    2981   ; printf("\r\nNo BreakPoints Set") ;
00001C50  4879 0000 2982          pea       @m68kde~1_64.L
00001C54  43E4      
00001C56  4E92      2983          jsr       (A2)
00001C58  584F      2984          addq.w    #4,A7
                    2985   BreakPointDisplay_7:
                    2986   ; for(i = 0; i < 8; i++)  {
00001C5A  4282      2987          clr.l     D2
                    2988   BreakPointDisplay_8:
00001C5C  0C82 0000 2989          cmp.l     #8,D2
00001C60  0008      
00001C62  6C00 005A 2990          bge       BreakPointDisplay_10
                    2991   ; // put opcode back, then put break point back
                    2992   ; if(BreakPointSetOrCleared[i] == 1)  {
00001C66  2002      2993          move.l    D2,D0
00001C68  E588      2994          lsl.l     #2,D0
00001C6A  41F9 0B00 2995          lea       _BreakPointSetOrCleared.L,A0
00001C6E  015E      
00001C70  2030 0800 2996          move.l    0(A0,D0.L),D0
00001C74  0C80 0000 2997          cmp.l     #1,D0
00001C78  0001      
00001C7A  6600 003E 2998          bne       BreakPointDisplay_11
                    2999   ; *(unsigned short int *)(BreakPointAddress[i]) = BreakPointInstruction[i];
00001C7E  2002      3000          move.l    D2,D0
00001C80  E388      3001          lsl.l     #1,D0
00001C82  41F9 0B00 3002          lea       _BreakPointInstruction.L,A0
00001C86  014E      
00001C88  2202      3003          move.l    D2,D1
00001C8A  E589      3004          lsl.l     #2,D1
00001C8C  2233 1800 3005          move.l    0(A3,D1.L),D1
00001C90  2241      3006          move.l    D1,A1
00001C92  32B0 0800 3007          move.w    0(A0,D0.L),(A1)
                    3008   ; *(unsigned short int *)(BreakPointAddress[i]) = (unsigned short int)(0x4e4e) ;
00001C96  2002      3009          move.l    D2,D0
00001C98  E588      3010          lsl.l     #2,D0
00001C9A  2033 0800 3011          move.l    0(A3,D0.L),D0
00001C9E  2040      3012          move.l    D0,A0
00001CA0  30BC 4E4E 3013          move.w    #20046,(A0)
                    3014   ; printf("\r\n%3d     $%08x",i, BreakPointAddress[i]) ;
00001CA4  2202      3015          move.l    D2,D1
00001CA6  E589      3016          lsl.l     #2,D1
00001CA8  2F33 1800 3017          move.l    0(A3,D1.L),-(A7)
00001CAC  2F02      3018          move.l    D2,-(A7)
00001CAE  4879 0000 3019          pea       @m68kde~1_65.L
00001CB2  43FA      
00001CB4  4E92      3020          jsr       (A2)
00001CB6  DEFC 000C 3021          add.w     #12,A7
                    3022   BreakPointDisplay_11:
00001CBA  5282      3023          addq.l    #1,D2
00001CBC  609E      3024          bra       BreakPointDisplay_8
                    3025   BreakPointDisplay_10:
                    3026   ; }
                    3027   ; }
                    3028   ; printf("\r\n") ;
00001CBE  4879 0000 3029          pea       @m68kde~1_1.L
00001CC2  3D84      
00001CC4  4E92      3030          jsr       (A2)
00001CC6  584F      3031          addq.w    #4,A7
00001CC8  4CDF 0C0C 3032          movem.l   (A7)+,D2/D3/A2/A3
00001CCC  4E75      3033          rts
                    3034   ; }
                    3035   ; void WatchPointDisplay(void)
                    3036   ; {
                    3037   _WatchPointDisplay:
00001CCE  48E7 3020 3038          movem.l   D2/D3/A2,-(A7)
00001CD2  45F9 0000 3039          lea       _printf.L,A2
00001CD6  3434      
                    3040   ; int i ;
                    3041   ; int WatchPointsSet = 0 ;
00001CD8  4283      3042          clr.l     D3
                    3043   ; // any watchpoints set
                    3044   ; for(i = 0; i < 8; i++)  {
00001CDA  4282      3045          clr.l     D2
                    3046   WatchPointDisplay_1:
00001CDC  0C82 0000 3047          cmp.l     #8,D2
00001CE0  0008      
00001CE2  6C1C      3048          bge.s     WatchPointDisplay_3
                    3049   ; if(WatchPointSetOrCleared[i] == 1)
00001CE4  2002      3050          move.l    D2,D0
00001CE6  E588      3051          lsl.l     #2,D0
00001CE8  41F9 0B00 3052          lea       _WatchPointSetOrCleared.L,A0
00001CEC  01A2      
00001CEE  2030 0800 3053          move.l    0(A0,D0.L),D0
00001CF2  0C80 0000 3054          cmp.l     #1,D0
00001CF6  0001      
00001CF8  6602      3055          bne.s     WatchPointDisplay_4
                    3056   ; WatchPointsSet = 1;
00001CFA  7601      3057          moveq     #1,D3
                    3058   WatchPointDisplay_4:
00001CFC  5282      3059          addq.l    #1,D2
00001CFE  60DC      3060          bra       WatchPointDisplay_1
                    3061   WatchPointDisplay_3:
                    3062   ; }
                    3063   ; if(WatchPointsSet == 1) {
00001D00  0C83 0000 3064          cmp.l     #1,D3
00001D04  0001      
00001D06  6616      3065          bne.s     WatchPointDisplay_6
                    3066   ; printf("\r\nNum     Address") ;
00001D08  4879 0000 3067          pea       @m68kde~1_66.L
00001D0C  440A      
00001D0E  4E92      3068          jsr       (A2)
00001D10  584F      3069          addq.w    #4,A7
                    3070   ; printf("\r\n---     ---------") ;
00001D12  4879 0000 3071          pea       @m68kde~1_67.L
00001D16  441C      
00001D18  4E92      3072          jsr       (A2)
00001D1A  584F      3073          addq.w    #4,A7
00001D1C  600A      3074          bra.s     WatchPointDisplay_7
                    3075   WatchPointDisplay_6:
                    3076   ; }
                    3077   ; else
                    3078   ; printf("\r\nNo WatchPoints Set") ;
00001D1E  4879 0000 3079          pea       @m68kde~1_68.L
00001D22  4430      
00001D24  4E92      3080          jsr       (A2)
00001D26  584F      3081          addq.w    #4,A7
                    3082   WatchPointDisplay_7:
                    3083   ; for(i = 0; i < 8; i++)  {
00001D28  4282      3084          clr.l     D2
                    3085   WatchPointDisplay_8:
00001D2A  0C82 0000 3086          cmp.l     #8,D2
00001D2E  0008      
00001D30  6C00 0038 3087          bge       WatchPointDisplay_10
                    3088   ; if(WatchPointSetOrCleared[i] == 1)
00001D34  2002      3089          move.l    D2,D0
00001D36  E588      3090          lsl.l     #2,D0
00001D38  41F9 0B00 3091          lea       _WatchPointSetOrCleared.L,A0
00001D3C  01A2      
00001D3E  2030 0800 3092          move.l    0(A0,D0.L),D0
00001D42  0C80 0000 3093          cmp.l     #1,D0
00001D46  0001      
00001D48  661C      3094          bne.s     WatchPointDisplay_11
                    3095   ; printf("\r\n%3d     $%08x",i, WatchPointAddress[i]) ;
00001D4A  2202      3096          move.l    D2,D1
00001D4C  E589      3097          lsl.l     #2,D1
00001D4E  41F9 0B00 3098          lea       _WatchPointAddress.L,A0
00001D52  0182      
00001D54  2F30 1800 3099          move.l    0(A0,D1.L),-(A7)
00001D58  2F02      3100          move.l    D2,-(A7)
00001D5A  4879 0000 3101          pea       @m68kde~1_65.L
00001D5E  43FA      
00001D60  4E92      3102          jsr       (A2)
00001D62  DEFC 000C 3103          add.w     #12,A7
                    3104   WatchPointDisplay_11:
00001D66  5282      3105          addq.l    #1,D2
00001D68  60C0      3106          bra       WatchPointDisplay_8
                    3107   WatchPointDisplay_10:
                    3108   ; }
                    3109   ; printf("\r\n") ;
00001D6A  4879 0000 3110          pea       @m68kde~1_1.L
00001D6E  3D84      
00001D70  4E92      3111          jsr       (A2)
00001D72  584F      3112          addq.w    #4,A7
00001D74  4CDF 040C 3113          movem.l   (A7)+,D2/D3/A2
00001D78  4E75      3114          rts
                    3115   ; }
                    3116   ; void BreakPointClear(void)
                    3117   ; {
                    3118   _BreakPointClear:
00001D7A  4E56 FFFC 3119          link      A6,#-4
00001D7E  48E7 2020 3120          movem.l   D2/A2,-(A7)
00001D82  45F9 0000 3121          lea       _printf.L,A2
00001D86  3434      
                    3122   ; unsigned int i ;
                    3123   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3124   ; BreakPointDisplay() ;
00001D88  4EB8 1BFA 3125          jsr       _BreakPointDisplay
                    3126   ; printf("\r\nEnter Break Point Number: ") ;
00001D8C  4879 0000 3127          pea       @m68kde~1_69.L
00001D90  4446      
00001D92  4E92      3128          jsr       (A2)
00001D94  584F      3129          addq.w    #4,A7
                    3130   ; i = xtod(_getch()) ;           // get break pointer number
00001D96  2F00      3131          move.l    D0,-(A7)
00001D98  4EB8 0B68 3132          jsr       __getch
00001D9C  2200      3133          move.l    D0,D1
00001D9E  201F      3134          move.l    (A7)+,D0
00001DA0  2F01      3135          move.l    D1,-(A7)
00001DA2  4EB8 0BD2 3136          jsr       _xtod
00001DA6  584F      3137          addq.w    #4,A7
00001DA8  C0BC 0000 3138          and.l     #255,D0
00001DAC  00FF      
00001DAE  2400      3139          move.l    D0,D2
                    3140   ; if((i < 0) || (i > 7))   {
00001DB0  0C82 0000 3141          cmp.l     #0,D2
00001DB4  0000      
00001DB6  6508      3142          blo.s     BreakPointClear_3
00001DB8  0C82 0000 3143          cmp.l     #7,D2
00001DBC  0007      
00001DBE  630E      3144          bls.s     BreakPointClear_1
                    3145   BreakPointClear_3:
                    3146   ; printf("\r\nIllegal Range : Use 0 - 7") ;
00001DC0  4879 0000 3147          pea       @m68kde~1_70.L
00001DC4  4464      
00001DC6  4E92      3148          jsr       (A2)
00001DC8  584F      3149          addq.w    #4,A7
                    3150   ; return ;
00001DCA  6000 0080 3151          bra       BreakPointClear_4
                    3152   BreakPointClear_1:
                    3153   ; }
                    3154   ; if(BreakPointSetOrCleared[i] == 1)  {       // if break point set
00001DCE  2002      3155          move.l    D2,D0
00001DD0  E588      3156          lsl.l     #2,D0
00001DD2  41F9 0B00 3157          lea       _BreakPointSetOrCleared.L,A0
00001DD6  015E      
00001DD8  2030 0800 3158          move.l    0(A0,D0.L),D0
00001DDC  0C80 0000 3159          cmp.l     #1,D0
00001DE0  0001      
00001DE2  6600 005A 3160          bne       BreakPointClear_5
                    3161   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program we are about to change
00001DE6  2002      3162          move.l    D2,D0
00001DE8  E588      3163          lsl.l     #2,D0
00001DEA  41F9 0B00 3164          lea       _BreakPointAddress.L,A0
00001DEE  012E      
00001DF0  2D70 0800 3165          move.l    0(A0,D0.L),-4(A6)
00001DF4  FFFC      
                    3166   ; BreakPointAddress[i] = 0 ;
00001DF6  2002      3167          move.l    D2,D0
00001DF8  E588      3168          lsl.l     #2,D0
00001DFA  41F9 0B00 3169          lea       _BreakPointAddress.L,A0
00001DFE  012E      
00001E00  42B0 0800 3170          clr.l     0(A0,D0.L)
                    3171   ; BreakPointSetOrCleared[i] = 0 ;
00001E04  2002      3172          move.l    D2,D0
00001E06  E588      3173          lsl.l     #2,D0
00001E08  41F9 0B00 3174          lea       _BreakPointSetOrCleared.L,A0
00001E0C  015E      
00001E0E  42B0 0800 3175          clr.l     0(A0,D0.L)
                    3176   ; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
00001E12  2002      3177          move.l    D2,D0
00001E14  E388      3178          lsl.l     #1,D0
00001E16  41F9 0B00 3179          lea       _BreakPointInstruction.L,A0
00001E1A  014E      
00001E1C  226E FFFC 3180          move.l    -4(A6),A1
00001E20  32B0 0800 3181          move.w    0(A0,D0.L),(A1)
                    3182   ; BreakPointInstruction[i] = 0 ;
00001E24  2002      3183          move.l    D2,D0
00001E26  E388      3184          lsl.l     #1,D0
00001E28  41F9 0B00 3185          lea       _BreakPointInstruction.L,A0
00001E2C  014E      
00001E2E  4270 0800 3186          clr.w     0(A0,D0.L)
                    3187   ; printf("\r\nBreak Point Cleared.....\r\n") ;
00001E32  4879 0000 3188          pea       @m68kde~1_71.L
00001E36  4480      
00001E38  4E92      3189          jsr       (A2)
00001E3A  584F      3190          addq.w    #4,A7
00001E3C  600A      3191          bra.s     BreakPointClear_6
                    3192   BreakPointClear_5:
                    3193   ; }
                    3194   ; else
                    3195   ; printf("\r\nBreak Point wasn't Set.....") ;
00001E3E  4879 0000 3196          pea       @m68kde~1_72.L
00001E42  449E      
00001E44  4E92      3197          jsr       (A2)
00001E46  584F      3198          addq.w    #4,A7
                    3199   BreakPointClear_6:
                    3200   ; BreakPointDisplay() ;
00001E48  4EB8 1BFA 3201          jsr       _BreakPointDisplay
                    3202   ; return ;
                    3203   BreakPointClear_4:
00001E4C  4CDF 0404 3204          movem.l   (A7)+,D2/A2
00001E50  4E5E      3205          unlk      A6
00001E52  4E75      3206          rts
                    3207   ; }
                    3208   ; void WatchPointClear(void)
                    3209   ; {
                    3210   _WatchPointClear:
00001E54  48E7 2020 3211          movem.l   D2/A2,-(A7)
00001E58  45F9 0000 3212          lea       _printf.L,A2
00001E5C  3434      
                    3213   ; unsigned int i ;
                    3214   ; WatchPointDisplay() ;
00001E5E  4EB8 1CCE 3215          jsr       _WatchPointDisplay
                    3216   ; printf("\r\nEnter Watch Point Number: ") ;
00001E62  4879 0000 3217          pea       @m68kde~1_73.L
00001E66  44BC      
00001E68  4E92      3218          jsr       (A2)
00001E6A  584F      3219          addq.w    #4,A7
                    3220   ; i = xtod(_getch()) ;           // get watch pointer number
00001E6C  2F00      3221          move.l    D0,-(A7)
00001E6E  4EB8 0B68 3222          jsr       __getch
00001E72  2200      3223          move.l    D0,D1
00001E74  201F      3224          move.l    (A7)+,D0
00001E76  2F01      3225          move.l    D1,-(A7)
00001E78  4EB8 0BD2 3226          jsr       _xtod
00001E7C  584F      3227          addq.w    #4,A7
00001E7E  C0BC 0000 3228          and.l     #255,D0
00001E82  00FF      
00001E84  2400      3229          move.l    D0,D2
                    3230   ; if((i < 0) || (i > 7))   {
00001E86  0C82 0000 3231          cmp.l     #0,D2
00001E8A  0000      
00001E8C  6508      3232          blo.s     WatchPointClear_3
00001E8E  0C82 0000 3233          cmp.l     #7,D2
00001E92  0007      
00001E94  630E      3234          bls.s     WatchPointClear_1
                    3235   WatchPointClear_3:
                    3236   ; printf("\r\nIllegal Range : Use 0 - 7") ;
00001E96  4879 0000 3237          pea       @m68kde~1_70.L
00001E9A  4464      
00001E9C  4E92      3238          jsr       (A2)
00001E9E  584F      3239          addq.w    #4,A7
                    3240   ; return ;
00001EA0  6000 004E 3241          bra       WatchPointClear_4
                    3242   WatchPointClear_1:
                    3243   ; }
                    3244   ; if(WatchPointSetOrCleared[i] == 1)  {       // if watch point set
00001EA4  2002      3245          move.l    D2,D0
00001EA6  E588      3246          lsl.l     #2,D0
00001EA8  41F9 0B00 3247          lea       _WatchPointSetOrCleared.L,A0
00001EAC  01A2      
00001EAE  2030 0800 3248          move.l    0(A0,D0.L),D0
00001EB2  0C80 0000 3249          cmp.l     #1,D0
00001EB6  0001      
00001EB8  6628      3250          bne.s     WatchPointClear_5
                    3251   ; WatchPointAddress[i] = 0 ;
00001EBA  2002      3252          move.l    D2,D0
00001EBC  E588      3253          lsl.l     #2,D0
00001EBE  41F9 0B00 3254          lea       _WatchPointAddress.L,A0
00001EC2  0182      
00001EC4  42B0 0800 3255          clr.l     0(A0,D0.L)
                    3256   ; WatchPointSetOrCleared[i] = 0 ;
00001EC8  2002      3257          move.l    D2,D0
00001ECA  E588      3258          lsl.l     #2,D0
00001ECC  41F9 0B00 3259          lea       _WatchPointSetOrCleared.L,A0
00001ED0  01A2      
00001ED2  42B0 0800 3260          clr.l     0(A0,D0.L)
                    3261   ; printf("\r\nWatch Point Cleared.....\r\n") ;
00001ED6  4879 0000 3262          pea       @m68kde~1_74.L
00001EDA  44DA      
00001EDC  4E92      3263          jsr       (A2)
00001EDE  584F      3264          addq.w    #4,A7
00001EE0  600A      3265          bra.s     WatchPointClear_6
                    3266   WatchPointClear_5:
                    3267   ; }
                    3268   ; else
                    3269   ; printf("\r\nWatch Point Was not Set.....") ;
00001EE2  4879 0000 3270          pea       @m68kde~1_75.L
00001EE6  44F8      
00001EE8  4E92      3271          jsr       (A2)
00001EEA  584F      3272          addq.w    #4,A7
                    3273   WatchPointClear_6:
                    3274   ; WatchPointDisplay() ;
00001EEC  4EB8 1CCE 3275          jsr       _WatchPointDisplay
                    3276   ; return ;
                    3277   WatchPointClear_4:
00001EF0  4CDF 0404 3278          movem.l   (A7)+,D2/A2
00001EF4  4E75      3279          rts
                    3280   ; }
                    3281   ; void DisableBreakPoints(void)
                    3282   ; {
                    3283   _DisableBreakPoints:
00001EF6  4E56 FFFC 3284          link      A6,#-4
00001EFA  2F02      3285          move.l    D2,-(A7)
                    3286   ; int i ;
                    3287   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3288   ; for(i = 0; i < 8; i++)  {
00001EFC  4282      3289          clr.l     D2
                    3290   DisableBreakPoints_1:
00001EFE  0C82 0000 3291          cmp.l     #8,D2
00001F02  0008      
00001F04  6C00 003E 3292          bge       DisableBreakPoints_3
                    3293   ; if(BreakPointSetOrCleared[i] == 1)    {                                                    // if break point set
00001F08  2002      3294          move.l    D2,D0
00001F0A  E588      3295          lsl.l     #2,D0
00001F0C  41F9 0B00 3296          lea       _BreakPointSetOrCleared.L,A0
00001F10  015E      
00001F12  2030 0800 3297          move.l    0(A0,D0.L),D0
00001F16  0C80 0000 3298          cmp.l     #1,D0
00001F1A  0001      
00001F1C  6622      3299          bne.s     DisableBreakPoints_4
                    3300   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00001F1E  2002      3301          move.l    D2,D0
00001F20  E588      3302          lsl.l     #2,D0
00001F22  41F9 0B00 3303          lea       _BreakPointAddress.L,A0
00001F26  012E      
00001F28  2D70 0800 3304          move.l    0(A0,D0.L),-4(A6)
00001F2C  FFFC      
                    3305   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program overwritting the $4e4e
00001F2E  2002      3306          move.l    D2,D0
00001F30  E388      3307          lsl.l     #1,D0
00001F32  41F9 0B00 3308          lea       _BreakPointInstruction.L,A0
00001F36  014E      
00001F38  226E FFFC 3309          move.l    -4(A6),A1
00001F3C  32B0 0800 3310          move.w    0(A0,D0.L),(A1)
                    3311   DisableBreakPoints_4:
00001F40  5282      3312          addq.l    #1,D2
00001F42  60BA      3313          bra       DisableBreakPoints_1
                    3314   DisableBreakPoints_3:
00001F44  241F      3315          move.l    (A7)+,D2
00001F46  4E5E      3316          unlk      A6
00001F48  4E75      3317          rts
                    3318   ; }
                    3319   ; }
                    3320   ; }
                    3321   ; void EnableBreakPoints(void)
                    3322   ; {
                    3323   _EnableBreakPoints:
00001F4A  4E56 FFFC 3324          link      A6,#-4
00001F4E  2F02      3325          move.l    D2,-(A7)
                    3326   ; int i ;
                    3327   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3328   ; for(i = 0; i < 8; i++)  {
00001F50  4282      3329          clr.l     D2
                    3330   EnableBreakPoints_1:
00001F52  0C82 0000 3331          cmp.l     #8,D2
00001F56  0008      
00001F58  6C32      3332          bge.s     EnableBreakPoints_3
                    3333   ; if(BreakPointSetOrCleared[i] == 1)    {                                                     // if break point set
00001F5A  2002      3334          move.l    D2,D0
00001F5C  E588      3335          lsl.l     #2,D0
00001F5E  41F9 0B00 3336          lea       _BreakPointSetOrCleared.L,A0
00001F62  015E      
00001F64  2030 0800 3337          move.l    0(A0,D0.L),D0
00001F68  0C80 0000 3338          cmp.l     #1,D0
00001F6C  0001      
00001F6E  6618      3339          bne.s     EnableBreakPoints_4
                    3340   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00001F70  2002      3341          move.l    D2,D0
00001F72  E588      3342          lsl.l     #2,D0
00001F74  41F9 0B00 3343          lea       _BreakPointAddress.L,A0
00001F78  012E      
00001F7A  2D70 0800 3344          move.l    0(A0,D0.L),-4(A6)
00001F7E  FFFC      
                    3345   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e);                              // put the breakpoint back in user program
00001F80  206E FFFC 3346          move.l    -4(A6),A0
00001F84  30BC 4E4E 3347          move.w    #20046,(A0)
                    3348   EnableBreakPoints_4:
00001F88  5282      3349          addq.l    #1,D2
00001F8A  60C6      3350          bra       EnableBreakPoints_1
                    3351   EnableBreakPoints_3:
00001F8C  241F      3352          move.l    (A7)+,D2
00001F8E  4E5E      3353          unlk      A6
00001F90  4E75      3354          rts
                    3355   ; }
                    3356   ; }
                    3357   ; }
                    3358   ; void KillAllBreakPoints(void)
                    3359   ; {
                    3360   _KillAllBreakPoints:
00001F92  4E56 FFFC 3361          link      A6,#-4
00001F96  2F02      3362          move.l    D2,-(A7)
                    3363   ; int i ;
                    3364   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3365   ; for(i = 0; i < 8; i++)  {
00001F98  4282      3366          clr.l     D2
                    3367   KillAllBreakPoints_1:
00001F9A  0C82 0000 3368          cmp.l     #8,D2
00001F9E  0008      
00001FA0  6C00 0052 3369          bge       KillAllBreakPoints_3
                    3370   ; // clear BP
                    3371   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00001FA4  2002      3372          move.l    D2,D0
00001FA6  E588      3373          lsl.l     #2,D0
00001FA8  41F9 0B00 3374          lea       _BreakPointAddress.L,A0
00001FAC  012E      
00001FAE  2D70 0800 3375          move.l    0(A0,D0.L),-4(A6)
00001FB2  FFFC      
                    3376   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program
00001FB4  2002      3377          move.l    D2,D0
00001FB6  E388      3378          lsl.l     #1,D0
00001FB8  41F9 0B00 3379          lea       _BreakPointInstruction.L,A0
00001FBC  014E      
00001FBE  226E FFFC 3380          move.l    -4(A6),A1
00001FC2  32B0 0800 3381          move.w    0(A0,D0.L),(A1)
                    3382   ; BreakPointAddress[i] = 0 ;                                                             // set BP address to NULL
00001FC6  2002      3383          move.l    D2,D0
00001FC8  E588      3384          lsl.l     #2,D0
00001FCA  41F9 0B00 3385          lea       _BreakPointAddress.L,A0
00001FCE  012E      
00001FD0  42B0 0800 3386          clr.l     0(A0,D0.L)
                    3387   ; BreakPointInstruction[i] = 0 ;
00001FD4  2002      3388          move.l    D2,D0
00001FD6  E388      3389          lsl.l     #1,D0
00001FD8  41F9 0B00 3390          lea       _BreakPointInstruction.L,A0
00001FDC  014E      
00001FDE  4270 0800 3391          clr.w     0(A0,D0.L)
                    3392   ; BreakPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
00001FE2  2002      3393          move.l    D2,D0
00001FE4  E588      3394          lsl.l     #2,D0
00001FE6  41F9 0B00 3395          lea       _BreakPointSetOrCleared.L,A0
00001FEA  015E      
00001FEC  42B0 0800 3396          clr.l     0(A0,D0.L)
00001FF0  5282      3397          addq.l    #1,D2
00001FF2  60A6      3398          bra       KillAllBreakPoints_1
                    3399   KillAllBreakPoints_3:
00001FF4  241F      3400          move.l    (A7)+,D2
00001FF6  4E5E      3401          unlk      A6
00001FF8  4E75      3402          rts
                    3403   ; }
                    3404   ; //BreakPointDisplay() ;       // display the break points
                    3405   ; }
                    3406   ; void KillAllWatchPoints(void)
                    3407   ; {
                    3408   _KillAllWatchPoints:
00001FFA  2F02      3409          move.l    D2,-(A7)
                    3410   ; int i ;
                    3411   ; for(i = 0; i < 8; i++)  {
00001FFC  4282      3412          clr.l     D2
                    3413   KillAllWatchPoints_1:
00001FFE  0C82 0000 3414          cmp.l     #8,D2
00002002  0008      
00002004  6C20      3415          bge.s     KillAllWatchPoints_3
                    3416   ; WatchPointAddress[i] = 0 ;                                                             // set BP address to NULL
00002006  2002      3417          move.l    D2,D0
00002008  E588      3418          lsl.l     #2,D0
0000200A  41F9 0B00 3419          lea       _WatchPointAddress.L,A0
0000200E  0182      
00002010  42B0 0800 3420          clr.l     0(A0,D0.L)
                    3421   ; WatchPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
00002014  2002      3422          move.l    D2,D0
00002016  E588      3423          lsl.l     #2,D0
00002018  41F9 0B00 3424          lea       _WatchPointSetOrCleared.L,A0
0000201C  01A2      
0000201E  42B0 0800 3425          clr.l     0(A0,D0.L)
00002022  5282      3426          addq.l    #1,D2
00002024  60D8      3427          bra       KillAllWatchPoints_1
                    3428   KillAllWatchPoints_3:
00002026  241F      3429          move.l    (A7)+,D2
00002028  4E75      3430          rts
                    3431   ; }
                    3432   ; //WatchPointDisplay() ;       // display the break points
                    3433   ; }
                    3434   ; void SetBreakPoint(void)
                    3435   ; {
                    3436   _SetBreakPoint:
0000202A  4E56 FFFC 3437          link      A6,#-4
0000202E  48E7 3830 3438          movem.l   D2/D3/D4/A2/A3,-(A7)
00002032  45F9 0000 3439          lea       _printf.L,A2
00002036  3434      
00002038  47F9 0B00 3440          lea       _BreakPointSetOrCleared.L,A3
0000203C  015E      
                    3441   ; int i ;
                    3442   ; int BPNumber;
                    3443   ; int BPAddress;
                    3444   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3445   ; // see if any free break points
                    3446   ; for(i = 0; i < 8; i ++) {
0000203E  4282      3447          clr.l     D2
                    3448   SetBreakPoint_1:
00002040  0C82 0000 3449          cmp.l     #8,D2
00002044  0008      
00002046  6C10      3450          bge.s     SetBreakPoint_3
                    3451   ; if( BreakPointSetOrCleared[i] == 0)
00002048  2002      3452          move.l    D2,D0
0000204A  E588      3453          lsl.l     #2,D0
0000204C  2033 0800 3454          move.l    0(A3,D0.L),D0
00002050  6602      3455          bne.s     SetBreakPoint_4
                    3456   ; break ;         // if spare BP found allow user to set it
00002052  6004      3457          bra.s     SetBreakPoint_3
                    3458   SetBreakPoint_4:
00002054  5282      3459          addq.l    #1,D2
00002056  60E8      3460          bra       SetBreakPoint_1
                    3461   SetBreakPoint_3:
                    3462   ; }
                    3463   ; if(i == 8) {
00002058  0C82 0000 3464          cmp.l     #8,D2
0000205C  0008      
0000205E  660E      3465          bne.s     SetBreakPoint_6
                    3466   ; printf("\r\nNo FREE Break Points.....") ;
00002060  4879 0000 3467          pea       @m68kde~1_76.L
00002064  4518      
00002066  4E92      3468          jsr       (A2)
00002068  584F      3469          addq.w    #4,A7
                    3470   ; return ;
0000206A  6000 00D6 3471          bra       SetBreakPoint_15
                    3472   SetBreakPoint_6:
                    3473   ; }
                    3474   ; printf("\r\nBreak Point Address: ") ;
0000206E  4879 0000 3475          pea       @m68kde~1_77.L
00002072  4534      
00002074  4E92      3476          jsr       (A2)
00002076  584F      3477          addq.w    #4,A7
                    3478   ; BPAddress = Get8HexDigits(0) ;
00002078  42A7      3479          clr.l     -(A7)
0000207A  4EB8 0CD8 3480          jsr       _Get8HexDigits
0000207E  584F      3481          addq.w    #4,A7
00002080  2600      3482          move.l    D0,D3
                    3483   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BPAddress) ;     // point to the instruction in the user program we are about to change
00002082  2803      3484          move.l    D3,D4
                    3485   ; if((BPAddress & 0x00000001) == 0x00000001)  {   // cannot set BP at an odd address
00002084  2003      3486          move.l    D3,D0
00002086  C0BC 0000 3487          and.l     #1,D0
0000208A  0001      
0000208C  0C80 0000 3488          cmp.l     #1,D0
00002090  0001      
00002092  660E      3489          bne.s     SetBreakPoint_9
                    3490   ; printf("\r\nError : Break Points CANNOT be set at ODD addresses") ;
00002094  4879 0000 3491          pea       @m68kde~1_78.L
00002098  454C      
0000209A  4E92      3492          jsr       (A2)
0000209C  584F      3493          addq.w    #4,A7
                    3494   ; return ;
0000209E  6000 00A2 3495          bra       SetBreakPoint_15
                    3496   SetBreakPoint_9:
                    3497   ; }
                    3498   ; if(BPAddress < 0x00008000)  {   // cannot set BP in ROM
000020A2  0C83 0000 3499          cmp.l     #32768,D3
000020A6  8000      
000020A8  640E      3500          bhs.s     SetBreakPoint_11
                    3501   ; printf("\r\nError : Break Points CANNOT be set for ROM in Range : [$0-$00007FFF]") ;
000020AA  4879 0000 3502          pea       @m68kde~1_79.L
000020AE  4582      
000020B0  4E92      3503          jsr       (A2)
000020B2  584F      3504          addq.w    #4,A7
                    3505   ; return ;
000020B4  6000 008C 3506          bra       SetBreakPoint_15
                    3507   SetBreakPoint_11:
                    3508   ; }
                    3509   ; // search for first free bp or existing same BP
                    3510   ; for(i = 0; i < 8; i++)  {
000020B8  4282      3511          clr.l     D2
                    3512   SetBreakPoint_13:
000020BA  0C82 0000 3513          cmp.l     #8,D2
000020BE  0008      
000020C0  6C00 0080 3514          bge       SetBreakPoint_15
                    3515   ; if(BreakPointAddress[i] == BPAddress)   {
000020C4  2002      3516          move.l    D2,D0
000020C6  E588      3517          lsl.l     #2,D0
000020C8  41F9 0B00 3518          lea       _BreakPointAddress.L,A0
000020CC  012E      
000020CE  B6B0 0800 3519          cmp.l     0(A0,D0.L),D3
000020D2  6610      3520          bne.s     SetBreakPoint_16
                    3521   ; printf("\r\nError: Break Point Already Exists at Address : %08x\r\n", BPAddress) ;
000020D4  2F03      3522          move.l    D3,-(A7)
000020D6  4879 0000 3523          pea       @m68kde~1_80.L
000020DA  45CA      
000020DC  4E92      3524          jsr       (A2)
000020DE  504F      3525          addq.w    #8,A7
                    3526   ; return ;
000020E0  6000 0060 3527          bra       SetBreakPoint_15
                    3528   SetBreakPoint_16:
                    3529   ; }
                    3530   ; if(BreakPointSetOrCleared[i] == 0) {
000020E4  2002      3531          move.l    D2,D0
000020E6  E588      3532          lsl.l     #2,D0
000020E8  2033 0800 3533          move.l    0(A3,D0.L),D0
000020EC  6600 004E 3534          bne       SetBreakPoint_18
                    3535   ; // set BP here
                    3536   ; BreakPointSetOrCleared[i] = 1 ;                                 // mark this breakpoint as set
000020F0  2002      3537          move.l    D2,D0
000020F2  E588      3538          lsl.l     #2,D0
000020F4  27BC 0000 3539          move.l    #1,0(A3,D0.L)
000020F8  0001 0800 
                    3540   ; BreakPointInstruction[i] = *ProgramBreakPointAddress ;          // copy the user program instruction here so we can put it back afterwards
000020FC  2044      3541          move.l    D4,A0
000020FE  2002      3542          move.l    D2,D0
00002100  E388      3543          lsl.l     #1,D0
00002102  43F9 0B00 3544          lea       _BreakPointInstruction.L,A1
00002106  014E      
00002108  3390 0800 3545          move.w    (A0),0(A1,D0.L)
                    3546   ; printf("\r\nBreak Point Set at Address: [$%08x]", ProgramBreakPointAddress) ;
0000210C  2F04      3547          move.l    D4,-(A7)
0000210E  4879 0000 3548          pea       @m68kde~1_81.L
00002112  4602      
00002114  4E92      3549          jsr       (A2)
00002116  504F      3550          addq.w    #8,A7
                    3551   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e)    ;   // put a Trap14 instruction at the user specified address
00002118  2044      3552          move.l    D4,A0
0000211A  30BC 4E4E 3553          move.w    #20046,(A0)
                    3554   ; BreakPointAddress[i] = BPAddress ;                              // record the address of this break point in the debugger
0000211E  2002      3555          move.l    D2,D0
00002120  E588      3556          lsl.l     #2,D0
00002122  41F9 0B00 3557          lea       _BreakPointAddress.L,A0
00002126  012E      
00002128  2183 0800 3558          move.l    D3,0(A0,D0.L)
                    3559   ; printf("\r\n") ;
0000212C  4879 0000 3560          pea       @m68kde~1_1.L
00002130  3D84      
00002132  4E92      3561          jsr       (A2)
00002134  584F      3562          addq.w    #4,A7
                    3563   ; BreakPointDisplay() ;       // display the break points
00002136  4EB8 1BFA 3564          jsr       _BreakPointDisplay
                    3565   ; return ;
0000213A  6006      3566          bra.s     SetBreakPoint_15
                    3567   SetBreakPoint_18:
0000213C  5282      3568          addq.l    #1,D2
0000213E  6000 FF7A 3569          bra       SetBreakPoint_13
                    3570   SetBreakPoint_15:
00002142  4CDF 0C1C 3571          movem.l   (A7)+,D2/D3/D4/A2/A3
00002146  4E5E      3572          unlk      A6
00002148  4E75      3573          rts
                    3574   ; }
                    3575   ; }
                    3576   ; }
                    3577   ; void SetWatchPoint(void)
                    3578   ; {
                    3579   _SetWatchPoint:
0000214A  4E56 FFF8 3580          link      A6,#-8
0000214E  48E7 3030 3581          movem.l   D2/D3/A2/A3,-(A7)
00002152  45F9 0000 3582          lea       _printf.L,A2
00002156  3434      
00002158  47F9 0B00 3583          lea       _WatchPointSetOrCleared.L,A3
0000215C  01A2      
                    3584   ; int i ;
                    3585   ; int WPNumber;
                    3586   ; int WPAddress;
                    3587   ; volatile unsigned short int *ProgramWatchPointAddress ;
                    3588   ; // see if any free break points
                    3589   ; for(i = 0; i < 8; i ++) {
0000215E  4282      3590          clr.l     D2
                    3591   SetWatchPoint_1:
00002160  0C82 0000 3592          cmp.l     #8,D2
00002164  0008      
00002166  6C10      3593          bge.s     SetWatchPoint_3
                    3594   ; if( WatchPointSetOrCleared[i] == 0)
00002168  2002      3595          move.l    D2,D0
0000216A  E588      3596          lsl.l     #2,D0
0000216C  2033 0800 3597          move.l    0(A3,D0.L),D0
00002170  6602      3598          bne.s     SetWatchPoint_4
                    3599   ; break ;         // if spare WP found allow user to set it
00002172  6004      3600          bra.s     SetWatchPoint_3
                    3601   SetWatchPoint_4:
00002174  5282      3602          addq.l    #1,D2
00002176  60E8      3603          bra       SetWatchPoint_1
                    3604   SetWatchPoint_3:
                    3605   ; }
                    3606   ; if(i == 8) {
00002178  0C82 0000 3607          cmp.l     #8,D2
0000217C  0008      
0000217E  660E      3608          bne.s     SetWatchPoint_6
                    3609   ; printf("\r\nNo FREE Watch Points.....") ;
00002180  4879 0000 3610          pea       @m68kde~1_82.L
00002184  4628      
00002186  4E92      3611          jsr       (A2)
00002188  584F      3612          addq.w    #4,A7
                    3613   ; return ;
0000218A  6000 008C 3614          bra       SetWatchPoint_11
                    3615   SetWatchPoint_6:
                    3616   ; }
                    3617   ; printf("\r\nWatch Point Address: ") ;
0000218E  4879 0000 3618          pea       @m68kde~1_83.L
00002192  4644      
00002194  4E92      3619          jsr       (A2)
00002196  584F      3620          addq.w    #4,A7
                    3621   ; WPAddress = Get8HexDigits(0) ;
00002198  42A7      3622          clr.l     -(A7)
0000219A  4EB8 0CD8 3623          jsr       _Get8HexDigits
0000219E  584F      3624          addq.w    #4,A7
000021A0  2600      3625          move.l    D0,D3
                    3626   ; // search for first free wp or existing same wp
                    3627   ; for(i = 0; i < 8; i++)  {
000021A2  4282      3628          clr.l     D2
                    3629   SetWatchPoint_9:
000021A4  0C82 0000 3630          cmp.l     #8,D2
000021A8  0008      
000021AA  6C00 006C 3631          bge       SetWatchPoint_11
                    3632   ; if(WatchPointAddress[i] == WPAddress && WPAddress != 0)   {     //so we can set a wp at 0
000021AE  2002      3633          move.l    D2,D0
000021B0  E588      3634          lsl.l     #2,D0
000021B2  41F9 0B00 3635          lea       _WatchPointAddress.L,A0
000021B6  0182      
000021B8  B6B0 0800 3636          cmp.l     0(A0,D0.L),D3
000021BC  6614      3637          bne.s     SetWatchPoint_12
000021BE  4A83      3638          tst.l     D3
000021C0  6710      3639          beq.s     SetWatchPoint_12
                    3640   ; printf("\r\nError: Watch Point Already Set at Address : %08x\r\n", WPAddress) ;
000021C2  2F03      3641          move.l    D3,-(A7)
000021C4  4879 0000 3642          pea       @m68kde~1_84.L
000021C8  465C      
000021CA  4E92      3643          jsr       (A2)
000021CC  504F      3644          addq.w    #8,A7
                    3645   ; return ;
000021CE  6000 0048 3646          bra       SetWatchPoint_11
                    3647   SetWatchPoint_12:
                    3648   ; }
                    3649   ; if(WatchPointSetOrCleared[i] == 0) {
000021D2  2002      3650          move.l    D2,D0
000021D4  E588      3651          lsl.l     #2,D0
000021D6  2033 0800 3652          move.l    0(A3,D0.L),D0
000021DA  6600 0038 3653          bne       SetWatchPoint_14
                    3654   ; WatchPointSetOrCleared[i] = 1 ;                                 // mark this watchpoint as set
000021DE  2002      3655          move.l    D2,D0
000021E0  E588      3656          lsl.l     #2,D0
000021E2  27BC 0000 3657          move.l    #1,0(A3,D0.L)
000021E6  0001 0800 
                    3658   ; printf("\r\nWatch Point Set at Address: [$%08x]", WPAddress) ;
000021EA  2F03      3659          move.l    D3,-(A7)
000021EC  4879 0000 3660          pea       @m68kde~1_85.L
000021F0  4692      
000021F2  4E92      3661          jsr       (A2)
000021F4  504F      3662          addq.w    #8,A7
                    3663   ; WatchPointAddress[i] = WPAddress ;                              // record the address of this watch point in the debugger
000021F6  2002      3664          move.l    D2,D0
000021F8  E588      3665          lsl.l     #2,D0
000021FA  41F9 0B00 3666          lea       _WatchPointAddress.L,A0
000021FE  0182      
00002200  2183 0800 3667          move.l    D3,0(A0,D0.L)
                    3668   ; printf("\r\n") ;
00002204  4879 0000 3669          pea       @m68kde~1_1.L
00002208  3D84      
0000220A  4E92      3670          jsr       (A2)
0000220C  584F      3671          addq.w    #4,A7
                    3672   ; WatchPointDisplay() ;       // display the break points
0000220E  4EB8 1CCE 3673          jsr       _WatchPointDisplay
                    3674   ; return ;
00002212  6004      3675          bra.s     SetWatchPoint_11
                    3676   SetWatchPoint_14:
00002214  5282      3677          addq.l    #1,D2
00002216  608C      3678          bra       SetWatchPoint_9
                    3679   SetWatchPoint_11:
00002218  4CDF 0C0C 3680          movem.l   (A7)+,D2/D3/A2/A3
0000221C  4E5E      3681          unlk      A6
0000221E  4E75      3682          rts
                    3683   ; }
                    3684   ; }
                    3685   ; }
                    3686   ; void HandleBreakPoint(void)
                    3687   ; {
                    3688   _HandleBreakPoint:
00002220  4E56 FFFC 3689          link      A6,#-4
00002224  48E7 0038 3690          movem.l   A2/A3/A4,-(A7)
00002228  45F9 0B00 3691          lea       _i.L,A2
0000222C  00C4      
0000222E  47F9 0000 3692          lea       _printf.L,A3
00002232  3434      
00002234  49F9 0B00 3693          lea       _PC.L,A4
00002238  0120      
                    3694   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3695   ; // now we have to put the break point back to run the instruction
                    3696   ; // PC will contain the address of the TRAP instruction but advanced by two bytes so lets play with that
                    3697   ; PC = PC - 2 ;  // ready for user to resume after reaching breakpoint
0000223A  5594      3698          subq.l    #2,(A4)
                    3699   ; printf("\r\n\r\n\r\n\r\n@BREAKPOINT") ;
0000223C  4879 0000 3700          pea       @m68kde~1_86.L
00002240  46B8      
00002242  4E93      3701          jsr       (A3)
00002244  584F      3702          addq.w    #4,A7
                    3703   ; printf("\r\nSingle Step : [ON]") ;
00002246  4879 0000 3704          pea       @m68kde~1_87.L
0000224A  46CC      
0000224C  4E93      3705          jsr       (A3)
0000224E  584F      3706          addq.w    #4,A7
                    3707   ; printf("\r\nBreakPoints : [Enabled]") ;
00002250  4879 0000 3708          pea       @m68kde~1_88.L
00002254  46E2      
00002256  4E93      3709          jsr       (A3)
00002258  584F      3710          addq.w    #4,A7
                    3711   ; // now clear the break point (put original instruction back)
                    3712   ; ProgramBreakPointAddress = PC ;
0000225A  2D54 FFFC 3713          move.l    (A4),-4(A6)
                    3714   ; for(i = 0; i < 8; i ++) {
0000225E  4292      3715          clr.l     (A2)
                    3716   HandleBreakPoint_1:
00002260  2012      3717          move.l    (A2),D0
00002262  0C80 0000 3718          cmp.l     #8,D0
00002266  0008      
00002268  6400 0056 3719          bhs       HandleBreakPoint_3
                    3720   ; if(BreakPointAddress[i] == PC) {        // if we have found the breakpoint
0000226C  2012      3721          move.l    (A2),D0
0000226E  E588      3722          lsl.l     #2,D0
00002270  41F9 0B00 3723          lea       _BreakPointAddress.L,A0
00002274  012E      
00002276  2230 0800 3724          move.l    0(A0,D0.L),D1
0000227A  B294      3725          cmp.l     (A4),D1
0000227C  6600 003E 3726          bne       HandleBreakPoint_4
                    3727   ; BreakPointAddress[i] = 0 ;
00002280  2012      3728          move.l    (A2),D0
00002282  E588      3729          lsl.l     #2,D0
00002284  41F9 0B00 3730          lea       _BreakPointAddress.L,A0
00002288  012E      
0000228A  42B0 0800 3731          clr.l     0(A0,D0.L)
                    3732   ; BreakPointSetOrCleared[i] = 0 ;
0000228E  2012      3733          move.l    (A2),D0
00002290  E588      3734          lsl.l     #2,D0
00002292  41F9 0B00 3735          lea       _BreakPointSetOrCleared.L,A0
00002296  015E      
00002298  42B0 0800 3736          clr.l     0(A0,D0.L)
                    3737   ; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
0000229C  2012      3738          move.l    (A2),D0
0000229E  E388      3739          lsl.l     #1,D0
000022A0  41F9 0B00 3740          lea       _BreakPointInstruction.L,A0
000022A4  014E      
000022A6  226E FFFC 3741          move.l    -4(A6),A1
000022AA  32B0 0800 3742          move.w    0(A0,D0.L),(A1)
                    3743   ; BreakPointInstruction[i] = 0 ;
000022AE  2012      3744          move.l    (A2),D0
000022B0  E388      3745          lsl.l     #1,D0
000022B2  41F9 0B00 3746          lea       _BreakPointInstruction.L,A0
000022B6  014E      
000022B8  4270 0800 3747          clr.w     0(A0,D0.L)
                    3748   HandleBreakPoint_4:
000022BC  5292      3749          addq.l    #1,(A2)
000022BE  60A0      3750          bra       HandleBreakPoint_1
                    3751   HandleBreakPoint_3:
                    3752   ; }
                    3753   ; }
                    3754   ; DumpRegisters() ;
000022C0  4EB8 144C 3755          jsr       _DumpRegisters
                    3756   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
000022C4  4879 0000 3757          pea       @m68kde~1_50.L
000022C8  425E      
000022CA  4E93      3758          jsr       (A3)
000022CC  584F      3759          addq.w    #4,A7
                    3760   ; printf("\r\nPress <ESC> to Resume User Program\r\n") ;
000022CE  4879 0000 3761          pea       @m68kde~1_89.L
000022D2  46FC      
000022D4  4E93      3762          jsr       (A3)
000022D6  584F      3763          addq.w    #4,A7
                    3764   ; menu() ;
000022D8  4EB9 0000 3765          jsr       _menu
000022DC  24E4      
000022DE  4CDF 1C00 3766          movem.l   (A7)+,A2/A3/A4
000022E2  4E5E      3767          unlk      A6
000022E4  4E75      3768          rts
                    3769   ; }
                    3770   ; void UnknownCommand()
                    3771   ; {
                    3772   _UnknownCommand:
                    3773   ; printf("\r\nUnknown Command.....\r\n") ;
000022E6  4879 0000 3774          pea       @m68kde~1_90.L
000022EA  4724      
000022EC  4EB9 0000 3775          jsr       _printf
000022F0  3434      
000022F2  584F      3776          addq.w    #4,A7
                    3777   ; Help() ;
000022F4  4EB9 0000 3778          jsr       _Help
000022F8  240A      
000022FA  4E75      3779          rts
                    3780   ; }
                    3781   ; // system when the users program executes a TRAP #15 instruction to halt program and return to debug monitor
                    3782   ; void CallDebugMonitor(void)
                    3783   ; {
                    3784   _CallDebugMonitor:
                    3785   ; printf("\r\nProgram Ended (TRAP #15)....") ;
000022FC  4879 0000 3786          pea       @m68kde~1_91.L
00002300  473E      
00002302  4EB9 0000 3787          jsr       _printf
00002306  3434      
00002308  584F      3788          addq.w    #4,A7
                    3789   ; menu();
0000230A  4EB9 0000 3790          jsr       _menu
0000230E  24E4      
00002310  4E75      3791          rts
                    3792   ; }
                    3793   ; void Breakpoint(void)
                    3794   ; {
                    3795   _Breakpoint:
00002312  2F02      3796          move.l    D2,-(A7)
                    3797   ; char c;
                    3798   ; c = toupper(_getch());
00002314  2F00      3799          move.l    D0,-(A7)
00002316  4EB8 0B68 3800          jsr       __getch
0000231A  2200      3801          move.l    D0,D1
0000231C  201F      3802          move.l    (A7)+,D0
0000231E  2F01      3803          move.l    D1,-(A7)
00002320  4EB9 0000 3804          jsr       _toupper
00002324  3408      
00002326  584F      3805          addq.w    #4,A7
00002328  1400      3806          move.b    D0,D2
                    3807   ; if( c == (char)('D'))                                      // BreakPoint Display
0000232A  0C02 0044 3808          cmp.b     #68,D2
0000232E  6608      3809          bne.s     Breakpoint_1
                    3810   ; BreakPointDisplay() ;
00002330  4EB8 1BFA 3811          jsr       _BreakPointDisplay
00002334  6000 0054 3812          bra       Breakpoint_10
                    3813   Breakpoint_1:
                    3814   ; else if(c == (char)('K')) {                                 // breakpoint Kill
00002338  0C02 004B 3815          cmp.b     #75,D2
0000233C  6630      3816          bne.s     Breakpoint_3
                    3817   ; printf("\r\nKill All Break Points...(y/n)?") ;
0000233E  4879 0000 3818          pea       @m68kde~1_92.L
00002342  475E      
00002344  4EB9 0000 3819          jsr       _printf
00002348  3434      
0000234A  584F      3820          addq.w    #4,A7
                    3821   ; c = toupper(_getch());
0000234C  2F00      3822          move.l    D0,-(A7)
0000234E  4EB8 0B68 3823          jsr       __getch
00002352  2200      3824          move.l    D0,D1
00002354  201F      3825          move.l    (A7)+,D0
00002356  2F01      3826          move.l    D1,-(A7)
00002358  4EB9 0000 3827          jsr       _toupper
0000235C  3408      
0000235E  584F      3828          addq.w    #4,A7
00002360  1400      3829          move.b    D0,D2
                    3830   ; if(c == (char)('Y'))
00002362  0C02 0059 3831          cmp.b     #89,D2
00002366  6604      3832          bne.s     Breakpoint_5
                    3833   ; KillAllBreakPoints() ;
00002368  4EB8 1F92 3834          jsr       _KillAllBreakPoints
                    3835   Breakpoint_5:
0000236C  601C      3836          bra.s     Breakpoint_10
                    3837   Breakpoint_3:
                    3838   ; }
                    3839   ; else if(c == (char)('S')) {
0000236E  0C02 0053 3840          cmp.b     #83,D2
00002372  6606      3841          bne.s     Breakpoint_7
                    3842   ; SetBreakPoint() ;
00002374  4EB8 202A 3843          jsr       _SetBreakPoint
00002378  6010      3844          bra.s     Breakpoint_10
                    3845   Breakpoint_7:
                    3846   ; }
                    3847   ; else if(c == (char)('C')) {
0000237A  0C02 0043 3848          cmp.b     #67,D2
0000237E  6606      3849          bne.s     Breakpoint_9
                    3850   ; BreakPointClear() ;
00002380  4EB8 1D7A 3851          jsr       _BreakPointClear
00002384  6004      3852          bra.s     Breakpoint_10
                    3853   Breakpoint_9:
                    3854   ; }
                    3855   ; else
                    3856   ; UnknownCommand() ;
00002386  4EB8 22E6 3857          jsr       _UnknownCommand
                    3858   Breakpoint_10:
0000238A  241F      3859          move.l    (A7)+,D2
0000238C  4E75      3860          rts
                    3861   ; }
                    3862   ; void Watchpoint(void)
                    3863   ; {
                    3864   _Watchpoint:
0000238E  2F02      3865          move.l    D2,-(A7)
                    3866   ; char c;
                    3867   ; c = toupper(_getch());
00002390  2F00      3868          move.l    D0,-(A7)
00002392  4EB8 0B68 3869          jsr       __getch
00002396  2200      3870          move.l    D0,D1
00002398  201F      3871          move.l    (A7)+,D0
0000239A  2F01      3872          move.l    D1,-(A7)
0000239C  4EB9 0000 3873          jsr       _toupper
000023A0  3408      
000023A2  584F      3874          addq.w    #4,A7
000023A4  1400      3875          move.b    D0,D2
                    3876   ; if( c == (char)('D'))                                      // WatchPoint Display
000023A6  0C02 0044 3877          cmp.b     #68,D2
000023AA  6608      3878          bne.s     Watchpoint_1
                    3879   ; WatchPointDisplay() ;
000023AC  4EB8 1CCE 3880          jsr       _WatchPointDisplay
000023B0  6000 0054 3881          bra       Watchpoint_10
                    3882   Watchpoint_1:
                    3883   ; else if(c == (char)('K')) {                                 // wtahcpoint Kill
000023B4  0C02 004B 3884          cmp.b     #75,D2
000023B8  6630      3885          bne.s     Watchpoint_3
                    3886   ; printf("\r\nKill All Watch Points...(y/n)?") ;
000023BA  4879 0000 3887          pea       @m68kde~1_93.L
000023BE  4780      
000023C0  4EB9 0000 3888          jsr       _printf
000023C4  3434      
000023C6  584F      3889          addq.w    #4,A7
                    3890   ; c = toupper(_getch());
000023C8  2F00      3891          move.l    D0,-(A7)
000023CA  4EB8 0B68 3892          jsr       __getch
000023CE  2200      3893          move.l    D0,D1
000023D0  201F      3894          move.l    (A7)+,D0
000023D2  2F01      3895          move.l    D1,-(A7)
000023D4  4EB9 0000 3896          jsr       _toupper
000023D8  3408      
000023DA  584F      3897          addq.w    #4,A7
000023DC  1400      3898          move.b    D0,D2
                    3899   ; if(c == (char)('Y'))
000023DE  0C02 0059 3900          cmp.b     #89,D2
000023E2  6604      3901          bne.s     Watchpoint_5
                    3902   ; KillAllWatchPoints() ;
000023E4  4EB8 1FFA 3903          jsr       _KillAllWatchPoints
                    3904   Watchpoint_5:
000023E8  601C      3905          bra.s     Watchpoint_10
                    3906   Watchpoint_3:
                    3907   ; }
                    3908   ; else if(c == (char)('S')) {
000023EA  0C02 0053 3909          cmp.b     #83,D2
000023EE  6606      3910          bne.s     Watchpoint_7
                    3911   ; SetWatchPoint() ;
000023F0  4EB8 214A 3912          jsr       _SetWatchPoint
000023F4  6010      3913          bra.s     Watchpoint_10
                    3914   Watchpoint_7:
                    3915   ; }
                    3916   ; else if(c == (char)('C')) {
000023F6  0C02 0043 3917          cmp.b     #67,D2
000023FA  6606      3918          bne.s     Watchpoint_9
                    3919   ; WatchPointClear() ;
000023FC  4EB8 1E54 3920          jsr       _WatchPointClear
00002400  6004      3921          bra.s     Watchpoint_10
                    3922   Watchpoint_9:
                    3923   ; }
                    3924   ; else
                    3925   ; UnknownCommand() ;
00002402  4EB8 22E6 3926          jsr       _UnknownCommand
                    3927   Watchpoint_10:
00002406  241F      3928          move.l    (A7)+,D2
00002408  4E75      3929          rts
                    3930   ; }
                    3931   ; void Help(void)
                    3932   ; {
                    3933   _Help:
0000240A  48E7 2020 3934          movem.l   D2/A2,-(A7)
0000240E  45F9 0000 3935          lea       _printf.L,A2
00002412  3434      
                    3936   ; char *banner = "\r\n----------------------------------------------------------------" ;
00002414  41F9 0000 3937          lea       @m68kde~1_94.L,A0
00002418  47A2      
0000241A  2408      3938          move.l    A0,D2
                    3939   ; printf(banner) ;
0000241C  2F02      3940          move.l    D2,-(A7)
0000241E  4E92      3941          jsr       (A2)
00002420  584F      3942          addq.w    #4,A7
                    3943   ; printf("\r\n  Debugger Command Summary") ;
00002422  4879 0000 3944          pea       @m68kde~1_95.L
00002426  47E6      
00002428  4E92      3945          jsr       (A2)
0000242A  584F      3946          addq.w    #4,A7
                    3947   ; printf(banner) ;
0000242C  2F02      3948          move.l    D2,-(A7)
0000242E  4E92      3949          jsr       (A2)
00002430  584F      3950          addq.w    #4,A7
                    3951   ; printf("\r\n  .(reg)       - Change Registers: e.g A0-A7,D0-D7,PC,SSP,USP,SR");
00002432  4879 0000 3952          pea       @m68kde~1_96.L
00002436  4804      
00002438  4E92      3953          jsr       (A2)
0000243A  584F      3954          addq.w    #4,A7
                    3955   ; printf("\r\n  BD/BS/BC/BK  - Break Point: Display/Set/Clear/Kill") ;
0000243C  4879 0000 3956          pea       @m68kde~1_97.L
00002440  4848      
00002442  4E92      3957          jsr       (A2)
00002444  584F      3958          addq.w    #4,A7
                    3959   ; printf("\r\n  C            - Copy Program from Flash to Main Memory") ;
00002446  4879 0000 3960          pea       @m68kde~1_98.L
0000244A  4880      
0000244C  4E92      3961          jsr       (A2)
0000244E  584F      3962          addq.w    #4,A7
                    3963   ; printf("\r\n  D            - Dump Memory Contents to Screen") ;
00002450  4879 0000 3964          pea       @m68kde~1_99.L
00002454  48BA      
00002456  4E92      3965          jsr       (A2)
00002458  584F      3966          addq.w    #4,A7
                    3967   ; printf("\r\n  E            - Enter String into Memory") ;
0000245A  4879 0000 3968          pea       @m68kde~1_100.L
0000245E  48EC      
00002460  4E92      3969          jsr       (A2)
00002462  584F      3970          addq.w    #4,A7
                    3971   ; printf("\r\n  F            - Fill Memory with Data") ;
00002464  4879 0000 3972          pea       @m68kde~1_101.L
00002468  4918      
0000246A  4E92      3973          jsr       (A2)
0000246C  584F      3974          addq.w    #4,A7
                    3975   ; printf("\r\n  G            - Go Program Starting at Address: $%08X", PC) ;
0000246E  2F39 0B00 3976          move.l    _PC.L,-(A7)
00002472  0120      
00002474  4879 0000 3977          pea       @m68kde~1_102.L
00002478  4942      
0000247A  4E92      3978          jsr       (A2)
0000247C  504F      3979          addq.w    #8,A7
                    3980   ; printf("\r\n  L            - Load Program (.HEX file) from Laptop") ;
0000247E  4879 0000 3981          pea       @m68kde~1_103.L
00002482  497C      
00002484  4E92      3982          jsr       (A2)
00002486  584F      3983          addq.w    #4,A7
                    3984   ; printf("\r\n  M            - Memory Examine and Change");
00002488  4879 0000 3985          pea       @m68kde~1_104.L
0000248C  49B4      
0000248E  4E92      3986          jsr       (A2)
00002490  584F      3987          addq.w    #4,A7
                    3988   ; printf("\r\n  P            - Program Flash Memory with User Program") ;
00002492  4879 0000 3989          pea       @m68kde~1_105.L
00002496  49E2      
00002498  4E92      3990          jsr       (A2)
0000249A  584F      3991          addq.w    #4,A7
                    3992   ; printf("\r\n  R            - Display 68000 Registers") ;
0000249C  4879 0000 3993          pea       @m68kde~1_106.L
000024A0  4A1C      
000024A2  4E92      3994          jsr       (A2)
000024A4  584F      3995          addq.w    #4,A7
                    3996   ; printf("\r\n  S            - Toggle ON/OFF Single Step Mode") ;
000024A6  4879 0000 3997          pea       @m68kde~1_107.L
000024AA  4A48      
000024AC  4E92      3998          jsr       (A2)
000024AE  584F      3999          addq.w    #4,A7
                    4000   ; printf("\r\n  TM           - Test Memory") ;
000024B0  4879 0000 4001          pea       @m68kde~1_108.L
000024B4  4A7A      
000024B6  4E92      4002          jsr       (A2)
000024B8  584F      4003          addq.w    #4,A7
                    4004   ; printf("\r\n  TS           - Test Switches: SW7-0") ;
000024BA  4879 0000 4005          pea       @m68kde~1_109.L
000024BE  4A9A      
000024C0  4E92      4006          jsr       (A2)
000024C2  584F      4007          addq.w    #4,A7
                    4008   ; printf("\r\n  TD           - Test Displays: LEDs and 7-Segment") ;
000024C4  4879 0000 4009          pea       @m68kde~1_110.L
000024C8  4AC2      
000024CA  4E92      4010          jsr       (A2)
000024CC  584F      4011          addq.w    #4,A7
                    4012   ; printf("\r\n  WD/WS/WC/WK  - Watch Point: Display/Set/Clear/Kill") ;
000024CE  4879 0000 4013          pea       @m68kde~1_111.L
000024D2  4AF8      
000024D4  4E92      4014          jsr       (A2)
000024D6  584F      4015          addq.w    #4,A7
                    4016   ; printf(banner) ;
000024D8  2F02      4017          move.l    D2,-(A7)
000024DA  4E92      4018          jsr       (A2)
000024DC  584F      4019          addq.w    #4,A7
000024DE  4CDF 0404 4020          movem.l   (A7)+,D2/A2
000024E2  4E75      4021          rts
                    4022   ; }
                    4023   ; void menu(void)
                    4024   ; {
                    4025   _menu:
000024E4  48E7 303C 4026          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
000024E8  45F9 0000 4027          lea       _printf.L,A2
000024EC  3434      
000024EE  47F9 0B00 4028          lea       _Trace.L,A3
000024F2  00D8      
000024F4  49F9 0B00 4029          lea       _x.L,A4
000024F8  00C8      
000024FA  4BF9 0B00 4030          lea       _SR.L,A5
000024FE  012C      
                    4031   ; char c,c1 ;
                    4032   ; while(1)    {
                    4033   menu_1:
                    4034   ; FlushKeyboard() ;               // dump unread characters from keyboard
00002500  4EB8 0BA6 4035          jsr       _FlushKeyboard
                    4036   ; printf("\r\n#") ;
00002504  4879 0000 4037          pea       @m68kde~1_112.L
00002508  4B30      
0000250A  4E92      4038          jsr       (A2)
0000250C  584F      4039          addq.w    #4,A7
                    4040   ; c = toupper(_getch());
0000250E  2F00      4041          move.l    D0,-(A7)
00002510  4EB8 0B68 4042          jsr       __getch
00002514  2200      4043          move.l    D0,D1
00002516  201F      4044          move.l    (A7)+,D0
00002518  2F01      4045          move.l    D1,-(A7)
0000251A  4EB9 0000 4046          jsr       _toupper
0000251E  3408      
00002520  584F      4047          addq.w    #4,A7
00002522  1400      4048          move.b    D0,D2
                    4049   ; if( c == (char)('L'))                  // load s record file
00002524  0C02 004C 4050          cmp.b     #76,D2
00002528  6608      4051          bne.s     menu_4
                    4052   ; Load_SRecordFile() ;
0000252A  4EB8 0E6A 4053          jsr       _Load_SRecordFile
0000252E  6000 021E 4054          bra       menu_46
                    4055   menu_4:
                    4056   ; else if( c == (char)('D'))             // dump memory
00002532  0C02 0044 4057          cmp.b     #68,D2
00002536  6608      4058          bne.s     menu_6
                    4059   ; DumpMemory() ;
00002538  4EB8 0D00 4060          jsr       _DumpMemory
0000253C  6000 0210 4061          bra       menu_46
                    4062   menu_6:
                    4063   ; else if( c == (char)('E'))             // Enter String into memory
00002540  0C02 0045 4064          cmp.b     #69,D2
00002544  660A      4065          bne.s     menu_8
                    4066   ; EnterString() ;
00002546  4EB9 0000 4067          jsr       _EnterString
0000254A  2896      
0000254C  6000 0200 4068          bra       menu_46
                    4069   menu_8:
                    4070   ; else if( c == (char)('F'))             // fill memory
00002550  0C02 0046 4071          cmp.b     #70,D2
00002554  6608      4072          bne.s     menu_10
                    4073   ; FillMemory() ;
00002556  4EB8 0DF0 4074          jsr       _FillMemory
0000255A  6000 01F2 4075          bra       menu_46
                    4076   menu_10:
                    4077   ; else if( c == (char)('G'))  {           // go user program
0000255E  0C02 0047 4078          cmp.b     #71,D2
00002562  6626      4079          bne.s     menu_12
                    4080   ; printf("\r\nProgram Running.....") ;
00002564  4879 0000 4081          pea       @m68kde~1_113.L
00002568  4B34      
0000256A  4E92      4082          jsr       (A2)
0000256C  584F      4083          addq.w    #4,A7
                    4084   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop") ;
0000256E  4879 0000 4085          pea       @m68kde~1_114.L
00002572  4B4C      
00002574  4E92      4086          jsr       (A2)
00002576  584F      4087          addq.w    #4,A7
                    4088   ; GoFlag = 1 ;
00002578  23FC 0000 4089          move.l    #1,_GoFlag.L
0000257C  0001 0B00 
00002580  00DC      
                    4090   ; go() ;
00002582  4EB8 08B8 4091          jsr       _go
00002586  6000 01C6 4092          bra       menu_46
                    4093   menu_12:
                    4094   ; }
                    4095   ; else if( c == (char)('M'))           // memory examine and modify
0000258A  0C02 004D 4096          cmp.b     #77,D2
0000258E  6608      4097          bne.s     menu_14
                    4098   ; MemoryChange() ;
00002590  4EB8 0FF8 4099          jsr       _MemoryChange
00002594  6000 01B8 4100          bra       menu_46
                    4101   menu_14:
                    4102   ; else if( c == (char)('P'))            // Program Flash Chip
00002598  0C02 0050 4103          cmp.b     #80,D2
0000259C  6608      4104          bne.s     menu_16
                    4105   ; ProgramFlashChip() ;
0000259E  4EB8 13BE 4106          jsr       _ProgramFlashChip
000025A2  6000 01AA 4107          bra       menu_46
                    4108   menu_16:
                    4109   ; else if( c == (char)('C'))             // copy flash chip to ram and go
000025A6  0C02 0043 4110          cmp.b     #67,D2
000025AA  6608      4111          bne.s     menu_18
                    4112   ; LoadFromFlashChip();
000025AC  4EB8 1434 4113          jsr       _LoadFromFlashChip
000025B0  6000 019C 4114          bra       menu_46
                    4115   menu_18:
                    4116   ; else if( c == (char)('R'))             // dump registers
000025B4  0C02 0052 4117          cmp.b     #82,D2
000025B8  6608      4118          bne.s     menu_20
                    4119   ; DumpRegisters() ;
000025BA  4EB8 144C 4120          jsr       _DumpRegisters
000025BE  6000 018E 4121          bra       menu_46
                    4122   menu_20:
                    4123   ; else if( c == (char)('.'))           // change registers
000025C2  0C02 002E 4124          cmp.b     #46,D2
000025C6  6608      4125          bne.s     menu_22
                    4126   ; ChangeRegisters() ;
000025C8  4EB8 193E 4127          jsr       _ChangeRegisters
000025CC  6000 0180 4128          bra       menu_46
                    4129   menu_22:
                    4130   ; else if( c == (char)('B'))              // breakpoint command
000025D0  0C02 0042 4131          cmp.b     #66,D2
000025D4  6608      4132          bne.s     menu_24
                    4133   ; Breakpoint() ;
000025D6  4EB8 2312 4134          jsr       _Breakpoint
000025DA  6000 0172 4135          bra       menu_46
                    4136   menu_24:
                    4137   ; else if( c == (char)('T'))  {          // Test command
000025DE  0C02 0054 4138          cmp.b     #84,D2
000025E2  6600 0046 4139          bne       menu_26
                    4140   ; c1 = toupper(_getch()) ;
000025E6  2F00      4141          move.l    D0,-(A7)
000025E8  4EB8 0B68 4142          jsr       __getch
000025EC  2200      4143          move.l    D0,D1
000025EE  201F      4144          move.l    (A7)+,D0
000025F0  2F01      4145          move.l    D1,-(A7)
000025F2  4EB9 0000 4146          jsr       _toupper
000025F6  3408      
000025F8  584F      4147          addq.w    #4,A7
000025FA  1600      4148          move.b    D0,D3
                    4149   ; if(c1 == (char)('M'))                    // memory test
000025FC  0C03 004D 4150          cmp.b     #77,D3
00002600  6608      4151          bne.s     menu_28
                    4152   ; MemoryTest() ;
00002602  4EB9 0000 4153          jsr       _MemoryTest
00002606  2E16      
00002608  601C      4154          bra.s     menu_33
                    4155   menu_28:
                    4156   ; else if( c1 == (char)('S'))              // Switch Test command
0000260A  0C03 0053 4157          cmp.b     #83,D3
0000260E  6606      4158          bne.s     menu_30
                    4159   ; SwitchTest() ;
00002610  4EB8 0AA4 4160          jsr       _SwitchTest
00002614  6010      4161          bra.s     menu_33
                    4162   menu_30:
                    4163   ; else if( c1 == (char)('D'))              // display Test command
00002616  0C03 0044 4164          cmp.b     #68,D3
0000261A  6606      4165          bne.s     menu_32
                    4166   ; TestLEDS() ;
0000261C  4EB8 0A50 4167          jsr       _TestLEDS
00002620  6004      4168          bra.s     menu_33
                    4169   menu_32:
                    4170   ; else
                    4171   ; UnknownCommand() ;
00002622  4EB8 22E6 4172          jsr       _UnknownCommand
                    4173   menu_33:
00002626  6000 0126 4174          bra       menu_46
                    4175   menu_26:
                    4176   ; }
                    4177   ; else if( c == (char)(' ')) {             // Next instruction command
0000262A  0C02 0020 4178          cmp.b     #32,D2
0000262E  6636      4179          bne.s     menu_34
                    4180   ; DisableBreakPoints() ;
00002630  4EB8 1EF6 4181          jsr       _DisableBreakPoints
                    4182   ; if(Trace == 1 && GoFlag == 1)   {    // if the program is running and trace mode on then 'N' is valid
00002634  2013      4183          move.l    (A3),D0
00002636  0C80 0000 4184          cmp.l     #1,D0
0000263A  0001      
0000263C  661A      4185          bne.s     menu_36
0000263E  2039 0B00 4186          move.l    _GoFlag.L,D0
00002642  00DC      
00002644  0C80 0000 4187          cmp.l     #1,D0
00002648  0001      
0000264A  660C      4188          bne.s     menu_36
                    4189   ; TraceException = 1 ;             // generate a trace exception for the next instruction if user wants to single step though next instruction
0000264C  13FC 0001 4190          move.b    #1,4194314
00002650  0040 000A 
                    4191   ; return ;
00002654  6000 00FC 4192          bra       menu_38
                    4193   menu_36:
                    4194   ; }
                    4195   ; else
                    4196   ; printf("\r\nError: Press 'G' first to start program") ;
00002658  4879 0000 4197          pea       @m68kde~1_115.L
0000265C  4B7A      
0000265E  4E92      4198          jsr       (A2)
00002660  584F      4199          addq.w    #4,A7
00002662  6000 00EA 4200          bra       menu_46
                    4201   menu_34:
                    4202   ; }
                    4203   ; else if( c == (char)('S')) {             // single step
00002666  0C02 0053 4204          cmp.b     #83,D2
0000266A  6600 008C 4205          bne       menu_39
                    4206   ; if(Trace == 0) {
0000266E  2013      4207          move.l    (A3),D0
00002670  6600 0050 4208          bne       menu_41
                    4209   ; DisableBreakPoints() ;
00002674  4EB8 1EF6 4210          jsr       _DisableBreakPoints
                    4211   ; printf("\r\nSingle Step  :[ON]") ;
00002678  4879 0000 4212          pea       @m68kde~1_116.L
0000267C  4BA4      
0000267E  4E92      4213          jsr       (A2)
00002680  584F      4214          addq.w    #4,A7
                    4215   ; printf("\r\nBreak Points :[Disabled]") ;
00002682  4879 0000 4216          pea       @m68kde~1_49.L
00002686  4242      
00002688  4E92      4217          jsr       (A2)
0000268A  584F      4218          addq.w    #4,A7
                    4219   ; SR = SR | (unsigned short int)(0x8000) ;    // set T bit in status register
0000268C  0055 8000 4220          or.w      #32768,(A5)
                    4221   ; printf("\r\nPress 'G' to Trace Program from address $%X.....",PC) ;
00002690  2F39 0B00 4222          move.l    _PC.L,-(A7)
00002694  0120      
00002696  4879 0000 4223          pea       @m68kde~1_117.L
0000269A  4BBA      
0000269C  4E92      4224          jsr       (A2)
0000269E  504F      4225          addq.w    #8,A7
                    4226   ; printf("\r\nPush <RESET Button> to Stop.....") ;
000026A0  4879 0000 4227          pea       @m68kde~1_118.L
000026A4  4BEE      
000026A6  4E92      4228          jsr       (A2)
000026A8  584F      4229          addq.w    #4,A7
                    4230   ; DumpRegisters() ;
000026AA  4EB8 144C 4231          jsr       _DumpRegisters
                    4232   ; Trace = 1;
000026AE  26BC 0000 4233          move.l    #1,(A3)
000026B2  0001      
                    4234   ; TraceException = 1;
000026B4  13FC 0001 4235          move.b    #1,4194314
000026B8  0040 000A 
                    4236   ; x = *(unsigned int *)(0x00000074) ;       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
000026BC  28B8 0074 4237          move.l    116,(A4)
000026C0  6032      4238          bra.s     menu_42
                    4239   menu_41:
                    4240   ; }
                    4241   ; else {
                    4242   ; Trace = 0 ;
000026C2  4293      4243          clr.l     (A3)
                    4244   ; TraceException = 0 ;
000026C4  4239 0040 4245          clr.b     4194314
000026C8  000A      
                    4246   ; x = *(unsigned int *)(0x00000074) ;       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
000026CA  28B8 0074 4247          move.l    116,(A4)
                    4248   ; EnableBreakPoints() ;
000026CE  4EB8 1F4A 4249          jsr       _EnableBreakPoints
                    4250   ; SR = SR & (unsigned short int)(0x7FFF) ;    // clear T bit in status register
000026D2  0255 7FFF 4251          and.w     #32767,(A5)
                    4252   ; printf("\r\nSingle Step : [OFF]") ;
000026D6  4879 0000 4253          pea       @m68kde~1_119.L
000026DA  4C12      
000026DC  4E92      4254          jsr       (A2)
000026DE  584F      4255          addq.w    #4,A7
                    4256   ; printf("\r\nBreak Points :[Enabled]") ;
000026E0  4879 0000 4257          pea       @m68kde~1_120.L
000026E4  4C28      
000026E6  4E92      4258          jsr       (A2)
000026E8  584F      4259          addq.w    #4,A7
                    4260   ; printf("\r\nPress <ESC> to Resume User Program.....") ;
000026EA  4879 0000 4261          pea       @m68kde~1_121.L
000026EE  4C42      
000026F0  4E92      4262          jsr       (A2)
000026F2  584F      4263          addq.w    #4,A7
                    4264   menu_42:
000026F4  6000 0058 4265          bra       menu_46
                    4266   menu_39:
                    4267   ; }
                    4268   ; }
                    4269   ; else if(c == (char)(0x1b))  {   // if user choses to end trace and run program
000026F8  0C02 001B 4270          cmp.b     #27,D2
000026FC  6600 0040 4271          bne       menu_43
                    4272   ; Trace = 0;
00002700  4293      4273          clr.l     (A3)
                    4274   ; TraceException = 0;
00002702  4239 0040 4275          clr.b     4194314
00002706  000A      
                    4276   ; x = *(unsigned int *)(0x00000074) ;   // read IRQ 5 vector to reset trace vector generator
00002708  28B8 0074 4277          move.l    116,(A4)
                    4278   ; EnableBreakPoints() ;
0000270C  4EB8 1F4A 4279          jsr       _EnableBreakPoints
                    4280   ; SR = SR & (unsigned short int)(0x7FFF) ;    // clear T bit in status register
00002710  0255 7FFF 4281          and.w     #32767,(A5)
                    4282   ; printf("\r\nSingle Step  :[OFF]") ;
00002714  4879 0000 4283          pea       @m68kde~1_122.L
00002718  4C6C      
0000271A  4E92      4284          jsr       (A2)
0000271C  584F      4285          addq.w    #4,A7
                    4286   ; printf("\r\nBreak Points :[Enabled]");
0000271E  4879 0000 4287          pea       @m68kde~1_120.L
00002722  4C28      
00002724  4E92      4288          jsr       (A2)
00002726  584F      4289          addq.w    #4,A7
                    4290   ; printf("\r\nProgram Running.....") ;
00002728  4879 0000 4291          pea       @m68kde~1_113.L
0000272C  4B34      
0000272E  4E92      4292          jsr       (A2)
00002730  584F      4293          addq.w    #4,A7
                    4294   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop") ;
00002732  4879 0000 4295          pea       @m68kde~1_114.L
00002736  4B4C      
00002738  4E92      4296          jsr       (A2)
0000273A  584F      4297          addq.w    #4,A7
                    4298   ; return ;
0000273C  6014      4299          bra.s     menu_38
                    4300   menu_43:
                    4301   ; }
                    4302   ; else if( c == (char)('W'))              // Watchpoint command
0000273E  0C02 0057 4303          cmp.b     #87,D2
00002742  6606      4304          bne.s     menu_45
                    4305   ; Watchpoint() ;
00002744  4EB8 238E 4306          jsr       _Watchpoint
00002748  6004      4307          bra.s     menu_46
                    4308   menu_45:
                    4309   ; else
                    4310   ; UnknownCommand() ;
0000274A  4EB8 22E6 4311          jsr       _UnknownCommand
                    4312   menu_46:
0000274E  6000 FDB0 4313          bra       menu_1
                    4314   menu_38:
00002752  4CDF 3C0C 4315          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00002756  4E75      4316          rts
                    4317   ; }
                    4318   ; }
                    4319   ; void PrintErrorMessageandAbort(char *string) {
                    4320   _PrintErrorMessageandAbort:
00002758  4E56 0000 4321          link      A6,#0
                    4322   ; printf("\r\n\r\nProgram ABORT !!!!!!\r\n") ;
0000275C  4879 0000 4323          pea       @m68kde~1_123.L
00002760  4C82      
00002762  4EB9 0000 4324          jsr       _printf
00002766  3434      
00002768  584F      4325          addq.w    #4,A7
                    4326   ; printf("%s\r\n", string) ;
0000276A  2F2E 0008 4327          move.l    8(A6),-(A7)
0000276E  4879 0000 4328          pea       @m68kde~1_124.L
00002772  4C9E      
00002774  4EB9 0000 4329          jsr       _printf
00002778  3434      
0000277A  504F      4330          addq.w    #8,A7
                    4331   ; menu() ;
0000277C  4EB8 24E4 4332          jsr       _menu
00002780  4E5E      4333          unlk      A6
00002782  4E75      4334          rts
                    4335   ; }
                    4336   ; void IRQMessage(int level) {
                    4337   _IRQMessage:
00002784  4E56 0000 4338          link      A6,#0
                    4339   ; printf("\r\n\r\nProgram ABORT !!!!!");
00002788  4879 0000 4340          pea       @m68kde~1_125.L
0000278C  4CA4      
0000278E  4EB9 0000 4341          jsr       _printf
00002792  3434      
00002794  584F      4342          addq.w    #4,A7
                    4343   ; printf("\r\nUnhandled Interrupt: IRQ%d !!!!!", level) ;
00002796  2F2E 0008 4344          move.l    8(A6),-(A7)
0000279A  4879 0000 4345          pea       @m68kde~1_126.L
0000279E  4CBC      
000027A0  4EB9 0000 4346          jsr       _printf
000027A4  3434      
000027A6  504F      4347          addq.w    #8,A7
                    4348   ; menu() ;
000027A8  4EB8 24E4 4349          jsr       _menu
000027AC  4E5E      4350          unlk      A6
000027AE  4E75      4351          rts
                    4352   ; }
                    4353   ; void UnhandledIRQ1(void) {
                    4354   _UnhandledIRQ1:
                    4355   ; IRQMessage(1);
000027B0  4878 0001 4356          pea       1
000027B4  4EB8 2784 4357          jsr       _IRQMessage
000027B8  584F      4358          addq.w    #4,A7
000027BA  4E75      4359          rts
                    4360   ; }
                    4361   ; void UnhandledIRQ2(void) {
                    4362   _UnhandledIRQ2:
                    4363   ; IRQMessage(2);
000027BC  4878 0002 4364          pea       2
000027C0  4EB8 2784 4365          jsr       _IRQMessage
000027C4  584F      4366          addq.w    #4,A7
000027C6  4E75      4367          rts
                    4368   ; }
                    4369   ; void UnhandledIRQ3(void){
                    4370   _UnhandledIRQ3:
                    4371   ; IRQMessage(3);
000027C8  4878 0003 4372          pea       3
000027CC  4EB8 2784 4373          jsr       _IRQMessage
000027D0  584F      4374          addq.w    #4,A7
000027D2  4E75      4375          rts
                    4376   ; }
                    4377   ; void UnhandledIRQ4(void) {
                    4378   _UnhandledIRQ4:
                    4379   ; IRQMessage(4);
000027D4  4878 0004 4380          pea       4
000027D8  4EB8 2784 4381          jsr       _IRQMessage
000027DC  584F      4382          addq.w    #4,A7
000027DE  4E75      4383          rts
                    4384   ; }
                    4385   ; void UnhandledIRQ5(void) {
                    4386   _UnhandledIRQ5:
                    4387   ; IRQMessage(5);
000027E0  4878 0005 4388          pea       5
000027E4  4EB8 2784 4389          jsr       _IRQMessage
000027E8  584F      4390          addq.w    #4,A7
000027EA  4E75      4391          rts
                    4392   ; }
                    4393   ; void UnhandledIRQ6(void) {
                    4394   _UnhandledIRQ6:
                    4395   ; PrintErrorMessageandAbort("ADDRESS ERROR: 16 or 32 Bit Transfer to/from an ODD Address....") ;
000027EC  4879 0000 4396          pea       @m68kde~1_127.L
000027F0  4CE0      
000027F2  4EB8 2758 4397          jsr       _PrintErrorMessageandAbort
000027F6  584F      4398          addq.w    #4,A7
                    4399   ; menu() ;
000027F8  4EB8 24E4 4400          jsr       _menu
000027FC  4E75      4401          rts
                    4402   ; }
                    4403   ; void UnhandledIRQ7(void) {
                    4404   _UnhandledIRQ7:
                    4405   ; IRQMessage(7);
000027FE  4878 0007 4406          pea       7
00002802  4EB8 2784 4407          jsr       _IRQMessage
00002806  584F      4408          addq.w    #4,A7
00002808  4E75      4409          rts
                    4410   ; }
                    4411   ; void UnhandledTrap(void) {
                    4412   _UnhandledTrap:
                    4413   ; PrintErrorMessageandAbort("Unhandled Trap !!!!!") ;
0000280A  4879 0000 4414          pea       @m68kde~1_128.L
0000280E  4D20      
00002810  4EB8 2758 4415          jsr       _PrintErrorMessageandAbort
00002814  584F      4416          addq.w    #4,A7
00002816  4E75      4417          rts
                    4418   ; }
                    4419   ; void BusError() {
                    4420   _BusError:
                    4421   ; PrintErrorMessageandAbort("BUS Error!") ;
00002818  4879 0000 4422          pea       @m68kde~1_129.L
0000281C  4D36      
0000281E  4EB8 2758 4423          jsr       _PrintErrorMessageandAbort
00002822  584F      4424          addq.w    #4,A7
00002824  4E75      4425          rts
                    4426   ; }
                    4427   ; void AddressError() {
                    4428   _AddressError:
                    4429   ; PrintErrorMessageandAbort("ADDRESS Error!") ;
00002826  4879 0000 4430          pea       @m68kde~1_130.L
0000282A  4D42      
0000282C  4EB8 2758 4431          jsr       _PrintErrorMessageandAbort
00002830  584F      4432          addq.w    #4,A7
00002832  4E75      4433          rts
                    4434   ; }
                    4435   ; void IllegalInstruction() {
                    4436   _IllegalInstruction:
                    4437   ; PrintErrorMessageandAbort("ILLEGAL INSTRUCTION") ;
00002834  4879 0000 4438          pea       @m68kde~1_131.L
00002838  4D52      
0000283A  4EB8 2758 4439          jsr       _PrintErrorMessageandAbort
0000283E  584F      4440          addq.w    #4,A7
00002840  4E75      4441          rts
                    4442   ; }
                    4443   ; void Dividebyzero() {
                    4444   _Dividebyzero:
                    4445   ; PrintErrorMessageandAbort("DIVIDE BY ZERO") ;
00002842  4879 0000 4446          pea       @m68kde~1_132.L
00002846  4D66      
00002848  4EB8 2758 4447          jsr       _PrintErrorMessageandAbort
0000284C  584F      4448          addq.w    #4,A7
0000284E  4E75      4449          rts
                    4450   ; }
                    4451   ; void Check() {
                    4452   _Check:
                    4453   ; PrintErrorMessageandAbort("'CHK' INSTRUCTION") ;
00002850  4879 0000 4454          pea       @m68kde~1_133.L
00002854  4D76      
00002856  4EB8 2758 4455          jsr       _PrintErrorMessageandAbort
0000285A  584F      4456          addq.w    #4,A7
0000285C  4E75      4457          rts
                    4458   ; }
                    4459   ; void Trapv() {
                    4460   _Trapv:
                    4461   ; PrintErrorMessageandAbort("TRAPV INSTRUCTION") ;
0000285E  4879 0000 4462          pea       @m68kde~1_134.L
00002862  4D88      
00002864  4EB8 2758 4463          jsr       _PrintErrorMessageandAbort
00002868  584F      4464          addq.w    #4,A7
0000286A  4E75      4465          rts
                    4466   ; }
                    4467   ; void PrivError() {
                    4468   _PrivError:
                    4469   ; PrintErrorMessageandAbort("PRIVILEGE VIOLATION") ;
0000286C  4879 0000 4470          pea       @m68kde~1_135.L
00002870  4D9A      
00002872  4EB8 2758 4471          jsr       _PrintErrorMessageandAbort
00002876  584F      4472          addq.w    #4,A7
00002878  4E75      4473          rts
                    4474   ; }
                    4475   ; void UnitIRQ() {
                    4476   _UnitIRQ:
                    4477   ; PrintErrorMessageandAbort("UNINITIALISED IRQ") ;
0000287A  4879 0000 4478          pea       @m68kde~1_136.L
0000287E  4DAE      
00002880  4EB8 2758 4479          jsr       _PrintErrorMessageandAbort
00002884  584F      4480          addq.w    #4,A7
00002886  4E75      4481          rts
                    4482   ; }
                    4483   ; void Spurious() {
                    4484   _Spurious:
                    4485   ; PrintErrorMessageandAbort("SPURIOUS IRQ") ;
00002888  4879 0000 4486          pea       @m68kde~1_137.L
0000288C  4DC0      
0000288E  4EB8 2758 4487          jsr       _PrintErrorMessageandAbort
00002892  584F      4488          addq.w    #4,A7
00002894  4E75      4489          rts
                    4490   ; }
                    4491   ; void EnterString(void)
                    4492   ; {
                    4493   _EnterString:
00002896  4E56 FFFC 4494          link      A6,#-4
0000289A  2F02      4495          move.l    D2,-(A7)
                    4496   ; unsigned char *Start;
                    4497   ; unsigned char c;
                    4498   ; printf("\r\nStart Address in Memory: ") ;
0000289C  4879 0000 4499          pea       @m68kde~1_138.L
000028A0  4DCE      
000028A2  4EB9 0000 4500          jsr       _printf
000028A6  3434      
000028A8  584F      4501          addq.w    #4,A7
                    4502   ; Start = Get8HexDigits(0) ;
000028AA  42A7      4503          clr.l     -(A7)
000028AC  4EB8 0CD8 4504          jsr       _Get8HexDigits
000028B0  584F      4505          addq.w    #4,A7
000028B2  2400      4506          move.l    D0,D2
                    4507   ; printf("\r\nEnter String (ESC to end) :") ;
000028B4  4879 0000 4508          pea       @m68kde~1_139.L
000028B8  4DEA      
000028BA  4EB9 0000 4509          jsr       _printf
000028BE  3434      
000028C0  584F      4510          addq.w    #4,A7
                    4511   ; while((c = getchar()) != 0x1b)
                    4512   EnterString_1:
000028C2  4EB9 0000 4513          jsr       _getch
000028C6  3356      
000028C8  1D40 FFFF 4514          move.b    D0,-1(A6)
000028CC  0C00 001B 4515          cmp.b     #27,D0
000028D0  670A      4516          beq.s     EnterString_3
                    4517   ; *Start++ = c ;
000028D2  2042      4518          move.l    D2,A0
000028D4  5282      4519          addq.l    #1,D2
000028D6  10AE FFFF 4520          move.b    -1(A6),(A0)
000028DA  60E6      4521          bra       EnterString_1
                    4522   EnterString_3:
                    4523   ; *Start = 0x00;  // terminate with a null
000028DC  2042      4524          move.l    D2,A0
000028DE  4210      4525          clr.b     (A0)
000028E0  241F      4526          move.l    (A7)+,D2
000028E2  4E5E      4527          unlk      A6
000028E4  4E75      4528          rts
                    4529   ; }
                    4530   ; // Returning an array containing the start and the end address of the test (two hex numbers)
                    4531   ; void ask_addr_range_sram (unsigned int* addr_array, int data_length) {
                    4532   _ask_addr_range_sram:
000028E6  4E56 0000 4533          link      A6,#0
000028EA  48E7 3820 4534          movem.l   D2/D3/D4/A2,-(A7)
000028EE  45F9 0000 4535          lea       _printf.L,A2
000028F2  3434      
000028F4  242E 0008 4536          move.l    8(A6),D2
                    4537   ; int start_addr_valid = 0;
000028F8  4284      4538          clr.l     D4
                    4539   ; int end_addr_valid = 0;
000028FA  4283      4540          clr.l     D3
                    4541   ; while (!start_addr_valid) {
                    4542   ask_addr_range_sram_1:
000028FC  4A84      4543          tst.l     D4
000028FE  6600 008C 4544          bne       ask_addr_range_sram_3
                    4545   ; printf("\r\nProvide the start address of the test.\n");
00002902  4879 0000 4546          pea       @m68kde~1_140.L
00002906  4E08      
00002908  4E92      4547          jsr       (A2)
0000290A  584F      4548          addq.w    #4,A7
                    4549   ; //scanf("%x", addr_array);
                    4550   ; addr_array[0] = Get8HexDigits(0);
0000290C  42A7      4551          clr.l     -(A7)
0000290E  4EB8 0CD8 4552          jsr       _Get8HexDigits
00002912  584F      4553          addq.w    #4,A7
00002914  2042      4554          move.l    D2,A0
00002916  2080      4555          move.l    D0,(A0)
                    4556   ; if (addr_array[0] < 4026531840) {
00002918  2042      4557          move.l    D2,A0
0000291A  2010      4558          move.l    (A0),D0
0000291C  0C80 F000 4559          cmp.l     #-268435456,D0
00002920  0000      
00002922  640E      4560          bhs.s     ask_addr_range_sram_4
                    4561   ; printf ("The start address is smaller than 0xf0000000, invalid!\n");
00002924  4879 0000 4562          pea       @m68kde~1_141.L
00002928  4E32      
0000292A  4E92      4563          jsr       (A2)
0000292C  584F      4564          addq.w    #4,A7
0000292E  6000 0058 4565          bra       ask_addr_range_sram_9
                    4566   ask_addr_range_sram_4:
                    4567   ; } else if (addr_array[0] > 4026793983) {
00002932  2042      4568          move.l    D2,A0
00002934  2010      4569          move.l    (A0),D0
00002936  0C80 F003 4570          cmp.l     #-268173313,D0
0000293A  FFFF      
0000293C  630E      4571          bls.s     ask_addr_range_sram_6
                    4572   ; printf ("The start address is bigger than 0xf003ffff, invalid!\n");
0000293E  4879 0000 4573          pea       @m68kde~1_142.L
00002942  4E6A      
00002944  4E92      4574          jsr       (A2)
00002946  584F      4575          addq.w    #4,A7
00002948  6000 003E 4576          bra       ask_addr_range_sram_9
                    4577   ask_addr_range_sram_6:
                    4578   ; } else { // If the data length is words or long words, check whether the start address is odd 
                    4579   ; if (data_length > 1 && addr_array[0] % 2 != 0) {
0000294C  202E 000C 4580          move.l    12(A6),D0
00002950  0C80 0000 4581          cmp.l     #1,D0
00002954  0001      
00002956  6F24      4582          ble.s     ask_addr_range_sram_8
00002958  2042      4583          move.l    D2,A0
0000295A  2F10      4584          move.l    (A0),-(A7)
0000295C  4878 0002 4585          pea       2
00002960  4EB9 0000 4586          jsr       ULDIV
00002964  3248      
00002966  202F 0004 4587          move.l    4(A7),D0
0000296A  504F      4588          addq.w    #8,A7
0000296C  4A80      4589          tst.l     D0
0000296E  670C      4590          beq.s     ask_addr_range_sram_8
                    4591   ; printf("The start address provided is odd, need an even one!\n");
00002970  4879 0000 4592          pea       @m68kde~1_143.L
00002974  4EA2      
00002976  4E92      4593          jsr       (A2)
00002978  584F      4594          addq.w    #4,A7
0000297A  600C      4595          bra.s     ask_addr_range_sram_9
                    4596   ask_addr_range_sram_8:
                    4597   ; } else {
                    4598   ; printf ("Start address valid.\n");
0000297C  4879 0000 4599          pea       @m68kde~1_144.L
00002980  4ED8      
00002982  4E92      4600          jsr       (A2)
00002984  584F      4601          addq.w    #4,A7
                    4602   ; start_addr_valid = 1;
00002986  7801      4603          moveq     #1,D4
                    4604   ask_addr_range_sram_9:
00002988  6000 FF72 4605          bra       ask_addr_range_sram_1
                    4606   ask_addr_range_sram_3:
                    4607   ; } 
                    4608   ; }
                    4609   ; }
                    4610   ; while (!end_addr_valid) {
                    4611   ask_addr_range_sram_10:
0000298C  4A83      4612          tst.l     D3
0000298E  6600 0094 4613          bne       ask_addr_range_sram_12
                    4614   ; printf("\r\nProvide the end address of the test.\n");
00002992  4879 0000 4615          pea       @m68kde~1_145.L
00002996  4EEE      
00002998  4E92      4616          jsr       (A2)
0000299A  584F      4617          addq.w    #4,A7
                    4618   ; //scanf("%x", addr_array+1);
                    4619   ; addr_array[1] = Get8HexDigits(0);
0000299C  42A7      4620          clr.l     -(A7)
0000299E  4EB8 0CD8 4621          jsr       _Get8HexDigits
000029A2  584F      4622          addq.w    #4,A7
000029A4  2042      4623          move.l    D2,A0
000029A6  2140 0004 4624          move.l    D0,4(A0)
                    4625   ; if (addr_array[1] < 4026531840) {
000029AA  2042      4626          move.l    D2,A0
000029AC  2028 0004 4627          move.l    4(A0),D0
000029B0  0C80 F000 4628          cmp.l     #-268435456,D0
000029B4  0000      
000029B6  640E      4629          bhs.s     ask_addr_range_sram_13
                    4630   ; printf ("The end address is smaller than 0xf0000000, invalid!\n");
000029B8  4879 0000 4631          pea       @m68kde~1_146.L
000029BC  4F16      
000029BE  4E92      4632          jsr       (A2)
000029C0  584F      4633          addq.w    #4,A7
000029C2  6000 005C 4634          bra       ask_addr_range_sram_18
                    4635   ask_addr_range_sram_13:
                    4636   ; } else if (addr_array[1] > 4026793983)
000029C6  2042      4637          move.l    D2,A0
000029C8  2028 0004 4638          move.l    4(A0),D0
000029CC  0C80 F003 4639          cmp.l     #-268173313,D0
000029D0  FFFF      
000029D2  630E      4640          bls.s     ask_addr_range_sram_15
                    4641   ; {
                    4642   ; printf ("The end address is bigger than 0xf003ffff, invalid!\n");
000029D4  4879 0000 4643          pea       @m68kde~1_147.L
000029D8  4F4C      
000029DA  4E92      4644          jsr       (A2)
000029DC  584F      4645          addq.w    #4,A7
000029DE  6000 0040 4646          bra       ask_addr_range_sram_18
                    4647   ask_addr_range_sram_15:
                    4648   ; } else { 
                    4649   ; if (data_length > 1 && addr_array[1] % 2 != 0) {
000029E2  202E 000C 4650          move.l    12(A6),D0
000029E6  0C80 0000 4651          cmp.l     #1,D0
000029EA  0001      
000029EC  6F26      4652          ble.s     ask_addr_range_sram_17
000029EE  2042      4653          move.l    D2,A0
000029F0  2F28 0004 4654          move.l    4(A0),-(A7)
000029F4  4878 0002 4655          pea       2
000029F8  4EB9 0000 4656          jsr       ULDIV
000029FC  3248      
000029FE  202F 0004 4657          move.l    4(A7),D0
00002A02  504F      4658          addq.w    #8,A7
00002A04  4A80      4659          tst.l     D0
00002A06  670C      4660          beq.s     ask_addr_range_sram_17
                    4661   ; printf("The end address provided is odd, need an even one!\n");
00002A08  4879 0000 4662          pea       @m68kde~1_148.L
00002A0C  4F82      
00002A0E  4E92      4663          jsr       (A2)
00002A10  584F      4664          addq.w    #4,A7
00002A12  600C      4665          bra.s     ask_addr_range_sram_18
                    4666   ask_addr_range_sram_17:
                    4667   ; } else {
                    4668   ; printf ("End address valid.\n");
00002A14  4879 0000 4669          pea       @m68kde~1_149.L
00002A18  4FB6      
00002A1A  4E92      4670          jsr       (A2)
00002A1C  584F      4671          addq.w    #4,A7
                    4672   ; end_addr_valid = 1;
00002A1E  7601      4673          moveq     #1,D3
                    4674   ask_addr_range_sram_18:
00002A20  6000 FF6A 4675          bra       ask_addr_range_sram_10
                    4676   ask_addr_range_sram_12:
00002A24  4CDF 041C 4677          movem.l   (A7)+,D2/D3/D4/A2
00002A28  4E5E      4678          unlk      A6
00002A2A  4E75      4679          rts
                    4680   ; } 
                    4681   ; }
                    4682   ; }
                    4683   ; }
                    4684   ; void ask_addr_range_sdram(unsigned int* addr_array, int data_length) {
                    4685   _ask_addr_range_sdram:
00002A2C  4E56 0000 4686          link      A6,#0
00002A30  48E7 3820 4687          movem.l   D2/D3/D4/A2,-(A7)
00002A34  45F9 0000 4688          lea       _printf.L,A2
00002A38  3434      
00002A3A  242E 0008 4689          move.l    8(A6),D2
                    4690   ; int start_addr_valid = 0;
00002A3E  4284      4691          clr.l     D4
                    4692   ; int end_addr_valid = 0;
00002A40  4283      4693          clr.l     D3
                    4694   ; while (!start_addr_valid) {
                    4695   ask_addr_range_sdram_1:
00002A42  4A84      4696          tst.l     D4
00002A44  6600 008C 4697          bne       ask_addr_range_sdram_3
                    4698   ; printf("\r\nProvide the start address of the test.\n");
00002A48  4879 0000 4699          pea       @m68kde~1_140.L
00002A4C  4E08      
00002A4E  4E92      4700          jsr       (A2)
00002A50  584F      4701          addq.w    #4,A7
                    4702   ; //scanf("%x", addr_array);
                    4703   ; addr_array[0] = Get8HexDigits(0);
00002A52  42A7      4704          clr.l     -(A7)
00002A54  4EB8 0CD8 4705          jsr       _Get8HexDigits
00002A58  584F      4706          addq.w    #4,A7
00002A5A  2042      4707          move.l    D2,A0
00002A5C  2080      4708          move.l    D0,(A0)
                    4709   ; if (addr_array[0] < 134217728) {
00002A5E  2042      4710          move.l    D2,A0
00002A60  2010      4711          move.l    (A0),D0
00002A62  0C80 0800 4712          cmp.l     #134217728,D0
00002A66  0000      
00002A68  640E      4713          bhs.s     ask_addr_range_sdram_4
                    4714   ; printf ("The start address is smaller than 0x08000000, invalid!\n");
00002A6A  4879 0000 4715          pea       @m68kde~1_150.L
00002A6E  4FCA      
00002A70  4E92      4716          jsr       (A2)
00002A72  584F      4717          addq.w    #4,A7
00002A74  6000 0058 4718          bra       ask_addr_range_sdram_9
                    4719   ask_addr_range_sdram_4:
                    4720   ; } else if (addr_array[0] > 201326591) {
00002A78  2042      4721          move.l    D2,A0
00002A7A  2010      4722          move.l    (A0),D0
00002A7C  0C80 0BFF 4723          cmp.l     #201326591,D0
00002A80  FFFF      
00002A82  630E      4724          bls.s     ask_addr_range_sdram_6
                    4725   ; printf ("The start address is bigger than 0x0bffffff, invalid!\n");
00002A84  4879 0000 4726          pea       @m68kde~1_151.L
00002A88  5002      
00002A8A  4E92      4727          jsr       (A2)
00002A8C  584F      4728          addq.w    #4,A7
00002A8E  6000 003E 4729          bra       ask_addr_range_sdram_9
                    4730   ask_addr_range_sdram_6:
                    4731   ; } else { // If the data length is words or long words, check whether the start address is odd 
                    4732   ; if (data_length > 1 && addr_array[0] % 2 != 0) {
00002A92  202E 000C 4733          move.l    12(A6),D0
00002A96  0C80 0000 4734          cmp.l     #1,D0
00002A9A  0001      
00002A9C  6F24      4735          ble.s     ask_addr_range_sdram_8
00002A9E  2042      4736          move.l    D2,A0
00002AA0  2F10      4737          move.l    (A0),-(A7)
00002AA2  4878 0002 4738          pea       2
00002AA6  4EB9 0000 4739          jsr       ULDIV
00002AAA  3248      
00002AAC  202F 0004 4740          move.l    4(A7),D0
00002AB0  504F      4741          addq.w    #8,A7
00002AB2  4A80      4742          tst.l     D0
00002AB4  670C      4743          beq.s     ask_addr_range_sdram_8
                    4744   ; printf("The start address provided is odd, need an even one!\n");
00002AB6  4879 0000 4745          pea       @m68kde~1_143.L
00002ABA  4EA2      
00002ABC  4E92      4746          jsr       (A2)
00002ABE  584F      4747          addq.w    #4,A7
00002AC0  600C      4748          bra.s     ask_addr_range_sdram_9
                    4749   ask_addr_range_sdram_8:
                    4750   ; } else {
                    4751   ; printf ("Start address valid.\n");
00002AC2  4879 0000 4752          pea       @m68kde~1_144.L
00002AC6  4ED8      
00002AC8  4E92      4753          jsr       (A2)
00002ACA  584F      4754          addq.w    #4,A7
                    4755   ; start_addr_valid = 1;
00002ACC  7801      4756          moveq     #1,D4
                    4757   ask_addr_range_sdram_9:
00002ACE  6000 FF72 4758          bra       ask_addr_range_sdram_1
                    4759   ask_addr_range_sdram_3:
                    4760   ; } 
                    4761   ; }
                    4762   ; }
                    4763   ; while (!end_addr_valid) {
                    4764   ask_addr_range_sdram_10:
00002AD2  4A83      4765          tst.l     D3
00002AD4  6600 0094 4766          bne       ask_addr_range_sdram_12
                    4767   ; printf("\r\nProvide the end address of the test.\n");
00002AD8  4879 0000 4768          pea       @m68kde~1_145.L
00002ADC  4EEE      
00002ADE  4E92      4769          jsr       (A2)
00002AE0  584F      4770          addq.w    #4,A7
                    4771   ; //scanf("%x", addr_array+1);
                    4772   ; addr_array[1] = Get8HexDigits(0);
00002AE2  42A7      4773          clr.l     -(A7)
00002AE4  4EB8 0CD8 4774          jsr       _Get8HexDigits
00002AE8  584F      4775          addq.w    #4,A7
00002AEA  2042      4776          move.l    D2,A0
00002AEC  2140 0004 4777          move.l    D0,4(A0)
                    4778   ; if (addr_array[1] < 134217728) {
00002AF0  2042      4779          move.l    D2,A0
00002AF2  2028 0004 4780          move.l    4(A0),D0
00002AF6  0C80 0800 4781          cmp.l     #134217728,D0
00002AFA  0000      
00002AFC  640E      4782          bhs.s     ask_addr_range_sdram_13
                    4783   ; printf ("The end address is smaller than 0x08000000, invalid!\n");
00002AFE  4879 0000 4784          pea       @m68kde~1_152.L
00002B02  503A      
00002B04  4E92      4785          jsr       (A2)
00002B06  584F      4786          addq.w    #4,A7
00002B08  6000 005C 4787          bra       ask_addr_range_sdram_18
                    4788   ask_addr_range_sdram_13:
                    4789   ; } else if (addr_array[1] > 201326591)
00002B0C  2042      4790          move.l    D2,A0
00002B0E  2028 0004 4791          move.l    4(A0),D0
00002B12  0C80 0BFF 4792          cmp.l     #201326591,D0
00002B16  FFFF      
00002B18  630E      4793          bls.s     ask_addr_range_sdram_15
                    4794   ; {
                    4795   ; printf ("The end address is bigger than 0x0bffffff, invalid!\n");
00002B1A  4879 0000 4796          pea       @m68kde~1_153.L
00002B1E  5070      
00002B20  4E92      4797          jsr       (A2)
00002B22  584F      4798          addq.w    #4,A7
00002B24  6000 0040 4799          bra       ask_addr_range_sdram_18
                    4800   ask_addr_range_sdram_15:
                    4801   ; } else { 
                    4802   ; if (data_length > 1 && addr_array[1] % 2 != 0) {
00002B28  202E 000C 4803          move.l    12(A6),D0
00002B2C  0C80 0000 4804          cmp.l     #1,D0
00002B30  0001      
00002B32  6F26      4805          ble.s     ask_addr_range_sdram_17
00002B34  2042      4806          move.l    D2,A0
00002B36  2F28 0004 4807          move.l    4(A0),-(A7)
00002B3A  4878 0002 4808          pea       2
00002B3E  4EB9 0000 4809          jsr       ULDIV
00002B42  3248      
00002B44  202F 0004 4810          move.l    4(A7),D0
00002B48  504F      4811          addq.w    #8,A7
00002B4A  4A80      4812          tst.l     D0
00002B4C  670C      4813          beq.s     ask_addr_range_sdram_17
                    4814   ; printf("The end address provided is odd, need an even one!\n");
00002B4E  4879 0000 4815          pea       @m68kde~1_148.L
00002B52  4F82      
00002B54  4E92      4816          jsr       (A2)
00002B56  584F      4817          addq.w    #4,A7
00002B58  600C      4818          bra.s     ask_addr_range_sdram_18
                    4819   ask_addr_range_sdram_17:
                    4820   ; } else {
                    4821   ; printf ("End address valid.\n");
00002B5A  4879 0000 4822          pea       @m68kde~1_149.L
00002B5E  4FB6      
00002B60  4E92      4823          jsr       (A2)
00002B62  584F      4824          addq.w    #4,A7
                    4825   ; end_addr_valid = 1;
00002B64  7601      4826          moveq     #1,D3
                    4827   ask_addr_range_sdram_18:
00002B66  6000 FF6A 4828          bra       ask_addr_range_sdram_10
                    4829   ask_addr_range_sdram_12:
00002B6A  4CDF 041C 4830          movem.l   (A7)+,D2/D3/D4/A2
00002B6E  4E5E      4831          unlk      A6
00002B70  4E75      4832          rts
                    4833   ; } 
                    4834   ; }
                    4835   ; }
                    4836   ; }
                    4837   ; // Return the byte data with the correct pattern
                    4838   ; unsigned char byte_data (int data_pattern){
                    4839   _byte_data:
00002B72  4E56 0000 4840          link      A6,#0
00002B76  2F02      4841          move.l    D2,-(A7)
00002B78  242E 0008 4842          move.l    8(A6),D2
                    4843   ; if (data_pattern == 1) {
00002B7C  0C82 0000 4844          cmp.l     #1,D2
00002B80  0001      
00002B82  6604      4845          bne.s     byte_data_1
                    4846   ; return 0;
00002B84  4200      4847          clr.b     D0
00002B86  602A      4848          bra.s     byte_data_8
                    4849   byte_data_1:
                    4850   ; } else if (data_pattern == 2) {
00002B88  0C82 0000 4851          cmp.l     #2,D2
00002B8C  0002      
00002B8E  6604      4852          bne.s     byte_data_4
                    4853   ; return 0x55;
00002B90  7055      4854          moveq     #85,D0
00002B92  601E      4855          bra.s     byte_data_8
                    4856   byte_data_4:
                    4857   ; } else if (data_pattern == 3) {
00002B94  0C82 0000 4858          cmp.l     #3,D2
00002B98  0003      
00002B9A  6606      4859          bne.s     byte_data_6
                    4860   ; return 0xaa;
00002B9C  103C 00AA 4861          move.b    #170,D0
00002BA0  6010      4862          bra.s     byte_data_8
                    4863   byte_data_6:
                    4864   ; } else if (data_pattern == 4) {
00002BA2  0C82 0000 4865          cmp.l     #4,D2
00002BA6  0004      
00002BA8  6608      4866          bne.s     byte_data_8
                    4867   ; return 0xff;
00002BAA  103C 00FF 4868          move.b    #255,D0
00002BAE  6000 0002 4869          bra       byte_data_8
                    4870   byte_data_8:
00002BB2  241F      4871          move.l    (A7)+,D2
00002BB4  4E5E      4872          unlk      A6
00002BB6  4E75      4873          rts
                    4874   ; } 
                    4875   ; }
                    4876   ; // Return the word data (16 bits) with the correct pattern
                    4877   ; unsigned short word_data (int data_pattern){
                    4878   _word_data:
00002BB8  4E56 0000 4879          link      A6,#0
00002BBC  2F02      4880          move.l    D2,-(A7)
00002BBE  242E 0008 4881          move.l    8(A6),D2
                    4882   ; if (data_pattern == 1) {
00002BC2  0C82 0000 4883          cmp.l     #1,D2
00002BC6  0001      
00002BC8  6604      4884          bne.s     word_data_1
                    4885   ; return 0;
00002BCA  4240      4886          clr.w     D0
00002BCC  602C      4887          bra.s     word_data_8
                    4888   word_data_1:
                    4889   ; } else if (data_pattern == 2) {
00002BCE  0C82 0000 4890          cmp.l     #2,D2
00002BD2  0002      
00002BD4  6606      4891          bne.s     word_data_4
                    4892   ; return 0x5555;
00002BD6  303C 5555 4893          move.w    #21845,D0
00002BDA  601E      4894          bra.s     word_data_8
                    4895   word_data_4:
                    4896   ; } else if (data_pattern == 3) {
00002BDC  0C82 0000 4897          cmp.l     #3,D2
00002BE0  0003      
00002BE2  6606      4898          bne.s     word_data_6
                    4899   ; return 0xaaaa;
00002BE4  303C AAAA 4900          move.w    #43690,D0
00002BE8  6010      4901          bra.s     word_data_8
                    4902   word_data_6:
                    4903   ; } else if (data_pattern == 4) {
00002BEA  0C82 0000 4904          cmp.l     #4,D2
00002BEE  0004      
00002BF0  6608      4905          bne.s     word_data_8
                    4906   ; return 0xffff;
00002BF2  303C FFFF 4907          move.w    #65535,D0
00002BF6  6000 0002 4908          bra       word_data_8
                    4909   word_data_8:
00002BFA  241F      4910          move.l    (A7)+,D2
00002BFC  4E5E      4911          unlk      A6
00002BFE  4E75      4912          rts
                    4913   ; } 
                    4914   ; }
                    4915   ; // Return the long word data (32 bits) with the correct pattern
                    4916   ; unsigned int long_word_data (int data_pattern){
                    4917   _long_word_data:
00002C00  4E56 0000 4918          link      A6,#0
00002C04  2F02      4919          move.l    D2,-(A7)
00002C06  242E 0008 4920          move.l    8(A6),D2
                    4921   ; if (data_pattern == 1) {
00002C0A  0C82 0000 4922          cmp.l     #1,D2
00002C0E  0001      
00002C10  6604      4923          bne.s     long_word_data_1
                    4924   ; return 0;
00002C12  4280      4925          clr.l     D0
00002C14  602E      4926          bra.s     long_word_data_8
                    4927   long_word_data_1:
                    4928   ; } else if (data_pattern == 2) {
00002C16  0C82 0000 4929          cmp.l     #2,D2
00002C1A  0002      
00002C1C  6608      4930          bne.s     long_word_data_4
                    4931   ; return 0x55555555;
00002C1E  203C 5555 4932          move.l    #1431655765,D0
00002C22  5555      
00002C24  601E      4933          bra.s     long_word_data_8
                    4934   long_word_data_4:
                    4935   ; } else if (data_pattern == 3) {
00002C26  0C82 0000 4936          cmp.l     #3,D2
00002C2A  0003      
00002C2C  6608      4937          bne.s     long_word_data_6
                    4938   ; return 0xaaaaaaaa;
00002C2E  203C AAAA 4939          move.l    #-1431655766,D0
00002C32  AAAA      
00002C34  600E      4940          bra.s     long_word_data_8
                    4941   long_word_data_6:
                    4942   ; } else if (data_pattern == 4) {
00002C36  0C82 0000 4943          cmp.l     #4,D2
00002C3A  0004      
00002C3C  6606      4944          bne.s     long_word_data_8
                    4945   ; return 0xffffffff;
00002C3E  70FF      4946          moveq     #-1,D0
00002C40  6000 0002 4947          bra       long_word_data_8
                    4948   long_word_data_8:
00002C44  241F      4949          move.l    (A7)+,D2
00002C46  4E5E      4950          unlk      A6
00002C48  4E75      4951          rts
                    4952   ; } 
                    4953   ; }
                    4954   ; int byte_test (unsigned char byte, unsigned int* addr_array) {
                    4955   _byte_test:
00002C4A  4E56 FFFC 4956          link      A6,#-4
00002C4E  48E7 3C00 4957          movem.l   D2/D3/D4/D5,-(A7)
00002C52  1A2E 000B 4958          move.b    11(A6),D5
00002C56  CABC 0000 4959          and.l     #255,D5
00002C5A  00FF      
                    4960   ; unsigned int start_addr = addr_array[0];
00002C5C  206E 000C 4961          move.l    12(A6),A0
00002C60  2810      4962          move.l    (A0),D4
                    4963   ; unsigned int end_addr = addr_array[1];
00002C62  206E 000C 4964          move.l    12(A6),A0
00002C66  2D68 0004 4965          move.l    4(A0),-4(A6)
00002C6A  FFFC      
                    4966   ; volatile unsigned char *test_addr = (volatile unsigned char *) start_addr;
00002C6C  2404      4967          move.l    D4,D2
                    4968   ; int i;
                    4969   ; for (i = 0; i < (end_addr - start_addr); i ++) {
00002C6E  4283      4970          clr.l     D3
                    4971   byte_test_1:
00002C70  202E FFFC 4972          move.l    -4(A6),D0
00002C74  9084      4973          sub.l     D4,D0
00002C76  B680      4974          cmp.l     D0,D3
00002C78  6400 0066 4975          bhs       byte_test_3
                    4976   ; test_addr = start_addr + i; 
00002C7C  2004      4977          move.l    D4,D0
00002C7E  D083      4978          add.l     D3,D0
00002C80  2400      4979          move.l    D0,D2
                    4980   ; *test_addr = byte;
00002C82  2042      4981          move.l    D2,A0
00002C84  1085      4982          move.b    D5,(A0)
                    4983   ; if (i % 10000 == 0){
00002C86  2F03      4984          move.l    D3,-(A7)
00002C88  4878 2710 4985          pea       10000
00002C8C  4EB9 0000 4986          jsr       LDIV
00002C90  325A      
00002C92  202F 0004 4987          move.l    4(A7),D0
00002C96  504F      4988          addq.w    #8,A7
00002C98  4A80      4989          tst.l     D0
00002C9A  6626      4990          bne.s     byte_test_4
                    4991   ; printf("Location %x, write data: %x, read data: %x\n", test_addr, byte, *test_addr);
00002C9C  2042      4992          move.l    D2,A0
00002C9E  1210      4993          move.b    (A0),D1
00002CA0  C2BC 0000 4994          and.l     #255,D1
00002CA4  00FF      
00002CA6  2F01      4995          move.l    D1,-(A7)
00002CA8  CABC 0000 4996          and.l     #255,D5
00002CAC  00FF      
00002CAE  2F05      4997          move.l    D5,-(A7)
00002CB0  2F02      4998          move.l    D2,-(A7)
00002CB2  4879 0000 4999          pea       @m68kde~1_154.L
00002CB6  50A6      
00002CB8  4EB9 0000 5000          jsr       _printf
00002CBC  3434      
00002CBE  DEFC 0010 5001          add.w     #16,A7
                    5002   byte_test_4:
                    5003   ; }
                    5004   ; if (*test_addr != byte) {
00002CC2  2042      5005          move.l    D2,A0
00002CC4  BA10      5006          cmp.b     (A0),D5
00002CC6  6714      5007          beq.s     byte_test_6
                    5008   ; printf("Test failed at location %x!\n", test_addr);
00002CC8  2F02      5009          move.l    D2,-(A7)
00002CCA  4879 0000 5010          pea       @m68kde~1_155.L
00002CCE  50D2      
00002CD0  4EB9 0000 5011          jsr       _printf
00002CD4  3434      
00002CD6  504F      5012          addq.w    #8,A7
                    5013   ; return 0;
00002CD8  4280      5014          clr.l     D0
00002CDA  6006      5015          bra.s     byte_test_8
                    5016   byte_test_6:
00002CDC  5283      5017          addq.l    #1,D3
00002CDE  6090      5018          bra       byte_test_1
                    5019   byte_test_3:
                    5020   ; }
                    5021   ; }
                    5022   ; return 1;
00002CE0  7001      5023          moveq     #1,D0
                    5024   byte_test_8:
00002CE2  4CDF 003C 5025          movem.l   (A7)+,D2/D3/D4/D5
00002CE6  4E5E      5026          unlk      A6
00002CE8  4E75      5027          rts
                    5028   ; }
                    5029   ; int word_test (unsigned short word, unsigned int* addr_array) {
                    5030   _word_test:
00002CEA  4E56 FFFC 5031          link      A6,#-4
00002CEE  48E7 3C00 5032          movem.l   D2/D3/D4/D5,-(A7)
00002CF2  3A2E 000A 5033          move.w    10(A6),D5
00002CF6  CABC 0000 5034          and.l     #65535,D5
00002CFA  FFFF      
                    5035   ; unsigned int start_addr = addr_array[0];
00002CFC  206E 000C 5036          move.l    12(A6),A0
00002D00  2810      5037          move.l    (A0),D4
                    5038   ; unsigned int end_addr = addr_array[1];
00002D02  206E 000C 5039          move.l    12(A6),A0
00002D06  2D68 0004 5040          move.l    4(A0),-4(A6)
00002D0A  FFFC      
                    5041   ; volatile unsigned short *test_addr = (volatile unsigned short *) start_addr;
00002D0C  2404      5042          move.l    D4,D2
                    5043   ; int i;
                    5044   ; for (i = 0; i < (end_addr - start_addr); i=i+2) {
00002D0E  4283      5045          clr.l     D3
                    5046   word_test_1:
00002D10  202E FFFC 5047          move.l    -4(A6),D0
00002D14  9084      5048          sub.l     D4,D0
00002D16  B680      5049          cmp.l     D0,D3
00002D18  6400 0066 5050          bhs       word_test_3
                    5051   ; test_addr = start_addr + i;
00002D1C  2004      5052          move.l    D4,D0
00002D1E  D083      5053          add.l     D3,D0
00002D20  2400      5054          move.l    D0,D2
                    5055   ; *test_addr = word;
00002D22  2042      5056          move.l    D2,A0
00002D24  3085      5057          move.w    D5,(A0)
                    5058   ; if (i % 10000 == 0){
00002D26  2F03      5059          move.l    D3,-(A7)
00002D28  4878 2710 5060          pea       10000
00002D2C  4EB9 0000 5061          jsr       LDIV
00002D30  325A      
00002D32  202F 0004 5062          move.l    4(A7),D0
00002D36  504F      5063          addq.w    #8,A7
00002D38  4A80      5064          tst.l     D0
00002D3A  6626      5065          bne.s     word_test_4
                    5066   ; printf("Location %x, write data: %x, read data: %x\n", test_addr, word, *test_addr);
00002D3C  2042      5067          move.l    D2,A0
00002D3E  3210      5068          move.w    (A0),D1
00002D40  C2BC 0000 5069          and.l     #65535,D1
00002D44  FFFF      
00002D46  2F01      5070          move.l    D1,-(A7)
00002D48  CABC 0000 5071          and.l     #65535,D5
00002D4C  FFFF      
00002D4E  2F05      5072          move.l    D5,-(A7)
00002D50  2F02      5073          move.l    D2,-(A7)
00002D52  4879 0000 5074          pea       @m68kde~1_154.L
00002D56  50A6      
00002D58  4EB9 0000 5075          jsr       _printf
00002D5C  3434      
00002D5E  DEFC 0010 5076          add.w     #16,A7
                    5077   word_test_4:
                    5078   ; }
                    5079   ; if (*test_addr != word) {
00002D62  2042      5080          move.l    D2,A0
00002D64  BA50      5081          cmp.w     (A0),D5
00002D66  6714      5082          beq.s     word_test_6
                    5083   ; printf("Test failed at location %x!\n", test_addr);
00002D68  2F02      5084          move.l    D2,-(A7)
00002D6A  4879 0000 5085          pea       @m68kde~1_155.L
00002D6E  50D2      
00002D70  4EB9 0000 5086          jsr       _printf
00002D74  3434      
00002D76  504F      5087          addq.w    #8,A7
                    5088   ; return 0;
00002D78  4280      5089          clr.l     D0
00002D7A  6006      5090          bra.s     word_test_8
                    5091   word_test_6:
00002D7C  5483      5092          addq.l    #2,D3
00002D7E  6090      5093          bra       word_test_1
                    5094   word_test_3:
                    5095   ; }
                    5096   ; }
                    5097   ; return 1;
00002D80  7001      5098          moveq     #1,D0
                    5099   word_test_8:
00002D82  4CDF 003C 5100          movem.l   (A7)+,D2/D3/D4/D5
00002D86  4E5E      5101          unlk      A6
00002D88  4E75      5102          rts
                    5103   ; }
                    5104   ; int long_word_test (unsigned int long_word, unsigned int* addr_array) {
                    5105   _long_word_test:
00002D8A  4E56 FFFC 5106          link      A6,#-4
00002D8E  48E7 3C00 5107          movem.l   D2/D3/D4/D5,-(A7)
00002D92  2A2E 0008 5108          move.l    8(A6),D5
                    5109   ; unsigned int start_addr = addr_array[0];
00002D96  206E 000C 5110          move.l    12(A6),A0
00002D9A  2810      5111          move.l    (A0),D4
                    5112   ; unsigned int end_addr = addr_array[1];
00002D9C  206E 000C 5113          move.l    12(A6),A0
00002DA0  2D68 0004 5114          move.l    4(A0),-4(A6)
00002DA4  FFFC      
                    5115   ; volatile unsigned int *test_addr = (volatile unsigned int *) start_addr;
00002DA6  2404      5116          move.l    D4,D2
                    5117   ; int i;
                    5118   ; for (i = 0; i < (end_addr - start_addr); i=i+4) {
00002DA8  4283      5119          clr.l     D3
                    5120   long_word_test_1:
00002DAA  202E FFFC 5121          move.l    -4(A6),D0
00002DAE  9084      5122          sub.l     D4,D0
00002DB0  B680      5123          cmp.l     D0,D3
00002DB2  6400 0058 5124          bhs       long_word_test_3
                    5125   ; test_addr = start_addr + i; 
00002DB6  2004      5126          move.l    D4,D0
00002DB8  D083      5127          add.l     D3,D0
00002DBA  2400      5128          move.l    D0,D2
                    5129   ; *test_addr = long_word;
00002DBC  2042      5130          move.l    D2,A0
00002DBE  2085      5131          move.l    D5,(A0)
                    5132   ; if (i % 10000 == 0){
00002DC0  2F03      5133          move.l    D3,-(A7)
00002DC2  4878 2710 5134          pea       10000
00002DC6  4EB9 0000 5135          jsr       LDIV
00002DCA  325A      
00002DCC  202F 0004 5136          move.l    4(A7),D0
00002DD0  504F      5137          addq.w    #8,A7
00002DD2  4A80      5138          tst.l     D0
00002DD4  6618      5139          bne.s     long_word_test_4
                    5140   ; printf("Location %x, write data: %x, read data: %x\n", test_addr, long_word, *test_addr);
00002DD6  2042      5141          move.l    D2,A0
00002DD8  2F10      5142          move.l    (A0),-(A7)
00002DDA  2F05      5143          move.l    D5,-(A7)
00002DDC  2F02      5144          move.l    D2,-(A7)
00002DDE  4879 0000 5145          pea       @m68kde~1_154.L
00002DE2  50A6      
00002DE4  4EB9 0000 5146          jsr       _printf
00002DE8  3434      
00002DEA  DEFC 0010 5147          add.w     #16,A7
                    5148   long_word_test_4:
                    5149   ; }
                    5150   ; if (*test_addr != long_word) {
00002DEE  2042      5151          move.l    D2,A0
00002DF0  BA90      5152          cmp.l     (A0),D5
00002DF2  6714      5153          beq.s     long_word_test_6
                    5154   ; printf("Test failed at location %x!\n", test_addr);
00002DF4  2F02      5155          move.l    D2,-(A7)
00002DF6  4879 0000 5156          pea       @m68kde~1_155.L
00002DFA  50D2      
00002DFC  4EB9 0000 5157          jsr       _printf
00002E00  3434      
00002E02  504F      5158          addq.w    #8,A7
                    5159   ; return 0;
00002E04  4280      5160          clr.l     D0
00002E06  6006      5161          bra.s     long_word_test_8
                    5162   long_word_test_6:
00002E08  5883      5163          addq.l    #4,D3
00002E0A  609E      5164          bra       long_word_test_1
                    5165   long_word_test_3:
                    5166   ; }
                    5167   ; }
                    5168   ; return 1;
00002E0C  7001      5169          moveq     #1,D0
                    5170   long_word_test_8:
00002E0E  4CDF 003C 5171          movem.l   (A7)+,D2/D3/D4/D5
00002E12  4E5E      5172          unlk      A6
00002E14  4E75      5173          rts
                    5174   ; }
                    5175   ; void MemoryTest(void)
                    5176   ; {
                    5177   _MemoryTest:
00002E16  4E56 FFD8 5178          link      A6,#-40
00002E1A  48E7 3F3C 5179          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00002E1E  45F9 0000 5180          lea       _printf.L,A2
00002E22  3434      
00002E24  47EE FFF0 5181          lea       -16(A6),A3
00002E28  4BF8 0C04 5182          lea       _Get1HexDigits.L,A5
                    5183   ; unsigned int *RamPtr, counter1=1 ;
00002E2C  2D7C 0000 5184          move.l    #1,-34(A6)
00002E30  0001 FFDE 
                    5185   ; register unsigned int i ;
                    5186   ; unsigned int Start, End ;
                    5187   ; char c ;
                    5188   ; int data_length;
                    5189   ; int data_pattern;
                    5190   ; int test_type;
                    5191   ; unsigned int addr_array[2];
                    5192   ; unsigned int start_addr, end_addr;
                    5193   ; unsigned char byte;
                    5194   ; unsigned short word;
                    5195   ; unsigned int long_word;
                    5196   ; int result;
                    5197   ; /*printf("\r\nStart Address: ") ;
                    5198   ; Start = Get8HexDigits(0) ;
                    5199   ; printf("\r\nEnd Address: ") ;
                    5200   ; End = Get8HexDigits(0) ;*/
                    5201   ; printf("\r\nDo you want the data to be 1. bytes, 2. words, or 3. long words? Provide the integer below.\n");
00002E34  4879 0000 5202          pea       @m68kde~1_156.L
00002E38  50F0      
00002E3A  4E92      5203          jsr       (A2)
00002E3C  584F      5204          addq.w    #4,A7
                    5205   ; //scanf("%x", &data_length);
                    5206   ; data_length = Get1HexDigits(0);
00002E3E  42A7      5207          clr.l     -(A7)
00002E40  4E95      5208          jsr       (A5)
00002E42  584F      5209          addq.w    #4,A7
00002E44  2400      5210          move.l    D0,D2
                    5211   ; //printf("data_length: %d", data_length);
                    5212   ; printf("\r\nDo you want the data to be composed of (hex) 1. 0, 2. 5, 3. A, or 4. F? Provide the integer below.\n");
00002E46  4879 0000 5213          pea       @m68kde~1_157.L
00002E4A  5150      
00002E4C  4E92      5214          jsr       (A2)
00002E4E  584F      5215          addq.w    #4,A7
                    5216   ; //scanf("%x", &data_pattern);
                    5217   ; data_pattern = Get1HexDigits(0);
00002E50  42A7      5218          clr.l     -(A7)
00002E52  4E95      5219          jsr       (A5)
00002E54  584F      5220          addq.w    #4,A7
00002E56  2800      5221          move.l    D0,D4
                    5222   ; //printf("data_pattern: %d", data_pattern);
                    5223   ; printf("\r\nDo you want to test 1. SRAM or 2. SDRAM? Provide the integer below.\n");
00002E58  4879 0000 5224          pea       @m68kde~1_158.L
00002E5C  51B6      
00002E5E  4E92      5225          jsr       (A2)
00002E60  584F      5226          addq.w    #4,A7
                    5227   ; test_type = Get1HexDigits(0);
00002E62  42A7      5228          clr.l     -(A7)
00002E64  4E95      5229          jsr       (A5)
00002E66  584F      5230          addq.w    #4,A7
00002E68  2840      5231          move.l    D0,A4
                    5232   ; if (test_type == 1){
00002E6A  200C      5233          move.l    A4,D0
00002E6C  0C80 0000 5234          cmp.l     #1,D0
00002E70  0001      
00002E72  660C      5235          bne.s     MemoryTest_1
                    5236   ; ask_addr_range_sram(addr_array, data_length);
00002E74  2F02      5237          move.l    D2,-(A7)
00002E76  2F0B      5238          move.l    A3,-(A7)
00002E78  4EB8 28E6 5239          jsr       _ask_addr_range_sram
00002E7C  504F      5240          addq.w    #8,A7
00002E7E  6014      5241          bra.s     MemoryTest_3
                    5242   MemoryTest_1:
                    5243   ; } else if (test_type == 2) {
00002E80  200C      5244          move.l    A4,D0
00002E82  0C80 0000 5245          cmp.l     #2,D0
00002E86  0002      
00002E88  660A      5246          bne.s     MemoryTest_3
                    5247   ; ask_addr_range_sdram(addr_array, data_length);
00002E8A  2F02      5248          move.l    D2,-(A7)
00002E8C  2F0B      5249          move.l    A3,-(A7)
00002E8E  4EB8 2A2C 5250          jsr       _ask_addr_range_sdram
00002E92  504F      5251          addq.w    #8,A7
                    5252   MemoryTest_3:
                    5253   ; }
                    5254   ; start_addr = addr_array[0];
00002E94  2D53 FFF8 5255          move.l    (A3),-8(A6)
                    5256   ; end_addr = addr_array[1];
00002E98  2D6B 0004 5257          move.l    4(A3),-4(A6)
00002E9C  FFFC      
                    5258   ; printf("Start address: %x\n", start_addr);
00002E9E  2F2E FFF8 5259          move.l    -8(A6),-(A7)
00002EA2  4879 0000 5260          pea       @m68kde~1_159.L
00002EA6  51FE      
00002EA8  4E92      5261          jsr       (A2)
00002EAA  504F      5262          addq.w    #8,A7
                    5263   ; printf("End address: %x\n", end_addr);
00002EAC  2F2E FFFC 5264          move.l    -4(A6),-(A7)
00002EB0  4879 0000 5265          pea       @m68kde~1_160.L
00002EB4  5212      
00002EB6  4E92      5266          jsr       (A2)
00002EB8  504F      5267          addq.w    #8,A7
                    5268   ; if (data_length == 1) {
00002EBA  0C82 0000 5269          cmp.l     #1,D2
00002EBE  0001      
00002EC0  6600 0034 5270          bne       MemoryTest_5
                    5271   ; byte = byte_data (data_pattern);
00002EC4  2F04      5272          move.l    D4,-(A7)
00002EC6  4EB8 2B72 5273          jsr       _byte_data
00002ECA  584F      5274          addq.w    #4,A7
00002ECC  1E00      5275          move.b    D0,D7
                    5276   ; printf ("Test data: %x\n",byte);
00002ECE  CEBC 0000 5277          and.l     #255,D7
00002ED2  00FF      
00002ED4  2F07      5278          move.l    D7,-(A7)
00002ED6  4879 0000 5279          pea       @m68kde~1_161.L
00002EDA  5224      
00002EDC  4E92      5280          jsr       (A2)
00002EDE  504F      5281          addq.w    #8,A7
                    5282   ; result = byte_test(byte, addr_array);
00002EE0  2F0B      5283          move.l    A3,-(A7)
00002EE2  CEBC 0000 5284          and.l     #255,D7
00002EE6  00FF      
00002EE8  2F07      5285          move.l    D7,-(A7)
00002EEA  4EB8 2C4A 5286          jsr       _byte_test
00002EEE  504F      5287          addq.w    #8,A7
00002EF0  2600      5288          move.l    D0,D3
00002EF2  6000 0066 5289          bra       MemoryTest_9
                    5290   MemoryTest_5:
                    5291   ; } else if (data_length == 2) {
00002EF6  0C82 0000 5292          cmp.l     #2,D2
00002EFA  0002      
00002EFC  6600 0032 5293          bne       MemoryTest_7
                    5294   ; word = word_data (data_pattern);
00002F00  2F04      5295          move.l    D4,-(A7)
00002F02  4EB8 2BB8 5296          jsr       _word_data
00002F06  584F      5297          addq.w    #4,A7
00002F08  3C00      5298          move.w    D0,D6
                    5299   ; printf ("Test data: %x\n", word);
00002F0A  CCBC 0000 5300          and.l     #65535,D6
00002F0E  FFFF      
00002F10  2F06      5301          move.l    D6,-(A7)
00002F12  4879 0000 5302          pea       @m68kde~1_161.L
00002F16  5224      
00002F18  4E92      5303          jsr       (A2)
00002F1A  504F      5304          addq.w    #8,A7
                    5305   ; result = word_test (word, addr_array);
00002F1C  2F0B      5306          move.l    A3,-(A7)
00002F1E  CCBC 0000 5307          and.l     #65535,D6
00002F22  FFFF      
00002F24  2F06      5308          move.l    D6,-(A7)
00002F26  4EB8 2CEA 5309          jsr       _word_test
00002F2A  504F      5310          addq.w    #8,A7
00002F2C  2600      5311          move.l    D0,D3
00002F2E  602A      5312          bra.s     MemoryTest_9
                    5313   MemoryTest_7:
                    5314   ; } else if (data_length == 3) {
00002F30  0C82 0000 5315          cmp.l     #3,D2
00002F34  0003      
00002F36  6622      5316          bne.s     MemoryTest_9
                    5317   ; long_word = long_word_data (data_pattern);
00002F38  2F04      5318          move.l    D4,-(A7)
00002F3A  4EB8 2C00 5319          jsr       _long_word_data
00002F3E  584F      5320          addq.w    #4,A7
00002F40  2A00      5321          move.l    D0,D5
                    5322   ; printf ("Test data: %x\n", long_word);
00002F42  2F05      5323          move.l    D5,-(A7)
00002F44  4879 0000 5324          pea       @m68kde~1_161.L
00002F48  5224      
00002F4A  4E92      5325          jsr       (A2)
00002F4C  504F      5326          addq.w    #8,A7
                    5327   ; result = long_word_test (long_word, addr_array);
00002F4E  2F0B      5328          move.l    A3,-(A7)
00002F50  2F05      5329          move.l    D5,-(A7)
00002F52  4EB8 2D8A 5330          jsr       _long_word_test
00002F56  504F      5331          addq.w    #8,A7
00002F58  2600      5332          move.l    D0,D3
                    5333   MemoryTest_9:
                    5334   ; }
                    5335   ; if (result == 1) {
00002F5A  0C83 0000 5336          cmp.l     #1,D3
00002F5E  0001      
00002F60  660A      5337          bne.s     MemoryTest_11
                    5338   ; printf("Test passed!\n");
00002F62  4879 0000 5339          pea       @m68kde~1_162.L
00002F66  5234      
00002F68  4E92      5340          jsr       (A2)
00002F6A  584F      5341          addq.w    #4,A7
                    5342   MemoryTest_11:
00002F6C  4CDF 3CFC 5343          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00002F70  4E5E      5344          unlk      A6
00002F72  4E75      5345          rts
                    5346   ; }
                    5347   ; }
                    5348   ; void main(void)
                    5349   ; {
                    5350   _main:
00002F74  4E56 FFF4 5351          link      A6,#-12
00002F78  48E7 3030 5352          movem.l   D2/D3/A2/A3,-(A7)
00002F7C  45F8 0A30 5353          lea       _InstallExceptionHandler.L,A2
00002F80  47F9 0000 5354          lea       _printf.L,A3
00002F84  3434      
                    5355   ; char c ;
                    5356   ; int i, j ;
                    5357   ; char *BugMessage = "DE1-68k Bug V1.77";
00002F86  41F9 0000 5358          lea       @m68kde~1_163.L,A0
00002F8A  5242      
00002F8C  2608      5359          move.l    A0,D3
                    5360   ; char *CopyrightMessage = "Copyright (C) PJ Davies 2016";
00002F8E  41F9 0000 5361          lea       @m68kde~1_164.L,A0
00002F92  5254      
00002F94  2D48 FFFC 5362          move.l    A0,-4(A6)
                    5363   ; KillAllBreakPoints() ;
00002F98  4EB8 1F92 5364          jsr       _KillAllBreakPoints
                    5365   ; i = x = y = z = PortA_Count = 0;
00002F9C  42B9 0B00 5366          clr.l     _PortA_Count.L
00002FA0  00D4      
00002FA2  42B9 0B00 5367          clr.l     _z.L
00002FA6  00D0      
00002FA8  42B9 0B00 5368          clr.l     _y.L
00002FAC  00CC      
00002FAE  42B9 0B00 5369          clr.l     _x.L
00002FB2  00C8      
00002FB4  4282      5370          clr.l     D2
                    5371   ; Trace = GoFlag = 0;                       // used in tracing/single stepping
00002FB6  42B9 0B00 5372          clr.l     _GoFlag.L
00002FBA  00DC      
00002FBC  42B9 0B00 5373          clr.l     _Trace.L
00002FC0  00D8      
                    5374   ; Echo = 1 ;
00002FC2  23FC 0000 5375          move.l    #1,_Echo.L
00002FC6  0001 0B00 
00002FCA  00E0      
                    5376   ; d0=d1=d2=d3=d4=d5=d6=d7=0 ;
00002FCC  42B9 0B00 5377          clr.l     _d7.L
00002FD0  0100      
00002FD2  42B9 0B00 5378          clr.l     _d6.L
00002FD6  00FC      
00002FD8  42B9 0B00 5379          clr.l     _d5.L
00002FDC  00F8      
00002FDE  42B9 0B00 5380          clr.l     _d4.L
00002FE2  00F4      
00002FE4  42B9 0B00 5381          clr.l     _d3.L
00002FE8  00F0      
00002FEA  42B9 0B00 5382          clr.l     _d2.L
00002FEE  00EC      
00002FF0  42B9 0B00 5383          clr.l     _d1.L
00002FF4  00E8      
00002FF6  42B9 0B00 5384          clr.l     _d0.L
00002FFA  00E4      
                    5385   ; a0=a1=a2=a3=a4=a5=a6=0 ;
00002FFC  42B9 0B00 5386          clr.l     _a6.L
00003000  011C      
00003002  42B9 0B00 5387          clr.l     _a5.L
00003006  0118      
00003008  42B9 0B00 5388          clr.l     _a4.L
0000300C  0114      
0000300E  42B9 0B00 5389          clr.l     _a3.L
00003012  0110      
00003014  42B9 0B00 5390          clr.l     _a2.L
00003018  010C      
0000301A  42B9 0B00 5391          clr.l     _a1.L
0000301E  0108      
00003020  42B9 0B00 5392          clr.l     _a0.L
00003024  0104      
                    5393   ; PC = ProgramStart, SSP=TopOfStack, USP = TopOfStack;
00003026  23FC 0800 5394          move.l    #134217728,_PC.L
0000302A  0000 0B00 
0000302E  0120      
00003030  23FC 0C00 5395          move.l    #201326592,_SSP.L
00003034  0000 0B00 
00003038  0124      
0000303A  23FC 0C00 5396          move.l    #201326592,_USP.L
0000303E  0000 0B00 
00003042  0128      
                    5397   ; SR = 0x2000;                            // clear interrupts enable tracing  uses IRQ6
00003044  33FC 2000 5398          move.w    #8192,_SR.L
00003048  0B00 012C 
                    5399   ; // Initialise Breakpoint variables
                    5400   ; for(i = 0; i < 8; i++)  {
0000304C  4282      5401          clr.l     D2
                    5402   main_1:
0000304E  0C82 0000 5403          cmp.l     #8,D2
00003052  0008      
00003054  6C00 004C 5404          bge       main_3
                    5405   ; BreakPointAddress[i] = 0;               //array of 8 breakpoint addresses
00003058  2002      5406          move.l    D2,D0
0000305A  E588      5407          lsl.l     #2,D0
0000305C  41F9 0B00 5408          lea       _BreakPointAddress.L,A0
00003060  012E      
00003062  42B0 0800 5409          clr.l     0(A0,D0.L)
                    5410   ; WatchPointAddress[i] = 0 ;
00003066  2002      5411          move.l    D2,D0
00003068  E588      5412          lsl.l     #2,D0
0000306A  41F9 0B00 5413          lea       _WatchPointAddress.L,A0
0000306E  0182      
00003070  42B0 0800 5414          clr.l     0(A0,D0.L)
                    5415   ; BreakPointInstruction[i] = 0;           // to hold the instruction at the break point
00003074  2002      5416          move.l    D2,D0
00003076  E388      5417          lsl.l     #1,D0
00003078  41F9 0B00 5418          lea       _BreakPointInstruction.L,A0
0000307C  014E      
0000307E  4270 0800 5419          clr.w     0(A0,D0.L)
                    5420   ; BreakPointSetOrCleared[i] = 0;          // indicates if break point set
00003082  2002      5421          move.l    D2,D0
00003084  E588      5422          lsl.l     #2,D0
00003086  41F9 0B00 5423          lea       _BreakPointSetOrCleared.L,A0
0000308A  015E      
0000308C  42B0 0800 5424          clr.l     0(A0,D0.L)
                    5425   ; WatchPointSetOrCleared[i] = 0;
00003090  2002      5426          move.l    D2,D0
00003092  E588      5427          lsl.l     #2,D0
00003094  41F9 0B00 5428          lea       _WatchPointSetOrCleared.L,A0
00003098  01A2      
0000309A  42B0 0800 5429          clr.l     0(A0,D0.L)
0000309E  5282      5430          addq.l    #1,D2
000030A0  60AC      5431          bra       main_1
                    5432   main_3:
                    5433   ; }
                    5434   ; Init_RS232() ;     // initialise the RS232 port
000030A2  4EB8 0B12 5435          jsr       _Init_RS232
                    5436   ; Init_LCD() ;
000030A6  4EB8 095E 5437          jsr       _Init_LCD
                    5438   ; for( i = 32; i < 48; i++)
000030AA  7420      5439          moveq     #32,D2
                    5440   main_4:
000030AC  0C82 0000 5441          cmp.l     #48,D2
000030B0  0030      
000030B2  6C0E      5442          bge.s     main_6
                    5443   ; InstallExceptionHandler(UnhandledTrap, i) ;		        // install Trap exception handler on vector 32-47
000030B4  2F02      5444          move.l    D2,-(A7)
000030B6  4878 280A 5445          pea       _UnhandledTrap.L
000030BA  4E92      5446          jsr       (A2)
000030BC  504F      5447          addq.w    #8,A7
000030BE  5282      5448          addq.l    #1,D2
000030C0  60EA      5449          bra       main_4
                    5450   main_6:
                    5451   ; InstallExceptionHandler(menu, 47) ;		                   // TRAP #15 call debug and end program
000030C2  4878 002F 5452          pea       47
000030C6  4878 24E4 5453          pea       _menu.L
000030CA  4E92      5454          jsr       (A2)
000030CC  504F      5455          addq.w    #8,A7
                    5456   ; InstallExceptionHandler(UnhandledIRQ1, 25) ;		      // install handler for interrupts
000030CE  4878 0019 5457          pea       25
000030D2  4878 27B0 5458          pea       _UnhandledIRQ1.L
000030D6  4E92      5459          jsr       (A2)
000030D8  504F      5460          addq.w    #8,A7
                    5461   ; InstallExceptionHandler(UnhandledIRQ2, 26) ;		      // install handler for interrupts
000030DA  4878 001A 5462          pea       26
000030DE  4878 27BC 5463          pea       _UnhandledIRQ2.L
000030E2  4E92      5464          jsr       (A2)
000030E4  504F      5465          addq.w    #8,A7
                    5466   ; InstallExceptionHandler(UnhandledIRQ3, 27) ;		      // install handler for interrupts
000030E6  4878 001B 5467          pea       27
000030EA  4878 27C8 5468          pea       _UnhandledIRQ3.L
000030EE  4E92      5469          jsr       (A2)
000030F0  504F      5470          addq.w    #8,A7
                    5471   ; InstallExceptionHandler(UnhandledIRQ4, 28) ;		      // install handler for interrupts
000030F2  4878 001C 5472          pea       28
000030F6  4878 27D4 5473          pea       _UnhandledIRQ4.L
000030FA  4E92      5474          jsr       (A2)
000030FC  504F      5475          addq.w    #8,A7
                    5476   ; InstallExceptionHandler(UnhandledIRQ5, 29) ;		      // install handler for interrupts
000030FE  4878 001D 5477          pea       29
00003102  4878 27E0 5478          pea       _UnhandledIRQ5.L
00003106  4E92      5479          jsr       (A2)
00003108  504F      5480          addq.w    #8,A7
                    5481   ; InstallExceptionHandler(UnhandledIRQ6, 30) ;		      // install handler for interrupts
0000310A  4878 001E 5482          pea       30
0000310E  4878 27EC 5483          pea       _UnhandledIRQ6.L
00003112  4E92      5484          jsr       (A2)
00003114  504F      5485          addq.w    #8,A7
                    5486   ; InstallExceptionHandler(UnhandledIRQ7, 31) ;		      // install handler for interrupts
00003116  4878 001F 5487          pea       31
0000311A  4878 27FE 5488          pea       _UnhandledIRQ7.L
0000311E  4E92      5489          jsr       (A2)
00003120  504F      5490          addq.w    #8,A7
                    5491   ; InstallExceptionHandler(HandleBreakPoint, 46) ;		           // install Trap 14 Break Point exception handler on vector 46
00003122  4878 002E 5492          pea       46
00003126  4878 2220 5493          pea       _HandleBreakPoint.L
0000312A  4E92      5494          jsr       (A2)
0000312C  504F      5495          addq.w    #8,A7
                    5496   ; InstallExceptionHandler(DumpRegistersandPause, 29) ;		   // install TRACE handler for IRQ5 on vector 29
0000312E  4878 001D 5497          pea       29
00003132  4878 1900 5498          pea       _DumpRegistersandPause.L
00003136  4E92      5499          jsr       (A2)
00003138  504F      5500          addq.w    #8,A7
                    5501   ; InstallExceptionHandler(BusError,2) ;                          // install Bus error handler
0000313A  4878 0002 5502          pea       2
0000313E  4878 2818 5503          pea       _BusError.L
00003142  4E92      5504          jsr       (A2)
00003144  504F      5505          addq.w    #8,A7
                    5506   ; InstallExceptionHandler(AddressError,3) ;                      // install address error handler (doesn't work on soft core 68k implementation)
00003146  4878 0003 5507          pea       3
0000314A  4878 2826 5508          pea       _AddressError.L
0000314E  4E92      5509          jsr       (A2)
00003150  504F      5510          addq.w    #8,A7
                    5511   ; InstallExceptionHandler(IllegalInstruction,4) ;                // install illegal instruction exception handler
00003152  4878 0004 5512          pea       4
00003156  4878 2834 5513          pea       _IllegalInstruction.L
0000315A  4E92      5514          jsr       (A2)
0000315C  504F      5515          addq.w    #8,A7
                    5516   ; InstallExceptionHandler(Dividebyzero,5) ;                      // install /0 exception handler
0000315E  4878 0005 5517          pea       5
00003162  4878 2842 5518          pea       _Dividebyzero.L
00003166  4E92      5519          jsr       (A2)
00003168  504F      5520          addq.w    #8,A7
                    5521   ; InstallExceptionHandler(Check,6) ;                             // install check instruction exception handler
0000316A  4878 0006 5522          pea       6
0000316E  4878 2850 5523          pea       _Check.L
00003172  4E92      5524          jsr       (A2)
00003174  504F      5525          addq.w    #8,A7
                    5526   ; InstallExceptionHandler(Trapv,7) ;                             // install trapv instruction exception handler
00003176  4878 0007 5527          pea       7
0000317A  4878 285E 5528          pea       _Trapv.L
0000317E  4E92      5529          jsr       (A2)
00003180  504F      5530          addq.w    #8,A7
                    5531   ; InstallExceptionHandler(PrivError,8) ;                         // install Priv Violation exception handler
00003182  4878 0008 5532          pea       8
00003186  4878 286C 5533          pea       _PrivError.L
0000318A  4E92      5534          jsr       (A2)
0000318C  504F      5535          addq.w    #8,A7
                    5536   ; InstallExceptionHandler(UnitIRQ,15) ;                          // install uninitialised IRQ exception handler
0000318E  4878 000F 5537          pea       15
00003192  4878 287A 5538          pea       _UnitIRQ.L
00003196  4E92      5539          jsr       (A2)
00003198  504F      5540          addq.w    #8,A7
                    5541   ; InstallExceptionHandler(Check,24) ;                            // install spurious IRQ exception handler
0000319A  4878 0018 5542          pea       24
0000319E  4878 2850 5543          pea       _Check.L
000031A2  4E92      5544          jsr       (A2)
000031A4  504F      5545          addq.w    #8,A7
                    5546   ; FlushKeyboard() ;                        // dump unread characters from keyboard
000031A6  4EB8 0BA6 5547          jsr       _FlushKeyboard
                    5548   ; TraceException = 0 ;                     // clear trace exception port to remove any software generated single step/trace
000031AA  4239 0040 5549          clr.b     4194314
000031AE  000A      
                    5550   ; // test for auto flash boot and run from Flash by reading switch 9 on DE1-soc board. If set, copy program from flash into Dram and run
                    5551   ; while(((char)(PortB & 0x02)) == (char)(0x02))    {
                    5552   main_7:
000031B0  1039 0040 5553          move.b    4194306,D0
000031B4  0002      
000031B6  C03C 0002 5554          and.b     #2,D0
000031BA  0C00 0002 5555          cmp.b     #2,D0
000031BE  662A      5556          bne.s     main_9
                    5557   ; LoadFromFlashChip();
000031C0  4EB8 1434 5558          jsr       _LoadFromFlashChip
                    5559   ; printf("\r\nRunning.....") ;
000031C4  4879 0000 5560          pea       @m68kde~1_165.L
000031C8  5272      
000031CA  4E93      5561          jsr       (A3)
000031CC  584F      5562          addq.w    #4,A7
                    5563   ; Oline1("Running.....") ;
000031CE  4879 0000 5564          pea       @m68kde~1_166.L
000031D2  5282      
000031D4  4EB8 0A02 5565          jsr       _Oline1
000031D8  584F      5566          addq.w    #4,A7
                    5567   ; GoFlag = 1;
000031DA  23FC 0000 5568          move.l    #1,_GoFlag.L
000031DE  0001 0B00 
000031E2  00DC      
                    5569   ; go() ;
000031E4  4EB8 08B8 5570          jsr       _go
000031E8  60C6      5571          bra       main_7
                    5572   main_9:
                    5573   ; }
                    5574   ; // otherwise start the debug monitor
                    5575   ; Oline0(BugMessage) ;
000031EA  2F03      5576          move.l    D3,-(A7)
000031EC  4EB8 09D4 5577          jsr       _Oline0
000031F0  584F      5578          addq.w    #4,A7
                    5579   ; Oline1("By: PJ Davies") ;
000031F2  4879 0000 5580          pea       @m68kde~1_167.L
000031F6  5290      
000031F8  4EB8 0A02 5581          jsr       _Oline1
000031FC  584F      5582          addq.w    #4,A7
                    5583   ; printf("\r\n%s", BugMessage) ;
000031FE  2F03      5584          move.l    D3,-(A7)
00003200  4879 0000 5585          pea       @m68kde~1_168.L
00003204  529E      
00003206  4E93      5586          jsr       (A3)
00003208  504F      5587          addq.w    #8,A7
                    5588   ; printf("\r\n%s", CopyrightMessage) ;
0000320A  2F2E FFFC 5589          move.l    -4(A6),-(A7)
0000320E  4879 0000 5590          pea       @m68kde~1_168.L
00003212  529E      
00003214  4E93      5591          jsr       (A3)
00003216  504F      5592          addq.w    #8,A7
                    5593   ; printf("\r\nStudent Name: Shidi Xi") ;
00003218  4879 0000 5594          pea       @m68kde~1_169.L
0000321C  52A4      
0000321E  4E93      5595          jsr       (A3)
00003220  584F      5596          addq.w    #4,A7
                    5597   ; printf("\r\nStudent Number: 90506643");
00003222  4879 0000 5598          pea       @m68kde~1_170.L
00003226  52BE      
00003228  4E93      5599          jsr       (A3)
0000322A  584F      5600          addq.w    #4,A7
                    5601   ; menu();
0000322C  4EB8 24E4 5602          jsr       _menu
00003230  4CDF 0C0C 5603          movem.l   (A7)+,D2/D3/A2/A3
00003234  4E5E      5604          unlk      A6
00003236  4E75      5605          rts
                    5606   ; }
                    5607   _strcpy:
00003238  206F 0004 5608          move.l    (4,A7),A0
0000323C  226F 0008 5609          move.l    (8,A7),A1
00003240  2008      5610          move.l    A0,D0
                    5611   strcpy_1:
00003242  10D9      5612          move.b    (A1)+,(A0)+
00003244  66FC      5613          bne       strcpy_1
00003246  4E75      5614          rts
                    5615   ULDIV:
00003248  4E56 0000 5616          link    A6,#0
0000324C  48E7 C000 5617          movem.l D0/D1,-(A7)
00003250  222E 0008 5618          move.l  8(A6),D1
00003254  202E 000C 5619          move.l  12(A6),D0
00003258  6036      5620          bra.s   ldiv_3
                    5621   LDIV:
0000325A  4E56 0000 5622          link    A6,#0
0000325E  48E7 C000 5623          movem.l D0/D1,-(A7)
00003262  222E 0008 5624          move.l  8(A6),D1
00003266  202E 000C 5625          move.l  12(A6),D0
0000326A  4A80      5626          tst.l   D0
0000326C  6A0E      5627          bpl.s   ldiv_1
0000326E  4480      5628          neg.l   D0
00003270  4A81      5629          tst.l   D1
00003272  6A14      5630          bpl.s   ldiv_2
00003274  4481      5631          neg.l   D1
00003276  612A      5632          bsr.s   dodiv
00003278  4481      5633          neg.l   D1
0000327A  6016      5634          bra.s   ldiv_4
                    5635   ldiv_1:
0000327C  4A81      5636          tst.l   D1
0000327E  6A10      5637          bpl.s   ldiv_3
00003280  4481      5638          neg.l   D1
00003282  611E      5639          bsr.s   dodiv
00003284  4480      5640          neg.l   D0
00003286  600A      5641          bra.s   ldiv_4
                    5642   ldiv_2:
00003288  6118      5643          bsr.s   dodiv
0000328A  4480      5644          neg.l   D0
0000328C  4481      5645          neg.l   D1
0000328E  6002      5646          bra.s   ldiv_4
                    5647   ldiv_3:
00003290  6110      5648          bsr.s   dodiv
                    5649   ldiv_4:
00003292  2D40 0008 5650          move.l  D0,8(A6)
00003296  2D41 000C 5651          move.l  D1,12(A6)
0000329A  4CDF 0003 5652          movem.l (A7)+,D0/D1
0000329E  4E5E      5653          unlk    A6
000032A0  4E75      5654          rts
                    5655   dodiv:
000032A2  0C81 0000 5656          cmpi.l  #$FFFF,D1
000032A6  FFFF      
000032A8  6236      5657          bhi.s   dodiv_2
000032AA  0C80 0000 5658          cmpi.l  #$FFFF,D0
000032AE  FFFF      
000032B0  6210      5659          bhi.s   dodiv_1
000032B2  80C1      5660          divu    D1,D0
000032B4  2200      5661          move.l  D0,D1
000032B6  4241      5662          clr.w   D1
000032B8  4841      5663          swap    D1
000032BA  0280 0000 5664          andi.l  #$FFFF,D0
000032BE  FFFF      
000032C0  4E75      5665          rts
                    5666   dodiv_1:
000032C2  48A7 A000 5667          movem.w D0/D2,-(A7)
000032C6  4240      5668          clr.w   D0
000032C8  4840      5669          swap    D0
000032CA  80C1      5670          divu    D1,D0
000032CC  3400      5671          move.w  D0,D2
000032CE  301F      5672          move.w  (A7)+,D0
000032D0  80C1      5673          divu    D1,D0
000032D2  4840      5674          swap    D0
000032D4  4281      5675          clr.l   D1
000032D6  3200      5676          move.w  D0,D1
000032D8  3002      5677          move.w  D2,D0
000032DA  4840      5678          swap    D0
000032DC  341F      5679          move.w  (A7)+,D2
000032DE  4E75      5680          rts
                    5681   dodiv_2:
000032E0  48E7 3800 5682          movem.l D2/D3/D4,-(A7)
000032E4  2401      5683          move.l  D1,D2
000032E6  4242      5684          clr.w   D2
000032E8  4842      5685          swap    D2
000032EA  5282      5686          addq.l  #1,D2
000032EC  2600      5687          move.l  D0,D3
000032EE  2801      5688          move.l  D1,D4
000032F0  2202      5689          move.l  D2,D1
000032F2  61CE      5690          bsr.s   dodiv_1
000032F4  2204      5691          move.l  D4,D1
000032F6  82C2      5692          divu    D2,D1
000032F8  80C1      5693          divu    D1,D0
000032FA  0280 0000 5694          andi.l  #$FFFF,D0
000032FE  FFFF      
                    5695   dodiv_3:
00003300  2204      5696          move.l  D4,D1
00003302  2404      5697          move.l  D4,D2
00003304  4842      5698          swap    D2
00003306  C2C0      5699          mulu    D0,D1
00003308  C4C0      5700          mulu    D0,D2
0000330A  4842      5701          swap    D2
0000330C  D282      5702          add.l   D2,D1
0000330E  9283      5703          sub.l   D3,D1
00003310  620A      5704          bhi.s   dodiv_4
00003312  4481      5705          neg.l   D1
00003314  B881      5706          cmp.l   D1,D4
00003316  6208      5707          bhi.s   dodiv_5
00003318  5280      5708          addq.l  #1,D0
0000331A  60E4      5709          bra.s   dodiv_3
                    5710   dodiv_4:
0000331C  5380      5711          subq.l  #1,D0
0000331E  60E0      5712          bra.s   dodiv_3
                    5713   dodiv_5:
00003320  4CDF 001C 5714          movem.l (A7)+,D2/D3/D4
00003324  4E75      5715          rts
                    5716   _putch:
00003326  4E56 0000 5717          link      A6,#0
0000332A  48E7 2000 5718          movem.l   D2,-(A7)
0000332E  242E 0008 5719          move.l    8(A6),D2
00003332  0C82 0000 5720          cmp.l     #10,D2
00003336  000A      
00003338  660A      5721          bne.s     putch_1
0000333A  4878 000D 5722          pea       13
0000333E  6100 D7FC 5723          bsr       __putch
00003342  584F      5724          addq.w    #4,A7
                    5725   putch_1:
00003344  2F02      5726          move.l    D2,-(A7)
00003346  6100 D7F4 5727          bsr       __putch
0000334A  584F      5728          addq.w    #4,A7
0000334C  2002      5729          move.l    D2,D0
0000334E  4CDF 0004 5730          movem.l   (A7)+,D2
00003352  4E5E      5731          unlk      A6
00003354  4E75      5732          rts
                    5733   _getch:
00003356  48E7 2000 5734          movem.l   D2,-(A7)
0000335A  2439 0B00 5735          move.l    __ungetbuf,D2
0000335E  00C0      
00003360  2039 0B00 5736          move.l    __ungetbuf,D0
00003364  00C0      
00003366  0C80 FFFF 5737          cmp.l     #-1,D0
0000336A  FFFF      
0000336C  670C      5738          beq.s     getch_1
0000336E  23FC FFFF 5739          move.l    #-1,__ungetbuf
00003372  FFFF 0B00 
00003376  00C0      
00003378  6010      5740          bra.s     getch_3
                    5741   getch_1:
0000337A  6100 D7EC 5742          bsr       __getch
0000337E  2400      5743          move.l    D0,D2
00003380  0C80 0000 5744          cmp.l     #13,D0
00003384  000D      
00003386  6602      5745          bne.s     getch_3
00003388  740A      5746          moveq     #10,D2
                    5747   getch_3:
0000338A  2002      5748          move.l    D2,D0
0000338C  4CDF 0004 5749          movem.l   (A7)+,D2
00003390  4E75      5750          rts
                    5751   _tolower:
00003392  4E56 0000 5752          link      A6,#0
00003396  48E7 2000 5753          movem.l   D2,-(A7)
0000339A  242E 0008 5754          move.l    8(A6),D2
0000339E  0C82 0000 5755          cmp.l     #65,D2
000033A2  0041      
000033A4  6D0E      5756          blt.s     tolower_1
000033A6  0C82 0000 5757          cmp.l     #90,D2
000033AA  005A      
000033AC  6E06      5758          bgt.s     tolower_1
000033AE  84BC 0000 5759          or.l      #32,D2
000033B2  0020      
                    5760   tolower_1:
000033B4  2002      5761          move.l    D2,D0
000033B6  4CDF 0004 5762          movem.l   (A7)+,D2
000033BA  4E5E      5763          unlk      A6
000033BC  4E75      5764          rts
                    5765   _sprintf:
000033BE  4E56 FFFC 5766          link      A6,#-4
000033C2  48E7 2000 5767          movem.l   D2,-(A7)
000033C6  41EE 000C 5768          lea       12(A6),A0
000033CA  5848      5769          addq.w    #4,A0
000033CC  2408      5770          move.l    A0,D2
000033CE  2F02      5771          move.l    D2,-(A7)
000033D0  2F2E 000C 5772          move.l    12(A6),-(A7)
000033D4  2F2E 0008 5773          move.l    8(A6),-(A7)
000033D8  6100 013E 5774          bsr       _vsprintf
000033DC  DEFC 000C 5775          add.w     #12,A7
000033E0  2D40 FFFC 5776          move.l    D0,-4(A6)
000033E4  4282      5777          clr.l     D2
000033E6  202E FFFC 5778          move.l    -4(A6),D0
000033EA  4CDF 0004 5779          movem.l   (A7)+,D2
000033EE  4E5E      5780          unlk      A6
000033F0  4E75      5781          rts
                    5782   _strcat:
000033F2  206F 0004 5783          move.l    (4,A7),A0	
000033F6  226F 0008 5784          move.l    (8,A7),A1	
000033FA  2008      5785          move.l    A0,D0		
                    5786   strcat_0:
000033FC  4A18      5787          tst.b     (A0)+
000033FE  66FC      5788          bne       strcat_0
00003400  5348      5789          subq      #1,A0
                    5790   strcat_1:
00003402  10D9      5791          move.b    (A1)+,(A0)+
00003404  66FC      5792          bne       strcat_1
00003406  4E75      5793          rts
                    5794   _toupper:
00003408  4E56 0000 5795          link      A6,#0
0000340C  48E7 2000 5796          movem.l   D2,-(A7)
00003410  242E 0008 5797          move.l    8(A6),D2
00003414  0C82 0000 5798          cmp.l     #97,D2
00003418  0061      
0000341A  6D0E      5799          blt.s     toupper_1
0000341C  0C82 0000 5800          cmp.l     #122,D2
00003420  007A      
00003422  6E06      5801          bgt.s     toupper_1
00003424  C4BC 0000 5802          and.l     #95,D2
00003428  005F      
                    5803   toupper_1:
0000342A  2002      5804          move.l    D2,D0
0000342C  4CDF 0004 5805          movem.l   (A7)+,D2
00003430  4E5E      5806          unlk      A6
00003432  4E75      5807          rts
                    5808   _printf:
00003434  4E56 FFFC 5809          link      A6,#-4
00003438  48E7 2000 5810          movem.l   D2,-(A7)
0000343C  41EE 0008 5811          lea       8(A6),A0
00003440  5848      5812          addq.w    #4,A0
00003442  2408      5813          move.l    A0,D2
00003444  2F02      5814          move.l    D2,-(A7)
00003446  2F2E 0008 5815          move.l    8(A6),-(A7)
0000344A  42A7      5816          clr.l     -(A7)
0000344C  6100 00CA 5817          bsr       _vsprintf
00003450  DEFC 000C 5818          add.w     #12,A7
00003454  2D40 FFFC 5819          move.l    D0,-4(A6)
00003458  4282      5820          clr.l     D2
0000345A  202E FFFC 5821          move.l    -4(A6),D0
0000345E  4CDF 0004 5822          movem.l   (A7)+,D2
00003462  4E5E      5823          unlk      A6
00003464  4E75      5824          rts
                    5825   @vsprintf_copy:
00003466  4E56 0000 5826          link      A6,#0
0000346A  206E 0008 5827          move.l    8(A6),A0
0000346E  4A90      5828          tst.l     (A0)
00003470  6710      5829          beq.s     @vsprintf_copy_1
00003472  202E 000C 5830          move.l    12(A6),D0
00003476  206E 0008 5831          move.l    8(A6),A0
0000347A  2250      5832          move.l    (A0),A1
0000347C  5290      5833          addq.l    #1,(A0)
0000347E  1280      5834          move.b    D0,(A1)
00003480  600A      5835          bra.s     @vsprintf_copy_2
                    5836   @vsprintf_copy_1:
00003482  2F2E 000C 5837          move.l    12(A6),-(A7)
00003486  6100 FE9E 5838          bsr       _putch
0000348A  584F      5839          addq.w    #4,A7
                    5840   @vsprintf_copy_2:
0000348C  4E5E      5841          unlk      A6
0000348E  4E75      5842          rts
                    5843   @vsprintf_getval:
00003490  4E56 0000 5844          link      A6,#0
00003494  48E7 3000 5845          movem.l   D2/D3,-(A7)
00003498  242E 0008 5846          move.l    8(A6),D2
0000349C  4283      5847          clr.l     D3
0000349E  2042      5848          move.l    D2,A0
000034A0  2050      5849          move.l    (A0),A0
000034A2  1010      5850          move.b    (A0),D0
000034A4  4880      5851          ext.w     D0
000034A6  48C0      5852          ext.l     D0
000034A8  0C80 0000 5853          cmp.l     #42,D0
000034AC  002A      
000034AE  6612      5854          bne.s     @vsprintf_getval_1
000034B0  206E 000C 5855          move.l    12(A6),A0
000034B4  2250      5856          move.l    (A0),A1
000034B6  5890      5857          addq.l    #4,(A0)
000034B8  2611      5858          move.l    (A1),D3
000034BA  2042      5859          move.l    D2,A0
000034BC  5290      5860          addq.l    #1,(A0)
000034BE  6000 004E 5861          bra       @vsprintf_getval_5
                    5862   @vsprintf_getval_1:
000034C2  2042      5863          move.l    D2,A0
000034C4  2050      5864          move.l    (A0),A0
000034C6  1010      5865          move.b    (A0),D0
000034C8  4880      5866          ext.w     D0
000034CA  48C0      5867          ext.l     D0
000034CC  0C80 0000 5868          cmp.l     #48,D0
000034D0  0030      
000034D2  6D00 003A 5869          blt       @vsprintf_getval_5
000034D6  2042      5870          move.l    D2,A0
000034D8  2050      5871          move.l    (A0),A0
000034DA  1010      5872          move.b    (A0),D0
000034DC  4880      5873          ext.w     D0
000034DE  48C0      5874          ext.l     D0
000034E0  0C80 0000 5875          cmp.l     #57,D0
000034E4  0039      
000034E6  6E26      5876          bgt.s     @vsprintf_getval_5
000034E8  2F03      5877          move.l    D3,-(A7)
000034EA  4878 000A 5878          pea       10
000034EE  6100 07F4 5879          bsr       LMUL
000034F2  2017      5880          move.l    (A7),D0
000034F4  504F      5881          addq.w    #8,A7
000034F6  2042      5882          move.l    D2,A0
000034F8  2250      5883          move.l    (A0),A1
000034FA  5290      5884          addq.l    #1,(A0)
000034FC  1211      5885          move.b    (A1),D1
000034FE  4881      5886          ext.w     D1
00003500  48C1      5887          ext.l     D1
00003502  D081      5888          add.l     D1,D0
00003504  0480 0000 5889          sub.l     #48,D0
00003508  0030      
0000350A  2600      5890          move.l    D0,D3
0000350C  60B4      5891          bra       @vsprintf_getval_1
                    5892   @vsprintf_getval_5:
0000350E  2003      5893          move.l    D3,D0
00003510  4CDF 000C 5894          movem.l   (A7)+,D2/D3
00003514  4E5E      5895          unlk      A6
00003516  4E75      5896          rts
                    5897   _vsprintf:
00003518  4E56 FFCC 5898          link      A6,#-52
0000351C  48E7 3F3C 5899          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00003520  45EE 0008 5900          lea       8(A6),A2
00003524  47F8 3466 5901          lea       @vsprintf_copy,A3
00003528  49F9 0000 5902          lea       _ultoa,A4
0000352C  3C70      
0000352E  4286      5903          clr.l     D6
                    5904   vsprintf_1:
00003530  206E 000C 5905          move.l    12(A6),A0
00003534  4A10      5906          tst.b     (A0)
00003536  6700 0624 5907          beq       vsprintf_3
0000353A  206E 000C 5908          move.l    12(A6),A0
0000353E  1010      5909          move.b    (A0),D0
00003540  4880      5910          ext.w     D0
00003542  48C0      5911          ext.l     D0
00003544  0C80 0000 5912          cmp.l     #37,D0
00003548  0025      
0000354A  671C      5913          beq.s     vsprintf_4
0000354C  206E 000C 5914          move.l    12(A6),A0
00003550  52AE 000C 5915          addq.l    #1,12(A6)
00003554  1210      5916          move.b    (A0),D1
00003556  4881      5917          ext.w     D1
00003558  48C1      5918          ext.l     D1
0000355A  2F01      5919          move.l    D1,-(A7)
0000355C  2F0A      5920          move.l    A2,-(A7)
0000355E  4E93      5921          jsr       (A3)
00003560  504F      5922          addq.w    #8,A7
00003562  5286      5923          addq.l    #1,D6
00003564  6000 05F2 5924          bra       vsprintf_2
                    5925   vsprintf_4:
00003568  52AE 000C 5926          addq.l    #1,12(A6)
0000356C  422E FFD3 5927          clr.b     -45(A6)
00003570  422E FFD2 5928          clr.b     -46(A6)
00003574  422E FFD0 5929          clr.b     -48(A6)
00003578  422E FFCF 5930          clr.b     -49(A6)
0000357C  422E FFCE 5931          clr.b     -50(A6)
00003580  422E FFCD 5932          clr.b     -51(A6)
00003584  42AE FFFC 5933          clr.l     -4(A6)
00003588  7AFF      5934          moveq     #-1,D5
0000358A  41EE FFDC 5935          lea       -36(A6),A0
0000358E  2608      5936          move.l    A0,D3
00003590  2408      5937          move.l    A0,D2
                    5938   vsprintf_6:
00003592  206E 000C 5939          move.l    12(A6),A0
00003596  1010      5940          move.b    (A0),D0
00003598  4880      5941          ext.w     D0
0000359A  48C0      5942          ext.l     D0
0000359C  0C80 0000 5943          cmp.l     #43,D0
000035A0  002B      
000035A2  6730      5944          beq.s     vsprintf_12
000035A4  6E18      5945          bgt.s     vsprintf_15
000035A6  0C80 0000 5946          cmp.l     #35,D0
000035AA  0023      
000035AC  6700 003E 5947          beq       vsprintf_14
000035B0  6E00 0046 5948          bgt       vsprintf_9
000035B4  0C80 0000 5949          cmp.l     #32,D0
000035B8  0020      
000035BA  6724      5950          beq.s     vsprintf_13
000035BC  603A      5951          bra.s     vsprintf_9
                    5952   vsprintf_15:
000035BE  0C80 0000 5953          cmp.l     #45,D0
000035C2  002D      
000035C4  6702      5954          beq.s     vsprintf_11
000035C6  6030      5955          bra.s     vsprintf_9
                    5956   vsprintf_11:
000035C8  1D7C 0001 5957          move.b    #1,-51(A6)
000035CC  FFCD      
000035CE  52AE 000C 5958          addq.l    #1,12(A6)
000035D2  6026      5959          bra.s     vsprintf_7
                    5960   vsprintf_12:
000035D4  1D7C 0001 5961          move.b    #1,-50(A6)
000035D8  FFCE      
000035DA  52AE 000C 5962          addq.l    #1,12(A6)
000035DE  601A      5963          bra.s     vsprintf_7
                    5964   vsprintf_13:
000035E0  1D7C 0001 5965          move.b    #1,-49(A6)
000035E4  FFCF      
000035E6  52AE 000C 5966          addq.l    #1,12(A6)
000035EA  600E      5967          bra.s     vsprintf_7
                    5968   vsprintf_14:
000035EC  1D7C 0001 5969          move.b    #1,-48(A6)
000035F0  FFD0      
000035F2  52AE 000C 5970          addq.l    #1,12(A6)
000035F6  6002      5971          bra.s     vsprintf_7
                    5972   vsprintf_9:
000035F8  6002      5973          bra.s     vsprintf_8
                    5974   vsprintf_7:
000035FA  6096      5975          bra       vsprintf_6
                    5976   vsprintf_8:
000035FC  206E 000C 5977          move.l    12(A6),A0
00003600  1010      5978          move.b    (A0),D0
00003602  4880      5979          ext.w     D0
00003604  48C0      5980          ext.l     D0
00003606  0C80 0000 5981          cmp.l     #48,D0
0000360A  0030      
0000360C  660A      5982          bne.s     vsprintf_16
0000360E  52AE 000C 5983          addq.l    #1,12(A6)
00003612  1D7C 0001 5984          move.b    #1,-46(A6)
00003616  FFD2      
                    5985   vsprintf_16:
00003618  486E 0010 5986          pea       16(A6)
0000361C  486E 000C 5987          pea       12(A6)
00003620  6100 FE6E 5988          bsr       @vsprintf_getval
00003624  504F      5989          addq.w    #8,A7
00003626  2A40      5990          move.l    D0,A5
00003628  206E 000C 5991          move.l    12(A6),A0
0000362C  1010      5992          move.b    (A0),D0
0000362E  4880      5993          ext.w     D0
00003630  48C0      5994          ext.l     D0
00003632  0C80 0000 5995          cmp.l     #46,D0
00003636  002E      
00003638  6614      5996          bne.s     vsprintf_18
0000363A  52AE 000C 5997          addq.l    #1,12(A6)
0000363E  486E 0010 5998          pea       16(A6)
00003642  486E 000C 5999          pea       12(A6)
00003646  6100 FE48 6000          bsr       @vsprintf_getval
0000364A  504F      6001          addq.w    #8,A7
0000364C  2A00      6002          move.l    D0,D5
                    6003   vsprintf_18:
0000364E  206E 000C 6004          move.l    12(A6),A0
00003652  1010      6005          move.b    (A0),D0
00003654  4880      6006          ext.w     D0
00003656  48C0      6007          ext.l     D0
00003658  0C80 0000 6008          cmp.l     #108,D0
0000365C  006C      
0000365E  660A      6009          bne.s     vsprintf_20
00003660  52AE 000C 6010          addq.l    #1,12(A6)
00003664  1D7C 0001 6011          move.b    #1,-45(A6)
00003668  FFD3      
                    6012   vsprintf_20:
0000366A  206E 000C 6013          move.l    12(A6),A0
0000366E  1010      6014          move.b    (A0),D0
00003670  4880      6015          ext.w     D0
00003672  48C0      6016          ext.l     D0
00003674  0C80 0000 6017          cmp.l     #111,D0
00003678  006F      
0000367A  6700 00D4 6018          beq       vsprintf_27
0000367E  6E34      6019          bgt.s     vsprintf_33
00003680  0C80 0000 6020          cmp.l     #100,D0
00003684  0064      
00003686  6700 0054 6021          beq       vsprintf_24
0000368A  6E1C      6022          bgt.s     vsprintf_34
0000368C  0C80 0000 6023          cmp.l     #99,D0
00003690  0063      
00003692  6700 012C 6024          beq       vsprintf_30
00003696  6E00 016A 6025          bgt       vsprintf_22
0000369A  0C80 0000 6026          cmp.l     #88,D0
0000369E  0058      
000036A0  6700 00E6 6027          beq       vsprintf_28
000036A4  6000 015C 6028          bra       vsprintf_22
                    6029   vsprintf_34:
000036A8  0C80 0000 6030          cmp.l     #105,D0
000036AC  0069      
000036AE  672C      6031          beq.s     vsprintf_24
000036B0  6000 0150 6032          bra       vsprintf_22
                    6033   vsprintf_33:
000036B4  0C80 0000 6034          cmp.l     #117,D0
000036B8  0075      
000036BA  6700 005C 6035          beq       vsprintf_26
000036BE  6E0E      6036          bgt.s     vsprintf_35
000036C0  0C80 0000 6037          cmp.l     #115,D0
000036C4  0073      
000036C6  6700 011C 6038          beq       vsprintf_31
000036CA  6000 0136 6039          bra       vsprintf_22
                    6040   vsprintf_35:
000036CE  0C80 0000 6041          cmp.l     #120,D0
000036D2  0078      
000036D4  6700 00B2 6042          beq       vsprintf_28
000036D8  6000 0128 6043          bra       vsprintf_22
                    6044   vsprintf_24:
000036DC  4A2E FFD3 6045          tst.b     -45(A6)
000036E0  671A      6046          beq.s     vsprintf_36
000036E2  4878 000A 6047          pea       10
000036E6  2F03      6048          move.l    D3,-(A7)
000036E8  206E 0010 6049          move.l    16(A6),A0
000036EC  58AE 0010 6050          addq.l    #4,16(A6)
000036F0  2F10      6051          move.l    (A0),-(A7)
000036F2  6100 04F8 6052          bsr       _ltoa
000036F6  DEFC 000C 6053          add.w     #12,A7
000036FA  6018      6054          bra.s     vsprintf_37
                    6055   vsprintf_36:
000036FC  4878 000A 6056          pea       10
00003700  2F03      6057          move.l    D3,-(A7)
00003702  206E 0010 6058          move.l    16(A6),A0
00003706  58AE 0010 6059          addq.l    #4,16(A6)
0000370A  2F10      6060          move.l    (A0),-(A7)
0000370C  6100 04DE 6061          bsr       _ltoa
00003710  DEFC 000C 6062          add.w     #12,A7
                    6063   vsprintf_37:
00003714  6000 00FA 6064          bra       vsprintf_23
                    6065   vsprintf_26:
00003718  4A2E FFD3 6066          tst.b     -45(A6)
0000371C  6718      6067          beq.s     vsprintf_38
0000371E  4878 000A 6068          pea       10
00003722  2F03      6069          move.l    D3,-(A7)
00003724  206E 0010 6070          move.l    16(A6),A0
00003728  58AE 0010 6071          addq.l    #4,16(A6)
0000372C  2F10      6072          move.l    (A0),-(A7)
0000372E  4E94      6073          jsr       (A4)
00003730  DEFC 000C 6074          add.w     #12,A7
00003734  6016      6075          bra.s     vsprintf_39
                    6076   vsprintf_38:
00003736  4878 000A 6077          pea       10
0000373A  2F03      6078          move.l    D3,-(A7)
0000373C  206E 0010 6079          move.l    16(A6),A0
00003740  58AE 0010 6080          addq.l    #4,16(A6)
00003744  2F10      6081          move.l    (A0),-(A7)
00003746  4E94      6082          jsr       (A4)
00003748  DEFC 000C 6083          add.w     #12,A7
                    6084   vsprintf_39:
0000374C  6000 00C2 6085          bra       vsprintf_23
                    6086   vsprintf_27:
00003750  4A2E FFD3 6087          tst.b     -45(A6)
00003754  6718      6088          beq.s     vsprintf_40
00003756  4878 0008 6089          pea       8
0000375A  2F03      6090          move.l    D3,-(A7)
0000375C  206E 0010 6091          move.l    16(A6),A0
00003760  58AE 0010 6092          addq.l    #4,16(A6)
00003764  2F10      6093          move.l    (A0),-(A7)
00003766  4E94      6094          jsr       (A4)
00003768  DEFC 000C 6095          add.w     #12,A7
0000376C  6016      6096          bra.s     vsprintf_41
                    6097   vsprintf_40:
0000376E  4878 0008 6098          pea       8
00003772  2F03      6099          move.l    D3,-(A7)
00003774  206E 0010 6100          move.l    16(A6),A0
00003778  58AE 0010 6101          addq.l    #4,16(A6)
0000377C  2F10      6102          move.l    (A0),-(A7)
0000377E  4E94      6103          jsr       (A4)
00003780  DEFC 000C 6104          add.w     #12,A7
                    6105   vsprintf_41:
00003784  6000 008A 6106          bra       vsprintf_23
                    6107   vsprintf_28:
00003788  4A2E FFD3 6108          tst.b     -45(A6)
0000378C  6718      6109          beq.s     vsprintf_42
0000378E  4878 0010 6110          pea       16
00003792  2F03      6111          move.l    D3,-(A7)
00003794  206E 0010 6112          move.l    16(A6),A0
00003798  58AE 0010 6113          addq.l    #4,16(A6)
0000379C  2F10      6114          move.l    (A0),-(A7)
0000379E  4E94      6115          jsr       (A4)
000037A0  DEFC 000C 6116          add.w     #12,A7
000037A4  6016      6117          bra.s     vsprintf_43
                    6118   vsprintf_42:
000037A6  4878 0010 6119          pea       16
000037AA  2F03      6120          move.l    D3,-(A7)
000037AC  206E 0010 6121          move.l    16(A6),A0
000037B0  58AE 0010 6122          addq.l    #4,16(A6)
000037B4  2F10      6123          move.l    (A0),-(A7)
000037B6  4E94      6124          jsr       (A4)
000037B8  DEFC 000C 6125          add.w     #12,A7
                    6126   vsprintf_43:
000037BC  6000 0052 6127          bra       vsprintf_23
                    6128   vsprintf_30:
000037C0  206E 0010 6129          move.l    16(A6),A0
000037C4  58AE 0010 6130          addq.l    #4,16(A6)
000037C8  2010      6131          move.l    (A0),D0
000037CA  2042      6132          move.l    D2,A0
000037CC  5282      6133          addq.l    #1,D2
000037CE  1080      6134          move.b    D0,(A0)
000037D0  2042      6135          move.l    D2,A0
000037D2  4210      6136          clr.b     (A0)
000037D4  200D      6137          move.l    A5,D0
000037D6  6704      6138          beq.s     vsprintf_44
000037D8  200D      6139          move.l    A5,D0
000037DA  6002      6140          bra.s     vsprintf_45
                    6141   vsprintf_44:
000037DC  7001      6142          moveq     #1,D0
                    6143   vsprintf_45:
000037DE  2A00      6144          move.l    D0,D5
000037E0  6000 002E 6145          bra       vsprintf_23
                    6146   vsprintf_31:
000037E4  206E 0010 6147          move.l    16(A6),A0
000037E8  58AE 0010 6148          addq.l    #4,16(A6)
000037EC  2610      6149          move.l    (A0),D3
000037EE  0C85 FFFF 6150          cmp.l     #-1,D5
000037F2  FFFF      
000037F4  660A      6151          bne.s     vsprintf_46
000037F6  2F03      6152          move.l    D3,-(A7)
000037F8  6100 0578 6153          bsr       _strlen
000037FC  584F      6154          addq.w    #4,A7
000037FE  2A00      6155          move.l    D0,D5
                    6156   vsprintf_46:
00003800  600E      6157          bra.s     vsprintf_23
                    6158   vsprintf_22:
00003802  206E 000C 6159          move.l    12(A6),A0
00003806  2242      6160          move.l    D2,A1
00003808  5282      6161          addq.l    #1,D2
0000380A  1290      6162          move.b    (A0),(A1)
0000380C  2042      6163          move.l    D2,A0
0000380E  4210      6164          clr.b     (A0)
                    6165   vsprintf_23:
00003810  2F03      6166          move.l    D3,-(A7)
00003812  6100 055E 6167          bsr       _strlen
00003816  584F      6168          addq.w    #4,A7
00003818  1800      6169          move.b    D0,D4
0000381A  206E 000C 6170          move.l    12(A6),A0
0000381E  1010      6171          move.b    (A0),D0
00003820  4880      6172          ext.w     D0
00003822  48C0      6173          ext.l     D0
00003824  0C80 0000 6174          cmp.l     #115,D0
00003828  0073      
0000382A  6618      6175          bne.s     vsprintf_48
0000382C  0C85 0000 6176          cmp.l     #0,D5
00003830  0000      
00003832  6D10      6177          blt.s     vsprintf_48
00003834  4884      6178          ext.w     D4
00003836  48C4      6179          ext.l     D4
00003838  B885      6180          cmp.l     D5,D4
0000383A  6F04      6181          ble.s     vsprintf_50
0000383C  1005      6182          move.b    D5,D0
0000383E  6002      6183          bra.s     vsprintf_51
                    6184   vsprintf_50:
00003840  1004      6185          move.b    D4,D0
                    6186   vsprintf_51:
00003842  1800      6187          move.b    D0,D4
                    6188   vsprintf_48:
00003844  206E 000C 6189          move.l    12(A6),A0
00003848  1010      6190          move.b    (A0),D0
0000384A  4880      6191          ext.w     D0
0000384C  48C0      6192          ext.l     D0
0000384E  0C80 0000 6193          cmp.l     #88,D0
00003852  0058      
00003854  6600 0026 6194          bne       vsprintf_56
00003858  41EE FFDC 6195          lea       -36(A6),A0
0000385C  2408      6196          move.l    A0,D2
                    6197   vsprintf_54:
0000385E  2042      6198          move.l    D2,A0
00003860  4A10      6199          tst.b     (A0)
00003862  6718      6200          beq.s     vsprintf_56
00003864  2042      6201          move.l    D2,A0
00003866  1210      6202          move.b    (A0),D1
00003868  4881      6203          ext.w     D1
0000386A  48C1      6204          ext.l     D1
0000386C  2F01      6205          move.l    D1,-(A7)
0000386E  6100 FB98 6206          bsr       _toupper
00003872  584F      6207          addq.w    #4,A7
00003874  2042      6208          move.l    D2,A0
00003876  1080      6209          move.b    D0,(A0)
00003878  5282      6210          addq.l    #1,D2
0000387A  60E2      6211          bra       vsprintf_54
                    6212   vsprintf_56:
0000387C  7E00      6213          moveq     #0,D7
0000387E  41EE FFD4 6214          lea       -44(A6),A0
00003882  2408      6215          move.l    A0,D2
00003884  206E 000C 6216          move.l    12(A6),A0
00003888  1010      6217          move.b    (A0),D0
0000388A  4880      6218          ext.w     D0
0000388C  48C0      6219          ext.l     D0
0000388E  0C80 0000 6220          cmp.l     #100,D0
00003892  0064      
00003894  6714      6221          beq.s     vsprintf_59
00003896  206E 000C 6222          move.l    12(A6),A0
0000389A  1010      6223          move.b    (A0),D0
0000389C  4880      6224          ext.w     D0
0000389E  48C0      6225          ext.l     D0
000038A0  0C80 0000 6226          cmp.l     #105,D0
000038A4  0069      
000038A6  6600 0076 6227          bne       vsprintf_65
                    6228   vsprintf_59:
000038AA  4A2E FFCE 6229          tst.b     -50(A6)
000038AE  6612      6230          bne.s     vsprintf_62
000038B0  2043      6231          move.l    D3,A0
000038B2  1010      6232          move.b    (A0),D0
000038B4  4880      6233          ext.w     D0
000038B6  48C0      6234          ext.l     D0
000038B8  0C80 0000 6235          cmp.l     #45,D0
000038BC  002D      
000038BE  6600 002E 6236          bne       vsprintf_60
                    6237   vsprintf_62:
000038C2  2043      6238          move.l    D3,A0
000038C4  1010      6239          move.b    (A0),D0
000038C6  4880      6240          ext.w     D0
000038C8  48C0      6241          ext.l     D0
000038CA  0C80 0000 6242          cmp.l     #45,D0
000038CE  002D      
000038D0  660E      6243          bne.s     vsprintf_63
000038D2  2043      6244          move.l    D3,A0
000038D4  5283      6245          addq.l    #1,D3
000038D6  2242      6246          move.l    D2,A1
000038D8  5282      6247          addq.l    #1,D2
000038DA  1290      6248          move.b    (A0),(A1)
000038DC  5304      6249          subq.b    #1,D4
000038DE  6008      6250          bra.s     vsprintf_64
                    6251   vsprintf_63:
000038E0  2042      6252          move.l    D2,A0
000038E2  5282      6253          addq.l    #1,D2
000038E4  10BC 002B 6254          move.b    #43,(A0)
                    6255   vsprintf_64:
000038E8  5287      6256          addq.l    #1,D7
000038EA  6000 0032 6257          bra       vsprintf_65
                    6258   vsprintf_60:
000038EE  4A2E FFCF 6259          tst.b     -49(A6)
000038F2  6700 002A 6260          beq       vsprintf_65
000038F6  2043      6261          move.l    D3,A0
000038F8  1010      6262          move.b    (A0),D0
000038FA  4880      6263          ext.w     D0
000038FC  48C0      6264          ext.l     D0
000038FE  0C80 0000 6265          cmp.l     #45,D0
00003902  002D      
00003904  660E      6266          bne.s     vsprintf_67
00003906  2043      6267          move.l    D3,A0
00003908  5283      6268          addq.l    #1,D3
0000390A  2242      6269          move.l    D2,A1
0000390C  5282      6270          addq.l    #1,D2
0000390E  1290      6271          move.b    (A0),(A1)
00003910  5304      6272          subq.b    #1,D4
00003912  6008      6273          bra.s     vsprintf_68
                    6274   vsprintf_67:
00003914  2042      6275          move.l    D2,A0
00003916  5282      6276          addq.l    #1,D2
00003918  10BC 0020 6277          move.b    #32,(A0)
                    6278   vsprintf_68:
0000391C  5287      6279          addq.l    #1,D7
                    6280   vsprintf_65:
0000391E  4A2E FFD0 6281          tst.b     -48(A6)
00003922  6700 0066 6282          beq       vsprintf_77
00003926  206E 000C 6283          move.l    12(A6),A0
0000392A  1010      6284          move.b    (A0),D0
0000392C  4880      6285          ext.w     D0
0000392E  48C0      6286          ext.l     D0
00003930  0C80 0000 6287          cmp.l     #111,D0
00003934  006F      
00003936  671A      6288          beq.s     vsprintf_73
00003938  6E0C      6289          bgt.s     vsprintf_76
0000393A  0C80 0000 6290          cmp.l     #88,D0
0000393E  0058      
00003940  6710      6291          beq.s     vsprintf_73
00003942  6000 0046 6292          bra       vsprintf_77
                    6293   vsprintf_76:
00003946  0C80 0000 6294          cmp.l     #120,D0
0000394A  0078      
0000394C  6704      6295          beq.s     vsprintf_73
0000394E  6000 003A 6296          bra       vsprintf_77
                    6297   vsprintf_73:
00003952  2042      6298          move.l    D2,A0
00003954  5282      6299          addq.l    #1,D2
00003956  10BC 0030 6300          move.b    #48,(A0)
0000395A  5287      6301          addq.l    #1,D7
0000395C  206E 000C 6302          move.l    12(A6),A0
00003960  1010      6303          move.b    (A0),D0
00003962  4880      6304          ext.w     D0
00003964  48C0      6305          ext.l     D0
00003966  0C80 0000 6306          cmp.l     #120,D0
0000396A  0078      
0000396C  6712      6307          beq.s     vsprintf_79
0000396E  206E 000C 6308          move.l    12(A6),A0
00003972  1010      6309          move.b    (A0),D0
00003974  4880      6310          ext.w     D0
00003976  48C0      6311          ext.l     D0
00003978  0C80 0000 6312          cmp.l     #88,D0
0000397C  0058      
0000397E  660A      6313          bne.s     vsprintf_77
                    6314   vsprintf_79:
00003980  2042      6315          move.l    D2,A0
00003982  5282      6316          addq.l    #1,D2
00003984  10BC 0078 6317          move.b    #120,(A0)
00003988  5287      6318          addq.l    #1,D7
                    6319   vsprintf_77:
0000398A  2042      6320          move.l    D2,A0
0000398C  4210      6321          clr.b     (A0)
0000398E  206E 000C 6322          move.l    12(A6),A0
00003992  1010      6323          move.b    (A0),D0
00003994  4880      6324          ext.w     D0
00003996  48C0      6325          ext.l     D0
00003998  0C80 0000 6326          cmp.l     #105,D0
0000399C  0069      
0000399E  6700 0076 6327          beq       vsprintf_82
000039A2  6E42      6328          bgt.s     vsprintf_93
000039A4  0C80 0000 6329          cmp.l     #99,D0
000039A8  0063      
000039AA  6700 0084 6330          beq       vsprintf_96
000039AE  6E1C      6331          bgt.s     vsprintf_94
000039B0  0C80 0000 6332          cmp.l     #88,D0
000039B4  0058      
000039B6  6700 005E 6333          beq       vsprintf_82
000039BA  6E00 0184 6334          bgt       vsprintf_80
000039BE  0C80 0000 6335          cmp.l     #69,D0
000039C2  0045      
000039C4  6700 0050 6336          beq       vsprintf_82
000039C8  6000 0176 6337          bra       vsprintf_80
                    6338   vsprintf_94:
000039CC  0C80 0000 6339          cmp.l     #101,D0
000039D0  0065      
000039D2  6700 0042 6340          beq       vsprintf_82
000039D6  6E00 0168 6341          bgt       vsprintf_80
000039DA  0C80 0000 6342          cmp.l     #100,D0
000039DE  0064      
000039E0  6734      6343          beq.s     vsprintf_82
000039E2  6000 015C 6344          bra       vsprintf_80
                    6345   vsprintf_93:
000039E6  0C80 0000 6346          cmp.l     #117,D0
000039EA  0075      
000039EC  6728      6347          beq.s     vsprintf_82
000039EE  6E1A      6348          bgt.s     vsprintf_95
000039F0  0C80 0000 6349          cmp.l     #115,D0
000039F4  0073      
000039F6  6700 0038 6350          beq       vsprintf_96
000039FA  6E00 0144 6351          bgt       vsprintf_80
000039FE  0C80 0000 6352          cmp.l     #111,D0
00003A02  006F      
00003A04  6710      6353          beq.s     vsprintf_82
00003A06  6000 0138 6354          bra       vsprintf_80
                    6355   vsprintf_95:
00003A0A  0C80 0000 6356          cmp.l     #120,D0
00003A0E  0078      
00003A10  6704      6357          beq.s     vsprintf_82
00003A12  6000 012C 6358          bra       vsprintf_80
                    6359   vsprintf_82:
00003A16  4A2E FFD2 6360          tst.b     -46(A6)
00003A1A  6714      6361          beq.s     vsprintf_96
00003A1C  4A2E FFCD 6362          tst.b     -51(A6)
00003A20  660E      6363          bne.s     vsprintf_96
00003A22  200D      6364          move.l    A5,D0
00003A24  9087      6365          sub.l     D7,D0
00003A26  4884      6366          ext.w     D4
00003A28  48C4      6367          ext.l     D4
00003A2A  9084      6368          sub.l     D4,D0
00003A2C  2D40 FFFC 6369          move.l    D0,-4(A6)
                    6370   vsprintf_96:
00003A30  202E FFFC 6371          move.l    -4(A6),D0
00003A34  0C80 0000 6372          cmp.l     #0,D0
00003A38  0000      
00003A3A  6C04      6373          bge.s     vsprintf_98
00003A3C  42AE FFFC 6374          clr.l     -4(A6)
                    6375   vsprintf_98:
00003A40  4A2E FFCD 6376          tst.b     -51(A6)
00003A44  6600 0030 6377          bne       vsprintf_104
00003A48  4884      6378          ext.w     D4
00003A4A  48C4      6379          ext.l     D4
00003A4C  2004      6380          move.l    D4,D0
00003A4E  D0AE FFFC 6381          add.l     -4(A6),D0
00003A52  D087      6382          add.l     D7,D0
00003A54  1D40 FFD1 6383          move.b    D0,-47(A6)
                    6384   vsprintf_102:
00003A58  102E FFD1 6385          move.b    -47(A6),D0
00003A5C  4880      6386          ext.w     D0
00003A5E  48C0      6387          ext.l     D0
00003A60  220D      6388          move.l    A5,D1
00003A62  534D      6389          subq.w    #1,A5
00003A64  B081      6390          cmp.l     D1,D0
00003A66  6C0E      6391          bge.s     vsprintf_104
00003A68  4878 0020 6392          pea       32
00003A6C  2F0A      6393          move.l    A2,-(A7)
00003A6E  4E93      6394          jsr       (A3)
00003A70  504F      6395          addq.w    #8,A7
00003A72  5286      6396          addq.l    #1,D6
00003A74  60E2      6397          bra       vsprintf_102
                    6398   vsprintf_104:
00003A76  41EE FFD4 6399          lea       -44(A6),A0
00003A7A  2408      6400          move.l    A0,D2
                    6401   vsprintf_105:
00003A7C  2042      6402          move.l    D2,A0
00003A7E  4A10      6403          tst.b     (A0)
00003A80  6716      6404          beq.s     vsprintf_107
00003A82  2042      6405          move.l    D2,A0
00003A84  5282      6406          addq.l    #1,D2
00003A86  1210      6407          move.b    (A0),D1
00003A88  4881      6408          ext.w     D1
00003A8A  48C1      6409          ext.l     D1
00003A8C  2F01      6410          move.l    D1,-(A7)
00003A8E  2F0A      6411          move.l    A2,-(A7)
00003A90  4E93      6412          jsr       (A3)
00003A92  504F      6413          addq.w    #8,A7
00003A94  5286      6414          addq.l    #1,D6
00003A96  60E4      6415          bra       vsprintf_105
                    6416   vsprintf_107:
00003A98  202E FFFC 6417          move.l    -4(A6),D0
00003A9C  1D40 FFD1 6418          move.b    D0,-47(A6)
                    6419   vsprintf_108:
00003AA0  102E FFD1 6420          move.b    -47(A6),D0
00003AA4  532E FFD1 6421          subq.b    #1,-47(A6)
00003AA8  4A00      6422          tst.b     D0
00003AAA  670E      6423          beq.s     vsprintf_110
00003AAC  4878 0030 6424          pea       48
00003AB0  2F0A      6425          move.l    A2,-(A7)
00003AB2  4E93      6426          jsr       (A3)
00003AB4  504F      6427          addq.w    #8,A7
00003AB6  5286      6428          addq.l    #1,D6
00003AB8  60E6      6429          bra       vsprintf_108
                    6430   vsprintf_110:
00003ABA  2043      6431          move.l    D3,A0
00003ABC  4A10      6432          tst.b     (A0)
00003ABE  6700 0048 6433          beq       vsprintf_113
00003AC2  206E 000C 6434          move.l    12(A6),A0
00003AC6  1010      6435          move.b    (A0),D0
00003AC8  4880      6436          ext.w     D0
00003ACA  48C0      6437          ext.l     D0
00003ACC  0C80 0000 6438          cmp.l     #115,D0
00003AD0  0073      
00003AD2  670C      6439          beq.s     vsprintf_116
00003AD4  6E18      6440          bgt.s     vsprintf_119
00003AD6  0C80 0000 6441          cmp.l     #99,D0
00003ADA  0063      
00003ADC  6702      6442          beq.s     vsprintf_116
00003ADE  600E      6443          bra.s     vsprintf_119
                    6444   vsprintf_116:
00003AE0  2005      6445          move.l    D5,D0
00003AE2  5385      6446          subq.l    #1,D5
00003AE4  0C80 0000 6447          cmp.l     #0,D0
00003AE8  0000      
00003AEA  6E02      6448          bgt.s     vsprintf_119
00003AEC  6016      6449          bra.s     vsprintf_115
                    6450   vsprintf_119:
00003AEE  2043      6451          move.l    D3,A0
00003AF0  5283      6452          addq.l    #1,D3
00003AF2  1210      6453          move.b    (A0),D1
00003AF4  4881      6454          ext.w     D1
00003AF6  48C1      6455          ext.l     D1
00003AF8  2F01      6456          move.l    D1,-(A7)
00003AFA  2F0A      6457          move.l    A2,-(A7)
00003AFC  4E93      6458          jsr       (A3)
00003AFE  504F      6459          addq.w    #8,A7
00003B00  5286      6460          addq.l    #1,D6
00003B02  6002      6461          bra.s     vsprintf_112
                    6462   vsprintf_115:
00003B04  6002      6463          bra.s     vsprintf_113
                    6464   vsprintf_112:
00003B06  60B2      6465          bra       vsprintf_110
                    6466   vsprintf_113:
00003B08  4A2E FFCD 6467          tst.b     -51(A6)
00003B0C  6700 0030 6468          beq       vsprintf_125
00003B10  4884      6469          ext.w     D4
00003B12  48C4      6470          ext.l     D4
00003B14  2004      6471          move.l    D4,D0
00003B16  D0AE FFFC 6472          add.l     -4(A6),D0
00003B1A  D087      6473          add.l     D7,D0
00003B1C  1D40 FFD1 6474          move.b    D0,-47(A6)
                    6475   vsprintf_123:
00003B20  102E FFD1 6476          move.b    -47(A6),D0
00003B24  4880      6477          ext.w     D0
00003B26  48C0      6478          ext.l     D0
00003B28  220D      6479          move.l    A5,D1
00003B2A  534D      6480          subq.w    #1,A5
00003B2C  B081      6481          cmp.l     D1,D0
00003B2E  6C0E      6482          bge.s     vsprintf_125
00003B30  4878 0020 6483          pea       32
00003B34  2F0A      6484          move.l    A2,-(A7)
00003B36  4E93      6485          jsr       (A3)
00003B38  504F      6486          addq.w    #8,A7
00003B3A  5386      6487          subq.l    #1,D6
00003B3C  60E2      6488          bra       vsprintf_123
                    6489   vsprintf_125:
00003B3E  6014      6490          bra.s     vsprintf_81
                    6491   vsprintf_80:
00003B40  206E 000C 6492          move.l    12(A6),A0
00003B44  1210      6493          move.b    (A0),D1
00003B46  4881      6494          ext.w     D1
00003B48  48C1      6495          ext.l     D1
00003B4A  2F01      6496          move.l    D1,-(A7)
00003B4C  2F0A      6497          move.l    A2,-(A7)
00003B4E  4E93      6498          jsr       (A3)
00003B50  504F      6499          addq.w    #8,A7
00003B52  5286      6500          addq.l    #1,D6
                    6501   vsprintf_81:
00003B54  52AE 000C 6502          addq.l    #1,12(A6)
                    6503   vsprintf_2:
00003B58  6000 F9D6 6504          bra       vsprintf_1
                    6505   vsprintf_3:
00003B5C  4A92      6506          tst.l     (A2)
00003B5E  6710      6507          beq.s     vsprintf_126
00003B60  4201      6508          clr.b     D1
00003B62  C2BC 0000 6509          and.l     #255,D1
00003B66  00FF      
00003B68  2F01      6510          move.l    D1,-(A7)
00003B6A  2F0A      6511          move.l    A2,-(A7)
00003B6C  4E93      6512          jsr       (A3)
00003B6E  504F      6513          addq.w    #8,A7
                    6514   vsprintf_126:
00003B70  2006      6515          move.l    D6,D0
00003B72  4CDF 3CFC 6516          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00003B76  4E5E      6517          unlk      A6
00003B78  4E75      6518          rts
                    6519   @itoa_convert:
00003B7A  4E56 0000 6520          link      A6,#0
00003B7E  48E7 3C00 6521          movem.l   D2/D3/D4/D5,-(A7)
00003B82  242E 0008 6522          move.l    8(A6),D2
00003B86  262E 0010 6523          move.l    16(A6),D3
00003B8A  2A2E 000C 6524          move.l    12(A6),D5
00003B8E  2F05      6525          move.l    D5,-(A7)
00003B90  2F03      6526          move.l    D3,-(A7)
00003B92  6100 F6B4 6527          bsr       ULDIV
00003B96  202F 0004 6528          move.l    4(A7),D0
00003B9A  504F      6529          addq.w    #8,A7
00003B9C  2800      6530          move.l    D0,D4
00003B9E  BA83      6531          cmp.l     D3,D5
00003BA0  651A      6532          blo.s     @itoa_convert_1
00003BA2  2F03      6533          move.l    D3,-(A7)
00003BA4  2F05      6534          move.l    D5,-(A7)
00003BA6  2F03      6535          move.l    D3,-(A7)
00003BA8  6100 F69E 6536          bsr       ULDIV
00003BAC  2217      6537          move.l    (A7),D1
00003BAE  504F      6538          addq.w    #8,A7
00003BB0  2F01      6539          move.l    D1,-(A7)
00003BB2  2F02      6540          move.l    D2,-(A7)
00003BB4  61C4      6541          bsr       @itoa_convert
00003BB6  DEFC 000C 6542          add.w     #12,A7
00003BBA  2400      6543          move.l    D0,D2
                    6544   @itoa_convert_1:
00003BBC  0C84 0000 6545          cmp.l     #9,D4
00003BC0  0009      
00003BC2  6E0A      6546          bgt.s     @itoa_convert_3
00003BC4  2004      6547          move.l    D4,D0
00003BC6  0680 0000 6548          add.l     #48,D0
00003BCA  0030      
00003BCC  600E      6549          bra.s     @itoa_convert_4
                    6550   @itoa_convert_3:
00003BCE  2004      6551          move.l    D4,D0
00003BD0  0680 0000 6552          add.l     #97,D0
00003BD4  0061      
00003BD6  0480 0000 6553          sub.l     #10,D0
00003BDA  000A      
                    6554   @itoa_convert_4:
00003BDC  2042      6555          move.l    D2,A0
00003BDE  1080      6556          move.b    D0,(A0)
00003BE0  2002      6557          move.l    D2,D0
00003BE2  5280      6558          addq.l    #1,D0
00003BE4  4CDF 003C 6559          movem.l   (A7)+,D2/D3/D4/D5
00003BE8  4E5E      6560          unlk      A6
00003BEA  4E75      6561          rts
                    6562   _ltoa:
00003BEC  4E56 0000 6563          link      A6,#0
00003BF0  48E7 3C00 6564          movem.l   D2/D3/D4/D5,-(A7)
00003BF4  242E 0008 6565          move.l    8(A6),D2
00003BF8  262E 000C 6566          move.l    12(A6),D3
00003BFC  2A2E 0010 6567          move.l    16(A6),D5
00003C00  2803      6568          move.l    D3,D4
00003C02  0C85 0000 6569          cmp.l     #2,D5
00003C06  0002      
00003C08  6D08      6570          blt.s     ltoa_3
00003C0A  0C85 0000 6571          cmp.l     #36,D5
00003C0E  0024      
00003C10  6F06      6572          ble.s     ltoa_1
                    6573   ltoa_3:
00003C12  2003      6574          move.l    D3,D0
00003C14  6000 0052 6575          bra       ltoa_4
                    6576   ltoa_1:
00003C18  0C85 0000 6577          cmp.l     #10,D5
00003C1C  000A      
00003C1E  6600 0032 6578          bne       ltoa_5
00003C22  0C82 0000 6579          cmp.l     #0,D2
00003C26  0000      
00003C28  6C28      6580          bge.s     ltoa_5
00003C2A  2002      6581          move.l    D2,D0
00003C2C  4480      6582          neg.l     D0
00003C2E  2400      6583          move.l    D0,D2
00003C30  0C82 0000 6584          cmp.l     #0,D2
00003C34  0000      
00003C36  6C12      6585          bge.s     ltoa_7
00003C38  4879 0000 6586          pea       @itoa_1
00003C3C  52DA      
00003C3E  2F03      6587          move.l    D3,-(A7)
00003C40  6100 F5F6 6588          bsr       _strcpy
00003C44  504F      6589          addq.w    #8,A7
00003C46  2003      6590          move.l    D3,D0
00003C48  601E      6591          bra.s     ltoa_4
                    6592   ltoa_7:
00003C4A  2044      6593          move.l    D4,A0
00003C4C  5284      6594          addq.l    #1,D4
00003C4E  10BC 002D 6595          move.b    #45,(A0)
                    6596   ltoa_5:
00003C52  2F05      6597          move.l    D5,-(A7)
00003C54  2F02      6598          move.l    D2,-(A7)
00003C56  2F04      6599          move.l    D4,-(A7)
00003C58  6100 FF20 6600          bsr       @itoa_convert
00003C5C  DEFC 000C 6601          add.w     #12,A7
00003C60  2800      6602          move.l    D0,D4
00003C62  2044      6603          move.l    D4,A0
00003C64  4210      6604          clr.b     (A0)
00003C66  2003      6605          move.l    D3,D0
                    6606   ltoa_4:
00003C68  4CDF 003C 6607          movem.l   (A7)+,D2/D3/D4/D5
00003C6C  4E5E      6608          unlk      A6
00003C6E  4E75      6609          rts
                    6610   _ultoa:
00003C70  4E56 0000 6611          link      A6,#0
00003C74  48E7 3800 6612          movem.l   D2/D3/D4,-(A7)
00003C78  262E 0010 6613          move.l    16(A6),D3
00003C7C  282E 000C 6614          move.l    12(A6),D4
00003C80  2404      6615          move.l    D4,D2
00003C82  0C83 0000 6616          cmp.l     #2,D3
00003C86  0002      
00003C88  6D08      6617          blt.s     ultoa_3
00003C8A  0C83 0000 6618          cmp.l     #36,D3
00003C8E  0024      
00003C90  6F04      6619          ble.s     ultoa_1
                    6620   ultoa_3:
00003C92  2004      6621          move.l    D4,D0
00003C94  6018      6622          bra.s     ultoa_4
                    6623   ultoa_1:
00003C96  2F03      6624          move.l    D3,-(A7)
00003C98  2F2E 0008 6625          move.l    8(A6),-(A7)
00003C9C  2F02      6626          move.l    D2,-(A7)
00003C9E  6100 FEDA 6627          bsr       @itoa_convert
00003CA2  DEFC 000C 6628          add.w     #12,A7
00003CA6  2400      6629          move.l    D0,D2
00003CA8  2042      6630          move.l    D2,A0
00003CAA  4210      6631          clr.b     (A0)
00003CAC  2004      6632          move.l    D4,D0
                    6633   ultoa_4:
00003CAE  4CDF 001C 6634          movem.l   (A7)+,D2/D3/D4
00003CB2  4E5E      6635          unlk      A6
00003CB4  4E75      6636          rts
                    6637   _itoa:
00003CB6  4E56 0000 6638          link      A6,#0
00003CBA  2F2E 0010 6639          move.l    16(A6),-(A7)
00003CBE  2F2E 000C 6640          move.l    12(A6),-(A7)
00003CC2  2F2E 0008 6641          move.l    8(A6),-(A7)
00003CC6  6100 FF24 6642          bsr       _ltoa
00003CCA  DEFC 000C 6643          add.w     #12,A7
00003CCE  4E5E      6644          unlk      A6
00003CD0  4E75      6645          rts
                    6646   ULMUL:
00003CD2  4E56 0000 6647          link    A6,#0
00003CD6  48E7 C000 6648          movem.l D0/D1,-(A7)
00003CDA  222E 0008 6649          move.l  8(A6),D1
00003CDE  202E 000C 6650          move.l  12(A6),D0
00003CE2  602C      6651          bra.s   lmul_3
                    6652   LMUL:
00003CE4  4E56 0000 6653          link    A6,#0
00003CE8  48E7 C000 6654          movem.l D0/D1,-(A7)
00003CEC  222E 0008 6655          move.l  8(A6),D1
00003CF0  202E 000C 6656          move.l  12(A6),D0
00003CF4  4A80      6657          tst.l   D0
00003CF6  6A0A      6658          bpl.s   lmul_1
00003CF8  4480      6659          neg.l   D0
00003CFA  4A81      6660          tst.l   D1
00003CFC  6A0A      6661          bpl.s   lmul_2
00003CFE  4481      6662          neg.l   D1
00003D00  600E      6663          bra.s   lmul_3
                    6664   lmul_1:
00003D02  4A81      6665          tst.l   D1
00003D04  6A0A      6666          bpl.s   lmul_3
00003D06  4481      6667          neg.l   D1
                    6668   lmul_2:
00003D08  6114      6669          bsr.s   domul
00003D0A  4481      6670          neg.l   D1
00003D0C  4080      6671          negx.l  D0
00003D0E  6002      6672          bra.s   lmul_4
                    6673   lmul_3:
00003D10  610C      6674          bsr.s   domul
                    6675   lmul_4:
00003D12  2D41 0008 6676          move.l  D1,8(A6)
00003D16  4CDF 0003 6677          movem.l (A7)+,D0/D1
00003D1A  4E5E      6678          unlk    A6
00003D1C  4E75      6679          rts
                    6680   domul:
00003D1E  0C81 0000 6681          cmpi.l  #$FFFF,D1
00003D22  FFFF      
00003D24  620C      6682          bhi.s   domul_1
00003D26  0C80 0000 6683          cmpi.l  #$FFFF,D0
00003D2A  FFFF      
00003D2C  620E      6684          bhi.s   domul_2
00003D2E  C2C0      6685          mulu    D0,D1
00003D30  4E75      6686          rts
                    6687   domul_1:
00003D32  0C80 0000 6688          cmpi.l  #$FFFF,D0
00003D36  FFFF      
00003D38  6218      6689          bhi.s   domul_4
00003D3A  6002      6690          bra.s   domul_3
                    6691   domul_2
00003D3C  C141      6692          exg     D0,D1
                    6693   domul_3:
00003D3E  2F02      6694          move.l  D2,-(A7)
00003D40  2401      6695          move.l  D1,D2
00003D42  4842      6696          swap    D2
00003D44  C2C0      6697          mulu    D0,D1
00003D46  C4C0      6698          mulu    D0,D2
00003D48  4842      6699          swap    D2
00003D4A  4242      6700          clr.w   D2
00003D4C  D282      6701          add.l   D2,D1
00003D4E  241F      6702          move.l  (A7)+,D2
00003D50  4E75      6703          rts
                    6704   domul_4:
00003D52  48E7 3000 6705          movem.l D2/D3,-(A7)
00003D56  2401      6706          move.l  D1,D2
00003D58  2601      6707          move.l  D1,D3
00003D5A  C2C0      6708          mulu    D0,D1
00003D5C  4842      6709          swap    D2
00003D5E  C4C0      6710          mulu    D0,D2
00003D60  4840      6711          swap    D0
00003D62  C6C0      6712          mulu    D0,D3
00003D64  D483      6713          add.l   D3,D2
00003D66  4842      6714          swap    D2
00003D68  4242      6715          clr.w   D2
00003D6A  D282      6716          add.l   D2,D1
00003D6C  4CDF 000C 6717          movem.l (A7)+,D2/D3
00003D70  4E75      6718          rts
                    6719   _strlen:
00003D72  206F 0004 6720          move.l    (4,A7),A0
00003D76  2248      6721          move.l    A0,A1
                    6722   strlen_1:
00003D78  4A19      6723          tst.b     (A1)+
00003D7A  66FC      6724          bne       strlen_1
00003D7C  2009      6725          move.l    A1,D0
00003D7E  9088      6726          sub.l     A0,D0
00003D80  5380      6727          subq.l    #1,D0
00003D82  4E75      6728          rts
                    6729          section   const
                    6730   
                    6731   @m68kde~1_1:
00003D84  0D0A 00   6732          dc.b      13,10,0
                    6733   @m68kde~1_2:
00003D88  0D53 7769 6734          dc.b      13,83,119,105,116,99,104,101,115,32,83,87,91
00003D8C  7463 6865 
00003D90  7320 5357 
00003D94  5B        
00003D95  372D 305D 6735          dc.b      55,45,48,93,32,61,32,0
00003D99  203D 2000 
                    6736   @m68kde~1_3:
00003D9E  3000      6737          dc.b      48,0
                    6738   @m68kde~1_4:
00003DA0  3100      6739          dc.b      49,0
                    6740   @m68kde~1_5:
00003DA2  0D0A 4475 6741          dc.b      13,10,68,117,109,112,32,77,101,109,111,114,121
00003DA6  6D70 204D 
00003DAA  656D 6F72 
00003DAE  79        
00003DAF  2042 6C6F 6742          dc.b      32,66,108,111,99,107,58,32,60,69,83,67,62,32
00003DB3  636B 3A20 
00003DB7  3C45 5343 
00003DBB  3E20      
00003DBD  746F 2041 6743          dc.b      116,111,32,65,98,111,114,116,44,32,60,83,80
00003DC1  626F 7274 
00003DC5  2C20 3C53 
00003DC9  50        
00003DCA  4143 453E 6744          dc.b      65,67,69,62,32,116,111,32,67,111,110,116,105
00003DCE  2074 6F20 
00003DD2  436F 6E74 
00003DD6  69        
00003DD7  6E75 6500 6745          dc.b      110,117,101,0
                    6746   @m68kde~1_6:
00003DDC  0D0A 456E 6747          dc.b      13,10,69,110,116,101,114,32,83,116,97,114,116
00003DE0  7465 7220 
00003DE4  5374 6172 
00003DE8  74        
00003DE9  2041 6464 6748          dc.b      32,65,100,100,114,101,115,115,58,32,0
00003DED  7265 7373 
00003DF1  3A20 00   
                    6749   @m68kde~1_7:
00003DF4  0D0A 2530 6750          dc.b      13,10,37,48,56,120,32,0
00003DF8  3878 2000 
                    6751   @m68kde~1_8:
00003DFC  2530 3258 6752          dc.b      37,48,50,88,0
00003E00  00        
                    6753   @m68kde~1_9:
00003E02  2020 00   6754          dc.b      32,32,0
                    6755   @m68kde~1_10:
00003E06  0D0A 4669 6756          dc.b      13,10,70,105,108,108,32,77,101,109,111,114,121
00003E0A  6C6C 204D 
00003E0E  656D 6F72 
00003E12  79        
00003E13  2042 6C6F 6757          dc.b      32,66,108,111,99,107,0
00003E17  636B 00   
                    6758   @m68kde~1_11:
00003E1A  0D0A 456E 6759          dc.b      13,10,69,110,116,101,114,32,69,110,100,32,65
00003E1E  7465 7220 
00003E22  456E 6420 
00003E26  41        
00003E27  6464 7265 6760          dc.b      100,100,114,101,115,115,58,32,0
00003E2B  7373 3A20 
00003E2F  00        
                    6761   @m68kde~1_12:
00003E30  0D0A 456E 6762          dc.b      13,10,69,110,116,101,114,32,70,105,108,108,32
00003E34  7465 7220 
00003E38  4669 6C6C 
00003E3C  20        
00003E3D  4461 7461 6763          dc.b      68,97,116,97,58,32,0
00003E41  3A20 00   
                    6764   @m68kde~1_13:
00003E44  0D0A 4669 6765          dc.b      13,10,70,105,108,108,105,110,103,32,65,100,100
00003E48  6C6C 696E 
00003E4C  6720 4164 
00003E50  64        
00003E51  7265 7373 6766          dc.b      114,101,115,115,101,115,32,91,36,37,48,56,88
00003E55  6573 205B 
00003E59  2425 3038 
00003E5D  58        
00003E5E  202D 2024 6767          dc.b      32,45,32,36,37,48,56,88,93,32,119,105,116,104
00003E62  2530 3858 
00003E66  5D20 7769 
00003E6A  7468      
00003E6C  2024 2530 6768          dc.b      32,36,37,48,50,88,0
00003E70  3258 00   
                    6769   @m68kde~1_14:
00003E74  0D0A 5573 6770          dc.b      13,10,85,115,101,32,72,121,112,101,114,84,101
00003E78  6520 4879 
00003E7C  7065 7254 
00003E80  65        
00003E81  726D 696E 6771          dc.b      114,109,105,110,97,108,32,116,111,32,83,101
00003E85  616C 2074 
00003E89  6F20 5365 
00003E8D  6E64 2054 6772          dc.b      110,100,32,84,101,120,116,32,70,105,108,101
00003E91  6578 7420 
00003E95  4669 6C65 
00003E99  2028 2E68 6773          dc.b      32,40,46,104,101,120,41,13,10,0
00003E9D  6578 290D 
00003EA1  0A00      
                    6774   @m68kde~1_15:
00003EA4  0D0A 4C6F 6775          dc.b      13,10,76,111,97,100,32,70,97,105,108,101,100
00003EA8  6164 2046 
00003EAC  6169 6C65 
00003EB0  64        
00003EB1  2061 7420 6776          dc.b      32,97,116,32,65,100,100,114,101,115,115,32,61
00003EB5  4164 6472 
00003EB9  6573 7320 
00003EBD  3D        
00003EBE  205B 2425 6777          dc.b      32,91,36,37,48,56,88,93,13,10,0
00003EC2  3038 585D 
00003EC6  0D0A 00   
                    6778   @m68kde~1_16:
00003ECA  0D0A 5375 6779          dc.b      13,10,83,117,99,99,101,115,115,58,32,68,111
00003ECE  6363 6573 
00003ED2  733A 2044 
00003ED6  6F        
00003ED7  776E 6C6F 6780          dc.b      119,110,108,111,97,100,101,100,32,37,100,32
00003EDB  6164 6564 
00003EDF  2025 6420 
00003EE3  6279 7465 6781          dc.b      98,121,116,101,115,13,10,0
00003EE7  730D 0A00 
                    6782   @m68kde~1_17:
00003EEC  0D0A 4578 6783          dc.b      13,10,69,120,97,109,105,110,101,32,97,110,100
00003EF0  616D 696E 
00003EF4  6520 616E 
00003EF8  64        
00003EF9  2043 6861 6784          dc.b      32,67,104,97,110,103,101,32,77,101,109,111,114
00003EFD  6E67 6520 
00003F01  4D65 6D6F 
00003F05  72        
00003F06  7900      6785          dc.b      121,0
                    6786   @m68kde~1_18:
00003F08  0D0A 3C45 6787          dc.b      13,10,60,69,83,67,62,32,116,111,32,83,116,111
00003F0C  5343 3E20 
00003F10  746F 2053 
00003F14  746F      
00003F16  702C 203C 6788          dc.b      112,44,32,60,83,80,65,67,69,62,32,116,111,32
00003F1A  5350 4143 
00003F1E  453E 2074 
00003F22  6F20      
00003F24  4164 7661 6789          dc.b      65,100,118,97,110,99,101,44,32,39,45,39,32,116
00003F28  6E63 652C 
00003F2C  2027 2D27 
00003F30  2074      
00003F32  6F20 476F 6790          dc.b      111,32,71,111,32,66,97,99,107,44,32,60,68,65
00003F36  2042 6163 
00003F3A  6B2C 203C 
00003F3E  4441      
00003F40  5441 3E20 6791          dc.b      84,65,62,32,116,111,32,99,104,97,110,103,101
00003F44  746F 2063 
00003F48  6861 6E67 
00003F4C  65        
00003F4D  00        6792          dc.b      0
                    6793   @m68kde~1_19:
00003F4E  0D0A 456E 6794          dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
00003F52  7465 7220 
00003F56  4164 6472 
00003F5A  65        
00003F5B  7373 3A20 6795          dc.b      115,115,58,32,0
00003F5F  00        
                    6796   @m68kde~1_20:
00003F60  0D0A 5B25 6797          dc.b      13,10,91,37,48,56,120,93,32,58,32,37,48,50,120
00003F64  3038 785D 
00003F68  203A 2025 
00003F6C  3032 78   
00003F6F  2020 00   6798          dc.b      32,32,0
                    6799   @m68kde~1_21:
00003F72  0D0A 5761 6800          dc.b      13,10,87,97,114,110,105,110,103,32,67,104,97
00003F76  726E 696E 
00003F7A  6720 4368 
00003F7E  61        
00003F7F  6E67 6520 6801          dc.b      110,103,101,32,70,97,105,108,101,100,58,32,87
00003F83  4661 696C 
00003F87  6564 3A20 
00003F8B  57        
00003F8C  726F 7465 6802          dc.b      114,111,116,101,32,91,37,48,50,120,93,44,32
00003F90  205B 2530 
00003F94  3278 5D2C 
00003F98  20        
00003F99  5265 6164 6803          dc.b      82,101,97,100,32,91,37,48,50,120,93,0
00003F9D  205B 2530 
00003FA1  3278 5D00 
                    6804   @m68kde~1_22:
00003FA6  0D0A 4461 6805          dc.b      13,10,68,97,116,97,32,100,105,115,99,114,101
00003FAA  7461 2064 
00003FAE  6973 6372 
00003FB2  65        
00003FB3  7061 6E63 6806          dc.b      112,97,110,99,121,32,97,116,32,108,111,99,97
00003FB7  7920 6174 
00003FBB  206C 6F63 
00003FBF  61        
00003FC0  7469 6F6E 6807          dc.b      116,105,111,110,58,32,37,120,32,83,68,82,65
00003FC4  3A20 2578 
00003FC8  2053 4452 
00003FCC  41        
00003FCD  4D20 6461 6808          dc.b      77,32,100,97,116,97,58,32,37,120,32,70,108,97
00003FD1  7461 3A20 
00003FD5  2578 2046 
00003FD9  6C61      
00003FDB  7368 2064 6809          dc.b      115,104,32,100,97,116,97,58,32,37,120,0
00003FDF  6174 613A 
00003FE3  2025 7800 
                    6810   @m68kde~1_23:
00003FE8  0D0A 6C6F 6811          dc.b      13,10,108,111,99,97,116,105,111,110,58,32,37
00003FEC  6361 7469 
00003FF0  6F6E 3A20 
00003FF4  25        
00003FF5  7820 5344 6812          dc.b      120,32,83,68,82,65,77,32,100,97,116,97,58,32
00003FF9  5241 4D20 
00003FFD  6461 7461 
00004001  3A20      
00004003  2578 2046 6813          dc.b      37,120,32,70,108,97,115,104,32,100,97,116,97
00004007  6C61 7368 
0000400B  2064 6174 
0000400F  61        
00004010  3A20 2578 6814          dc.b      58,32,37,120,0
00004014  00        
                    6815   @m68kde~1_24:
00004016  0D0A 4572 6816          dc.b      13,10,69,114,97,115,105,110,103,32,83,80,73
0000401A  6173 696E 
0000401E  6720 5350 
00004022  49        
00004023  2066 6C61 6817          dc.b      32,102,108,97,115,104,46,46,46,46,0
00004027  7368 2E2E 
0000402B  2E2E 00   
                    6818   @m68kde~1_25:
0000402E  0D0A 5772 6819          dc.b      13,10,87,114,105,116,116,105,110,103,32,116
00004032  6974 7469 
00004036  6E67 2074 
0000403A  6865 2053 6820          dc.b      104,101,32,83,80,73,32,102,108,97,115,104,32
0000403E  5049 2066 
00004042  6C61 7368 
00004046  20        
00004047  7573 696E 6821          dc.b      117,115,105,110,103,32,83,68,82,65,77,32,100
0000404B  6720 5344 
0000404F  5241 4D20 
00004053  64        
00004054  6174 612E 6822          dc.b      97,116,97,46,46,46,46,0
00004058  2E2E 2E00 
                    6823   @m68kde~1_26:
0000405C  0D0A 5265 6824          dc.b      13,10,82,101,97,100,105,110,103,32,116,104,101
00004060  6164 696E 
00004064  6720 7468 
00004068  65        
00004069  2053 5049 6825          dc.b      32,83,80,73,32,102,108,97,115,104,32,100,97
0000406D  2066 6C61 
00004071  7368 2064 
00004075  61        
00004076  7461 2061 6826          dc.b      116,97,32,97,110,100,32,99,111,109,112,97,114
0000407A  6E64 2063 
0000407E  6F6D 7061 
00004082  72        
00004083  696E 6720 6827          dc.b      105,110,103,32,116,111,32,83,68,82,65,77,46
00004087  746F 2053 
0000408B  4452 414D 
0000408F  2E        
00004090  2E2E 2E00 6828          dc.b      46,46,46,0
                    6829   @m68kde~1_27:
00004094  0D0A 4C6F 6830          dc.b      13,10,76,111,97,100,105,110,103,32,80,114,111
00004098  6164 696E 
0000409C  6720 5072 
000040A0  6F        
000040A1  6772 616D 6831          dc.b      103,114,97,109,32,70,114,111,109,32,83,80,73
000040A5  2046 726F 
000040A9  6D20 5350 
000040AD  49        
000040AE  2046 6C61 6832          dc.b      32,70,108,97,115,104,46,46,46,46,0
000040B2  7368 2E2E 
000040B6  2E2E 00   
                    6833   @m68kde~1_28:
000040BA  2425 3038 6834          dc.b      36,37,48,56,88,32,32,0
000040BE  5820 2000 
                    6835   @m68kde~1_29:
000040C2  2000      6836          dc.b      32,0
                    6837   @m68kde~1_30:
000040C4  2E00      6838          dc.b      46,0
                    6839   @m68kde~1_31:
000040C6  2563 00   6840          dc.b      37,99,0
                    6841   @m68kde~1_32:
000040CA  00        6842          dc.b      0
                    6843   @m68kde~1_33:
000040CC  0D0A 0D0A 6844          dc.b      13,10,13,10,32,68,48,32,61,32,36,37,48,56,88
000040D0  2044 3020 
000040D4  3D20 2425 
000040D8  3038 58   
000040DB  2020 4130 6845          dc.b      32,32,65,48,32,61,32,36,37,48,56,88,0
000040DF  203D 2024 
000040E3  2530 3858 
000040E7  00        
                    6846   @m68kde~1_34:
000040E8  0D0A 2044 6847          dc.b      13,10,32,68,49,32,61,32,36,37,48,56,88,32,32
000040EC  3120 3D20 
000040F0  2425 3038 
000040F4  5820 20   
000040F7  4131 203D 6848          dc.b      65,49,32,61,32,36,37,48,56,88,0
000040FB  2024 2530 
000040FF  3858 00   
                    6849   @m68kde~1_35:
00004102  0D0A 2044 6850          dc.b      13,10,32,68,50,32,61,32,36,37,48,56,88,32,32
00004106  3220 3D20 
0000410A  2425 3038 
0000410E  5820 20   
00004111  4132 203D 6851          dc.b      65,50,32,61,32,36,37,48,56,88,0
00004115  2024 2530 
00004119  3858 00   
                    6852   @m68kde~1_36:
0000411C  0D0A 2044 6853          dc.b      13,10,32,68,51,32,61,32,36,37,48,56,88,32,32
00004120  3320 3D20 
00004124  2425 3038 
00004128  5820 20   
0000412B  4133 203D 6854          dc.b      65,51,32,61,32,36,37,48,56,88,0
0000412F  2024 2530 
00004133  3858 00   
                    6855   @m68kde~1_37:
00004136  0D0A 2044 6856          dc.b      13,10,32,68,52,32,61,32,36,37,48,56,88,32,32
0000413A  3420 3D20 
0000413E  2425 3038 
00004142  5820 20   
00004145  4134 203D 6857          dc.b      65,52,32,61,32,36,37,48,56,88,0
00004149  2024 2530 
0000414D  3858 00   
                    6858   @m68kde~1_38:
00004150  0D0A 2044 6859          dc.b      13,10,32,68,53,32,61,32,36,37,48,56,88,32,32
00004154  3520 3D20 
00004158  2425 3038 
0000415C  5820 20   
0000415F  4135 203D 6860          dc.b      65,53,32,61,32,36,37,48,56,88,0
00004163  2024 2530 
00004167  3858 00   
                    6861   @m68kde~1_39:
0000416A  0D0A 2044 6862          dc.b      13,10,32,68,54,32,61,32,36,37,48,56,88,32,32
0000416E  3620 3D20 
00004172  2425 3038 
00004176  5820 20   
00004179  4136 203D 6863          dc.b      65,54,32,61,32,36,37,48,56,88,0
0000417D  2024 2530 
00004181  3858 00   
                    6864   @m68kde~1_40:
00004184  0D0A 2044 6865          dc.b      13,10,32,68,55,32,61,32,36,37,48,56,88,32,32
00004188  3720 3D20 
0000418C  2425 3038 
00004190  5820 20   
00004193  4137 203D 6866          dc.b      65,55,32,61,32,36,37,48,56,88,0
00004197  2024 2530 
0000419B  3858 00   
                    6867   @m68kde~1_41:
0000419E  0D0A 0D0A 6868          dc.b      13,10,13,10,85,83,80,32,61,32,36,37,48,56,88
000041A2  5553 5020 
000041A6  3D20 2425 
000041AA  3038 58   
000041AD  2020 2841 6869          dc.b      32,32,40,65,55,41,32,85,115,101,114,32,83,80
000041B1  3729 2055 
000041B5  7365 7220 
000041B9  5350      
000041BB  00        6870          dc.b      0
                    6871   @m68kde~1_42:
000041BC  0D0A 5353 6872          dc.b      13,10,83,83,80,32,61,32,36,37,48,56,88,32,32
000041C0  5020 3D20 
000041C4  2425 3038 
000041C8  5820 20   
000041CB  2841 3729 6873          dc.b      40,65,55,41,32,83,117,112,101,114,118,105,115
000041CF  2053 7570 
000041D3  6572 7669 
000041D7  73        
000041D8  6F72 2053 6874          dc.b      111,114,32,83,80,0
000041DC  5000      
                    6875   @m68kde~1_43:
000041DE  0D0A 2053 6876          dc.b      13,10,32,83,82,32,61,32,36,37,48,52,88,32,32
000041E2  5220 3D20 
000041E6  2425 3034 
000041EA  5820 20   
000041ED  2000      6877          dc.b      32,0
                    6878   @m68kde~1_44:
000041F0  2020 205B 6879          dc.b      32,32,32,91,0
000041F4  00        
                    6880   @m68kde~1_45:
000041F6  0D0A 2050 6881          dc.b      13,10,32,80,67,32,61,32,36,37,48,56,88,32,32
000041FA  4320 3D20 
000041FE  2425 3038 
00004202  5820 20   
00004205  00        6882          dc.b      0
                    6883   @m68kde~1_46:
00004206  5B40 2042 6884          dc.b      91,64,32,66,82,69,65,75,80,79,73,78,84,93,0
0000420A  5245 414B 
0000420E  504F 494E 
00004212  545D 00   
                    6885   @m68kde~1_47:
00004216  0D0A 5750 6886          dc.b      13,10,87,80,37,100,32,61,32,37,115,0
0000421A  2564 203D 
0000421E  2025 7300 
                    6887   @m68kde~1_48:
00004222  0D0A 0D0A 6888          dc.b      13,10,13,10,13,10,13,10,13,10,13,10,83,105,110
00004226  0D0A 0D0A 
0000422A  0D0A 0D0A 
0000422E  5369 6E   
00004231  676C 6520 6889          dc.b      103,108,101,32,83,116,101,112,32,32,58,91,79
00004235  5374 6570 
00004239  2020 3A5B 
0000423D  4F        
0000423E  4E5D 00   6890          dc.b      78,93,0
                    6891   @m68kde~1_49:
00004242  0D0A 4272 6892          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00004246  6561 6B20 
0000424A  506F 696E 
0000424E  74        
0000424F  7320 3A5B 6893          dc.b      115,32,58,91,68,105,115,97,98,108,101,100,93
00004253  4469 7361 
00004257  626C 6564 
0000425B  5D        
0000425C  00        6894          dc.b      0
                    6895   @m68kde~1_50:
0000425E  0D0A 5072 6896          dc.b      13,10,80,114,101,115,115,32,60,83,80,65,67,69
00004262  6573 7320 
00004266  3C53 5041 
0000426A  4345      
0000426C  3E20 746F 6897          dc.b      62,32,116,111,32,69,120,101,99,117,116,101,32
00004270  2045 7865 
00004274  6375 7465 
00004278  20        
00004279  4E65 7874 6898          dc.b      78,101,120,116,32,73,110,115,116,114,117,99
0000427D  2049 6E73 
00004281  7472 7563 
00004285  7469 6F6E 6899          dc.b      116,105,111,110,0
00004289  00        
                    6900   @m68kde~1_51:
0000428A  0D0A 5072 6901          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
0000428E  6573 7320 
00004292  3C45 5343 
00004296  3E20      
00004298  746F 2052 6902          dc.b      116,111,32,82,101,115,117,109,101,32,80,114
0000429C  6573 756D 
000042A0  6520 5072 
000042A4  6F67 7261 6903          dc.b      111,103,114,97,109,0
000042A8  6D00      
                    6904   @m68kde~1_52:
000042AA  0D0A 496C 6905          dc.b      13,10,73,108,108,101,103,97,108,32,68,97,116
000042AE  6C65 6761 
000042B2  6C20 4461 
000042B6  74        
000042B7  6120 5265 6906          dc.b      97,32,82,101,103,105,115,116,101,114,32,58,32
000042BB  6769 7374 
000042BF  6572 203A 
000042C3  20        
000042C4  5573 6520 6907          dc.b      85,115,101,32,68,48,45,68,55,46,46,46,46,46
000042C8  4430 2D44 
000042CC  372E 2E2E 
000042D0  2E2E      
000042D2  0D0A 00   6908          dc.b      13,10,0
                    6909   @m68kde~1_53:
000042D6  0D0A 4425 6910          dc.b      13,10,68,37,99,32,61,32,0
000042DA  6320 3D20 
000042DE  00        
                    6911   @m68kde~1_54:
000042E0  0D0A 496C 6912          dc.b      13,10,73,108,108,101,103,97,108,32,65,100,100
000042E4  6C65 6761 
000042E8  6C20 4164 
000042EC  64        
000042ED  7265 7373 6913          dc.b      114,101,115,115,32,82,101,103,105,115,116,101
000042F1  2052 6567 
000042F5  6973 7465 
000042F9  7220 3A20 6914          dc.b      114,32,58,32,85,115,101,32,65,48,45,65,55,46
000042FD  5573 6520 
00004301  4130 2D41 
00004305  372E      
00004307  2E2E 2E2E 6915          dc.b      46,46,46,46,13,10,0
0000430B  0D0A 00   
                    6916   @m68kde~1_55:
0000430E  0D0A 4125 6917          dc.b      13,10,65,37,99,32,61,32,0
00004312  6320 3D20 
00004316  00        
                    6918   @m68kde~1_56:
00004318  0D0A 5573 6919          dc.b      13,10,85,115,101,114,32,83,80,32,61,32,0
0000431C  6572 2053 
00004320  5020 3D20 
00004324  00        
                    6920   @m68kde~1_57:
00004326  0D0A 496C 6921          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
0000432A  6C65 6761 
0000432E  6C20 5265 
00004332  67        
00004333  6973 7465 6922          dc.b      105,115,116,101,114,46,46,46,46,0
00004337  722E 2E2E 
0000433B  2E00      
                    6923   @m68kde~1_58:
0000433E  0D0A 5379 6924          dc.b      13,10,83,121,115,116,101,109,32,83,80,32,61
00004342  7374 656D 
00004346  2053 5020 
0000434A  3D        
0000434B  2000      6925          dc.b      32,0
                    6926   @m68kde~1_59:
0000434E  0D0A 5043 6927          dc.b      13,10,80,67,32,61,32,0
00004352  203D 2000 
                    6928   @m68kde~1_60:
00004356  0D0A 5352 6929          dc.b      13,10,83,82,32,61,32,0
0000435A  203D 2000 
                    6930   @m68kde~1_61:
0000435E  0D0A 496C 6931          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
00004362  6C65 6761 
00004366  6C20 5265 
0000436A  67        
0000436B  6973 7465 6932          dc.b      105,115,116,101,114,58,32,85,115,101,32,65,48
0000436F  723A 2055 
00004373  7365 2041 
00004377  30        
00004378  2D41 372C 6933          dc.b      45,65,55,44,32,68,48,45,68,55,44,32,83,83,80
0000437C  2044 302D 
00004380  4437 2C20 
00004384  5353 50   
00004387  2C20 5553 6934          dc.b      44,32,85,83,80,44,32,80,67,32,111,114,32,83
0000438B  502C 2050 
0000438F  4320 6F72 
00004393  2053      
00004395  520D 0A00 6935          dc.b      82,13,10,0
                    6936   @m68kde~1_62:
0000439A  0D0A 0D0A 6937          dc.b      13,10,13,10,78,117,109,32,32,32,32,32,65,100
0000439E  4E75 6D20 
000043A2  2020 2020 
000043A6  4164      
000043A8  6472 6573 6938          dc.b      100,114,101,115,115,32,32,32,32,32,32,73,110
000043AC  7320 2020 
000043B0  2020 2049 
000043B4  6E        
000043B5  7374 7275 6939          dc.b      115,116,114,117,99,116,105,111,110,0
000043B9  6374 696F 
000043BD  6E00      
                    6940   @m68kde~1_63:
000043C0  0D0A 2D2D 6941          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
000043C4  2D20 2020 
000043C8  2020 2D2D 
000043CC  2D2D 2D   
000043CF  2D2D 2D2D 6942          dc.b      45,45,45,45,32,32,32,32,45,45,45,45,45,45,45
000043D3  2020 2020 
000043D7  2D2D 2D2D 
000043DB  2D2D 2D   
000043DE  2D2D 2D2D 6943          dc.b      45,45,45,45,0
000043E2  00        
                    6944   @m68kde~1_64:
000043E4  0D0A 4E6F 6945          dc.b      13,10,78,111,32,66,114,101,97,107,80,111,105
000043E8  2042 7265 
000043EC  616B 506F 
000043F0  69        
000043F1  6E74 7320 6946          dc.b      110,116,115,32,83,101,116,0
000043F5  5365 7400 
                    6947   @m68kde~1_65:
000043FA  0D0A 2533 6948          dc.b      13,10,37,51,100,32,32,32,32,32,36,37,48,56,120
000043FE  6420 2020 
00004402  2020 2425 
00004406  3038 78   
00004409  00        6949          dc.b      0
                    6950   @m68kde~1_66:
0000440A  0D0A 4E75 6951          dc.b      13,10,78,117,109,32,32,32,32,32,65,100,100,114
0000440E  6D20 2020 
00004412  2020 4164 
00004416  6472      
00004418  6573 7300 6952          dc.b      101,115,115,0
                    6953   @m68kde~1_67:
0000441C  0D0A 2D2D 6954          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
00004420  2D20 2020 
00004424  2020 2D2D 
00004428  2D2D 2D   
0000442B  2D2D 2D2D 6955          dc.b      45,45,45,45,0
0000442F  00        
                    6956   @m68kde~1_68:
00004430  0D0A 4E6F 6957          dc.b      13,10,78,111,32,87,97,116,99,104,80,111,105
00004434  2057 6174 
00004438  6368 506F 
0000443C  69        
0000443D  6E74 7320 6958          dc.b      110,116,115,32,83,101,116,0
00004441  5365 7400 
                    6959   @m68kde~1_69:
00004446  0D0A 456E 6960          dc.b      13,10,69,110,116,101,114,32,66,114,101,97,107
0000444A  7465 7220 
0000444E  4272 6561 
00004452  6B        
00004453  2050 6F69 6961          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
00004457  6E74 204E 
0000445B  756D 6265 
0000445F  72        
00004460  3A20 00   6962          dc.b      58,32,0
                    6963   @m68kde~1_70:
00004464  0D0A 496C 6964          dc.b      13,10,73,108,108,101,103,97,108,32,82,97,110
00004468  6C65 6761 
0000446C  6C20 5261 
00004470  6E        
00004471  6765 203A 6965          dc.b      103,101,32,58,32,85,115,101,32,48,32,45,32,55
00004475  2055 7365 
00004479  2030 202D 
0000447D  2037      
0000447F  00        6966          dc.b      0
                    6967   @m68kde~1_71:
00004480  0D0A 4272 6968          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00004484  6561 6B20 
00004488  506F 696E 
0000448C  74        
0000448D  2043 6C65 6969          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
00004491  6172 6564 
00004495  2E2E 2E2E 
00004499  2E        
0000449A  0D0A 00   6970          dc.b      13,10,0
                    6971   @m68kde~1_72:
0000449E  0D0A 4272 6972          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
000044A2  6561 6B20 
000044A6  506F 696E 
000044AA  74        
000044AB  2077 6173 6973          dc.b      32,119,97,115,110,39,116,32,83,101,116,46,46
000044AF  6E27 7420 
000044B3  5365 742E 
000044B7  2E        
000044B8  2E2E 2E00 6974          dc.b      46,46,46,0
                    6975   @m68kde~1_73:
000044BC  0D0A 456E 6976          dc.b      13,10,69,110,116,101,114,32,87,97,116,99,104
000044C0  7465 7220 
000044C4  5761 7463 
000044C8  68        
000044C9  2050 6F69 6977          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
000044CD  6E74 204E 
000044D1  756D 6265 
000044D5  72        
000044D6  3A20 00   6978          dc.b      58,32,0
                    6979   @m68kde~1_74:
000044DA  0D0A 5761 6980          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
000044DE  7463 6820 
000044E2  506F 696E 
000044E6  74        
000044E7  2043 6C65 6981          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
000044EB  6172 6564 
000044EF  2E2E 2E2E 
000044F3  2E        
000044F4  0D0A 00   6982          dc.b      13,10,0
                    6983   @m68kde~1_75:
000044F8  0D0A 5761 6984          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
000044FC  7463 6820 
00004500  506F 696E 
00004504  74        
00004505  2057 6173 6985          dc.b      32,87,97,115,32,110,111,116,32,83,101,116,46
00004509  206E 6F74 
0000450D  2053 6574 
00004511  2E        
00004512  2E2E 2E2E 6986          dc.b      46,46,46,46,0
00004516  00        
                    6987   @m68kde~1_76:
00004518  0D0A 4E6F 6988          dc.b      13,10,78,111,32,70,82,69,69,32,66,114,101,97
0000451C  2046 5245 
00004520  4520 4272 
00004524  6561      
00004526  6B20 506F 6989          dc.b      107,32,80,111,105,110,116,115,46,46,46,46,46
0000452A  696E 7473 
0000452E  2E2E 2E2E 
00004532  2E        
00004533  00        6990          dc.b      0
                    6991   @m68kde~1_77:
00004534  0D0A 4272 6992          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00004538  6561 6B20 
0000453C  506F 696E 
00004540  74        
00004541  2041 6464 6993          dc.b      32,65,100,100,114,101,115,115,58,32,0
00004545  7265 7373 
00004549  3A20 00   
                    6994   @m68kde~1_78:
0000454C  0D0A 4572 6995          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
00004550  726F 7220 
00004554  3A20 4272 
00004558  65        
00004559  616B 2050 6996          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
0000455D  6F69 6E74 
00004561  7320 4341 
00004565  4E        
00004566  4E4F 5420 6997          dc.b      78,79,84,32,98,101,32,115,101,116,32,97,116
0000456A  6265 2073 
0000456E  6574 2061 
00004572  74        
00004573  204F 4444 6998          dc.b      32,79,68,68,32,97,100,100,114,101,115,115,101
00004577  2061 6464 
0000457B  7265 7373 
0000457F  65        
00004580  7300      6999          dc.b      115,0
                    7000   @m68kde~1_79:
00004582  0D0A 4572 7001          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
00004586  726F 7220 
0000458A  3A20 4272 
0000458E  65        
0000458F  616B 2050 7002          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
00004593  6F69 6E74 
00004597  7320 4341 
0000459B  4E        
0000459C  4E4F 5420 7003          dc.b      78,79,84,32,98,101,32,115,101,116,32,102,111
000045A0  6265 2073 
000045A4  6574 2066 
000045A8  6F        
000045A9  7220 524F 7004          dc.b      114,32,82,79,77,32,105,110,32,82,97,110,103
000045AD  4D20 696E 
000045B1  2052 616E 
000045B5  67        
000045B6  6520 3A20 7005          dc.b      101,32,58,32,91,36,48,45,36,48,48,48,48,55,70
000045BA  5B24 302D 
000045BE  2430 3030 
000045C2  3037 46   
000045C5  4646 5D00 7006          dc.b      70,70,93,0
                    7007   @m68kde~1_80:
000045CA  0D0A 4572 7008          dc.b      13,10,69,114,114,111,114,58,32,66,114,101,97
000045CE  726F 723A 
000045D2  2042 7265 
000045D6  61        
000045D7  6B20 506F 7009          dc.b      107,32,80,111,105,110,116,32,65,108,114,101
000045DB  696E 7420 
000045DF  416C 7265 
000045E3  6164 7920 7010          dc.b      97,100,121,32,69,120,105,115,116,115,32,97,116
000045E7  4578 6973 
000045EB  7473 2061 
000045EF  74        
000045F0  2041 6464 7011          dc.b      32,65,100,100,114,101,115,115,32,58,32,37,48
000045F4  7265 7373 
000045F8  203A 2025 
000045FC  30        
000045FD  3878 0D0A 7012          dc.b      56,120,13,10,0
00004601  00        
                    7013   @m68kde~1_81:
00004602  0D0A 4272 7014          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00004606  6561 6B20 
0000460A  506F 696E 
0000460E  74        
0000460F  2053 6574 7015          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
00004613  2061 7420 
00004617  4164 6472 
0000461B  65        
0000461C  7373 3A20 7016          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
00004620  5B24 2530 
00004624  3878 5D00 
                    7017   @m68kde~1_82:
00004628  0D0A 4E6F 7018          dc.b      13,10,78,111,32,70,82,69,69,32,87,97,116,99
0000462C  2046 5245 
00004630  4520 5761 
00004634  7463      
00004636  6820 506F 7019          dc.b      104,32,80,111,105,110,116,115,46,46,46,46,46
0000463A  696E 7473 
0000463E  2E2E 2E2E 
00004642  2E        
00004643  00        7020          dc.b      0
                    7021   @m68kde~1_83:
00004644  0D0A 5761 7022          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00004648  7463 6820 
0000464C  506F 696E 
00004650  74        
00004651  2041 6464 7023          dc.b      32,65,100,100,114,101,115,115,58,32,0
00004655  7265 7373 
00004659  3A20 00   
                    7024   @m68kde~1_84:
0000465C  0D0A 4572 7025          dc.b      13,10,69,114,114,111,114,58,32,87,97,116,99
00004660  726F 723A 
00004664  2057 6174 
00004668  63        
00004669  6820 506F 7026          dc.b      104,32,80,111,105,110,116,32,65,108,114,101
0000466D  696E 7420 
00004671  416C 7265 
00004675  6164 7920 7027          dc.b      97,100,121,32,83,101,116,32,97,116,32,65,100
00004679  5365 7420 
0000467D  6174 2041 
00004681  64        
00004682  6472 6573 7028          dc.b      100,114,101,115,115,32,58,32,37,48,56,120,13
00004686  7320 3A20 
0000468A  2530 3878 
0000468E  0D        
0000468F  0A00      7029          dc.b      10,0
                    7030   @m68kde~1_85:
00004692  0D0A 5761 7031          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00004696  7463 6820 
0000469A  506F 696E 
0000469E  74        
0000469F  2053 6574 7032          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
000046A3  2061 7420 
000046A7  4164 6472 
000046AB  65        
000046AC  7373 3A20 7033          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
000046B0  5B24 2530 
000046B4  3878 5D00 
                    7034   @m68kde~1_86:
000046B8  0D0A 0D0A 7035          dc.b      13,10,13,10,13,10,13,10,64,66,82,69,65,75,80
000046BC  0D0A 0D0A 
000046C0  4042 5245 
000046C4  414B 50   
000046C7  4F49 4E54 7036          dc.b      79,73,78,84,0
000046CB  00        
                    7037   @m68kde~1_87:
000046CC  0D0A 5369 7038          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
000046D0  6E67 6C65 
000046D4  2053 7465 
000046D8  70        
000046D9  203A 205B 7039          dc.b      32,58,32,91,79,78,93,0
000046DD  4F4E 5D00 
                    7040   @m68kde~1_88:
000046E2  0D0A 4272 7041          dc.b      13,10,66,114,101,97,107,80,111,105,110,116,115
000046E6  6561 6B50 
000046EA  6F69 6E74 
000046EE  73        
000046EF  203A 205B 7042          dc.b      32,58,32,91,69,110,97,98,108,101,100,93,0
000046F3  456E 6162 
000046F7  6C65 645D 
000046FB  00        
                    7043   @m68kde~1_89:
000046FC  0D0A 5072 7044          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00004700  6573 7320 
00004704  3C45 5343 
00004708  3E20      
0000470A  746F 2052 7045          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
0000470E  6573 756D 
00004712  6520 5573 
00004716  6572 2050 7046          dc.b      101,114,32,80,114,111,103,114,97,109,13,10,0
0000471A  726F 6772 
0000471E  616D 0D0A 
00004722  00        
                    7047   @m68kde~1_90:
00004724  0D0A 556E 7048          dc.b      13,10,85,110,107,110,111,119,110,32,67,111,109
00004728  6B6E 6F77 
0000472C  6E20 436F 
00004730  6D        
00004731  6D61 6E64 7049          dc.b      109,97,110,100,46,46,46,46,46,13,10,0
00004735  2E2E 2E2E 
00004739  2E0D 0A00 
                    7050   @m68kde~1_91:
0000473E  0D0A 5072 7051          dc.b      13,10,80,114,111,103,114,97,109,32,69,110,100
00004742  6F67 7261 
00004746  6D20 456E 
0000474A  64        
0000474B  6564 2028 7052          dc.b      101,100,32,40,84,82,65,80,32,35,49,53,41,46
0000474F  5452 4150 
00004753  2023 3135 
00004757  292E      
00004759  2E2E 2E00 7053          dc.b      46,46,46,0
                    7054   @m68kde~1_92:
0000475E  0D0A 4B69 7055          dc.b      13,10,75,105,108,108,32,65,108,108,32,66,114
00004762  6C6C 2041 
00004766  6C6C 2042 
0000476A  72        
0000476B  6561 6B20 7056          dc.b      101,97,107,32,80,111,105,110,116,115,46,46,46
0000476F  506F 696E 
00004773  7473 2E2E 
00004777  2E        
00004778  2879 2F6E 7057          dc.b      40,121,47,110,41,63,0
0000477C  293F 00   
                    7058   @m68kde~1_93:
00004780  0D0A 4B69 7059          dc.b      13,10,75,105,108,108,32,65,108,108,32,87,97
00004784  6C6C 2041 
00004788  6C6C 2057 
0000478C  61        
0000478D  7463 6820 7060          dc.b      116,99,104,32,80,111,105,110,116,115,46,46,46
00004791  506F 696E 
00004795  7473 2E2E 
00004799  2E        
0000479A  2879 2F6E 7061          dc.b      40,121,47,110,41,63,0
0000479E  293F 00   
                    7062   @m68kde~1_94:
000047A2  0D0A 2D2D 7063          dc.b      13,10,45,45,45,45,45,45,45,45,45,45,45,45,45
000047A6  2D2D 2D2D 
000047AA  2D2D 2D2D 
000047AE  2D2D 2D   
000047B1  2D2D 2D2D 7064          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000047B5  2D2D 2D2D 
000047B9  2D2D 2D2D 
000047BD  2D2D 2D   
000047C0  2D2D 2D2D 7065          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000047C4  2D2D 2D2D 
000047C8  2D2D 2D2D 
000047CC  2D2D 2D   
000047CF  2D2D 2D2D 7066          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000047D3  2D2D 2D2D 
000047D7  2D2D 2D2D 
000047DB  2D2D 2D   
000047DE  2D2D 2D2D 7067          dc.b      45,45,45,45,45,45,0
000047E2  2D2D 00   
                    7068   @m68kde~1_95:
000047E6  0D0A 2020 7069          dc.b      13,10,32,32,68,101,98,117,103,103,101,114,32
000047EA  4465 6275 
000047EE  6767 6572 
000047F2  20        
000047F3  436F 6D6D 7070          dc.b      67,111,109,109,97,110,100,32,83,117,109,109
000047F7  616E 6420 
000047FB  5375 6D6D 
000047FF  6172 7900 7071          dc.b      97,114,121,0
                    7072   @m68kde~1_96:
00004804  0D0A 2020 7073          dc.b      13,10,32,32,46,40,114,101,103,41,32,32,32,32
00004808  2E28 7265 
0000480C  6729 2020 
00004810  2020      
00004812  2020 202D 7074          dc.b      32,32,32,45,32,67,104,97,110,103,101,32,82,101
00004816  2043 6861 
0000481A  6E67 6520 
0000481E  5265      
00004820  6769 7374 7075          dc.b      103,105,115,116,101,114,115,58,32,101,46,103
00004824  6572 733A 
00004828  2065 2E67 
0000482C  2041 302D 7076          dc.b      32,65,48,45,65,55,44,68,48,45,68,55,44,80,67
00004830  4137 2C44 
00004834  302D 4437 
00004838  2C50 43   
0000483B  2C53 5350 7077          dc.b      44,83,83,80,44,85,83,80,44,83,82,0
0000483F  2C55 5350 
00004843  2C53 5200 
                    7078   @m68kde~1_97:
00004848  0D0A 2020 7079          dc.b      13,10,32,32,66,68,47,66,83,47,66,67,47,66,75
0000484C  4244 2F42 
00004850  532F 4243 
00004854  2F42 4B   
00004857  2020 2D20 7080          dc.b      32,32,45,32,66,114,101,97,107,32,80,111,105
0000485B  4272 6561 
0000485F  6B20 506F 
00004863  69        
00004864  6E74 3A20 7081          dc.b      110,116,58,32,68,105,115,112,108,97,121,47,83
00004868  4469 7370 
0000486C  6C61 792F 
00004870  53        
00004871  6574 2F43 7082          dc.b      101,116,47,67,108,101,97,114,47,75,105,108,108
00004875  6C65 6172 
00004879  2F4B 696C 
0000487D  6C        
0000487E  00        7083          dc.b      0
                    7084   @m68kde~1_98:
00004880  0D0A 2020 7085          dc.b      13,10,32,32,67,32,32,32,32,32,32,32,32,32,32
00004884  4320 2020 
00004888  2020 2020 
0000488C  2020 20   
0000488F  2020 2D20 7086          dc.b      32,32,45,32,67,111,112,121,32,80,114,111,103
00004893  436F 7079 
00004897  2050 726F 
0000489B  67        
0000489C  7261 6D20 7087          dc.b      114,97,109,32,102,114,111,109,32,70,108,97,115
000048A0  6672 6F6D 
000048A4  2046 6C61 
000048A8  73        
000048A9  6820 746F 7088          dc.b      104,32,116,111,32,77,97,105,110,32,77,101,109
000048AD  204D 6169 
000048B1  6E20 4D65 
000048B5  6D        
000048B6  6F72 7900 7089          dc.b      111,114,121,0
                    7090   @m68kde~1_99:
000048BA  0D0A 2020 7091          dc.b      13,10,32,32,68,32,32,32,32,32,32,32,32,32,32
000048BE  4420 2020 
000048C2  2020 2020 
000048C6  2020 20   
000048C9  2020 2D20 7092          dc.b      32,32,45,32,68,117,109,112,32,77,101,109,111
000048CD  4475 6D70 
000048D1  204D 656D 
000048D5  6F        
000048D6  7279 2043 7093          dc.b      114,121,32,67,111,110,116,101,110,116,115,32
000048DA  6F6E 7465 
000048DE  6E74 7320 
000048E2  746F 2053 7094          dc.b      116,111,32,83,99,114,101,101,110,0
000048E6  6372 6565 
000048EA  6E00      
                    7095   @m68kde~1_100:
000048EC  0D0A 2020 7096          dc.b      13,10,32,32,69,32,32,32,32,32,32,32,32,32,32
000048F0  4520 2020 
000048F4  2020 2020 
000048F8  2020 20   
000048FB  2020 2D20 7097          dc.b      32,32,45,32,69,110,116,101,114,32,83,116,114
000048FF  456E 7465 
00004903  7220 5374 
00004907  72        
00004908  696E 6720 7098          dc.b      105,110,103,32,105,110,116,111,32,77,101,109
0000490C  696E 746F 
00004910  204D 656D 
00004914  6F72 7900 7099          dc.b      111,114,121,0
                    7100   @m68kde~1_101:
00004918  0D0A 2020 7101          dc.b      13,10,32,32,70,32,32,32,32,32,32,32,32,32,32
0000491C  4620 2020 
00004920  2020 2020 
00004924  2020 20   
00004927  2020 2D20 7102          dc.b      32,32,45,32,70,105,108,108,32,77,101,109,111
0000492B  4669 6C6C 
0000492F  204D 656D 
00004933  6F        
00004934  7279 2077 7103          dc.b      114,121,32,119,105,116,104,32,68,97,116,97,0
00004938  6974 6820 
0000493C  4461 7461 
00004940  00        
                    7104   @m68kde~1_102:
00004942  0D0A 2020 7105          dc.b      13,10,32,32,71,32,32,32,32,32,32,32,32,32,32
00004946  4720 2020 
0000494A  2020 2020 
0000494E  2020 20   
00004951  2020 2D20 7106          dc.b      32,32,45,32,71,111,32,80,114,111,103,114,97
00004955  476F 2050 
00004959  726F 6772 
0000495D  61        
0000495E  6D20 5374 7107          dc.b      109,32,83,116,97,114,116,105,110,103,32,97,116
00004962  6172 7469 
00004966  6E67 2061 
0000496A  74        
0000496B  2041 6464 7108          dc.b      32,65,100,100,114,101,115,115,58,32,36,37,48
0000496F  7265 7373 
00004973  3A20 2425 
00004977  30        
00004978  3858 00   7109          dc.b      56,88,0
                    7110   @m68kde~1_103:
0000497C  0D0A 2020 7111          dc.b      13,10,32,32,76,32,32,32,32,32,32,32,32,32,32
00004980  4C20 2020 
00004984  2020 2020 
00004988  2020 20   
0000498B  2020 2D20 7112          dc.b      32,32,45,32,76,111,97,100,32,80,114,111,103
0000498F  4C6F 6164 
00004993  2050 726F 
00004997  67        
00004998  7261 6D20 7113          dc.b      114,97,109,32,40,46,72,69,88,32,102,105,108
0000499C  282E 4845 
000049A0  5820 6669 
000049A4  6C        
000049A5  6529 2066 7114          dc.b      101,41,32,102,114,111,109,32,76,97,112,116,111
000049A9  726F 6D20 
000049AD  4C61 7074 
000049B1  6F        
000049B2  7000      7115          dc.b      112,0
                    7116   @m68kde~1_104:
000049B4  0D0A 2020 7117          dc.b      13,10,32,32,77,32,32,32,32,32,32,32,32,32,32
000049B8  4D20 2020 
000049BC  2020 2020 
000049C0  2020 20   
000049C3  2020 2D20 7118          dc.b      32,32,45,32,77,101,109,111,114,121,32,69,120
000049C7  4D65 6D6F 
000049CB  7279 2045 
000049CF  78        
000049D0  616D 696E 7119          dc.b      97,109,105,110,101,32,97,110,100,32,67,104,97
000049D4  6520 616E 
000049D8  6420 4368 
000049DC  61        
000049DD  6E67 6500 7120          dc.b      110,103,101,0
                    7121   @m68kde~1_105:
000049E2  0D0A 2020 7122          dc.b      13,10,32,32,80,32,32,32,32,32,32,32,32,32,32
000049E6  5020 2020 
000049EA  2020 2020 
000049EE  2020 20   
000049F1  2020 2D20 7123          dc.b      32,32,45,32,80,114,111,103,114,97,109,32,70
000049F5  5072 6F67 
000049F9  7261 6D20 
000049FD  46        
000049FE  6C61 7368 7124          dc.b      108,97,115,104,32,77,101,109,111,114,121,32
00004A02  204D 656D 
00004A06  6F72 7920 
00004A0A  7769 7468 7125          dc.b      119,105,116,104,32,85,115,101,114,32,80,114
00004A0E  2055 7365 
00004A12  7220 5072 
00004A16  6F67 7261 7126          dc.b      111,103,114,97,109,0
00004A1A  6D00      
                    7127   @m68kde~1_106:
00004A1C  0D0A 2020 7128          dc.b      13,10,32,32,82,32,32,32,32,32,32,32,32,32,32
00004A20  5220 2020 
00004A24  2020 2020 
00004A28  2020 20   
00004A2B  2020 2D20 7129          dc.b      32,32,45,32,68,105,115,112,108,97,121,32,54
00004A2F  4469 7370 
00004A33  6C61 7920 
00004A37  36        
00004A38  3830 3030 7130          dc.b      56,48,48,48,32,82,101,103,105,115,116,101,114
00004A3C  2052 6567 
00004A40  6973 7465 
00004A44  72        
00004A45  7300      7131          dc.b      115,0
                    7132   @m68kde~1_107:
00004A48  0D0A 2020 7133          dc.b      13,10,32,32,83,32,32,32,32,32,32,32,32,32,32
00004A4C  5320 2020 
00004A50  2020 2020 
00004A54  2020 20   
00004A57  2020 2D20 7134          dc.b      32,32,45,32,84,111,103,103,108,101,32,79,78
00004A5B  546F 6767 
00004A5F  6C65 204F 
00004A63  4E        
00004A64  2F4F 4646 7135          dc.b      47,79,70,70,32,83,105,110,103,108,101,32,83
00004A68  2053 696E 
00004A6C  676C 6520 
00004A70  53        
00004A71  7465 7020 7136          dc.b      116,101,112,32,77,111,100,101,0
00004A75  4D6F 6465 
00004A79  00        
                    7137   @m68kde~1_108:
00004A7A  0D0A 2020 7138          dc.b      13,10,32,32,84,77,32,32,32,32,32,32,32,32,32
00004A7E  544D 2020 
00004A82  2020 2020 
00004A86  2020 20   
00004A89  2020 2D20 7139          dc.b      32,32,45,32,84,101,115,116,32,77,101,109,111
00004A8D  5465 7374 
00004A91  204D 656D 
00004A95  6F        
00004A96  7279 00   7140          dc.b      114,121,0
                    7141   @m68kde~1_109:
00004A9A  0D0A 2020 7142          dc.b      13,10,32,32,84,83,32,32,32,32,32,32,32,32,32
00004A9E  5453 2020 
00004AA2  2020 2020 
00004AA6  2020 20   
00004AA9  2020 2D20 7143          dc.b      32,32,45,32,84,101,115,116,32,83,119,105,116
00004AAD  5465 7374 
00004AB1  2053 7769 
00004AB5  74        
00004AB6  6368 6573 7144          dc.b      99,104,101,115,58,32,83,87,55,45,48,0
00004ABA  3A20 5357 
00004ABE  372D 3000 
                    7145   @m68kde~1_110:
00004AC2  0D0A 2020 7146          dc.b      13,10,32,32,84,68,32,32,32,32,32,32,32,32,32
00004AC6  5444 2020 
00004ACA  2020 2020 
00004ACE  2020 20   
00004AD1  2020 2D20 7147          dc.b      32,32,45,32,84,101,115,116,32,68,105,115,112
00004AD5  5465 7374 
00004AD9  2044 6973 
00004ADD  70        
00004ADE  6C61 7973 7148          dc.b      108,97,121,115,58,32,76,69,68,115,32,97,110
00004AE2  3A20 4C45 
00004AE6  4473 2061 
00004AEA  6E        
00004AEB  6420 372D 7149          dc.b      100,32,55,45,83,101,103,109,101,110,116,0
00004AEF  5365 676D 
00004AF3  656E 7400 
                    7150   @m68kde~1_111:
00004AF8  0D0A 2020 7151          dc.b      13,10,32,32,87,68,47,87,83,47,87,67,47,87,75
00004AFC  5744 2F57 
00004B00  532F 5743 
00004B04  2F57 4B   
00004B07  2020 2D20 7152          dc.b      32,32,45,32,87,97,116,99,104,32,80,111,105,110
00004B0B  5761 7463 
00004B0F  6820 506F 
00004B13  696E      
00004B15  743A 2044 7153          dc.b      116,58,32,68,105,115,112,108,97,121,47,83,101
00004B19  6973 706C 
00004B1D  6179 2F53 
00004B21  65        
00004B22  742F 436C 7154          dc.b      116,47,67,108,101,97,114,47,75,105,108,108,0
00004B26  6561 722F 
00004B2A  4B69 6C6C 
00004B2E  00        
                    7155   @m68kde~1_112:
00004B30  0D0A 2300 7156          dc.b      13,10,35,0
                    7157   @m68kde~1_113:
00004B34  0D0A 5072 7158          dc.b      13,10,80,114,111,103,114,97,109,32,82,117,110
00004B38  6F67 7261 
00004B3C  6D20 5275 
00004B40  6E        
00004B41  6E69 6E67 7159          dc.b      110,105,110,103,46,46,46,46,46,0
00004B45  2E2E 2E2E 
00004B49  2E00      
                    7160   @m68kde~1_114:
00004B4C  0D0A 5072 7161          dc.b      13,10,80,114,101,115,115,32,60,82,69,83,69,84
00004B50  6573 7320 
00004B54  3C52 4553 
00004B58  4554      
00004B5A  3E20 6275 7162          dc.b      62,32,98,117,116,116,111,110,32,60,75,101,121
00004B5E  7474 6F6E 
00004B62  203C 4B65 
00004B66  79        
00004B67  303E 206F 7163          dc.b      48,62,32,111,110,32,68,69,49,32,116,111,32,115
00004B6B  6E20 4445 
00004B6F  3120 746F 
00004B73  2073      
00004B75  746F 7000 7164          dc.b      116,111,112,0
                    7165   @m68kde~1_115:
00004B7A  0D0A 4572 7166          dc.b      13,10,69,114,114,111,114,58,32,80,114,101,115
00004B7E  726F 723A 
00004B82  2050 7265 
00004B86  73        
00004B87  7320 2747 7167          dc.b      115,32,39,71,39,32,102,105,114,115,116,32,116
00004B8B  2720 6669 
00004B8F  7273 7420 
00004B93  74        
00004B94  6F20 7374 7168          dc.b      111,32,115,116,97,114,116,32,112,114,111,103
00004B98  6172 7420 
00004B9C  7072 6F67 
00004BA0  7261 6D00 7169          dc.b      114,97,109,0
                    7170   @m68kde~1_116:
00004BA4  0D0A 5369 7171          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00004BA8  6E67 6C65 
00004BAC  2053 7465 
00004BB0  70        
00004BB1  2020 3A5B 7172          dc.b      32,32,58,91,79,78,93,0
00004BB5  4F4E 5D00 
                    7173   @m68kde~1_117:
00004BBA  0D0A 5072 7174          dc.b      13,10,80,114,101,115,115,32,39,71,39,32,116
00004BBE  6573 7320 
00004BC2  2747 2720 
00004BC6  74        
00004BC7  6F20 5472 7175          dc.b      111,32,84,114,97,99,101,32,80,114,111,103,114
00004BCB  6163 6520 
00004BCF  5072 6F67 
00004BD3  72        
00004BD4  616D 2066 7176          dc.b      97,109,32,102,114,111,109,32,97,100,100,114
00004BD8  726F 6D20 
00004BDC  6164 6472 
00004BE0  6573 7320 7177          dc.b      101,115,115,32,36,37,88,46,46,46,46,46,0
00004BE4  2425 582E 
00004BE8  2E2E 2E2E 
00004BEC  00        
                    7178   @m68kde~1_118:
00004BEE  0D0A 5075 7179          dc.b      13,10,80,117,115,104,32,60,82,69,83,69,84,32
00004BF2  7368 203C 
00004BF6  5245 5345 
00004BFA  5420      
00004BFC  4275 7474 7180          dc.b      66,117,116,116,111,110,62,32,116,111,32,83,116
00004C00  6F6E 3E20 
00004C04  746F 2053 
00004C08  74        
00004C09  6F70 2E2E 7181          dc.b      111,112,46,46,46,46,46,0
00004C0D  2E2E 2E00 
                    7182   @m68kde~1_119:
00004C12  0D0A 5369 7183          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00004C16  6E67 6C65 
00004C1A  2053 7465 
00004C1E  70        
00004C1F  203A 205B 7184          dc.b      32,58,32,91,79,70,70,93,0
00004C23  4F46 465D 
00004C27  00        
                    7185   @m68kde~1_120:
00004C28  0D0A 4272 7186          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00004C2C  6561 6B20 
00004C30  506F 696E 
00004C34  74        
00004C35  7320 3A5B 7187          dc.b      115,32,58,91,69,110,97,98,108,101,100,93,0
00004C39  456E 6162 
00004C3D  6C65 645D 
00004C41  00        
                    7188   @m68kde~1_121:
00004C42  0D0A 5072 7189          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00004C46  6573 7320 
00004C4A  3C45 5343 
00004C4E  3E20      
00004C50  746F 2052 7190          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
00004C54  6573 756D 
00004C58  6520 5573 
00004C5C  6572 2050 7191          dc.b      101,114,32,80,114,111,103,114,97,109,46,46,46
00004C60  726F 6772 
00004C64  616D 2E2E 
00004C68  2E        
00004C69  2E2E 00   7192          dc.b      46,46,0
                    7193   @m68kde~1_122:
00004C6C  0D0A 5369 7194          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00004C70  6E67 6C65 
00004C74  2053 7465 
00004C78  70        
00004C79  2020 3A5B 7195          dc.b      32,32,58,91,79,70,70,93,0
00004C7D  4F46 465D 
00004C81  00        
                    7196   @m68kde~1_123:
00004C82  0D0A 0D0A 7197          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
00004C86  5072 6F67 
00004C8A  7261 6D20 
00004C8E  41        
00004C8F  424F 5254 7198          dc.b      66,79,82,84,32,33,33,33,33,33,33,13,10,0
00004C93  2021 2121 
00004C97  2121 210D 
00004C9B  0A00      
                    7199   @m68kde~1_124:
00004C9E  2573 0D0A 7200          dc.b      37,115,13,10,0
00004CA2  00        
                    7201   @m68kde~1_125:
00004CA4  0D0A 0D0A 7202          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
00004CA8  5072 6F67 
00004CAC  7261 6D20 
00004CB0  41        
00004CB1  424F 5254 7203          dc.b      66,79,82,84,32,33,33,33,33,33,0
00004CB5  2021 2121 
00004CB9  2121 00   
                    7204   @m68kde~1_126:
00004CBC  0D0A 556E 7205          dc.b      13,10,85,110,104,97,110,100,108,101,100,32,73
00004CC0  6861 6E64 
00004CC4  6C65 6420 
00004CC8  49        
00004CC9  6E74 6572 7206          dc.b      110,116,101,114,114,117,112,116,58,32,73,82
00004CCD  7275 7074 
00004CD1  3A20 4952 
00004CD5  5125 6420 7207          dc.b      81,37,100,32,33,33,33,33,33,0
00004CD9  2121 2121 
00004CDD  2100      
                    7208   @m68kde~1_127:
00004CE0  4144 4452 7209          dc.b      65,68,68,82,69,83,83,32,69,82,82,79,82,58,32
00004CE4  4553 5320 
00004CE8  4552 524F 
00004CEC  523A 20   
00004CEF  3136 206F 7210          dc.b      49,54,32,111,114,32,51,50,32,66,105,116,32,84
00004CF3  7220 3332 
00004CF7  2042 6974 
00004CFB  2054      
00004CFD  7261 6E73 7211          dc.b      114,97,110,115,102,101,114,32,116,111,47,102
00004D01  6665 7220 
00004D05  746F 2F66 
00004D09  726F 6D20 7212          dc.b      114,111,109,32,97,110,32,79,68,68,32,65,100
00004D0D  616E 204F 
00004D11  4444 2041 
00004D15  64        
00004D16  6472 6573 7213          dc.b      100,114,101,115,115,46,46,46,46,0
00004D1A  732E 2E2E 
00004D1E  2E00      
                    7214   @m68kde~1_128:
00004D20  556E 6861 7215          dc.b      85,110,104,97,110,100,108,101,100,32,84,114
00004D24  6E64 6C65 
00004D28  6420 5472 
00004D2C  6170 2021 7216          dc.b      97,112,32,33,33,33,33,33,0
00004D30  2121 2121 
00004D34  00        
                    7217   @m68kde~1_129:
00004D36  4255 5320 7218          dc.b      66,85,83,32,69,114,114,111,114,33,0
00004D3A  4572 726F 
00004D3E  7221 00   
                    7219   @m68kde~1_130:
00004D42  4144 4452 7220          dc.b      65,68,68,82,69,83,83,32,69,114,114,111,114,33
00004D46  4553 5320 
00004D4A  4572 726F 
00004D4E  7221      
00004D50  00        7221          dc.b      0
                    7222   @m68kde~1_131:
00004D52  494C 4C45 7223          dc.b      73,76,76,69,71,65,76,32,73,78,83,84,82,85,67
00004D56  4741 4C20 
00004D5A  494E 5354 
00004D5E  5255 43   
00004D61  5449 4F4E 7224          dc.b      84,73,79,78,0
00004D65  00        
                    7225   @m68kde~1_132:
00004D66  4449 5649 7226          dc.b      68,73,86,73,68,69,32,66,89,32,90,69,82,79,0
00004D6A  4445 2042 
00004D6E  5920 5A45 
00004D72  524F 00   
                    7227   @m68kde~1_133:
00004D76  2743 484B 7228          dc.b      39,67,72,75,39,32,73,78,83,84,82,85,67,84,73
00004D7A  2720 494E 
00004D7E  5354 5255 
00004D82  4354 49   
00004D85  4F4E 00   7229          dc.b      79,78,0
                    7230   @m68kde~1_134:
00004D88  5452 4150 7231          dc.b      84,82,65,80,86,32,73,78,83,84,82,85,67,84,73
00004D8C  5620 494E 
00004D90  5354 5255 
00004D94  4354 49   
00004D97  4F4E 00   7232          dc.b      79,78,0
                    7233   @m68kde~1_135:
00004D9A  5052 4956 7234          dc.b      80,82,73,86,73,76,69,71,69,32,86,73,79,76,65
00004D9E  494C 4547 
00004DA2  4520 5649 
00004DA6  4F4C 41   
00004DA9  5449 4F4E 7235          dc.b      84,73,79,78,0
00004DAD  00        
                    7236   @m68kde~1_136:
00004DAE  554E 494E 7237          dc.b      85,78,73,78,73,84,73,65,76,73,83,69,68,32,73
00004DB2  4954 4941 
00004DB6  4C49 5345 
00004DBA  4420 49   
00004DBD  5251 00   7238          dc.b      82,81,0
                    7239   @m68kde~1_137:
00004DC0  5350 5552 7240          dc.b      83,80,85,82,73,79,85,83,32,73,82,81,0
00004DC4  494F 5553 
00004DC8  2049 5251 
00004DCC  00        
                    7241   @m68kde~1_138:
00004DCE  0D0A 5374 7242          dc.b      13,10,83,116,97,114,116,32,65,100,100,114,101
00004DD2  6172 7420 
00004DD6  4164 6472 
00004DDA  65        
00004DDB  7373 2069 7243          dc.b      115,115,32,105,110,32,77,101,109,111,114,121
00004DDF  6E20 4D65 
00004DE3  6D6F 7279 
00004DE7  3A20 00   7244          dc.b      58,32,0
                    7245   @m68kde~1_139:
00004DEA  0D0A 456E 7246          dc.b      13,10,69,110,116,101,114,32,83,116,114,105,110
00004DEE  7465 7220 
00004DF2  5374 7269 
00004DF6  6E        
00004DF7  6720 2845 7247          dc.b      103,32,40,69,83,67,32,116,111,32,101,110,100
00004DFB  5343 2074 
00004DFF  6F20 656E 
00004E03  64        
00004E04  2920 3A00 7248          dc.b      41,32,58,0
                    7249   @m68kde~1_140:
00004E08  0D0A 5072 7250          dc.b      13,10,80,114,111,118,105,100,101,32,116,104
00004E0C  6F76 6964 
00004E10  6520 7468 
00004E14  6520 7374 7251          dc.b      101,32,115,116,97,114,116,32,97,100,100,114
00004E18  6172 7420 
00004E1C  6164 6472 
00004E20  6573 7320 7252          dc.b      101,115,115,32,111,102,32,116,104,101,32,116
00004E24  6F66 2074 
00004E28  6865 2074 
00004E2C  6573 742E 7253          dc.b      101,115,116,46,10,0
00004E30  0A00      
                    7254   @m68kde~1_141:
00004E32  5468 6520 7255          dc.b      84,104,101,32,115,116,97,114,116,32,97,100,100
00004E36  7374 6172 
00004E3A  7420 6164 
00004E3E  64        
00004E3F  7265 7373 7256          dc.b      114,101,115,115,32,105,115,32,115,109,97,108
00004E43  2069 7320 
00004E47  736D 616C 
00004E4B  6C65 7220 7257          dc.b      108,101,114,32,116,104,97,110,32,48,120,102
00004E4F  7468 616E 
00004E53  2030 7866 
00004E57  3030 3030 7258          dc.b      48,48,48,48,48,48,48,44,32,105,110,118,97,108
00004E5B  3030 302C 
00004E5F  2069 6E76 
00004E63  616C      
00004E65  6964 210A 7259          dc.b      105,100,33,10,0
00004E69  00        
                    7260   @m68kde~1_142:
00004E6A  5468 6520 7261          dc.b      84,104,101,32,115,116,97,114,116,32,97,100,100
00004E6E  7374 6172 
00004E72  7420 6164 
00004E76  64        
00004E77  7265 7373 7262          dc.b      114,101,115,115,32,105,115,32,98,105,103,103
00004E7B  2069 7320 
00004E7F  6269 6767 
00004E83  6572 2074 7263          dc.b      101,114,32,116,104,97,110,32,48,120,102,48,48
00004E87  6861 6E20 
00004E8B  3078 6630 
00004E8F  30        
00004E90  3366 6666 7264          dc.b      51,102,102,102,102,44,32,105,110,118,97,108
00004E94  662C 2069 
00004E98  6E76 616C 
00004E9C  6964 210A 7265          dc.b      105,100,33,10,0
00004EA0  00        
                    7266   @m68kde~1_143:
00004EA2  5468 6520 7267          dc.b      84,104,101,32,115,116,97,114,116,32,97,100,100
00004EA6  7374 6172 
00004EAA  7420 6164 
00004EAE  64        
00004EAF  7265 7373 7268          dc.b      114,101,115,115,32,112,114,111,118,105,100,101
00004EB3  2070 726F 
00004EB7  7669 6465 
00004EBB  6420 6973 7269          dc.b      100,32,105,115,32,111,100,100,44,32,110,101
00004EBF  206F 6464 
00004EC3  2C20 6E65 
00004EC7  6564 2061 7270          dc.b      101,100,32,97,110,32,101,118,101,110,32,111
00004ECB  6E20 6576 
00004ECF  656E 206F 
00004ED3  6E65 210A 7271          dc.b      110,101,33,10,0
00004ED7  00        
                    7272   @m68kde~1_144:
00004ED8  5374 6172 7273          dc.b      83,116,97,114,116,32,97,100,100,114,101,115
00004EDC  7420 6164 
00004EE0  6472 6573 
00004EE4  7320 7661 7274          dc.b      115,32,118,97,108,105,100,46,10,0
00004EE8  6C69 642E 
00004EEC  0A00      
                    7275   @m68kde~1_145:
00004EEE  0D0A 5072 7276          dc.b      13,10,80,114,111,118,105,100,101,32,116,104
00004EF2  6F76 6964 
00004EF6  6520 7468 
00004EFA  6520 656E 7277          dc.b      101,32,101,110,100,32,97,100,100,114,101,115
00004EFE  6420 6164 
00004F02  6472 6573 
00004F06  7320 6F66 7278          dc.b      115,32,111,102,32,116,104,101,32,116,101,115
00004F0A  2074 6865 
00004F0E  2074 6573 
00004F12  742E 0A00 7279          dc.b      116,46,10,0
                    7280   @m68kde~1_146:
00004F16  5468 6520 7281          dc.b      84,104,101,32,101,110,100,32,97,100,100,114
00004F1A  656E 6420 
00004F1E  6164 6472 
00004F22  6573 7320 7282          dc.b      101,115,115,32,105,115,32,115,109,97,108,108
00004F26  6973 2073 
00004F2A  6D61 6C6C 
00004F2E  6572 2074 7283          dc.b      101,114,32,116,104,97,110,32,48,120,102,48,48
00004F32  6861 6E20 
00004F36  3078 6630 
00004F3A  30        
00004F3B  3030 3030 7284          dc.b      48,48,48,48,48,44,32,105,110,118,97,108,105
00004F3F  302C 2069 
00004F43  6E76 616C 
00004F47  69        
00004F48  6421 0A00 7285          dc.b      100,33,10,0
                    7286   @m68kde~1_147:
00004F4C  5468 6520 7287          dc.b      84,104,101,32,101,110,100,32,97,100,100,114
00004F50  656E 6420 
00004F54  6164 6472 
00004F58  6573 7320 7288          dc.b      101,115,115,32,105,115,32,98,105,103,103,101
00004F5C  6973 2062 
00004F60  6967 6765 
00004F64  7220 7468 7289          dc.b      114,32,116,104,97,110,32,48,120,102,48,48,51
00004F68  616E 2030 
00004F6C  7866 3030 
00004F70  33        
00004F71  6666 6666 7290          dc.b      102,102,102,102,44,32,105,110,118,97,108,105
00004F75  2C20 696E 
00004F79  7661 6C69 
00004F7D  6421 0A00 7291          dc.b      100,33,10,0
                    7292   @m68kde~1_148:
00004F82  5468 6520 7293          dc.b      84,104,101,32,101,110,100,32,97,100,100,114
00004F86  656E 6420 
00004F8A  6164 6472 
00004F8E  6573 7320 7294          dc.b      101,115,115,32,112,114,111,118,105,100,101,100
00004F92  7072 6F76 
00004F96  6964 6564 
00004F9A  2069 7320 7295          dc.b      32,105,115,32,111,100,100,44,32,110,101,101
00004F9E  6F64 642C 
00004FA2  206E 6565 
00004FA6  6420 616E 7296          dc.b      100,32,97,110,32,101,118,101,110,32,111,110
00004FAA  2065 7665 
00004FAE  6E20 6F6E 
00004FB2  6521 0A00 7297          dc.b      101,33,10,0
                    7298   @m68kde~1_149:
00004FB6  456E 6420 7299          dc.b      69,110,100,32,97,100,100,114,101,115,115,32
00004FBA  6164 6472 
00004FBE  6573 7320 
00004FC2  7661 6C69 7300          dc.b      118,97,108,105,100,46,10,0
00004FC6  642E 0A00 
                    7301   @m68kde~1_150:
00004FCA  5468 6520 7302          dc.b      84,104,101,32,115,116,97,114,116,32,97,100,100
00004FCE  7374 6172 
00004FD2  7420 6164 
00004FD6  64        
00004FD7  7265 7373 7303          dc.b      114,101,115,115,32,105,115,32,115,109,97,108
00004FDB  2069 7320 
00004FDF  736D 616C 
00004FE3  6C65 7220 7304          dc.b      108,101,114,32,116,104,97,110,32,48,120,48,56
00004FE7  7468 616E 
00004FEB  2030 7830 
00004FEF  38        
00004FF0  3030 3030 7305          dc.b      48,48,48,48,48,48,44,32,105,110,118,97,108,105
00004FF4  3030 2C20 
00004FF8  696E 7661 
00004FFC  6C69      
00004FFE  6421 0A00 7306          dc.b      100,33,10,0
                    7307   @m68kde~1_151:
00005002  5468 6520 7308          dc.b      84,104,101,32,115,116,97,114,116,32,97,100,100
00005006  7374 6172 
0000500A  7420 6164 
0000500E  64        
0000500F  7265 7373 7309          dc.b      114,101,115,115,32,105,115,32,98,105,103,103
00005013  2069 7320 
00005017  6269 6767 
0000501B  6572 2074 7310          dc.b      101,114,32,116,104,97,110,32,48,120,48,98,102
0000501F  6861 6E20 
00005023  3078 3062 
00005027  66        
00005028  6666 6666 7311          dc.b      102,102,102,102,102,44,32,105,110,118,97,108
0000502C  662C 2069 
00005030  6E76 616C 
00005034  6964 210A 7312          dc.b      105,100,33,10,0
00005038  00        
                    7313   @m68kde~1_152:
0000503A  5468 6520 7314          dc.b      84,104,101,32,101,110,100,32,97,100,100,114
0000503E  656E 6420 
00005042  6164 6472 
00005046  6573 7320 7315          dc.b      101,115,115,32,105,115,32,115,109,97,108,108
0000504A  6973 2073 
0000504E  6D61 6C6C 
00005052  6572 2074 7316          dc.b      101,114,32,116,104,97,110,32,48,120,48,56,48
00005056  6861 6E20 
0000505A  3078 3038 
0000505E  30        
0000505F  3030 3030 7317          dc.b      48,48,48,48,48,44,32,105,110,118,97,108,105
00005063  302C 2069 
00005067  6E76 616C 
0000506B  69        
0000506C  6421 0A00 7318          dc.b      100,33,10,0
                    7319   @m68kde~1_153:
00005070  5468 6520 7320          dc.b      84,104,101,32,101,110,100,32,97,100,100,114
00005074  656E 6420 
00005078  6164 6472 
0000507C  6573 7320 7321          dc.b      101,115,115,32,105,115,32,98,105,103,103,101
00005080  6973 2062 
00005084  6967 6765 
00005088  7220 7468 7322          dc.b      114,32,116,104,97,110,32,48,120,48,98,102,102
0000508C  616E 2030 
00005090  7830 6266 
00005094  66        
00005095  6666 6666 7323          dc.b      102,102,102,102,44,32,105,110,118,97,108,105
00005099  2C20 696E 
0000509D  7661 6C69 
000050A1  6421 0A00 7324          dc.b      100,33,10,0
                    7325   @m68kde~1_154:
000050A6  4C6F 6361 7326          dc.b      76,111,99,97,116,105,111,110,32,37,120,44,32
000050AA  7469 6F6E 
000050AE  2025 782C 
000050B2  20        
000050B3  7772 6974 7327          dc.b      119,114,105,116,101,32,100,97,116,97,58,32,37
000050B7  6520 6461 
000050BB  7461 3A20 
000050BF  25        
000050C0  782C 2072 7328          dc.b      120,44,32,114,101,97,100,32,100,97,116,97,58
000050C4  6561 6420 
000050C8  6461 7461 
000050CC  3A        
000050CD  2025 780A 7329          dc.b      32,37,120,10,0
000050D1  00        
                    7330   @m68kde~1_155:
000050D2  5465 7374 7331          dc.b      84,101,115,116,32,102,97,105,108,101,100,32
000050D6  2066 6169 
000050DA  6C65 6420 
000050DE  6174 206C 7332          dc.b      97,116,32,108,111,99,97,116,105,111,110,32,37
000050E2  6F63 6174 
000050E6  696F 6E20 
000050EA  25        
000050EB  7821 0A00 7333          dc.b      120,33,10,0
                    7334   @m68kde~1_156:
000050F0  0D0A 446F 7335          dc.b      13,10,68,111,32,121,111,117,32,119,97,110,116
000050F4  2079 6F75 
000050F8  2077 616E 
000050FC  74        
000050FD  2074 6865 7336          dc.b      32,116,104,101,32,100,97,116,97,32,116,111,32
00005101  2064 6174 
00005105  6120 746F 
00005109  20        
0000510A  6265 2031 7337          dc.b      98,101,32,49,46,32,98,121,116,101,115,44,32
0000510E  2E20 6279 
00005112  7465 732C 
00005116  20        
00005117  322E 2077 7338          dc.b      50,46,32,119,111,114,100,115,44,32,111,114,32
0000511B  6F72 6473 
0000511F  2C20 6F72 
00005123  20        
00005124  332E 206C 7339          dc.b      51,46,32,108,111,110,103,32,119,111,114,100
00005128  6F6E 6720 
0000512C  776F 7264 
00005130  733F 2050 7340          dc.b      115,63,32,80,114,111,118,105,100,101,32,116
00005134  726F 7669 
00005138  6465 2074 
0000513C  6865 2069 7341          dc.b      104,101,32,105,110,116,101,103,101,114,32,98
00005140  6E74 6567 
00005144  6572 2062 
00005148  656C 6F77 7342          dc.b      101,108,111,119,46,10,0
0000514C  2E0A 00   
                    7343   @m68kde~1_157:
00005150  0D0A 446F 7344          dc.b      13,10,68,111,32,121,111,117,32,119,97,110,116
00005154  2079 6F75 
00005158  2077 616E 
0000515C  74        
0000515D  2074 6865 7345          dc.b      32,116,104,101,32,100,97,116,97,32,116,111,32
00005161  2064 6174 
00005165  6120 746F 
00005169  20        
0000516A  6265 2063 7346          dc.b      98,101,32,99,111,109,112,111,115,101,100,32
0000516E  6F6D 706F 
00005172  7365 6420 
00005176  6F66 2028 7347          dc.b      111,102,32,40,104,101,120,41,32,49,46,32,48
0000517A  6865 7829 
0000517E  2031 2E20 
00005182  30        
00005183  2C20 322E 7348          dc.b      44,32,50,46,32,53,44,32,51,46,32,65,44,32,111
00005187  2035 2C20 
0000518B  332E 2041 
0000518F  2C20 6F   
00005192  7220 342E 7349          dc.b      114,32,52,46,32,70,63,32,80,114,111,118,105
00005196  2046 3F20 
0000519A  5072 6F76 
0000519E  69        
0000519F  6465 2074 7350          dc.b      100,101,32,116,104,101,32,105,110,116,101,103
000051A3  6865 2069 
000051A7  6E74 6567 
000051AB  6572 2062 7351          dc.b      101,114,32,98,101,108,111,119,46,10,0
000051AF  656C 6F77 
000051B3  2E0A 00   
                    7352   @m68kde~1_158:
000051B6  0D0A 446F 7353          dc.b      13,10,68,111,32,121,111,117,32,119,97,110,116
000051BA  2079 6F75 
000051BE  2077 616E 
000051C2  74        
000051C3  2074 6F20 7354          dc.b      32,116,111,32,116,101,115,116,32,49,46,32,83
000051C7  7465 7374 
000051CB  2031 2E20 
000051CF  53        
000051D0  5241 4D20 7355          dc.b      82,65,77,32,111,114,32,50,46,32,83,68,82,65
000051D4  6F72 2032 
000051D8  2E20 5344 
000051DC  5241      
000051DE  4D3F 2050 7356          dc.b      77,63,32,80,114,111,118,105,100,101,32,116,104
000051E2  726F 7669 
000051E6  6465 2074 
000051EA  68        
000051EB  6520 696E 7357          dc.b      101,32,105,110,116,101,103,101,114,32,98,101
000051EF  7465 6765 
000051F3  7220 6265 
000051F7  6C6F 772E 7358          dc.b      108,111,119,46,10,0
000051FB  0A00      
                    7359   @m68kde~1_159:
000051FE  5374 6172 7360          dc.b      83,116,97,114,116,32,97,100,100,114,101,115
00005202  7420 6164 
00005206  6472 6573 
0000520A  733A 2025 7361          dc.b      115,58,32,37,120,10,0
0000520E  780A 00   
                    7362   @m68kde~1_160:
00005212  456E 6420 7363          dc.b      69,110,100,32,97,100,100,114,101,115,115,58
00005216  6164 6472 
0000521A  6573 733A 
0000521E  2025 780A 7364          dc.b      32,37,120,10,0
00005222  00        
                    7365   @m68kde~1_161:
00005224  5465 7374 7366          dc.b      84,101,115,116,32,100,97,116,97,58,32,37,120
00005228  2064 6174 
0000522C  613A 2025 
00005230  78        
00005231  0A00      7367          dc.b      10,0
                    7368   @m68kde~1_162:
00005234  5465 7374 7369          dc.b      84,101,115,116,32,112,97,115,115,101,100,33
00005238  2070 6173 
0000523C  7365 6421 
00005240  0A00      7370          dc.b      10,0
                    7371   @m68kde~1_163:
00005242  4445 312D 7372          dc.b      68,69,49,45,54,56,107,32,66,117,103,32,86,49
00005246  3638 6B20 
0000524A  4275 6720 
0000524E  5631      
00005250  2E37 3700 7373          dc.b      46,55,55,0
                    7374   @m68kde~1_164:
00005254  436F 7079 7375          dc.b      67,111,112,121,114,105,103,104,116,32,40,67
00005258  7269 6768 
0000525C  7420 2843 
00005260  2920 504A 7376          dc.b      41,32,80,74,32,68,97,118,105,101,115,32,50,48
00005264  2044 6176 
00005268  6965 7320 
0000526C  3230      
0000526E  3136 00   7377          dc.b      49,54,0
                    7378   @m68kde~1_165:
00005272  0D0A 5275 7379          dc.b      13,10,82,117,110,110,105,110,103,46,46,46,46
00005276  6E6E 696E 
0000527A  672E 2E2E 
0000527E  2E        
0000527F  2E00      7380          dc.b      46,0
                    7381   @m68kde~1_166:
00005282  5275 6E6E 7382          dc.b      82,117,110,110,105,110,103,46,46,46,46,46,0
00005286  696E 672E 
0000528A  2E2E 2E2E 
0000528E  00        
                    7383   @m68kde~1_167:
00005290  4279 3A20 7384          dc.b      66,121,58,32,80,74,32,68,97,118,105,101,115
00005294  504A 2044 
00005298  6176 6965 
0000529C  73        
0000529D  00        7385          dc.b      0
                    7386   @m68kde~1_168:
0000529E  0D0A 2573 7387          dc.b      13,10,37,115,0
000052A2  00        
                    7388   @m68kde~1_169:
000052A4  0D0A 5374 7389          dc.b      13,10,83,116,117,100,101,110,116,32,78,97,109
000052A8  7564 656E 
000052AC  7420 4E61 
000052B0  6D        
000052B1  653A 2053 7390          dc.b      101,58,32,83,104,105,100,105,32,88,105,0
000052B5  6869 6469 
000052B9  2058 6900 
                    7391   @m68kde~1_170:
000052BE  0D0A 5374 7392          dc.b      13,10,83,116,117,100,101,110,116,32,78,117,109
000052C2  7564 656E 
000052C6  7420 4E75 
000052CA  6D        
000052CB  6265 723A 7393          dc.b      98,101,114,58,32,57,48,53,48,54,54,52,51,0
000052CF  2039 3035 
000052D3  3036 3634 
000052D7  3300      
                    7394          section   data
000052DA            7395                   align
          0000 52DA 7396   DataStart       equ       *
                    7397   
                    7398   *********************************************************************************************************
                    7399   * Data Section for Initialised Data - these will be placed in rom as constants and have to be copied
                    7400   * to ram as part of the CStart routine in this file
                    7401   *********************************************************************************************************
                    7402   
                    7403   @itoa_1:
000052DA  2D32 3134 7404          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
000052DE  3734 3833 
000052E2  3634 3800 
                    7405          section   bss
000052E6            7406                   align
          0000 52E6 7407   DataEnd         equ     *                       this label will equate to the address of the last byte of global variable in it
                    7408   
                    7409   *********************************************************************************************************
                    7410   * Section for Uninitialised Data held in ROM as constants
                    7411   *********************************************************************************************************
                    7412   
0B000000            7413                   org     RamVectorTable          Ram based vector table must be stored here otherwise InstallException Handler will not work
          0000 000C 7414   DataLength      equ     DataEnd-DataStart       length of data needed to copy to Ram on bootup
                    7415   
                    7416   
0B000000            7417   bss             org       bss
                    7418   
                    7419   *********************************************************************************************************
                    7420   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    7421   * install the exception handler using the C function InstallExceptionHandler()
                    7422   *********************************************************************************************************
                    7423   
                    7424   
                    7425   
0B000000            7426   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
0B000004            7427   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
0B000008            7428   VBusError        ds.l    1      storage for address of Bus Error Handler
0B00000C            7429   VAddressError    ds.l    1      storage for address of Address Error Handler
0B000010            7430   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
0B000014            7431   VDividebyZero    ds.l    1      storage for address of divide by zero handler
0B000018            7432   VCheck           ds.l    1      ditto
0B00001C            7433   VTrapV           ds.l    1      ditto
0B000020            7434   VPrivilege       ds.l    1      ditto
0B000024            7435   VTrace           ds.l    1
0B000028            7436   VLine1010emul    ds.l    1
0B00002C            7437   VLine1111emul    ds.l    1
0B000030            7438   VUnassigned1     ds.l    1
0B000034            7439   VUnassigned2     ds.l    1
0B000038            7440   VUnassigned3     ds.l    1
0B00003C            7441   VUninit_IRQ      ds.l    1
0B000040            7442   VUnassigned4     ds.l    1
0B000044            7443   VUnassigned5     ds.l    1
0B000048            7444   VUnassigned6     ds.l    1
0B00004C            7445   VUnassigned7     ds.l    1
0B000050            7446   VUnassigned8     ds.l    1
0B000054            7447   VUnassigned9     ds.l    1
0B000058            7448   VUnassigned10    ds.l    1
0B00005C            7449   VUnassigned11    ds.l    1
0B000060            7450   VSpuriousIRQ     ds.l    1
                    7451   
                    7452   * Interrupt handlers Vector 25-31
0B000064            7453   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000068            7454   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00006C            7455   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000070            7456   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000074            7457   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000078            7458   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00007C            7459   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    7460   
                    7461   * Trap Handler vectors 32-47
0B000080            7462   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000084            7463   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000088            7464   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00008C            7465   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000090            7466   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000094            7467   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000098            7468   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00009C            7469   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A0            7470   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A4            7471   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A8            7472   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000AC            7473   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B0            7474   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B4            7475   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B8            7476   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000BC            7477   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    7478   
                    7479   * the remaining exceptions are unassigned in the 68000 so no need to allocate storage for them here
                    7480   
                    7481   ***********************************************************************************************************
                    7482   * Other Variables
                    7483   ***********************************************************************************************************
                    7484   *__DebugA5       ds.l    1
                    7485   *__UserA5        ds.l    1
                    7486   
                    7487   ***********************************************************************************************************
0B0000C0            7488   __ungetbuf:     ds.l    1       ; ungetbuffer for stdio functions
0B0000C4            7489   __allocp:       ds.l    0       ; start of allocation units
0B0000C4            7490   __heap:         ds.l    0       ; pointers for malloc functions
                    7491   
                    7492   *__himem:       ds.l    himem            ; highest memory location + 1
                    7493   *__stklen:      ds.l    stklen           ; default stack size
                    7494   
                    7495   *********************************************************************************************************
                    7496   * Section for Heap
                    7497   *********************************************************************************************************
                    7498   
                    7499   _i:
0B0000C4            7500          ds.b      4
                    7501   _x:
0B0000C8            7502          ds.b      4
                    7503   _y:
0B0000CC            7504          ds.b      4
                    7505   _z:
0B0000D0            7506          ds.b      4
                    7507   _PortA_Count:
0B0000D4            7508          ds.b      4
                    7509   _Trace:
0B0000D8            7510          ds.b      4
                    7511   _GoFlag:
0B0000DC            7512          ds.b      4
                    7513   _Echo:
0B0000E0            7514          ds.b      4
                    7515   _d0:
0B0000E4            7516          ds.b      4
                    7517   _d1:
0B0000E8            7518          ds.b      4
                    7519   _d2:
0B0000EC            7520          ds.b      4
                    7521   _d3:
0B0000F0            7522          ds.b      4
                    7523   _d4:
0B0000F4            7524          ds.b      4
                    7525   _d5:
0B0000F8            7526          ds.b      4
                    7527   _d6:
0B0000FC            7528          ds.b      4
                    7529   _d7:
0B000100            7530          ds.b      4
                    7531   _a0:
0B000104            7532          ds.b      4
                    7533   _a1:
0B000108            7534          ds.b      4
                    7535   _a2:
0B00010C            7536          ds.b      4
                    7537   _a3:
0B000110            7538          ds.b      4
                    7539   _a4:
0B000114            7540          ds.b      4
                    7541   _a5:
0B000118            7542          ds.b      4
                    7543   _a6:
0B00011C            7544          ds.b      4
                    7545   _PC:
0B000120            7546          ds.b      4
                    7547   _SSP:
0B000124            7548          ds.b      4
                    7549   _USP:
0B000128            7550          ds.b      4
                    7551   _SR:
0B00012C            7552          ds.b      2
                    7553   _BreakPointAddress:
0B00012E            7554          ds.b      32
                    7555   _BreakPointInstruction:
0B00014E            7556          ds.b      16
                    7557   _BreakPointSetOrCleared:
0B00015E            7558          ds.b      32
                    7559   _InstructionSize:
0B00017E            7560          ds.b      4
                    7561   _WatchPointAddress:
0B000182            7562          ds.b      32
                    7563   _WatchPointSetOrCleared:
0B0001A2            7564          ds.b      32
                    7565   _WatchPointString:
0B0001C2            7566          ds.b      800
                    7567   _TempString:
0B0004E2            7568          ds.b      100
                    7569          section   heap
0B000546            7570                   align
          0B00 0546 7571   bssEnd          equ *                   end of storage space for unitialised variables
                    7572   *                                       we have to copy all initialised variable from rom to here at startup
          0B00 0546 7573   heap   equ       *
0B000546            7574                    align
          0000 0000

Assembly errors: 0
