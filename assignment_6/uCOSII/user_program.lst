680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 07 Apr 2023      Time: 10:46:31          Source: C:\IDE68K\UCOSII\USER_PROGRAM.SRC

                       1          section   code
                       2   **********************************************************************************************************
                       3   * CSTART.ASM  -  C startup-code
                       4   *
                       5   *          Initialises the system prior to running the users main() program
                       6   *
                       7   *          1) Sets up the user program stack pointer
                       8   *          2) Switches to User mode in the 68000
                       9   *          3) Enables All Interrupts 1-7 on 68000
                      10   *          4) Copies all initialised C program variables from Rom to Ram prior to running main()
                      11   *
                      12   **********************************************************************************************************
00000000              13                   align
                      14   
                      15   
                      16   **********************************************************************************************************
                      17   * The Following ORG Statement marks the address of the start of the this CStart Program
                      18   *
                      19   * The debug Monitor and Flash Load and Program routines assume your program lives here
                      20   **********************************************************************************************************
08000000              21                   org       $08000000
08000000  46FC 2000   22   start:          move.w    #$2000,SR             clear interrupts to enable all, move to supervisor mode
                      23   
                      24   ******************************************************************************************
                      25   * Set unitialised global variables to 0 at startup
                      26   ******************************************************************************************
08000004  207C 0800   27   mainloop        movea.l   #BssStart,a0          point a0 to the start of the initialised data section held in ROM
08000008  1FFE      
0800000A  203C 0000   28                   move.l    #BssLength,d0         figure out how many bytes of C program variables data to copy
0800000E  001C      
08000010  6700 0024   29                   beq       go_main               if no data to copy go straight to program
08000014  10FC 0000   30   Zeroinit        move.b    #0,(a0)+              copy the C program initialise variables from rom to ram
08000018  5380        31                   subq.l    #1,d0
0800001A  66F8        32                   bne       Zeroinit
                      33   
                      34   *******************************************************************************************
                      35   * last minute initialisation before calling main
                      36   *******************************************************************************************
                      37   
0800001C  23FC FFFF   38                   move.l    #-1,__ungetbuf         required for use of scanf() etc in C programs
08000020  FFFF 0800 
08000024  1FF2      
08000026  42B9 0800   39                   clr.l     __allocp               used by malloc() in C
0800002A  1FF6      
0800002C  23FC 0800   40                   move.l    #heap,__heap           pointer to free memory
08000030  201A 0800 
08000034  1FFA      
08000036  4EB9 0800   41   go_main         jsr       _main
0800003A  0F8A      
0800003C  60C2        42                   bra       start
                      43   
                      44   ; C:\M68KV6.0-800BY480\PROGRAMS\DEBUGMONITORCODE\M68KUSERPROGRAM (DE1).C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                      45   ; #include <stdio.h>
                      46   ; #include <string.h>
                      47   ; #include <ctype.h>
                      48   ; //IMPORTANT
                      49   ; //
                      50   ; // Uncomment one of the two #defines below
                      51   ; // Define StartOfExceptionVectorTable as 08030000 if running programs from sram or
                      52   ; // 0B000000 for running programs from dram
                      53   ; //
                      54   ; // In your labs, you will initially start by designing a system with SRam and later move to
                      55   ; // Dram, so these constants will need to be changed based on the version of the system you have
                      56   ; // building
                      57   ; //
                      58   ; // The working 68k system SOF file posted on canvas that you can use for your pre-lab
                      59   ; // is based around Dram so #define accordingly before building
                      60   ; //SRAM
                      61   ; //#define StartOfExceptionVectorTable 0x08030000
                      62   ; //DRAM
                      63   ; #define StartOfExceptionVectorTable 0x0B000000
                      64   ; /**********************************************************************************************
                      65   ; **	Parallel port addresses
                      66   ; **********************************************************************************************/
                      67   ; #define PortA   *(volatile unsigned char *)(0x00400000)
                      68   ; #define PortB   *(volatile unsigned char *)(0x00400002)
                      69   ; #define PortC   *(volatile unsigned char *)(0x00400004)
                      70   ; #define PortD   *(volatile unsigned char *)(0x00400006)
                      71   ; #define PortE   *(volatile unsigned char *)(0x00400008)
                      72   ; /*********************************************************************************************
                      73   ; **	Hex 7 seg displays port addresses
                      74   ; *********************************************************************************************/
                      75   ; #define HEX_A        *(volatile unsigned char *)(0x00400010)
                      76   ; #define HEX_B        *(volatile unsigned char *)(0x00400012)
                      77   ; #define HEX_C        *(volatile unsigned char *)(0x00400014)    // de2 only
                      78   ; #define HEX_D        *(volatile unsigned char *)(0x00400016)    // de2 only
                      79   ; /**********************************************************************************************
                      80   ; **	LCD display port addresses
                      81   ; **********************************************************************************************/
                      82   ; #define LCDcommand   *(volatile unsigned char *)(0x00400020)
                      83   ; #define LCDdata      *(volatile unsigned char *)(0x00400022)
                      84   ; /********************************************************************************************
                      85   ; **	Timer Port addresses
                      86   ; *********************************************************************************************/
                      87   ; #define Timer1Data      *(volatile unsigned char *)(0x00400030)
                      88   ; #define Timer1Control   *(volatile unsigned char *)(0x00400032)
                      89   ; #define Timer1Status    *(volatile unsigned char *)(0x00400032)
                      90   ; #define Timer2Data      *(volatile unsigned char *)(0x00400034)
                      91   ; #define Timer2Control   *(volatile unsigned char *)(0x00400036)
                      92   ; #define Timer2Status    *(volatile unsigned char *)(0x00400036)
                      93   ; #define Timer3Data      *(volatile unsigned char *)(0x00400038)
                      94   ; #define Timer3Control   *(volatile unsigned char *)(0x0040003A)
                      95   ; #define Timer3Status    *(volatile unsigned char *)(0x0040003A)
                      96   ; #define Timer4Data      *(volatile unsigned char *)(0x0040003C)
                      97   ; #define Timer4Control   *(volatile unsigned char *)(0x0040003E)
                      98   ; #define Timer4Status    *(volatile unsigned char *)(0x0040003E)
                      99   ; /*********************************************************************************************
                     100   ; **	RS232 port addresses
                     101   ; *********************************************************************************************/
                     102   ; #define RS232_Control     *(volatile unsigned char *)(0x00400040)
                     103   ; #define RS232_Status      *(volatile unsigned char *)(0x00400040)
                     104   ; #define RS232_TxData      *(volatile unsigned char *)(0x00400042)
                     105   ; #define RS232_RxData      *(volatile unsigned char *)(0x00400042)
                     106   ; #define RS232_Baud        *(volatile unsigned char *)(0x00400044)
                     107   ; /*********************************************************************************************
                     108   ; **	PIA 1 and 2 port addresses
                     109   ; *********************************************************************************************/
                     110   ; #define PIA1_PortA_Data     *(volatile unsigned char *)(0x00400050)         // combined data and data direction register share same address
                     111   ; #define PIA1_PortA_Control *(volatile unsigned char *)(0x00400052)
                     112   ; #define PIA1_PortB_Data     *(volatile unsigned char *)(0x00400054)         // combined data and data direction register share same address
                     113   ; #define PIA1_PortB_Control *(volatile unsigned char *)(0x00400056)
                     114   ; #define PIA2_PortA_Data     *(volatile unsigned char *)(0x00400060)         // combined data and data direction register share same address
                     115   ; #define PIA2_PortA_Control *(volatile unsigned char *)(0x00400062)
                     116   ; #define PIA2_PortB_data     *(volatile unsigned char *)(0x00400064)         // combined data and data direction register share same address
                     117   ; #define PIA2_PortB_Control *(volatile unsigned char *)(0x00400066)
                     118   ; /*******************************************************************************************
                     119   ; ** I2C address and common commands
                     120   ; *******************************************************************************************/
                     121   ; #define I2C_prescale_reg_L *(volatile unsigned char *) (0x00408000)
                     122   ; #define I2C_prescale_reg_H *(volatile unsigned char *) (0x00408002)
                     123   ; #define I2C_control_reg  *(volatile unsigned char *) (0x00408004)
                     124   ; #define I2C_TX_reg  *(volatile unsigned char *) (0x00408006)
                     125   ; #define I2C_RX_reg  *(volatile unsigned char *) (0x00408006)
                     126   ; #define I2C_command_reg  *(volatile unsigned char *) (0x00408008)
                     127   ; #define I2C_status_reg  *(volatile unsigned char *) (0x00408008)
                     128   ; #define start_write_cmd_I2C (char) (0x91)          // generate start signal and enable write, clear any pending interrupt
                     129   ; #define write_cmd_I2C (char) (0x11)            // send TX byte without generating a start signal
                     130   ; #define stop_write_cmd_I2C (char) (0x51)
                     131   ; #define stop_read_NACK_cmd_I2C (char) (0x69)
                     132   ; #define read_ACK_cmd_I2C (char) (0x21)
                     133   ; /*******************************************************************************************
                     134   ; ** CAN bus
                     135   ; *******************************************************************************************/
                     136   ; #define CAN0_CONTROLLER(i) (*(volatile unsigned char *)(0x00500000 + (i << 1)))
                     137   ; #define CAN1_CONTROLLER(i) (*(volatile unsigned char *)(0x00500200 + (i << 1)))
                     138   ; /* Can 0 register definitions */
                     139   ; #define Can0_ModeControlReg      CAN0_CONTROLLER(0)
                     140   ; #define Can0_CommandReg          CAN0_CONTROLLER(1)
                     141   ; #define Can0_StatusReg           CAN0_CONTROLLER(2)
                     142   ; #define Can0_InterruptReg        CAN0_CONTROLLER(3)
                     143   ; #define Can0_InterruptEnReg      CAN0_CONTROLLER(4) /* PeliCAN mode */
                     144   ; #define Can0_BusTiming0Reg       CAN0_CONTROLLER(6)
                     145   ; #define Can0_BusTiming1Reg       CAN0_CONTROLLER(7)
                     146   ; #define Can0_OutControlReg       CAN0_CONTROLLER(8)
                     147   ; /* address definitions of Other Registers */
                     148   ; #define Can0_ArbLostCapReg       CAN0_CONTROLLER(11)
                     149   ; #define Can0_ErrCodeCapReg       CAN0_CONTROLLER(12)
                     150   ; #define Can0_ErrWarnLimitReg     CAN0_CONTROLLER(13)
                     151   ; #define Can0_RxErrCountReg       CAN0_CONTROLLER(14)
                     152   ; #define Can0_TxErrCountReg       CAN0_CONTROLLER(15)
                     153   ; #define Can0_RxMsgCountReg       CAN0_CONTROLLER(29)
                     154   ; #define Can0_RxBufStartAdr       CAN0_CONTROLLER(30)
                     155   ; #define Can0_ClockDivideReg      CAN0_CONTROLLER(31)
                     156   ; /* address definitions of Acceptance Code & Mask Registers - RESET MODE */
                     157   ; #define Can0_AcceptCode0Reg      CAN0_CONTROLLER(16)
                     158   ; #define Can0_AcceptCode1Reg      CAN0_CONTROLLER(17)
                     159   ; #define Can0_AcceptCode2Reg      CAN0_CONTROLLER(18)
                     160   ; #define Can0_AcceptCode3Reg      CAN0_CONTROLLER(19)
                     161   ; #define Can0_AcceptMask0Reg      CAN0_CONTROLLER(20)
                     162   ; #define Can0_AcceptMask1Reg      CAN0_CONTROLLER(21)
                     163   ; #define Can0_AcceptMask2Reg      CAN0_CONTROLLER(22)
                     164   ; #define Can0_AcceptMask3Reg      CAN0_CONTROLLER(23)
                     165   ; /* address definitions Rx Buffer - OPERATING MODE - Read only register*/
                     166   ; #define Can0_RxFrameInfo         CAN0_CONTROLLER(16)
                     167   ; #define Can0_RxBuffer1           CAN0_CONTROLLER(17)
                     168   ; #define Can0_RxBuffer2           CAN0_CONTROLLER(18)
                     169   ; #define Can0_RxBuffer3           CAN0_CONTROLLER(19)
                     170   ; #define Can0_RxBuffer4           CAN0_CONTROLLER(20)
                     171   ; #define Can0_RxBuffer5           CAN0_CONTROLLER(21)
                     172   ; #define Can0_RxBuffer6           CAN0_CONTROLLER(22)
                     173   ; #define Can0_RxBuffer7           CAN0_CONTROLLER(23)
                     174   ; #define Can0_RxBuffer8           CAN0_CONTROLLER(24)
                     175   ; #define Can0_RxBuffer9           CAN0_CONTROLLER(25)
                     176   ; #define Can0_RxBuffer10          CAN0_CONTROLLER(26)
                     177   ; #define Can0_RxBuffer11          CAN0_CONTROLLER(27)
                     178   ; #define Can0_RxBuffer12          CAN0_CONTROLLER(28)
                     179   ; /* address definitions of the Tx-Buffer - OPERATING MODE - Write only register */
                     180   ; #define Can0_TxFrameInfo         CAN0_CONTROLLER(16)
                     181   ; #define Can0_TxBuffer1           CAN0_CONTROLLER(17)
                     182   ; #define Can0_TxBuffer2           CAN0_CONTROLLER(18)
                     183   ; #define Can0_TxBuffer3           CAN0_CONTROLLER(19)
                     184   ; #define Can0_TxBuffer4           CAN0_CONTROLLER(20)
                     185   ; #define Can0_TxBuffer5           CAN0_CONTROLLER(21)
                     186   ; #define Can0_TxBuffer6           CAN0_CONTROLLER(22)
                     187   ; #define Can0_TxBuffer7           CAN0_CONTROLLER(23)
                     188   ; #define Can0_TxBuffer8           CAN0_CONTROLLER(24)
                     189   ; #define Can0_TxBuffer9           CAN0_CONTROLLER(25)
                     190   ; #define Can0_TxBuffer10          CAN0_CONTROLLER(26)
                     191   ; #define Can0_TxBuffer11          CAN0_CONTROLLER(27)
                     192   ; #define Can0_TxBuffer12          CAN0_CONTROLLER(28)
                     193   ; /* read only addresses */
                     194   ; #define Can0_TxFrameInfoRd       CAN0_CONTROLLER(96)
                     195   ; #define Can0_TxBufferRd1         CAN0_CONTROLLER(97)
                     196   ; #define Can0_TxBufferRd2         CAN0_CONTROLLER(98)
                     197   ; #define Can0_TxBufferRd3         CAN0_CONTROLLER(99)
                     198   ; #define Can0_TxBufferRd4         CAN0_CONTROLLER(100)
                     199   ; #define Can0_TxBufferRd5         CAN0_CONTROLLER(101)
                     200   ; #define Can0_TxBufferRd6         CAN0_CONTROLLER(102)
                     201   ; #define Can0_TxBufferRd7         CAN0_CONTROLLER(103)
                     202   ; #define Can0_TxBufferRd8         CAN0_CONTROLLER(104)
                     203   ; #define Can0_TxBufferRd9         CAN0_CONTROLLER(105)
                     204   ; #define Can0_TxBufferRd10        CAN0_CONTROLLER(106)
                     205   ; #define Can0_TxBufferRd11        CAN0_CONTROLLER(107)
                     206   ; #define Can0_TxBufferRd12        CAN0_CONTROLLER(108)
                     207   ; /* CAN1 Controller register definitions */
                     208   ; #define Can1_ModeControlReg      CAN1_CONTROLLER(0)
                     209   ; #define Can1_CommandReg          CAN1_CONTROLLER(1)
                     210   ; #define Can1_StatusReg           CAN1_CONTROLLER(2)
                     211   ; #define Can1_InterruptReg        CAN1_CONTROLLER(3)
                     212   ; #define Can1_InterruptEnReg      CAN1_CONTROLLER(4) /* PeliCAN mode */
                     213   ; #define Can1_BusTiming0Reg       CAN1_CONTROLLER(6)
                     214   ; #define Can1_BusTiming1Reg       CAN1_CONTROLLER(7)
                     215   ; #define Can1_OutControlReg       CAN1_CONTROLLER(8)
                     216   ; /* address definitions of Other Registers */
                     217   ; #define Can1_ArbLostCapReg       CAN1_CONTROLLER(11)
                     218   ; #define Can1_ErrCodeCapReg       CAN1_CONTROLLER(12)
                     219   ; #define Can1_ErrWarnLimitReg     CAN1_CONTROLLER(13)
                     220   ; #define Can1_RxErrCountReg       CAN1_CONTROLLER(14)
                     221   ; #define Can1_TxErrCountReg       CAN1_CONTROLLER(15)
                     222   ; #define Can1_RxMsgCountReg       CAN1_CONTROLLER(29)
                     223   ; #define Can1_RxBufStartAdr       CAN1_CONTROLLER(30)
                     224   ; #define Can1_ClockDivideReg      CAN1_CONTROLLER(31)
                     225   ; /* address definitions of Acceptance Code & Mask Registers - RESET MODE */
                     226   ; #define Can1_AcceptCode0Reg      CAN1_CONTROLLER(16)
                     227   ; #define Can1_AcceptCode1Reg      CAN1_CONTROLLER(17)
                     228   ; #define Can1_AcceptCode2Reg      CAN1_CONTROLLER(18)
                     229   ; #define Can1_AcceptCode3Reg      CAN1_CONTROLLER(19)
                     230   ; #define Can1_AcceptMask0Reg      CAN1_CONTROLLER(20)
                     231   ; #define Can1_AcceptMask1Reg      CAN1_CONTROLLER(21)
                     232   ; #define Can1_AcceptMask2Reg      CAN1_CONTROLLER(22)
                     233   ; #define Can1_AcceptMask3Reg      CAN1_CONTROLLER(23)
                     234   ; /* address definitions Rx Buffer - OPERATING MODE - Read only register*/
                     235   ; #define Can1_RxFrameInfo         CAN1_CONTROLLER(16)
                     236   ; #define Can1_RxBuffer1           CAN1_CONTROLLER(17)
                     237   ; #define Can1_RxBuffer2           CAN1_CONTROLLER(18)
                     238   ; #define Can1_RxBuffer3           CAN1_CONTROLLER(19)
                     239   ; #define Can1_RxBuffer4           CAN1_CONTROLLER(20)
                     240   ; #define Can1_RxBuffer5           CAN1_CONTROLLER(21)
                     241   ; #define Can1_RxBuffer6           CAN1_CONTROLLER(22)
                     242   ; #define Can1_RxBuffer7           CAN1_CONTROLLER(23)
                     243   ; #define Can1_RxBuffer8           CAN1_CONTROLLER(24)
                     244   ; #define Can1_RxBuffer9           CAN1_CONTROLLER(25)
                     245   ; #define Can1_RxBuffer10          CAN1_CONTROLLER(26)
                     246   ; #define Can1_RxBuffer11          CAN1_CONTROLLER(27)
                     247   ; #define Can1_RxBuffer12          CAN1_CONTROLLER(28)
                     248   ; /* address definitions of the Tx-Buffer - OPERATING MODE - Write only register */
                     249   ; #define Can1_TxFrameInfo         CAN1_CONTROLLER(16)
                     250   ; #define Can1_TxBuffer1           CAN1_CONTROLLER(17)
                     251   ; #define Can1_TxBuffer2           CAN1_CONTROLLER(18)
                     252   ; #define Can1_TxBuffer3           CAN1_CONTROLLER(19)
                     253   ; #define Can1_TxBuffer4           CAN1_CONTROLLER(20)
                     254   ; #define Can1_TxBuffer5           CAN1_CONTROLLER(21)
                     255   ; #define Can1_TxBuffer6           CAN1_CONTROLLER(22)
                     256   ; #define Can1_TxBuffer7           CAN1_CONTROLLER(23)
                     257   ; #define Can1_TxBuffer8           CAN1_CONTROLLER(24)
                     258   ; #define Can1_TxBuffer9           CAN1_CONTROLLER(25)
                     259   ; #define Can1_TxBuffer10          CAN1_CONTROLLER(26)
                     260   ; #define Can1_TxBuffer11          CAN1_CONTROLLER(27)
                     261   ; #define Can1_TxBuffer12          CAN1_CONTROLLER(28)
                     262   ; /* read only addresses */
                     263   ; #define Can1_TxFrameInfoRd       CAN1_CONTROLLER(96)
                     264   ; #define Can1_TxBufferRd1         CAN1_CONTROLLER(97)
                     265   ; #define Can1_TxBufferRd2         CAN1_CONTROLLER(98)
                     266   ; #define Can1_TxBufferRd3         CAN1_CONTROLLER(99)
                     267   ; #define Can1_TxBufferRd4         CAN1_CONTROLLER(100)
                     268   ; #define Can1_TxBufferRd5         CAN1_CONTROLLER(101)
                     269   ; #define Can1_TxBufferRd6         CAN1_CONTROLLER(102)
                     270   ; #define Can1_TxBufferRd7         CAN1_CONTROLLER(103)
                     271   ; #define Can1_TxBufferRd8         CAN1_CONTROLLER(104)
                     272   ; #define Can1_TxBufferRd9         CAN1_CONTROLLER(105)
                     273   ; #define Can1_TxBufferRd10        CAN1_CONTROLLER(106)
                     274   ; #define Can1_TxBufferRd11        CAN1_CONTROLLER(107)
                     275   ; #define Can1_TxBufferRd12        CAN1_CONTROLLER(108)
                     276   ; /* bit definitions for the Mode & Control Register */
                     277   ; #define RM_RR_Bit 0x01 /* reset mode (request) bit */
                     278   ; #define LOM_Bit 0x02 /* listen only mode bit */
                     279   ; #define STM_Bit 0x04 /* self test mode bit */
                     280   ; #define AFM_Bit 0x08 /* acceptance filter mode bit */
                     281   ; #define SM_Bit  0x10 /* enter sleep mode bit */
                     282   ; /* bit definitions for the Interrupt Enable & Control Register */
                     283   ; #define RIE_Bit 0x01 /* receive interrupt enable bit */
                     284   ; #define TIE_Bit 0x02 /* transmit interrupt enable bit */
                     285   ; #define EIE_Bit 0x04 /* error warning interrupt enable bit */
                     286   ; #define DOIE_Bit 0x08 /* data overrun interrupt enable bit */
                     287   ; #define WUIE_Bit 0x10 /* wake-up interrupt enable bit */
                     288   ; #define EPIE_Bit 0x20 /* error passive interrupt enable bit */
                     289   ; #define ALIE_Bit 0x40 /* arbitration lost interr. enable bit*/
                     290   ; #define BEIE_Bit 0x80 /* bus error interrupt enable bit */
                     291   ; /* bit definitions for the Command Register */
                     292   ; #define TR_Bit 0x01 /* transmission request bit */
                     293   ; #define AT_Bit 0x02 /* abort transmission bit */
                     294   ; #define RRB_Bit 0x04 /* release receive buffer bit */
                     295   ; #define CDO_Bit 0x08 /* clear data overrun bit */
                     296   ; #define SRR_Bit 0x10 /* self reception request bit */
                     297   ; /* bit definitions for the Status Register */
                     298   ; #define RBS_Bit 0x01 /* receive buffer status bit */
                     299   ; #define DOS_Bit 0x02 /* data overrun status bit */
                     300   ; #define TBS_Bit 0x04 /* transmit buffer status bit */
                     301   ; #define TCS_Bit 0x08 /* transmission complete status bit */
                     302   ; #define RS_Bit 0x10 /* receive status bit */
                     303   ; #define TS_Bit 0x20 /* transmit status bit */
                     304   ; #define ES_Bit 0x40 /* error status bit */
                     305   ; #define BS_Bit 0x80 /* bus status bit */
                     306   ; /* bit definitions for the Interrupt Register */
                     307   ; #define RI_Bit 0x01 /* receive interrupt bit */
                     308   ; #define TI_Bit 0x02 /* transmit interrupt bit */
                     309   ; #define EI_Bit 0x04 /* error warning interrupt bit */
                     310   ; #define DOI_Bit 0x08 /* data overrun interrupt bit */
                     311   ; #define WUI_Bit 0x10 /* wake-up interrupt bit */
                     312   ; #define EPI_Bit 0x20 /* error passive interrupt bit */
                     313   ; #define ALI_Bit 0x40 /* arbitration lost interrupt bit */
                     314   ; #define BEI_Bit 0x80 /* bus error interrupt bit */
                     315   ; /* bit definitions for the Bus Timing Registers */
                     316   ; #define SAM_Bit 0x80                        /* sample mode bit 1 == the bus is sampled 3 times, 0 == the bus is sampled once */
                     317   ; /* bit definitions for the Output Control Register OCMODE1, OCMODE0 */
                     318   ; #define BiPhaseMode 0x00 /* bi-phase output mode */
                     319   ; #define NormalMode 0x02 /* normal output mode */
                     320   ; #define ClkOutMode 0x03 /* clock output mode */
                     321   ; /* output pin configuration for TX1 */
                     322   ; #define OCPOL1_Bit 0x20 /* output polarity control bit */
                     323   ; #define Tx1Float 0x00 /* configured as float */
                     324   ; #define Tx1PullDn 0x40 /* configured as pull-down */
                     325   ; #define Tx1PullUp 0x80 /* configured as pull-up */
                     326   ; #define Tx1PshPull 0xC0 /* configured as push/pull */
                     327   ; /* output pin configuration for TX0 */
                     328   ; #define OCPOL0_Bit 0x04 /* output polarity control bit */
                     329   ; #define Tx0Float 0x00 /* configured as float */
                     330   ; #define Tx0PullDn 0x08 /* configured as pull-down */
                     331   ; #define Tx0PullUp 0x10 /* configured as pull-up */
                     332   ; #define Tx0PshPull 0x18 /* configured as push/pull */
                     333   ; /* bit definitions for the Clock Divider Register */
                     334   ; #define DivBy1 0x07 /* CLKOUT = oscillator frequency */
                     335   ; #define DivBy2 0x00 /* CLKOUT = 1/2 oscillator frequency */
                     336   ; #define ClkOff_Bit 0x08 /* clock off bit, control of the CLK OUT pin */
                     337   ; #define RXINTEN_Bit 0x20 /* pin TX1 used for receive interrupt */
                     338   ; #define CBP_Bit 0x40 /* CAN comparator bypass control bit */
                     339   ; #define CANMode_Bit 0x80 /* CAN mode definition bit */
                     340   ; /*- definition of used constants ---------------------------------------*/
                     341   ; #define YES 1
                     342   ; #define NO 0
                     343   ; #define ENABLE 1
                     344   ; #define DISABLE 0
                     345   ; #define ENABLE_N 0
                     346   ; #define DISABLE_N 1
                     347   ; #define INTLEVELACT 0
                     348   ; #define INTEDGEACT 1
                     349   ; #define PRIORITY_LOW 0
                     350   ; #define PRIORITY_HIGH 1
                     351   ; /* default (reset) value for register content, clear register */
                     352   ; #define ClrByte 0x00
                     353   ; /* constant: clear Interrupt Enable Register */
                     354   ; #define ClrIntEnSJA ClrByte
                     355   ; /* definitions for the acceptance code and mask register */
                     356   ; #define DontCare 0xFF
                     357   ; /*  bus timing values for
                     358   ; **  bit-rate : 100 kBit/s
                     359   ; **  oscillator frequency : 25 MHz, 1 sample per bit, 0 tolerance %
                     360   ; **  maximum tolerated propagation delay : 4450 ns
                     361   ; **  minimum requested propagation delay : 500 ns
                     362   ; **
                     363   ; **  https://www.kvaser.com/support/calculators/bit-timing-calculator/
                     364   ; **  T1 	T2 	BTQ 	SP% 	SJW 	BIT RATE 	ERR% 	BTR0 	BTR1
                     365   ; **  17	8	25	    68	     1	      100	    0	      04	7f
                     366   ; */
                     367   ; /*********************************************************************************************************************************
                     368   ; * 
                     369   ; * 
                     370   ; (( DO NOT initialise global variables here, do it main even if you want 0
                     371   ; (( it's a limitation of the compiler
                     372   ; (( YOU HAVE BEEN WARNED
                     373   ; *********************************************************************************************************************************/
                     374   ; unsigned int i, x, y, z, PortA_Count;
                     375   ; unsigned char Timer1Count, Timer2Count, Timer3Count, Timer4Count ;
                     376   ; /*******************************************************************************************
                     377   ; ** Function Prototypes
                     378   ; *******************************************************************************************/
                     379   ; int _getch( void );
                     380   ; char xtod(int c);
                     381   ; int Get1HexDigits(char *CheckSumPtr);
                     382   ; int Get2HexDigits(char *CheckSumPtr);
                     383   ; int Get4HexDigits(char *CheckSumPtr);
                     384   ; int Get6HexDigits(char *CheckSumPtr);
                     385   ; void Wait1ms(void);
                     386   ; void Wait3ms(void);
                     387   ; void Wait500ms (void);
                     388   ; void Init_LCD(void) ;
                     389   ; void LCDOutchar(int c);
                     390   ; void LCDOutMess(char *theMessage);
                     391   ; void LCDClearln(void);
                     392   ; void LCDline1Message(char *theMessage);
                     393   ; void LCDline2Message(char *theMessage);
                     394   ; int sprintf(char *out, const char *format, ...) ;
                     395   ; unsigned int ask_EEPROM_internal_addr(void);
                     396   ; unsigned char ask_EEPROM_data(void);
                     397   ; void EEPROM_internal_writting_polling(unsigned char slave_addr_RW);
                     398   ; void I2C_init(void);
                     399   ; void I2C_TX_command_status (char data, char command);
                     400   ; void I2C_byte_write (void);
                     401   ; void I2C_byte_read (void);
                     402   ; unsigned int ask_EEPROM_addr_range(void);
                     403   ; void I2C_multi_write (void);
                     404   ; void I2C_multi_read (void);
                     405   ; int boundry_checker (int intended_page_size, unsigned int current_addr);
                     406   ; void DAC(void);
                     407   ; unsigned char ask_ADC_channel (void);
                     408   ; /*******************************************************************************************
                     409   ; ** CAN bus functions
                     410   ; *******************************************************************************************/
                     411   ; // initialisation for Can controller 0
                     412   ; void Init_CanBus_Controller0(void)
                     413   ; {
                     414   _Init_CanBus_Controller0:
                     415   ; // TODO - put your Canbus initialisation code for CanController 0 here
                     416   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                     417   ; printf("\r\nInitializing Can controller 0");
0800003E  4879 0800  418          pea       @m68kus~1_1.L
08000042  1AE4      
08000044  4EB9 0800  419          jsr       _printf
08000048  115E      
0800004A  584F       420          addq.w    #4,A7
                     421   ; while((Can0_ModeControlReg & RM_RR_Bit ) == ClrByte)
                     422   Init_CanBus_Controller0_1:
0800004C  1039 0050  423          move.b    5242880,D0
08000050  0000      
08000052  C03C 0001  424          and.b     #1,D0
08000056  6612       425          bne.s     Init_CanBus_Controller0_3
                     426   ; {
                     427   ; Can0_ModeControlReg = Can0_ModeControlReg | RM_RR_Bit;
08000058  1039 0050  428          move.b    5242880,D0
0800005C  0000      
0800005E  803C 0001  429          or.b      #1,D0
08000062  13C0 0050  430          move.b    D0,5242880
08000066  0000      
08000068  60E2       431          bra       Init_CanBus_Controller0_1
                     432   Init_CanBus_Controller0_3:
                     433   ; }
                     434   ; Can0_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy1;
0800006A  13FC 00C7  435          move.b    #199,5242942
0800006E  0050 003E 
                     436   ; Can0_InterruptEnReg = ClrIntEnSJA;
08000072  4239 0050  437          clr.b     5242888
08000076  0008      
                     438   ; Can0_AcceptCode0Reg = ClrByte;
08000078  4239 0050  439          clr.b     5242912
0800007C  0020      
                     440   ; Can0_AcceptCode1Reg = ClrByte;
0800007E  4239 0050  441          clr.b     5242914
08000082  0022      
                     442   ; Can0_AcceptCode2Reg = ClrByte;
08000084  4239 0050  443          clr.b     5242916
08000088  0024      
                     444   ; Can0_AcceptCode3Reg = ClrByte;
0800008A  4239 0050  445          clr.b     5242918
0800008E  0026      
                     446   ; Can0_AcceptMask0Reg = DontCare;
08000090  13FC 00FF  447          move.b    #255,5242920
08000094  0050 0028 
                     448   ; Can0_AcceptMask1Reg = DontCare;
08000098  13FC 00FF  449          move.b    #255,5242922
0800009C  0050 002A 
                     450   ; Can0_AcceptMask2Reg = DontCare;
080000A0  13FC 00FF  451          move.b    #255,5242924
080000A4  0050 002C 
                     452   ; Can0_AcceptMask3Reg = DontCare;
080000A8  13FC 00FF  453          move.b    #255,5242926
080000AC  0050 002E 
                     454   ; // see the comment on line 275
                     455   ; Can0_BusTiming0Reg = 0x04;
080000B0  13FC 0004  456          move.b    #4,5242892
080000B4  0050 000C 
                     457   ; Can0_BusTiming1Reg = 0x7f;
080000B8  13FC 007F  458          move.b    #127,5242894
080000BC  0050 000E 
                     459   ; Can0_OutControlReg = Tx0Float | Tx0PshPull | NormalMode;
080000C0  13FC 001A  460          move.b    #26,5242896
080000C4  0050 0010 
                     461   ; while ((Can0_ModeControlReg & RM_RR_Bit) != ClrByte)
                     462   Init_CanBus_Controller0_4:
080000C8  1039 0050  463          move.b    5242880,D0
080000CC  0000      
080000CE  C03C 0001  464          and.b     #1,D0
080000D2  6708       465          beq.s     Init_CanBus_Controller0_6
                     466   ; {
                     467   ; Can0_ModeControlReg = ClrByte;
080000D4  4239 0050  468          clr.b     5242880
080000D8  0000      
080000DA  60EC       469          bra       Init_CanBus_Controller0_4
                     470   Init_CanBus_Controller0_6:
080000DC  4E75       471          rts
                     472   ; }
                     473   ; }
                     474   ; // initialisation for Can controller 1
                     475   ; void Init_CanBus_Controller1(void)
                     476   ; {
                     477   _Init_CanBus_Controller1:
                     478   ; // TODO - put your Canbus initialisation code for CanController 1 here
                     479   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                     480   ; printf("\r\nInitializing Can controller 1");
080000DE  4879 0800  481          pea       @m68kus~1_2.L
080000E2  1B04      
080000E4  4EB9 0800  482          jsr       _printf
080000E8  115E      
080000EA  584F       483          addq.w    #4,A7
                     484   ; while((Can1_ModeControlReg & RM_RR_Bit ) == ClrByte)
                     485   Init_CanBus_Controller1_1:
080000EC  1039 0050  486          move.b    5243392,D0
080000F0  0200      
080000F2  C03C 0001  487          and.b     #1,D0
080000F6  6612       488          bne.s     Init_CanBus_Controller1_3
                     489   ; {
                     490   ; Can1_ModeControlReg = Can1_ModeControlReg | RM_RR_Bit;
080000F8  1039 0050  491          move.b    5243392,D0
080000FC  0200      
080000FE  803C 0001  492          or.b      #1,D0
08000102  13C0 0050  493          move.b    D0,5243392
08000106  0200      
08000108  60E2       494          bra       Init_CanBus_Controller1_1
                     495   Init_CanBus_Controller1_3:
                     496   ; }
                     497   ; Can1_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy1;
0800010A  13FC 00C7  498          move.b    #199,5243454
0800010E  0050 023E 
                     499   ; Can1_InterruptEnReg = ClrIntEnSJA;
08000112  4239 0050  500          clr.b     5243400
08000116  0208      
                     501   ; Can1_AcceptCode0Reg = ClrByte;
08000118  4239 0050  502          clr.b     5243424
0800011C  0220      
                     503   ; Can1_AcceptCode1Reg = ClrByte;
0800011E  4239 0050  504          clr.b     5243426
08000122  0222      
                     505   ; Can1_AcceptCode2Reg = ClrByte;
08000124  4239 0050  506          clr.b     5243428
08000128  0224      
                     507   ; Can1_AcceptCode3Reg = ClrByte;
0800012A  4239 0050  508          clr.b     5243430
0800012E  0226      
                     509   ; Can1_AcceptMask0Reg = DontCare;
08000130  13FC 00FF  510          move.b    #255,5243432
08000134  0050 0228 
                     511   ; Can1_AcceptMask1Reg = DontCare;
08000138  13FC 00FF  512          move.b    #255,5243434
0800013C  0050 022A 
                     513   ; Can1_AcceptMask2Reg = DontCare;
08000140  13FC 00FF  514          move.b    #255,5243436
08000144  0050 022C 
                     515   ; Can1_AcceptMask3Reg = DontCare;
08000148  13FC 00FF  516          move.b    #255,5243438
0800014C  0050 022E 
                     517   ; // see the comment on line 275
                     518   ; Can1_BusTiming0Reg = 0x04;
08000150  13FC 0004  519          move.b    #4,5243404
08000154  0050 020C 
                     520   ; Can1_BusTiming1Reg = 0x7f;
08000158  13FC 007F  521          move.b    #127,5243406
0800015C  0050 020E 
                     522   ; Can1_OutControlReg = Tx1Float | Tx1PshPull | NormalMode;
08000160  13FC 00C2  523          move.b    #194,5243408
08000164  0050 0210 
                     524   ; while ((Can1_ModeControlReg & RM_RR_Bit) != ClrByte)
                     525   Init_CanBus_Controller1_4:
08000168  1039 0050  526          move.b    5243392,D0
0800016C  0200      
0800016E  C03C 0001  527          and.b     #1,D0
08000172  6708       528          beq.s     Init_CanBus_Controller1_6
                     529   ; {
                     530   ; Can1_ModeControlReg = ClrByte;
08000174  4239 0050  531          clr.b     5243392
08000178  0200      
0800017A  60EC       532          bra       Init_CanBus_Controller1_4
                     533   Init_CanBus_Controller1_6:
0800017C  4E75       534          rts
                     535   ; }
                     536   ; }
                     537   ; // Transmit for sending a message via Can controller 0
                     538   ; void CanBus0_Transmit(void)
                     539   ; {
                     540   _CanBus0_Transmit:
                     541   ; // TODO - put your Canbus transmit code for CanController 0 here
                     542   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                     543   ; printf("\r\nTransmitting Can controller 0");
0800017E  4879 0800  544          pea       @m68kus~1_3.L
08000182  1B24      
08000184  4EB9 0800  545          jsr       _printf
08000188  115E      
0800018A  584F       546          addq.w    #4,A7
                     547   ; while((Can0_StatusReg & TBS_Bit ) != TBS_Bit ) {}
                     548   CanBus0_Transmit_1:
0800018C  1039 0050  549          move.b    5242884,D0
08000190  0004      
08000192  C03C 0004  550          and.b     #4,D0
08000196  0C00 0004  551          cmp.b     #4,D0
0800019A  6702       552          beq.s     CanBus0_Transmit_3
0800019C  60EE       553          bra       CanBus0_Transmit_1
                     554   CanBus0_Transmit_3:
                     555   ; // frame format = 0 (standard), RTR = 0 (data framee), DLC = b'1000 (8 bytes), see data sheet page 40-41
                     556   ; Can0_TxFrameInfo = 0x08;
0800019E  13FC 0008  557          move.b    #8,5242912
080001A2  0050 0020 
                     558   ; // 11 bits identifier, don't care, since we don't have filtering
                     559   ; Can0_TxBuffer1 = 0x00;
080001A6  4239 0050  560          clr.b     5242914
080001AA  0022      
                     561   ; Can0_TxBuffer2 = 0x00;
080001AC  4239 0050  562          clr.b     5242916
080001B0  0024      
                     563   ; // 8 bytes data;
                     564   ; Can0_TxBuffer3 = 0x00;
080001B2  4239 0050  565          clr.b     5242918
080001B6  0026      
                     566   ; Can0_TxBuffer4 = 0x01;
080001B8  13FC 0001  567          move.b    #1,5242920
080001BC  0050 0028 
                     568   ; Can0_TxBuffer5 = 0x02;
080001C0  13FC 0002  569          move.b    #2,5242922
080001C4  0050 002A 
                     570   ; Can0_TxBuffer6 = 0x03;
080001C8  13FC 0003  571          move.b    #3,5242924
080001CC  0050 002C 
                     572   ; Can0_TxBuffer7 = 0x04;
080001D0  13FC 0004  573          move.b    #4,5242926
080001D4  0050 002E 
                     574   ; Can0_TxBuffer8 = 0x05;
080001D8  13FC 0005  575          move.b    #5,5242928
080001DC  0050 0030 
                     576   ; Can0_TxBuffer9 = 0x06;
080001E0  13FC 0006  577          move.b    #6,5242930
080001E4  0050 0032 
                     578   ; Can0_TxBuffer10 = 0x07;
080001E8  13FC 0007  579          move.b    #7,5242932
080001EC  0050 0034 
                     580   ; Can0_CommandReg = TR_Bit;
080001F0  13FC 0001  581          move.b    #1,5242882
080001F4  0050 0002 
                     582   ; // wait for the transmission to complete
                     583   ; while((Can0_StatusReg & TCS_Bit ) != TCS_Bit ) {}
                     584   CanBus0_Transmit_4:
080001F8  1039 0050  585          move.b    5242884,D0
080001FC  0004      
080001FE  C03C 0008  586          and.b     #8,D0
08000202  0C00 0008  587          cmp.b     #8,D0
08000206  6702       588          beq.s     CanBus0_Transmit_6
08000208  60EE       589          bra       CanBus0_Transmit_4
                     590   CanBus0_Transmit_6:
0800020A  4E75       591          rts
                     592   ; }
                     593   ; // Transmit for sending a message via Can controller 1
                     594   ; void CanBus1_Transmit(void)
                     595   ; {
                     596   _CanBus1_Transmit:
                     597   ; // TODO - put your Canbus transmit code for CanController 1 here
                     598   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                     599   ; ("\r\nTransmitting Can controller 1");
0800020C  41F9 0800  600          lea       @m68kus~1_4.L,A0
08000210  1B44      
                     601   ; while((Can1_StatusReg & TBS_Bit ) != TBS_Bit ) {}
                     602   CanBus1_Transmit_1:
08000212  1039 0050  603          move.b    5243396,D0
08000216  0204      
08000218  C03C 0004  604          and.b     #4,D0
0800021C  0C00 0004  605          cmp.b     #4,D0
08000220  6702       606          beq.s     CanBus1_Transmit_3
08000222  60EE       607          bra       CanBus1_Transmit_1
                     608   CanBus1_Transmit_3:
                     609   ; // frame format = 0 (standard), RTR = 0 (data framee), DLC = b'1000 (8 bytes), see data sheet page 40-41
                     610   ; Can1_TxFrameInfo = 0x08;
08000224  13FC 0008  611          move.b    #8,5243424
08000228  0050 0220 
                     612   ; // 11 bits identifier, don't care, since we don't have filtering
                     613   ; Can1_TxBuffer1 = 0x00;
0800022C  4239 0050  614          clr.b     5243426
08000230  0222      
                     615   ; Can1_TxBuffer2 = 0x00;
08000232  4239 0050  616          clr.b     5243428
08000236  0224      
                     617   ; // 8 bytes data;
                     618   ; Can1_TxBuffer3 = 0x00;
08000238  4239 0050  619          clr.b     5243430
0800023C  0226      
                     620   ; Can1_TxBuffer4 = 0x01;
0800023E  13FC 0001  621          move.b    #1,5243432
08000242  0050 0228 
                     622   ; Can1_TxBuffer5 = 0x02;
08000246  13FC 0002  623          move.b    #2,5243434
0800024A  0050 022A 
                     624   ; Can1_TxBuffer6 = 0x03;
0800024E  13FC 0003  625          move.b    #3,5243436
08000252  0050 022C 
                     626   ; Can1_TxBuffer7 = 0x04;
08000256  13FC 0004  627          move.b    #4,5243438
0800025A  0050 022E 
                     628   ; Can1_TxBuffer8 = 0x05;
0800025E  13FC 0005  629          move.b    #5,5243440
08000262  0050 0230 
                     630   ; Can1_TxBuffer9 = 0x06;
08000266  13FC 0006  631          move.b    #6,5243442
0800026A  0050 0232 
                     632   ; Can1_TxBuffer10 = 0x07;
0800026E  13FC 0007  633          move.b    #7,5243444
08000272  0050 0234 
                     634   ; Can1_CommandReg = TR_Bit;
08000276  13FC 0001  635          move.b    #1,5243394
0800027A  0050 0202 
                     636   ; // wait for the transmission to complete
                     637   ; while((Can1_StatusReg & TCS_Bit ) != TCS_Bit ) {}
                     638   CanBus1_Transmit_4:
0800027E  1039 0050  639          move.b    5243396,D0
08000282  0204      
08000284  C03C 0008  640          and.b     #8,D0
08000288  0C00 0008  641          cmp.b     #8,D0
0800028C  6702       642          beq.s     CanBus1_Transmit_6
0800028E  60EE       643          bra       CanBus1_Transmit_4
                     644   CanBus1_Transmit_6:
08000290  4E75       645          rts
                     646   ; }
                     647   ; // Receive for reading a received message via Can controller 0
                     648   ; void CanBus0_Receive(void)
                     649   ; {
                     650   _CanBus0_Receive:
08000292  2F0A       651          move.l    A2,-(A7)
08000294  45F9 0800  652          lea       _printf.L,A2
08000298  115E      
                     653   ; // TODO - put your Canbus receive code for CanController 0 here
                     654   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                     655   ; // wait for the receiver buffer to be full
                     656   ; ("\r\nReading Can controller 0");
0800029A  41F9 0800  657          lea       @m68kus~1_5.L,A0
0800029E  1B64      
                     658   ; while ((Can0_StatusReg & RBS_Bit) != RBS_Bit) {}
                     659   CanBus0_Receive_1:
080002A0  1039 0050  660          move.b    5242884,D0
080002A4  0004      
080002A6  C03C 0001  661          and.b     #1,D0
080002AA  0C00 0001  662          cmp.b     #1,D0
080002AE  6702       663          beq.s     CanBus0_Receive_3
080002B0  60EE       664          bra       CanBus0_Receive_1
                     665   CanBus0_Receive_3:
                     666   ; printf("\r\n%x",Can0_RxBuffer1);
080002B2  1239 0050  667          move.b    5242914,D1
080002B6  0022      
080002B8  C2BC 0000  668          and.l     #255,D1
080002BC  00FF      
080002BE  2F01       669          move.l    D1,-(A7)
080002C0  4879 0800  670          pea       @m68kus~1_6.L
080002C4  1B80      
080002C6  4E92       671          jsr       (A2)
080002C8  504F       672          addq.w    #8,A7
                     673   ; printf("\r\n%x",Can0_RxBuffer2);
080002CA  1239 0050  674          move.b    5242916,D1
080002CE  0024      
080002D0  C2BC 0000  675          and.l     #255,D1
080002D4  00FF      
080002D6  2F01       676          move.l    D1,-(A7)
080002D8  4879 0800  677          pea       @m68kus~1_6.L
080002DC  1B80      
080002DE  4E92       678          jsr       (A2)
080002E0  504F       679          addq.w    #8,A7
                     680   ; printf("\r\n%x",Can0_RxBuffer3);
080002E2  1239 0050  681          move.b    5242918,D1
080002E6  0026      
080002E8  C2BC 0000  682          and.l     #255,D1
080002EC  00FF      
080002EE  2F01       683          move.l    D1,-(A7)
080002F0  4879 0800  684          pea       @m68kus~1_6.L
080002F4  1B80      
080002F6  4E92       685          jsr       (A2)
080002F8  504F       686          addq.w    #8,A7
                     687   ; printf("\r\n%x",Can0_RxBuffer4);
080002FA  1239 0050  688          move.b    5242920,D1
080002FE  0028      
08000300  C2BC 0000  689          and.l     #255,D1
08000304  00FF      
08000306  2F01       690          move.l    D1,-(A7)
08000308  4879 0800  691          pea       @m68kus~1_6.L
0800030C  1B80      
0800030E  4E92       692          jsr       (A2)
08000310  504F       693          addq.w    #8,A7
                     694   ; Can0_CommandReg = RRB_Bit;
08000312  13FC 0004  695          move.b    #4,5242882
08000316  0050 0002 
0800031A  245F       696          move.l    (A7)+,A2
0800031C  4E75       697          rts
                     698   ; }
                     699   ; // Receive for reading a received message via Can controller 1
                     700   ; void CanBus1_Receive(void)
                     701   ; {
                     702   _CanBus1_Receive:
0800031E  2F0A       703          move.l    A2,-(A7)
08000320  45F9 0800  704          lea       _printf.L,A2
08000324  115E      
                     705   ; // TODO - put your Canbus receive code for CanController 1 here
                     706   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                     707   ; ("\r\nReading Can controller 1");
08000326  41F9 0800  708          lea       @m68kus~1_7.L,A0
0800032A  1B86      
                     709   ; while ((Can1_StatusReg & RBS_Bit) != RBS_Bit) {}
                     710   CanBus1_Receive_1:
0800032C  1039 0050  711          move.b    5243396,D0
08000330  0204      
08000332  C03C 0001  712          and.b     #1,D0
08000336  0C00 0001  713          cmp.b     #1,D0
0800033A  6702       714          beq.s     CanBus1_Receive_3
0800033C  60EE       715          bra       CanBus1_Receive_1
                     716   CanBus1_Receive_3:
                     717   ; printf("\r\n%x",Can1_RxBuffer1);
0800033E  1239 0050  718          move.b    5243426,D1
08000342  0222      
08000344  C2BC 0000  719          and.l     #255,D1
08000348  00FF      
0800034A  2F01       720          move.l    D1,-(A7)
0800034C  4879 0800  721          pea       @m68kus~1_6.L
08000350  1B80      
08000352  4E92       722          jsr       (A2)
08000354  504F       723          addq.w    #8,A7
                     724   ; printf("\r\n%x",Can1_RxBuffer2);
08000356  1239 0050  725          move.b    5243428,D1
0800035A  0224      
0800035C  C2BC 0000  726          and.l     #255,D1
08000360  00FF      
08000362  2F01       727          move.l    D1,-(A7)
08000364  4879 0800  728          pea       @m68kus~1_6.L
08000368  1B80      
0800036A  4E92       729          jsr       (A2)
0800036C  504F       730          addq.w    #8,A7
                     731   ; printf("\r\n%x",Can1_RxBuffer3);
0800036E  1239 0050  732          move.b    5243430,D1
08000372  0226      
08000374  C2BC 0000  733          and.l     #255,D1
08000378  00FF      
0800037A  2F01       734          move.l    D1,-(A7)
0800037C  4879 0800  735          pea       @m68kus~1_6.L
08000380  1B80      
08000382  4E92       736          jsr       (A2)
08000384  504F       737          addq.w    #8,A7
                     738   ; printf("\r\n%x",Can1_RxBuffer4);
08000386  1239 0050  739          move.b    5243432,D1
0800038A  0228      
0800038C  C2BC 0000  740          and.l     #255,D1
08000390  00FF      
08000392  2F01       741          move.l    D1,-(A7)
08000394  4879 0800  742          pea       @m68kus~1_6.L
08000398  1B80      
0800039A  4E92       743          jsr       (A2)
0800039C  504F       744          addq.w    #8,A7
                     745   ; Can1_CommandReg = RRB_Bit;
0800039E  13FC 0004  746          move.b    #4,5243394
080003A2  0050 0202 
080003A6  245F       747          move.l    (A7)+,A2
080003A8  4E75       748          rts
                     749   ; }
                     750   ; void CanBusTest(void)
                     751   ; {
                     752   _CanBusTest:
080003AA  2F0A       753          move.l    A2,-(A7)
080003AC  45F9 0800  754          lea       _printf.L,A2
080003B0  115E      
                     755   ; // initialise the two Can controllers
                     756   ; Init_CanBus_Controller0();
080003B2  4EB9 0800  757          jsr       _Init_CanBus_Controller0
080003B6  003E      
                     758   ; Init_CanBus_Controller1();
080003B8  4EB9 0800  759          jsr       _Init_CanBus_Controller1
080003BC  00DE      
                     760   ; printf("\r\n\r\n---- CANBUS Test ----\r\n") ;
080003BE  4879 0800  761          pea       @m68kus~1_8.L
080003C2  1BA2      
080003C4  4E92       762          jsr       (A2)
080003C6  584F       763          addq.w    #4,A7
                     764   ; // simple application to alternately transmit and receive messages from each of two nodes
                     765   ; while(1)    {
                     766   CanBusTest_1:
                     767   ; Wait500ms ();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
080003C8  4EB9 0800  768          jsr       _Wait500ms
080003CC  0CA4      
                     769   ; CanBus0_Transmit() ;       // transmit a message via Controller 0
080003CE  4EB9 0800  770          jsr       _CanBus0_Transmit
080003D2  017E      
                     771   ; CanBus1_Receive() ;        // receive a message via Controller 1 (and display it)
080003D4  4EB9 0800  772          jsr       _CanBus1_Receive
080003D8  031E      
                     773   ; printf("\r\n") ;
080003DA  4879 0800  774          pea       @m68kus~1_9.L
080003DE  1BBE      
080003E0  4E92       775          jsr       (A2)
080003E2  584F       776          addq.w    #4,A7
                     777   ; Wait500ms ();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
080003E4  4EB9 0800  778          jsr       _Wait500ms
080003E8  0CA4      
                     779   ; CanBus1_Transmit() ;        // transmit a message via Controller 1
080003EA  4EB9 0800  780          jsr       _CanBus1_Transmit
080003EE  020C      
                     781   ; CanBus0_Receive() ;         // receive a message via Controller 0 (and display it)
080003F0  4EB9 0800  782          jsr       _CanBus0_Receive
080003F4  0292      
                     783   ; printf("\r\n") ;
080003F6  4879 0800  784          pea       @m68kus~1_9.L
080003FA  1BBE      
080003FC  4E92       785          jsr       (A2)
080003FE  584F       786          addq.w    #4,A7
08000400  60C6       787          bra       CanBusTest_1
                     788   ; }
                     789   ; }
                     790   ; /*******************************************************************************************
                     791   ; ** I2C functions
                     792   ; *******************************************************************************************/
                     793   ; unsigned int ask_EEPROM_internal_addr(void){
                     794   _ask_EEPROM_internal_addr:
08000402  48E7 3000  795          movem.l   D2/D3,-(A7)
                     796   ; // ask the internal EEPROM address, return an array, storing the upper byte at location 0, and the lower byte at 1, the block select at 2
                     797   ; int valid = 0;
08000406  4283       798          clr.l     D3
                     799   ; unsigned int addr;
                     800   ; printf("\r\nWhat is the internal EEPROM address you want to access? ");
08000408  4879 0800  801          pea       @m68kus~1_10.L
0800040C  1BC2      
0800040E  4EB9 0800  802          jsr       _printf
08000412  115E      
08000414  584F       803          addq.w    #4,A7
                     804   ; while (!valid){
                     805   ask_EEPROM_internal_addr_1:
08000416  4A83       806          tst.l     D3
08000418  6628       807          bne.s     ask_EEPROM_internal_addr_3
                     808   ; addr = Get6HexDigits(0);
0800041A  42A7       809          clr.l     -(A7)
0800041C  4EB9 0800  810          jsr       _Get6HexDigits
08000420  0E44      
08000422  584F       811          addq.w    #4,A7
08000424  2400       812          move.l    D0,D2
                     813   ; if (addr > 0x01ffff) { // 128k byte memory
08000426  0C82 0001  814          cmp.l     #131071,D2
0800042A  FFFF      
0800042C  6310       815          bls.s     ask_EEPROM_internal_addr_4
                     816   ; printf("\r\nAddress cannot be greater than 0x01ffff! Input again: ");
0800042E  4879 0800  817          pea       @m68kus~1_11.L
08000432  1BFE      
08000434  4EB9 0800  818          jsr       _printf
08000438  115E      
0800043A  584F       819          addq.w    #4,A7
0800043C  6002       820          bra.s     ask_EEPROM_internal_addr_5
                     821   ask_EEPROM_internal_addr_4:
                     822   ; } else {
                     823   ; valid = 1;
0800043E  7601       824          moveq     #1,D3
                     825   ask_EEPROM_internal_addr_5:
08000440  60D4       826          bra       ask_EEPROM_internal_addr_1
                     827   ask_EEPROM_internal_addr_3:
                     828   ; }
                     829   ; }
                     830   ; return addr;
08000442  2002       831          move.l    D2,D0
08000444  4CDF 000C  832          movem.l   (A7)+,D2/D3
08000448  4E75       833          rts
                     834   ; }
                     835   ; unsigned char ask_EEPROM_data(void){
                     836   _ask_EEPROM_data:
0800044A  4E56 FFFC  837          link      A6,#-4
                     838   ; // ask the data to be written into the EEPROM
                     839   ; unsigned char data;
                     840   ; printf("\r\nWhat is the data you want to write into the EEPROM? ");
0800044E  4879 0800  841          pea       @m68kus~1_12.L
08000452  1C38      
08000454  4EB9 0800  842          jsr       _printf
08000458  115E      
0800045A  584F       843          addq.w    #4,A7
                     844   ; data = Get2HexDigits(0);
0800045C  42A7       845          clr.l     -(A7)
0800045E  4EB9 0800  846          jsr       _Get2HexDigits
08000462  0DBE      
08000464  584F       847          addq.w    #4,A7
08000466  1D40 FFFF  848          move.b    D0,-1(A6)
                     849   ; return data;
0800046A  102E FFFF  850          move.b    -1(A6),D0
0800046E  4E5E       851          unlk      A6
08000470  4E75       852          rts
                     853   ; }
                     854   ; void EEPROM_internal_writting_polling(unsigned char slave_addr_RW){
                     855   _EEPROM_internal_writting_pollin:
08000472  4E56 0000  856          link      A6,#0
08000476  2F02       857          move.l    D2,-(A7)
                     858   ; int flag = 1;
08000478  7401       859          moveq     #1,D2
                     860   ; // EEPROM acknowledge polling, wait for EEPROM's internal writting
                     861   ; // send the writting control byte with a start signal
                     862   ; I2C_TX_reg = slave_addr_RW;
0800047A  13EE 000B  863          move.b    11(A6),4227078
0800047E  0040 8006 
                     864   ; while (flag) {
                     865   EEPROM_internal_writting_pollin_1:
08000482  4A82       866          tst.l     D2
08000484  672A       867          beq.s     EEPROM_internal_writting_pollin_3
                     868   ; I2C_command_reg = start_write_cmd_I2C;
08000486  13FC 0091  869          move.b    #145,4227080
0800048A  0040 8008 
                     870   ; // wait for the master core to finish transmitting
                     871   ; while ((I2C_status_reg & 0x02) != 0){}
                     872   EEPROM_internal_writting_pollin_4:
0800048E  1039 0040  873          move.b    4227080,D0
08000492  8008      
08000494  C03C 0002  874          and.b     #2,D0
08000498  6702       875          beq.s     EEPROM_internal_writting_pollin_6
0800049A  60F2       876          bra       EEPROM_internal_writting_pollin_4
                     877   EEPROM_internal_writting_pollin_6:
                     878   ; // if we didn't get ACK bit, then EEPROM is done writting, quit polling 
                     879   ; if ((I2C_status_reg & 0x80) == 0) {
0800049C  1039 0040  880          move.b    4227080,D0
080004A0  8008      
080004A2  C07C 00FF  881          and.w     #255,D0
080004A6  C07C 0080  882          and.w     #128,D0
080004AA  6602       883          bne.s     EEPROM_internal_writting_pollin_7
                     884   ; flag = 0;
080004AC  4282       885          clr.l     D2
                     886   EEPROM_internal_writting_pollin_7:
080004AE  60D2       887          bra       EEPROM_internal_writting_pollin_1
                     888   EEPROM_internal_writting_pollin_3:
080004B0  241F       889          move.l    (A7)+,D2
080004B2  4E5E       890          unlk      A6
080004B4  4E75       891          rts
                     892   ; }
                     893   ; }
                     894   ; }
                     895   ; void I2C_init (void) {
                     896   _I2C_init:
                     897   ; // disenable the core to allow us to set the prescale registers
                     898   ; I2C_control_reg = 0x00; 
080004B6  4239 0040  899          clr.b     4227076
080004BA  8004      
                     900   ; // set prescale registers to 0x0031
                     901   ; I2C_prescale_reg_L = 0x31;
080004BC  13FC 0031  902          move.b    #49,4227072
080004C0  0040 8000 
                     903   ; I2C_prescale_reg_H = 0x00;
080004C4  4239 0040  904          clr.b     4227074
080004C8  8002      
                     905   ; // enable the core, disenable the interrupt
                     906   ; I2C_control_reg = 0x80;
080004CA  13FC 0080  907          move.b    #128,4227076
080004CE  0040 8004 
080004D2  4E75       908          rts
                     909   ; }
                     910   ; void I2C_TX_command_status (unsigned char data, unsigned char command) {
                     911   _I2C_TX_command_status:
080004D4  4E56 0000  912          link      A6,#0
                     913   ; //printf("\r\ndata: %x", data);
                     914   ; //printf("\r\ncommand: %x", command);
                     915   ; I2C_TX_reg = data;
080004D8  13EE 000B  916          move.b    11(A6),4227078
080004DC  0040 8006 
                     917   ; I2C_command_reg = command;
080004E0  13EE 000F  918          move.b    15(A6),4227080
080004E4  0040 8008 
                     919   ; // check the TIP bit, if it's 1, we wait here
                     920   ; while ((I2C_status_reg & 0x02) != 0){}
                     921   I2C_TX_command_status_1:
080004E8  1039 0040  922          move.b    4227080,D0
080004EC  8008      
080004EE  C03C 0002  923          and.b     #2,D0
080004F2  6702       924          beq.s     I2C_TX_command_status_3
080004F4  60F2       925          bra       I2C_TX_command_status_1
                     926   I2C_TX_command_status_3:
                     927   ; //printf("\r\nTIP done");
                     928   ; // wait for acknowledge from slave
                     929   ; while ((I2C_status_reg & 0x80) != 0){
                     930   I2C_TX_command_status_4:
080004F6  1039 0040  931          move.b    4227080,D0
080004FA  8008      
080004FC  C07C 00FF  932          and.w     #255,D0
08000500  C07C 0080  933          and.w     #128,D0
08000504  6702       934          beq.s     I2C_TX_command_status_6
                     935   ; //printf("\r\n%x", I2C_status_reg);
                     936   ; }
08000506  60EE       937          bra       I2C_TX_command_status_4
                     938   I2C_TX_command_status_6:
08000508  4E5E       939          unlk      A6
0800050A  4E75       940          rts
                     941   ; //printf("\r\nACK received");
                     942   ; }
                     943   ; void I2C_byte_write (void) {
                     944   _I2C_byte_write:
0800050C  4E56 FFF8  945          link      A6,#-8
08000510  48E7 3020  946          movem.l   D2/D3/A2,-(A7)
08000514  45F9 0800  947          lea       _I2C_TX_command_status.L,A2
08000518  04D4      
                     948   ; unsigned char slave_addr_RW;
                     949   ; unsigned char slave_write_data;
                     950   ; unsigned char EEPROM_block_select;
                     951   ; unsigned char EEPROM_internal_addr_H, EEPROM_internal_addr_L;
                     952   ; unsigned int addr;
                     953   ; int EEPROM_polling_flag = 1;
0800051A  2D7C 0000  954          move.l    #1,-4(A6)
0800051E  0001 FFFC 
                     955   ; printf("\r\nRandom EEPROM byte write");
08000522  4879 0800  956          pea       @m68kus~1_13.L
08000526  1C70      
08000528  4EB9 0800  957          jsr       _printf
0800052C  115E      
0800052E  584F       958          addq.w    #4,A7
                     959   ; // get the internal address
                     960   ; addr = ask_EEPROM_internal_addr();
08000530  4EB9 0800  961          jsr       _ask_EEPROM_internal_addr
08000534  0402      
08000536  2400       962          move.l    D0,D2
                     963   ; EEPROM_internal_addr_H = (addr & 0x00ff00) >> 8;
08000538  2002       964          move.l    D2,D0
0800053A  C0BC 0000  965          and.l     #65280,D0
0800053E  FF00      
08000540  E088       966          lsr.l     #8,D0
08000542  1D40 FFFA  967          move.b    D0,-6(A6)
                     968   ; EEPROM_internal_addr_L = addr & 0x0000ff;
08000546  2002       969          move.l    D2,D0
08000548  C0BC 0000  970          and.l     #255,D0
0800054C  00FF      
0800054E  1D40 FFFB  971          move.b    D0,-5(A6)
                     972   ; EEPROM_block_select = (addr & 0x010000) >> 16;
08000552  2002       973          move.l    D2,D0
08000554  C0BC 0001  974          and.l     #65536,D0
08000558  0000      
0800055A  E088       975          lsr.l     #8,D0
0800055C  E088       976          lsr.l     #8,D0
0800055E  1D40 FFF9  977          move.b    D0,-7(A6)
                     978   ; slave_write_data = ask_EEPROM_data();
08000562  4EB9 0800  979          jsr       _ask_EEPROM_data
08000566  044A      
08000568  1D40 FFF8  980          move.b    D0,-8(A6)
                     981   ; // EEPROM tag (b'1010) + chip select ('b00) + block select + write (0)
                     982   ; slave_addr_RW = (0xa0 | (EEPROM_block_select << 1));
0800056C  303C 00A0  983          move.w    #160,D0
08000570  122E FFF9  984          move.b    -7(A6),D1
08000574  E309       985          lsl.b     #1,D1
08000576  C27C 00FF  986          and.w     #255,D1
0800057A  8041       987          or.w      D1,D0
0800057C  1600       988          move.b    D0,D3
                     989   ; // send the control byte and generate a start signal
                     990   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
0800057E  4878 0091  991          pea       145
08000582  4883       992          ext.w     D3
08000584  48C3       993          ext.l     D3
08000586  2F03       994          move.l    D3,-(A7)
08000588  4E92       995          jsr       (A2)
0800058A  504F       996          addq.w    #8,A7
                     997   ; // write EEPROM internal addr (upper and lower byte), no start signal
                     998   ; I2C_TX_command_status(EEPROM_internal_addr_H, write_cmd_I2C);
0800058C  4878 0011  999          pea       17
08000590  122E FFFA 1000          move.b    -6(A6),D1
08000594  4881      1001          ext.w     D1
08000596  48C1      1002          ext.l     D1
08000598  2F01      1003          move.l    D1,-(A7)
0800059A  4E92      1004          jsr       (A2)
0800059C  504F      1005          addq.w    #8,A7
                    1006   ; I2C_TX_command_status(EEPROM_internal_addr_L, write_cmd_I2C);
0800059E  4878 0011 1007          pea       17
080005A2  122E FFFB 1008          move.b    -5(A6),D1
080005A6  4881      1009          ext.w     D1
080005A8  48C1      1010          ext.l     D1
080005AA  2F01      1011          move.l    D1,-(A7)
080005AC  4E92      1012          jsr       (A2)
080005AE  504F      1013          addq.w    #8,A7
                    1014   ; // write the actual data, and generate a stop condition after receiving an Acknowledge from the slave
                    1015   ; I2C_TX_command_status(slave_write_data, stop_write_cmd_I2C);
080005B0  4878 0051 1016          pea       81
080005B4  122E FFF8 1017          move.b    -8(A6),D1
080005B8  4881      1018          ext.w     D1
080005BA  48C1      1019          ext.l     D1
080005BC  2F01      1020          move.l    D1,-(A7)
080005BE  4E92      1021          jsr       (A2)
080005C0  504F      1022          addq.w    #8,A7
                    1023   ; EEPROM_internal_writting_polling(slave_addr_RW);
080005C2  C6BC 0000 1024          and.l     #255,D3
080005C6  00FF      
080005C8  2F03      1025          move.l    D3,-(A7)
080005CA  4EB9 0800 1026          jsr       _EEPROM_internal_writting_pollin
080005CE  0472      
080005D0  584F      1027          addq.w    #4,A7
                    1028   ; printf("\r\nEEPROM writting done!");
080005D2  4879 0800 1029          pea       @m68kus~1_14.L
080005D6  1C8C      
080005D8  4EB9 0800 1030          jsr       _printf
080005DC  115E      
080005DE  584F      1031          addq.w    #4,A7
080005E0  4CDF 040C 1032          movem.l   (A7)+,D2/D3/A2
080005E4  4E5E      1033          unlk      A6
080005E6  4E75      1034          rts
                    1035   ; }
                    1036   ; void I2C_byte_read (void) {
                    1037   _I2C_byte_read:
080005E8  4E56 FFFC 1038          link      A6,#-4
080005EC  48E7 3820 1039          movem.l   D2/D3/D4/A2,-(A7)
080005F0  45F9 0800 1040          lea       _I2C_TX_command_status.L,A2
080005F4  04D4      
                    1041   ; char slave_addr_RW;
                    1042   ; unsigned char slave_read_data;
                    1043   ; unsigned char EEPROM_block_select;
                    1044   ; unsigned int addr;
                    1045   ; unsigned char EEPROM_internal_addr_H, EEPROM_internal_addr_L;
                    1046   ; printf("\r\nRandom EEPROM byte read");
080005F6  4879 0800 1047          pea       @m68kus~1_15.L
080005FA  1CA4      
080005FC  4EB9 0800 1048          jsr       _printf
08000600  115E      
08000602  584F      1049          addq.w    #4,A7
                    1050   ; // get the internal address
                    1051   ; addr = ask_EEPROM_internal_addr();
08000604  4EB9 0800 1052          jsr       _ask_EEPROM_internal_addr
08000608  0402      
0800060A  2600      1053          move.l    D0,D3
                    1054   ; EEPROM_internal_addr_H = (addr & 0x00ff00) >> 8;
0800060C  2003      1055          move.l    D3,D0
0800060E  C0BC 0000 1056          and.l     #65280,D0
08000612  FF00      
08000614  E088      1057          lsr.l     #8,D0
08000616  1D40 FFFE 1058          move.b    D0,-2(A6)
                    1059   ; EEPROM_internal_addr_L = addr & 0x0000ff;
0800061A  2003      1060          move.l    D3,D0
0800061C  C0BC 0000 1061          and.l     #255,D0
08000620  00FF      
08000622  1D40 FFFF 1062          move.b    D0,-1(A6)
                    1063   ; EEPROM_block_select = (addr & 0x010000) >> 16;
08000626  2003      1064          move.l    D3,D0
08000628  C0BC 0001 1065          and.l     #65536,D0
0800062C  0000      
0800062E  E088      1066          lsr.l     #8,D0
08000630  E088      1067          lsr.l     #8,D0
08000632  1800      1068          move.b    D0,D4
                    1069   ; // EEPROM tag (b'1010) + chip select ('b00) + block select + write (0)
                    1070   ; slave_addr_RW = (0xa0 | (EEPROM_block_select << 1));
08000634  303C 00A0 1071          move.w    #160,D0
08000638  1204      1072          move.b    D4,D1
0800063A  E309      1073          lsl.b     #1,D1
0800063C  C27C 00FF 1074          and.w     #255,D1
08000640  8041      1075          or.w      D1,D0
08000642  1400      1076          move.b    D0,D2
                    1077   ; // send the control byte and generate a start signal
                    1078   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
08000644  4878 0091 1079          pea       145
08000648  4882      1080          ext.w     D2
0800064A  48C2      1081          ext.l     D2
0800064C  2F02      1082          move.l    D2,-(A7)
0800064E  4E92      1083          jsr       (A2)
08000650  504F      1084          addq.w    #8,A7
                    1085   ; // write EEPROM internal addr (upper and lower byte), no start signal
                    1086   ; I2C_TX_command_status(EEPROM_internal_addr_H, write_cmd_I2C);
08000652  4878 0011 1087          pea       17
08000656  122E FFFE 1088          move.b    -2(A6),D1
0800065A  4881      1089          ext.w     D1
0800065C  48C1      1090          ext.l     D1
0800065E  2F01      1091          move.l    D1,-(A7)
08000660  4E92      1092          jsr       (A2)
08000662  504F      1093          addq.w    #8,A7
                    1094   ; I2C_TX_command_status(EEPROM_internal_addr_L, write_cmd_I2C);
08000664  4878 0011 1095          pea       17
08000668  122E FFFF 1096          move.b    -1(A6),D1
0800066C  4881      1097          ext.w     D1
0800066E  48C1      1098          ext.l     D1
08000670  2F01      1099          move.l    D1,-(A7)
08000672  4E92      1100          jsr       (A2)
08000674  504F      1101          addq.w    #8,A7
                    1102   ; // EEPROM tag (b'1010) + chip select ('b00) + block select + read (1)
                    1103   ; slave_addr_RW = (0xa1 | (EEPROM_block_select << 1));
08000676  303C 00A1 1104          move.w    #161,D0
0800067A  1204      1105          move.b    D4,D1
0800067C  E309      1106          lsl.b     #1,D1
0800067E  C27C 00FF 1107          and.w     #255,D1
08000682  8041      1108          or.w      D1,D0
08000684  1400      1109          move.b    D0,D2
                    1110   ; // send the control byte and generate a repeated start signal
                    1111   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
08000686  4878 0091 1112          pea       145
0800068A  4882      1113          ext.w     D2
0800068C  48C2      1114          ext.l     D2
0800068E  2F02      1115          move.l    D2,-(A7)
08000690  4E92      1116          jsr       (A2)
08000692  504F      1117          addq.w    #8,A7
                    1118   ; // set STO bit to 1, set RD bit to 1, set ACk to 1 (NACK), set IACK to 1
                    1119   ; I2C_command_reg = stop_read_NACK_cmd_I2C;
08000694  13FC 0069 1120          move.b    #105,4227080
08000698  0040 8008 
                    1121   ; // polling the IF flag in the status reg
                    1122   ; while ((I2C_status_reg & 0x01) != 1){}
                    1123   I2C_byte_read_1:
0800069C  1039 0040 1124          move.b    4227080,D0
080006A0  8008      
080006A2  C03C 0001 1125          and.b     #1,D0
080006A6  0C00 0001 1126          cmp.b     #1,D0
080006AA  6702      1127          beq.s     I2C_byte_read_3
080006AC  60EE      1128          bra       I2C_byte_read_1
                    1129   I2C_byte_read_3:
                    1130   ; slave_read_data = I2C_RX_reg;
080006AE  1D79 0040 1131          move.b    4227078,-3(A6)
080006B2  8006 FFFD 
                    1132   ; printf("\r\nEEPROM reading done! %x",slave_read_data);
080006B6  122E FFFD 1133          move.b    -3(A6),D1
080006BA  C2BC 0000 1134          and.l     #255,D1
080006BE  00FF      
080006C0  2F01      1135          move.l    D1,-(A7)
080006C2  4879 0800 1136          pea       @m68kus~1_16.L
080006C6  1CBE      
080006C8  4EB9 0800 1137          jsr       _printf
080006CC  115E      
080006CE  504F      1138          addq.w    #8,A7
080006D0  4CDF 041C 1139          movem.l   (A7)+,D2/D3/D4/A2
080006D4  4E5E      1140          unlk      A6
080006D6  4E75      1141          rts
                    1142   ; }
                    1143   ; unsigned int ask_EEPROM_addr_range(void) {
                    1144   _ask_EEPROM_addr_range:
080006D8  48E7 3020 1145          movem.l   D2/D3/A2,-(A7)
080006DC  45F9 0800 1146          lea       _printf.L,A2
080006E0  115E      
                    1147   ; unsigned int size;
                    1148   ; int valid = 0;
080006E2  4283      1149          clr.l     D3
                    1150   ; printf("\r\nWhat is the EEPROM address range size (in hex) you want to access? ");
080006E4  4879 0800 1151          pea       @m68kus~1_17.L
080006E8  1CD8      
080006EA  4E92      1152          jsr       (A2)
080006EC  584F      1153          addq.w    #4,A7
                    1154   ; while (!valid) {
                    1155   ask_EEPROM_addr_range_1:
080006EE  4A83      1156          tst.l     D3
080006F0  6600 0036 1157          bne       ask_EEPROM_addr_range_3
                    1158   ; size = Get6HexDigits(0);
080006F4  42A7      1159          clr.l     -(A7)
080006F6  4EB9 0800 1160          jsr       _Get6HexDigits
080006FA  0E44      
080006FC  584F      1161          addq.w    #4,A7
080006FE  2400      1162          move.l    D0,D2
                    1163   ; if (size > 0x020000) {
08000700  0C82 0002 1164          cmp.l     #131072,D2
08000704  0000      
08000706  630C      1165          bls.s     ask_EEPROM_addr_range_4
                    1166   ; printf ("\r\nSize cannot be larger than 'h020000 (128K bytes), input again: ");
08000708  4879 0800 1167          pea       @m68kus~1_18.L
0800070C  1D1E      
0800070E  4E92      1168          jsr       (A2)
08000710  584F      1169          addq.w    #4,A7
08000712  6012      1170          bra.s     ask_EEPROM_addr_range_7
                    1171   ask_EEPROM_addr_range_4:
                    1172   ; } else if (size == 0) {
08000714  4A82      1173          tst.l     D2
08000716  660C      1174          bne.s     ask_EEPROM_addr_range_6
                    1175   ; printf("\r\nSize cannot be 0, the minimum size is 'h000001 (1 byte), input again: ");
08000718  4879 0800 1176          pea       @m68kus~1_19.L
0800071C  1D60      
0800071E  4E92      1177          jsr       (A2)
08000720  584F      1178          addq.w    #4,A7
08000722  6002      1179          bra.s     ask_EEPROM_addr_range_7
                    1180   ask_EEPROM_addr_range_6:
                    1181   ; } else {
                    1182   ; valid = 1;
08000724  7601      1183          moveq     #1,D3
                    1184   ask_EEPROM_addr_range_7:
08000726  60C6      1185          bra       ask_EEPROM_addr_range_1
                    1186   ask_EEPROM_addr_range_3:
                    1187   ; }
                    1188   ; }
                    1189   ; return size;
08000728  2002      1190          move.l    D2,D0
0800072A  4CDF 040C 1191          movem.l   (A7)+,D2/D3/A2
0800072E  4E75      1192          rts
                    1193   ; }
                    1194   ; int boundry_checker (int intended_page_size, unsigned int current_addr) {
                    1195   _boundry_checker:
08000730  4E56 0000 1196          link      A6,#0
08000734  48E7 3800 1197          movem.l   D2/D3/D4,-(A7)
08000738  242E 000C 1198          move.l    12(A6),D2
                    1199   ; // check boundry crossing, return the appropriate number of bytes we should write in a page write (page_size)
                    1200   ; unsigned int new_addr;
                    1201   ; int page_size;
                    1202   ; // if we write the intended page size, what's the end address we're gonna be at?
                    1203   ; new_addr = current_addr + intended_page_size - 1;
0800073C  2002      1204          move.l    D2,D0
0800073E  D0AE 0008 1205          add.l     8(A6),D0
08000742  5380      1206          subq.l    #1,D0
08000744  2800      1207          move.l    D0,D4
                    1208   ; if (current_addr <= 0xffff && new_addr > 0xffff) {
08000746  0C82 0000 1209          cmp.l     #65535,D2
0800074A  FFFF      
0800074C  621A      1210          bhi.s     boundry_checker_1
0800074E  0C84 0000 1211          cmp.l     #65535,D4
08000752  FFFF      
08000754  6312      1212          bls.s     boundry_checker_1
                    1213   ; // cross the middle boundry
                    1214   ; page_size = 0xffff - current_addr + 1;
08000756  303C FFFF 1215          move.w    #65535,D0
0800075A  C0BC 0000 1216          and.l     #65535,D0
0800075E  FFFF      
08000760  9082      1217          sub.l     D2,D0
08000762  5280      1218          addq.l    #1,D0
08000764  2600      1219          move.l    D0,D3
08000766  6022      1220          bra.s     boundry_checker_4
                    1221   boundry_checker_1:
                    1222   ; } else if (current_addr <= 0x1ffff && new_addr > 0x1ffff) {
08000768  0C82 0001 1223          cmp.l     #131071,D2
0800076C  FFFF      
0800076E  6216      1224          bhi.s     boundry_checker_3
08000770  0C84 0001 1225          cmp.l     #131071,D4
08000774  FFFF      
08000776  630E      1226          bls.s     boundry_checker_3
                    1227   ; // cross the end boundry
                    1228   ; page_size = 0x1ffff - current_addr + 1;
08000778  203C 0001 1229          move.l    #131071,D0
0800077C  FFFF      
0800077E  9082      1230          sub.l     D2,D0
08000780  5280      1231          addq.l    #1,D0
08000782  2600      1232          move.l    D0,D3
08000784  6004      1233          bra.s     boundry_checker_4
                    1234   boundry_checker_3:
                    1235   ; } else {
                    1236   ; page_size = intended_page_size;
08000786  262E 0008 1237          move.l    8(A6),D3
                    1238   boundry_checker_4:
                    1239   ; }
                    1240   ; return page_size;
0800078A  2003      1241          move.l    D3,D0
0800078C  4CDF 001C 1242          movem.l   (A7)+,D2/D3/D4
08000790  4E5E      1243          unlk      A6
08000792  4E75      1244          rts
                    1245   ; }
                    1246   ; void I2C_multi_write (void) {
                    1247   _I2C_multi_write:
08000794  4E56 FFF8 1248          link      A6,#-8
08000798  48E7 3F30 1249          movem.l   D2/D3/D4/D5/D6/D7/A2/A3,-(A7)
0800079C  45F9 0800 1250          lea       _I2C_TX_command_status.L,A2
080007A0  04D4      
080007A2  47F9 0800 1251          lea       _printf.L,A3
080007A6  115E      
                    1252   ; unsigned int size, addr, page_index;
                    1253   ; unsigned char slave_addr_RW;
                    1254   ; unsigned char EEPROM_block_select, EEPROM_internal_addr_H, EEPROM_internal_addr_L;
                    1255   ; char command;
                    1256   ; int page_size;
                    1257   ; int page_limit = 128;
080007A8  2C3C 0000 1258          move.l    #128,D6
080007AC  0080      
                    1259   ; unsigned char write_data = 0;
080007AE  422E FFFF 1260          clr.b     -1(A6)
                    1261   ; printf("\r\nMultipe bytes EEPROM write");
080007B2  4879 0800 1262          pea       @m68kus~1_20.L
080007B6  1DAA      
080007B8  4E93      1263          jsr       (A3)
080007BA  584F      1264          addq.w    #4,A7
                    1265   ; // ask the range of the writting
                    1266   ; size = ask_EEPROM_addr_range();
080007BC  4EB9 0800 1267          jsr       _ask_EEPROM_addr_range
080007C0  06D8      
080007C2  2800      1268          move.l    D0,D4
                    1269   ; // ask the start address
                    1270   ; addr = ask_EEPROM_internal_addr();
080007C4  4EB9 0800 1271          jsr       _ask_EEPROM_internal_addr
080007C8  0402      
080007CA  2400      1272          move.l    D0,D2
                    1273   ; printf("\r\nWritting...");
080007CC  4879 0800 1274          pea       @m68kus~1_21.L
080007D0  1DC8      
080007D2  4E93      1275          jsr       (A3)
080007D4  584F      1276          addq.w    #4,A7
                    1277   ; while (size > 0){
                    1278   I2C_multi_write_1:
080007D6  0C84 0000 1279          cmp.l     #0,D4
080007DA  0000      
080007DC  6300 00EA 1280          bls       I2C_multi_write_3
                    1281   ; command = write_cmd_I2C;
080007E0  1D7C 0011 1282          move.b    #17,-2(A6)
080007E4  FFFE      
                    1283   ; if (size <= page_limit) {
080007E6  B886      1284          cmp.l     D6,D4
080007E8  6210      1285          bhi.s     I2C_multi_write_4
                    1286   ; page_size = boundry_checker(size, addr);
080007EA  2F02      1287          move.l    D2,-(A7)
080007EC  2F04      1288          move.l    D4,-(A7)
080007EE  4EB9 0800 1289          jsr       _boundry_checker
080007F2  0730      
080007F4  504F      1290          addq.w    #8,A7
080007F6  2600      1291          move.l    D0,D3
080007F8  6012      1292          bra.s     I2C_multi_write_6
                    1293   I2C_multi_write_4:
                    1294   ; } else if (size > page_limit) {
080007FA  B886      1295          cmp.l     D6,D4
080007FC  630E      1296          bls.s     I2C_multi_write_6
                    1297   ; page_size = boundry_checker(page_limit, addr);
080007FE  2F02      1298          move.l    D2,-(A7)
08000800  2F06      1299          move.l    D6,-(A7)
08000802  4EB9 0800 1300          jsr       _boundry_checker
08000806  0730      
08000808  504F      1301          addq.w    #8,A7
0800080A  2600      1302          move.l    D0,D3
                    1303   I2C_multi_write_6:
                    1304   ; }
                    1305   ; EEPROM_internal_addr_H = (addr & 0x00ff00) >> 8;
0800080C  2002      1306          move.l    D2,D0
0800080E  C0BC 0000 1307          and.l     #65280,D0
08000812  FF00      
08000814  E088      1308          lsr.l     #8,D0
08000816  1D40 FFFC 1309          move.b    D0,-4(A6)
                    1310   ; EEPROM_internal_addr_L = addr & 0x0000ff;
0800081A  2002      1311          move.l    D2,D0
0800081C  C0BC 0000 1312          and.l     #255,D0
08000820  00FF      
08000822  1D40 FFFD 1313          move.b    D0,-3(A6)
                    1314   ; EEPROM_block_select = (addr & 0x010000) >> 16;
08000826  2002      1315          move.l    D2,D0
08000828  C0BC 0001 1316          and.l     #65536,D0
0800082C  0000      
0800082E  E088      1317          lsr.l     #8,D0
08000830  E088      1318          lsr.l     #8,D0
08000832  1D40 FFFB 1319          move.b    D0,-5(A6)
                    1320   ; // EEPROM tag (b'1010) + chip select ('b00) + block select + write (0)
                    1321   ; slave_addr_RW = (0xa0 | (EEPROM_block_select << 1));
08000836  303C 00A0 1322          move.w    #160,D0
0800083A  122E FFFB 1323          move.b    -5(A6),D1
0800083E  E309      1324          lsl.b     #1,D1
08000840  C27C 00FF 1325          and.w     #255,D1
08000844  8041      1326          or.w      D1,D0
08000846  1E00      1327          move.b    D0,D7
                    1328   ; // send the control byte and generate a start signal
                    1329   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
08000848  4878 0091 1330          pea       145
0800084C  4887      1331          ext.w     D7
0800084E  48C7      1332          ext.l     D7
08000850  2F07      1333          move.l    D7,-(A7)
08000852  4E92      1334          jsr       (A2)
08000854  504F      1335          addq.w    #8,A7
                    1336   ; // write EEPROM internal addr (upper and lower byte), no start signal
                    1337   ; I2C_TX_command_status(EEPROM_internal_addr_H, write_cmd_I2C);
08000856  4878 0011 1338          pea       17
0800085A  122E FFFC 1339          move.b    -4(A6),D1
0800085E  4881      1340          ext.w     D1
08000860  48C1      1341          ext.l     D1
08000862  2F01      1342          move.l    D1,-(A7)
08000864  4E92      1343          jsr       (A2)
08000866  504F      1344          addq.w    #8,A7
                    1345   ; I2C_TX_command_status(EEPROM_internal_addr_L, write_cmd_I2C);
08000868  4878 0011 1346          pea       17
0800086C  122E FFFD 1347          move.b    -3(A6),D1
08000870  4881      1348          ext.w     D1
08000872  48C1      1349          ext.l     D1
08000874  2F01      1350          move.l    D1,-(A7)
08000876  4E92      1351          jsr       (A2)
08000878  504F      1352          addq.w    #8,A7
                    1353   ; for (page_index = 0; page_index < page_size; page_index++) {
0800087A  4285      1354          clr.l     D5
                    1355   I2C_multi_write_8:
0800087C  BA83      1356          cmp.l     D3,D5
0800087E  6400 0030 1357          bhs       I2C_multi_write_10
                    1358   ; // write the actual data (128 bytes), generate a stop signal at the 128th byte
                    1359   ; if (page_index == page_size - 1) {
08000882  2003      1360          move.l    D3,D0
08000884  5380      1361          subq.l    #1,D0
08000886  BA80      1362          cmp.l     D0,D5
08000888  6606      1363          bne.s     I2C_multi_write_11
                    1364   ; command = stop_write_cmd_I2C;
0800088A  1D7C 0051 1365          move.b    #81,-2(A6)
0800088E  FFFE      
                    1366   I2C_multi_write_11:
                    1367   ; }
                    1368   ; I2C_TX_command_status(write_data, command);
08000890  122E FFFE 1369          move.b    -2(A6),D1
08000894  4881      1370          ext.w     D1
08000896  48C1      1371          ext.l     D1
08000898  2F01      1372          move.l    D1,-(A7)
0800089A  122E FFFF 1373          move.b    -1(A6),D1
0800089E  4881      1374          ext.w     D1
080008A0  48C1      1375          ext.l     D1
080008A2  2F01      1376          move.l    D1,-(A7)
080008A4  4E92      1377          jsr       (A2)
080008A6  504F      1378          addq.w    #8,A7
                    1379   ; write_data ++;
080008A8  522E FFFF 1380          addq.b    #1,-1(A6)
080008AC  5285      1381          addq.l    #1,D5
080008AE  60CC      1382          bra       I2C_multi_write_8
                    1383   I2C_multi_write_10:
                    1384   ; }
                    1385   ; EEPROM_internal_writting_polling(slave_addr_RW);
080008B0  CEBC 0000 1386          and.l     #255,D7
080008B4  00FF      
080008B6  2F07      1387          move.l    D7,-(A7)
080008B8  4EB9 0800 1388          jsr       _EEPROM_internal_writting_pollin
080008BC  0472      
080008BE  584F      1389          addq.w    #4,A7
                    1390   ; addr = addr + page_size;
080008C0  D483      1391          add.l     D3,D2
                    1392   ; size = size - page_size;
080008C2  9883      1393          sub.l     D3,D4
080008C4  6000 FF10 1394          bra       I2C_multi_write_1
                    1395   I2C_multi_write_3:
                    1396   ; // refresh the writting command to exclude stop signal
                    1397   ; }
                    1398   ; printf("\r\nMultiple bytes writting done");
080008C8  4879 0800 1399          pea       @m68kus~1_22.L
080008CC  1DD6      
080008CE  4E93      1400          jsr       (A3)
080008D0  584F      1401          addq.w    #4,A7
080008D2  4CDF 0CFC 1402          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3
080008D6  4E5E      1403          unlk      A6
080008D8  4E75      1404          rts
                    1405   ; }
                    1406   ; void I2C_multi_read (void) {
                    1407   _I2C_multi_read:
080008DA  4E56 FFF8 1408          link      A6,#-8
080008DE  48E7 3F30 1409          movem.l   D2/D3/D4/D5/D6/D7/A2/A3,-(A7)
080008E2  45F9 0800 1410          lea       _I2C_TX_command_status.L,A2
080008E6  04D4      
                    1411   ; unsigned int size, addr, page_index;
                    1412   ; unsigned char slave_addr_RW;
                    1413   ; unsigned char EEPROM_block_select, EEPROM_internal_addr_H, EEPROM_internal_addr_L;
                    1414   ; char command;
                    1415   ; int page_size;
                    1416   ; unsigned char read_data;
                    1417   ; unsigned int counter = 0;
080008E8  7E00      1418          moveq     #0,D7
                    1419   ; unsigned printing_step_size = 1;
080008EA  367C 0001 1420          move.w    #1,A3
                    1421   ; printf("\r\nMultiple bytes EEPROM read");
080008EE  4879 0800 1422          pea       @m68kus~1_23.L
080008F2  1DF6      
080008F4  4EB9 0800 1423          jsr       _printf
080008F8  115E      
080008FA  584F      1424          addq.w    #4,A7
                    1425   ; // ask the range of the writting
                    1426   ; size = ask_EEPROM_addr_range();
080008FC  4EB9 0800 1427          jsr       _ask_EEPROM_addr_range
08000900  06D8      
08000902  2600      1428          move.l    D0,D3
                    1429   ; // ask the start address
                    1430   ; addr = ask_EEPROM_internal_addr();
08000904  4EB9 0800 1431          jsr       _ask_EEPROM_internal_addr
08000908  0402      
0800090A  2400      1432          move.l    D0,D2
                    1433   ; // if we have more than 10 items to read, we only print out 10 lines.
                    1434   ; if (size > 10){
0800090C  0C83 0000 1435          cmp.l     #10,D3
08000910  000A      
08000912  6312      1436          bls.s     I2C_multi_read_1
                    1437   ; printing_step_size = size/10;
08000914  2F03      1438          move.l    D3,-(A7)
08000916  4878 000A 1439          pea       10
0800091A  4EB9 0800 1440          jsr       ULDIV
0800091E  1080      
08000920  2017      1441          move.l    (A7),D0
08000922  504F      1442          addq.w    #8,A7
08000924  2640      1443          move.l    D0,A3
                    1444   I2C_multi_read_1:
                    1445   ; }
                    1446   ; while (size > 0){
                    1447   I2C_multi_read_3:
08000926  0C83 0000 1448          cmp.l     #0,D3
0800092A  0000      
0800092C  6300 0124 1449          bls       I2C_multi_read_5
                    1450   ; command = read_ACK_cmd_I2C;
08000930  1D7C 0021 1451          move.b    #33,-2(A6)
08000934  FFFE      
                    1452   ; page_size = boundry_checker(size, addr);
08000936  2F02      1453          move.l    D2,-(A7)
08000938  2F03      1454          move.l    D3,-(A7)
0800093A  4EB9 0800 1455          jsr       _boundry_checker
0800093E  0730      
08000940  504F      1456          addq.w    #8,A7
08000942  2800      1457          move.l    D0,D4
                    1458   ; EEPROM_internal_addr_H = (addr & 0x00ff00) >> 8;
08000944  2002      1459          move.l    D2,D0
08000946  C0BC 0000 1460          and.l     #65280,D0
0800094A  FF00      
0800094C  E088      1461          lsr.l     #8,D0
0800094E  1D40 FFFC 1462          move.b    D0,-4(A6)
                    1463   ; EEPROM_internal_addr_L = addr & 0x0000ff;
08000952  2002      1464          move.l    D2,D0
08000954  C0BC 0000 1465          and.l     #255,D0
08000958  00FF      
0800095A  1D40 FFFD 1466          move.b    D0,-3(A6)
                    1467   ; EEPROM_block_select = (addr & 0x010000) >> 16;
0800095E  2002      1468          move.l    D2,D0
08000960  C0BC 0001 1469          and.l     #65536,D0
08000964  0000      
08000966  E088      1470          lsr.l     #8,D0
08000968  E088      1471          lsr.l     #8,D0
0800096A  1D40 FFFB 1472          move.b    D0,-5(A6)
                    1473   ; // EEPROM tag (b'1010) + chip select ('b00) + block select + write (0)
                    1474   ; slave_addr_RW = (0xa0 | (EEPROM_block_select << 1));
0800096E  303C 00A0 1475          move.w    #160,D0
08000972  122E FFFB 1476          move.b    -5(A6),D1
08000976  E309      1477          lsl.b     #1,D1
08000978  C27C 00FF 1478          and.w     #255,D1
0800097C  8041      1479          or.w      D1,D0
0800097E  1C00      1480          move.b    D0,D6
                    1481   ; // send the control byte and generate a start signal
                    1482   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
08000980  4878 0091 1483          pea       145
08000984  4886      1484          ext.w     D6
08000986  48C6      1485          ext.l     D6
08000988  2F06      1486          move.l    D6,-(A7)
0800098A  4E92      1487          jsr       (A2)
0800098C  504F      1488          addq.w    #8,A7
                    1489   ; // write EEPROM internal addr (upper and lower byte), no start signal
                    1490   ; I2C_TX_command_status(EEPROM_internal_addr_H, write_cmd_I2C);
0800098E  4878 0011 1491          pea       17
08000992  122E FFFC 1492          move.b    -4(A6),D1
08000996  4881      1493          ext.w     D1
08000998  48C1      1494          ext.l     D1
0800099A  2F01      1495          move.l    D1,-(A7)
0800099C  4E92      1496          jsr       (A2)
0800099E  504F      1497          addq.w    #8,A7
                    1498   ; I2C_TX_command_status(EEPROM_internal_addr_L, write_cmd_I2C);
080009A0  4878 0011 1499          pea       17
080009A4  122E FFFD 1500          move.b    -3(A6),D1
080009A8  4881      1501          ext.w     D1
080009AA  48C1      1502          ext.l     D1
080009AC  2F01      1503          move.l    D1,-(A7)
080009AE  4E92      1504          jsr       (A2)
080009B0  504F      1505          addq.w    #8,A7
                    1506   ; // EEPROM tag (b'1010) + chip select ('b00) + block select + read (1)
                    1507   ; slave_addr_RW = (0xa1 | (EEPROM_block_select << 1));
080009B2  303C 00A1 1508          move.w    #161,D0
080009B6  122E FFFB 1509          move.b    -5(A6),D1
080009BA  E309      1510          lsl.b     #1,D1
080009BC  C27C 00FF 1511          and.w     #255,D1
080009C0  8041      1512          or.w      D1,D0
080009C2  1C00      1513          move.b    D0,D6
                    1514   ; // send the control byte and generate a repeated start signal
                    1515   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
080009C4  4878 0091 1516          pea       145
080009C8  4886      1517          ext.w     D6
080009CA  48C6      1518          ext.l     D6
080009CC  2F06      1519          move.l    D6,-(A7)
080009CE  4E92      1520          jsr       (A2)
080009D0  504F      1521          addq.w    #8,A7
                    1522   ; for (page_index = 0; page_index < page_size; page_index++) {
080009D2  4285      1523          clr.l     D5
                    1524   I2C_multi_read_6:
080009D4  BA84      1525          cmp.l     D4,D5
080009D6  6400 0072 1526          bhs       I2C_multi_read_8
                    1527   ; if (page_index == page_size - 1) {
080009DA  2004      1528          move.l    D4,D0
080009DC  5380      1529          subq.l    #1,D0
080009DE  BA80      1530          cmp.l     D0,D5
080009E0  6606      1531          bne.s     I2C_multi_read_9
                    1532   ; command = stop_read_NACK_cmd_I2C;
080009E2  1D7C 0069 1533          move.b    #105,-2(A6)
080009E6  FFFE      
                    1534   I2C_multi_read_9:
                    1535   ; }
                    1536   ; I2C_command_reg = command;
080009E8  13EE FFFE 1537          move.b    -2(A6),4227080
080009EC  0040 8008 
                    1538   ; // polling the IF flag in the status reg
                    1539   ; while ((I2C_status_reg & 0x01) != 1){}
                    1540   I2C_multi_read_11:
080009F0  1039 0040 1541          move.b    4227080,D0
080009F4  8008      
080009F6  C03C 0001 1542          and.b     #1,D0
080009FA  0C00 0001 1543          cmp.b     #1,D0
080009FE  6702      1544          beq.s     I2C_multi_read_13
08000A00  60EE      1545          bra       I2C_multi_read_11
                    1546   I2C_multi_read_13:
                    1547   ; if (counter % printing_step_size == 0){
08000A02  2F07      1548          move.l    D7,-(A7)
08000A04  2F0B      1549          move.l    A3,-(A7)
08000A06  4EB9 0800 1550          jsr       ULDIV
08000A0A  1080      
08000A0C  202F 0004 1551          move.l    4(A7),D0
08000A10  504F      1552          addq.w    #8,A7
08000A12  4A80      1553          tst.l     D0
08000A14  662E      1554          bne.s     I2C_multi_read_14
                    1555   ; read_data = I2C_RX_reg;
08000A16  1D79 0040 1556          move.b    4227078,-1(A6)
08000A1A  8006 FFFF 
                    1557   ; printf("\r\nAddress: %x, Read data: %x",counter & 0x01ffff, read_data);
08000A1E  122E FFFF 1558          move.b    -1(A6),D1
08000A22  C2BC 0000 1559          and.l     #255,D1
08000A26  00FF      
08000A28  2F01      1560          move.l    D1,-(A7)
08000A2A  2207      1561          move.l    D7,D1
08000A2C  C2BC 0001 1562          and.l     #131071,D1
08000A30  FFFF      
08000A32  2F01      1563          move.l    D1,-(A7)
08000A34  4879 0800 1564          pea       @m68kus~1_24.L
08000A38  1E14      
08000A3A  4EB9 0800 1565          jsr       _printf
08000A3E  115E      
08000A40  DEFC 000C 1566          add.w     #12,A7
                    1567   I2C_multi_read_14:
                    1568   ; }
                    1569   ; counter ++;
08000A44  5287      1570          addq.l    #1,D7
08000A46  5285      1571          addq.l    #1,D5
08000A48  608A      1572          bra       I2C_multi_read_6
                    1573   I2C_multi_read_8:
                    1574   ; }
                    1575   ; addr = addr + page_size;
08000A4A  D484      1576          add.l     D4,D2
                    1577   ; size = size - page_size;        
08000A4C  9684      1578          sub.l     D4,D3
08000A4E  6000 FED6 1579          bra       I2C_multi_read_3
                    1580   I2C_multi_read_5:
08000A52  4CDF 0CFC 1581          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3
08000A56  4E5E      1582          unlk      A6
08000A58  4E75      1583          rts
                    1584   ; }
                    1585   ; }
                    1586   ; void DAC(void) {
                    1587   _DAC:
08000A5A  4E56 FFFC 1588          link      A6,#-4
08000A5E  48E7 2020 1589          movem.l   D2/A2,-(A7)
08000A62  45F9 0800 1590          lea       _I2C_TX_command_status.L,A2
08000A66  04D4      
                    1591   ; unsigned char slave_addr_RW;
                    1592   ; unsigned char control_byte;
                    1593   ; unsigned char command = write_cmd_I2C;
08000A68  7411      1594          moveq     #17,D2
                    1595   ; printf("\r\nUsing DAC to control LED");
08000A6A  4879 0800 1596          pea       @m68kus~1_25.L
08000A6E  1E32      
08000A70  4EB9 0800 1597          jsr       _printf
08000A74  115E      
08000A76  584F      1598          addq.w    #4,A7
                    1599   ; // PCF8591 tag (b'1001) + chip select (b'000) + write (0)
                    1600   ; slave_addr_RW = 0x90;
08000A78  1D7C 0090 1601          move.b    #144,-2(A6)
08000A7C  FFFE      
                    1602   ; // only enable the analog bit
                    1603   ; control_byte = 0x40;
08000A7E  1D7C 0040 1604          move.b    #64,-1(A6)
08000A82  FFFF      
                    1605   ; // send the slave address byte and generate a start signal
                    1606   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
08000A84  4878 0091 1607          pea       145
08000A88  122E FFFE 1608          move.b    -2(A6),D1
08000A8C  4881      1609          ext.w     D1
08000A8E  48C1      1610          ext.l     D1
08000A90  2F01      1611          move.l    D1,-(A7)
08000A92  4E92      1612          jsr       (A2)
08000A94  504F      1613          addq.w    #8,A7
                    1614   ; //printf("\r\nslave address sent");
                    1615   ; // send the control byte to PCF8591
                    1616   ; I2C_TX_command_status(control_byte, write_cmd_I2C);
08000A96  4878 0011 1617          pea       17
08000A9A  122E FFFF 1618          move.b    -1(A6),D1
08000A9E  4881      1619          ext.w     D1
08000AA0  48C1      1620          ext.l     D1
08000AA2  2F01      1621          move.l    D1,-(A7)
08000AA4  4E92      1622          jsr       (A2)
08000AA6  504F      1623          addq.w    #8,A7
                    1624   ; //printf("\r\ncontrol byte sent");
                    1625   ; /*
                    1626   ; for (i = 0; i <2560; i++) {
                    1627   ; // keep writting digital signal
                    1628   ; if (i == 2559) {
                    1629   ; // generate a stop signal at the last byte
                    1630   ; command = stop_write_cmd_I2C;
                    1631   ; }
                    1632   ; I2C_TX_command_status(digital_write_data, command);
                    1633   ; digital_write_data ++;
                    1634   ; }
                    1635   ; */
                    1636   ; while (1){
                    1637   DAC_1:
                    1638   ; I2C_TX_command_status(0xff,command);
08000AA8  4882      1639          ext.w     D2
08000AAA  48C2      1640          ext.l     D2
08000AAC  2F02      1641          move.l    D2,-(A7)
08000AAE  4878 00FF 1642          pea       255
08000AB2  4E92      1643          jsr       (A2)
08000AB4  504F      1644          addq.w    #8,A7
                    1645   ; Wait500ms ();
08000AB6  4EB9 0800 1646          jsr       _Wait500ms
08000ABA  0CA4      
                    1647   ; I2C_TX_command_status(0x00,command);
08000ABC  4882      1648          ext.w     D2
08000ABE  48C2      1649          ext.l     D2
08000AC0  2F02      1650          move.l    D2,-(A7)
08000AC2  42A7      1651          clr.l     -(A7)
08000AC4  4E92      1652          jsr       (A2)
08000AC6  504F      1653          addq.w    #8,A7
                    1654   ; Wait500ms ();
08000AC8  4EB9 0800 1655          jsr       _Wait500ms
08000ACC  0CA4      
08000ACE  60D8      1656          bra       DAC_1
                    1657   ; }
                    1658   ; }
                    1659   ; void ADC(void) {
                    1660   _ADC:
08000AD0  4E56 FFFC 1661          link      A6,#-4
08000AD4  48E7 2020 1662          movem.l   D2/A2,-(A7)
08000AD8  45F9 0800 1663          lea       _I2C_TX_command_status.L,A2
08000ADC  04D4      
                    1664   ; unsigned char slave_addr_RW;
                    1665   ; unsigned char control_byte;
                    1666   ; unsigned char command = read_ACK_cmd_I2C;
08000ADE  1D7C 0021 1667          move.b    #33,-2(A6)
08000AE2  FFFE      
                    1668   ; unsigned char read_data;
                    1669   ; printf("\r\nReading values from the ADC");
08000AE4  4879 0800 1670          pea       @m68kus~1_26.L
08000AE8  1E4E      
08000AEA  4EB9 0800 1671          jsr       _printf
08000AEE  115E      
08000AF0  584F      1672          addq.w    #4,A7
                    1673   ; // PCF8591 tag (b'1001) + chip select (b'000) + write (0)
                    1674   ; slave_addr_RW = 0x90;
08000AF2  143C 0090 1675          move.b    #144,D2
                    1676   ; // generate the control byte based on the channel user selected
                    1677   ; control_byte = ask_ADC_channel();
08000AF6  4EB9 0800 1678          jsr       _ask_ADC_channel
08000AFA  0B70      
08000AFC  1D40 FFFD 1679          move.b    D0,-3(A6)
                    1680   ; // send the slave address byte and generate a start signal
                    1681   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
08000B00  4878 0091 1682          pea       145
08000B04  4882      1683          ext.w     D2
08000B06  48C2      1684          ext.l     D2
08000B08  2F02      1685          move.l    D2,-(A7)
08000B0A  4E92      1686          jsr       (A2)
08000B0C  504F      1687          addq.w    #8,A7
                    1688   ; // send the control byte to PCF8591
                    1689   ; I2C_TX_command_status(control_byte, write_cmd_I2C);
08000B0E  4878 0011 1690          pea       17
08000B12  122E FFFD 1691          move.b    -3(A6),D1
08000B16  4881      1692          ext.w     D1
08000B18  48C1      1693          ext.l     D1
08000B1A  2F01      1694          move.l    D1,-(A7)
08000B1C  4E92      1695          jsr       (A2)
08000B1E  504F      1696          addq.w    #8,A7
                    1697   ; // PCF8591 tag (b'1001) + chip select (b'000) + read (1)
                    1698   ; slave_addr_RW = 0x91;
08000B20  143C 0091 1699          move.b    #145,D2
                    1700   ; // repeated start
                    1701   ; I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
08000B24  4878 0091 1702          pea       145
08000B28  4882      1703          ext.w     D2
08000B2A  48C2      1704          ext.l     D2
08000B2C  2F02      1705          move.l    D2,-(A7)
08000B2E  4E92      1706          jsr       (A2)
08000B30  504F      1707          addq.w    #8,A7
                    1708   ; // send the slave address byte and generate a repeated start signal
                    1709   ; //I2C_TX_command_status(slave_addr_RW, start_write_cmd_I2C);
                    1710   ; while (1) {
                    1711   ADC_1:
                    1712   ; I2C_command_reg = command;
08000B32  13EE FFFE 1713          move.b    -2(A6),4227080
08000B36  0040 8008 
                    1714   ; // polling the IF flag in the status reg
                    1715   ; while ((I2C_status_reg & 0x01) != 1){}
                    1716   ADC_4:
08000B3A  1039 0040 1717          move.b    4227080,D0
08000B3E  8008      
08000B40  C03C 0001 1718          and.b     #1,D0
08000B44  0C00 0001 1719          cmp.b     #1,D0
08000B48  6702      1720          beq.s     ADC_6
08000B4A  60EE      1721          bra       ADC_4
                    1722   ADC_6:
                    1723   ; read_data = I2C_RX_reg;
08000B4C  1D79 0040 1724          move.b    4227078,-1(A6)
08000B50  8006 FFFF 
                    1725   ; printf("\r\nRead data: %x", read_data);
08000B54  122E FFFF 1726          move.b    -1(A6),D1
08000B58  C2BC 0000 1727          and.l     #255,D1
08000B5C  00FF      
08000B5E  2F01      1728          move.l    D1,-(A7)
08000B60  4879 0800 1729          pea       @m68kus~1_27.L
08000B64  1E6C      
08000B66  4EB9 0800 1730          jsr       _printf
08000B6A  115E      
08000B6C  504F      1731          addq.w    #8,A7
08000B6E  60C2      1732          bra       ADC_1
                    1733   ; }
                    1734   ; }
                    1735   ; unsigned char ask_ADC_channel (void){
                    1736   _ask_ADC_channel:
08000B70  48E7 3800 1737          movem.l   D2/D3/D4,-(A7)
                    1738   ; unsigned char channel;
                    1739   ; unsigned char control_byte;
                    1740   ; int valid = 0;
08000B74  4282      1741          clr.l     D2
                    1742   ; while (!valid){
                    1743   ask_ADC_channel_1:
08000B76  4A82      1744          tst.l     D2
08000B78  6600 0052 1745          bne       ask_ADC_channel_3
                    1746   ; printf("\r\nWhich channel you want to read? 1. Potentiometer 2.Photoresistor 3.Thermistor ");
08000B7C  4879 0800 1747          pea       @m68kus~1_28.L
08000B80  1E7C      
08000B82  4EB9 0800 1748          jsr       _printf
08000B86  115E      
08000B88  584F      1749          addq.w    #4,A7
                    1750   ; channel = Get1HexDigits(0);
08000B8A  42A7      1751          clr.l     -(A7)
08000B8C  4EB9 0800 1752          jsr       _Get1HexDigits
08000B90  0D86      
08000B92  584F      1753          addq.w    #4,A7
08000B94  1800      1754          move.b    D0,D4
                    1755   ; if (channel == 1) {
08000B96  0C04 0001 1756          cmp.b     #1,D4
08000B9A  6606      1757          bne.s     ask_ADC_channel_4
                    1758   ; control_byte = 0x01;
08000B9C  7601      1759          moveq     #1,D3
                    1760   ; valid = 1;
08000B9E  7401      1761          moveq     #1,D2
08000BA0  6028      1762          bra.s     ask_ADC_channel_9
                    1763   ask_ADC_channel_4:
                    1764   ; } else if (channel == 2) {
08000BA2  0C04 0002 1765          cmp.b     #2,D4
08000BA6  6606      1766          bne.s     ask_ADC_channel_6
                    1767   ; control_byte = 0x02;
08000BA8  7602      1768          moveq     #2,D3
                    1769   ; valid = 1;
08000BAA  7401      1770          moveq     #1,D2
08000BAC  601C      1771          bra.s     ask_ADC_channel_9
                    1772   ask_ADC_channel_6:
                    1773   ; } else if (channel == 3) {
08000BAE  0C04 0003 1774          cmp.b     #3,D4
08000BB2  6606      1775          bne.s     ask_ADC_channel_8
                    1776   ; control_byte = 0x03;
08000BB4  7603      1777          moveq     #3,D3
                    1778   ; valid = 1;
08000BB6  7401      1779          moveq     #1,D2
08000BB8  6010      1780          bra.s     ask_ADC_channel_9
                    1781   ask_ADC_channel_8:
                    1782   ; } else {
                    1783   ; printf("\r\nInvalid selection!");
08000BBA  4879 0800 1784          pea       @m68kus~1_29.L
08000BBE  1ECE      
08000BC0  4EB9 0800 1785          jsr       _printf
08000BC4  115E      
08000BC6  584F      1786          addq.w    #4,A7
                    1787   ; valid = 0;
08000BC8  4282      1788          clr.l     D2
                    1789   ask_ADC_channel_9:
08000BCA  60AA      1790          bra       ask_ADC_channel_1
                    1791   ask_ADC_channel_3:
                    1792   ; }
                    1793   ; }
                    1794   ; return control_byte;
08000BCC  1003      1795          move.b    D3,D0
08000BCE  4CDF 001C 1796          movem.l   (A7)+,D2/D3/D4
08000BD2  4E75      1797          rts
                    1798   ; }
                    1799   ; /*****************************************************************************************
                    1800   ; **	Interrupt service routine for Timers
                    1801   ; **
                    1802   ; **  Timers 1 - 4 share a common IRQ on the CPU  so this function uses polling to figure
                    1803   ; **  out which timer is producing the interrupt
                    1804   ; **
                    1805   ; *****************************************************************************************/
                    1806   ; void Timer_ISR()
                    1807   ; {
                    1808   _Timer_ISR:
                    1809   ; if(Timer1Status == 1) {         // Did Timer 1 produce the Interrupt?
08000BD4  1039 0040 1810          move.b    4194354,D0
08000BD8  0032      
08000BDA  0C00 0001 1811          cmp.b     #1,D0
08000BDE  661A      1812          bne.s     Timer_ISR_1
                    1813   ; Timer1Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
08000BE0  13FC 0003 1814          move.b    #3,4194354
08000BE4  0040 0032 
                    1815   ; PortA = Timer1Count++ ;     // increment an LED count on PortA with each tick of Timer 1
08000BE8  1039 0800 1816          move.b    _Timer1Count.L,D0
08000BEC  2012      
08000BEE  5239 0800 1817          addq.b    #1,_Timer1Count.L
08000BF2  2012      
08000BF4  13C0 0040 1818          move.b    D0,4194304
08000BF8  0000      
                    1819   Timer_ISR_1:
                    1820   ; }
                    1821   ; if(Timer2Status == 1) {         // Did Timer 2 produce the Interrupt?
08000BFA  1039 0040 1822          move.b    4194358,D0
08000BFE  0036      
08000C00  0C00 0001 1823          cmp.b     #1,D0
08000C04  661A      1824          bne.s     Timer_ISR_3
                    1825   ; Timer2Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
08000C06  13FC 0003 1826          move.b    #3,4194358
08000C0A  0040 0036 
                    1827   ; PortC = Timer2Count++ ;     // increment an LED count on PortC with each tick of Timer 2
08000C0E  1039 0800 1828          move.b    _Timer2Count.L,D0
08000C12  2014      
08000C14  5239 0800 1829          addq.b    #1,_Timer2Count.L
08000C18  2014      
08000C1A  13C0 0040 1830          move.b    D0,4194308
08000C1E  0004      
                    1831   Timer_ISR_3:
                    1832   ; }
                    1833   ; if(Timer3Status == 1) {         // Did Timer 3 produce the Interrupt?
08000C20  1039 0040 1834          move.b    4194362,D0
08000C24  003A      
08000C26  0C00 0001 1835          cmp.b     #1,D0
08000C2A  661A      1836          bne.s     Timer_ISR_5
                    1837   ; Timer3Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
08000C2C  13FC 0003 1838          move.b    #3,4194362
08000C30  0040 003A 
                    1839   ; HEX_A = Timer3Count++ ;     // increment a HEX count on Port HEX_A with each tick of Timer 3
08000C34  1039 0800 1840          move.b    _Timer3Count.L,D0
08000C38  2016      
08000C3A  5239 0800 1841          addq.b    #1,_Timer3Count.L
08000C3E  2016      
08000C40  13C0 0040 1842          move.b    D0,4194320
08000C44  0010      
                    1843   Timer_ISR_5:
                    1844   ; }
                    1845   ; if(Timer4Status == 1) {         // Did Timer 4 produce the Interrupt?
08000C46  1039 0040 1846          move.b    4194366,D0
08000C4A  003E      
08000C4C  0C00 0001 1847          cmp.b     #1,D0
08000C50  661A      1848          bne.s     Timer_ISR_7
                    1849   ; Timer4Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
08000C52  13FC 0003 1850          move.b    #3,4194366
08000C56  0040 003E 
                    1851   ; HEX_B = Timer4Count++ ;     // increment a HEX count on HEX_B with each tick of Timer 4
08000C5A  1039 0800 1852          move.b    _Timer4Count.L,D0
08000C5E  2018      
08000C60  5239 0800 1853          addq.b    #1,_Timer4Count.L
08000C64  2018      
08000C66  13C0 0040 1854          move.b    D0,4194322
08000C6A  0012      
                    1855   Timer_ISR_7:
08000C6C  4E75      1856          rts
                    1857   ; }
                    1858   ; }
                    1859   ; /*****************************************************************************************
                    1860   ; **	Interrupt service routine for ACIA. This device has it's own dedicate IRQ level
                    1861   ; **  Add your code here to poll Status register and clear interrupt
                    1862   ; *****************************************************************************************/
                    1863   ; void ACIA_ISR()
                    1864   ; {}
                    1865   _ACIA_ISR:
08000C6E  4E75      1866          rts
                    1867   ; /***************************************************************************************
                    1868   ; **	Interrupt service routine for PIAs 1 and 2. These devices share an IRQ level
                    1869   ; **  Add your code here to poll Status register and clear interrupt
                    1870   ; *****************************************************************************************/
                    1871   ; void PIA_ISR()
                    1872   ; {}
                    1873   _PIA_ISR:
08000C70  4E75      1874          rts
                    1875   ; /***********************************************************************************
                    1876   ; **	Interrupt service routine for Key 2 on DE1 board. Add your own response here
                    1877   ; ************************************************************************************/
                    1878   ; void Key2PressISR()
                    1879   ; {}
                    1880   _Key2PressISR:
08000C72  4E75      1881          rts
                    1882   ; /***********************************************************************************
                    1883   ; **	Interrupt service routine for Key 1 on DE1 board. Add your own response here
                    1884   ; ************************************************************************************/
                    1885   ; void Key1PressISR()
                    1886   ; {}
                    1887   _Key1PressISR:
08000C74  4E75      1888          rts
                    1889   ; /************************************************************************************
                    1890   ; **   Delay Subroutine to give the 68000 something useless to do to waste 1 mSec
                    1891   ; ************************************************************************************/
                    1892   ; void Wait1ms(void)
                    1893   ; {
                    1894   _Wait1ms:
08000C76  2F02      1895          move.l    D2,-(A7)
                    1896   ; int  i ;
                    1897   ; for(i = 0; i < 1000; i ++)
08000C78  4282      1898          clr.l     D2
                    1899   Wait1ms_1:
08000C7A  0C82 0000 1900          cmp.l     #1000,D2
08000C7E  03E8      
08000C80  6C04      1901          bge.s     Wait1ms_3
08000C82  5282      1902          addq.l    #1,D2
08000C84  60F4      1903          bra       Wait1ms_1
                    1904   Wait1ms_3:
08000C86  241F      1905          move.l    (A7)+,D2
08000C88  4E75      1906          rts
                    1907   ; ;
                    1908   ; }
                    1909   ; /************************************************************************************
                    1910   ; **  Subroutine to give the 68000 something useless to do to waste 3 mSec
                    1911   ; **************************************************************************************/
                    1912   ; void Wait3ms(void)
                    1913   ; {
                    1914   _Wait3ms:
08000C8A  2F02      1915          move.l    D2,-(A7)
                    1916   ; int i ;
                    1917   ; for(i = 0; i < 3; i++)
08000C8C  4282      1918          clr.l     D2
                    1919   Wait3ms_1:
08000C8E  0C82 0000 1920          cmp.l     #3,D2
08000C92  0003      
08000C94  6C0A      1921          bge.s     Wait3ms_3
                    1922   ; Wait1ms() ;
08000C96  4EB9 0800 1923          jsr       _Wait1ms
08000C9A  0C76      
08000C9C  5282      1924          addq.l    #1,D2
08000C9E  60EE      1925          bra       Wait3ms_1
                    1926   Wait3ms_3:
08000CA0  241F      1927          move.l    (A7)+,D2
08000CA2  4E75      1928          rts
                    1929   ; }
                    1930   ; void Wait500ms (void) {
                    1931   _Wait500ms:
08000CA4  2F02      1932          move.l    D2,-(A7)
                    1933   ; int i;
                    1934   ; for (i = 0; i<500; i++){
08000CA6  4282      1935          clr.l     D2
                    1936   Wait500ms_1:
08000CA8  0C82 0000 1937          cmp.l     #500,D2
08000CAC  01F4      
08000CAE  6C0A      1938          bge.s     Wait500ms_3
                    1939   ; Wait1ms();
08000CB0  4EB9 0800 1940          jsr       _Wait1ms
08000CB4  0C76      
08000CB6  5282      1941          addq.l    #1,D2
08000CB8  60EE      1942          bra       Wait500ms_1
                    1943   Wait500ms_3:
08000CBA  241F      1944          move.l    (A7)+,D2
08000CBC  4E75      1945          rts
                    1946   ; }
                    1947   ; }
                    1948   ; /*********************************************************************************************
                    1949   ; **  Subroutine to initialise the LCD display by writing some commands to the LCD internal registers
                    1950   ; **  Sets it for parallel port and 2 line display mode (if I recall correctly)
                    1951   ; *********************************************************************************************/
                    1952   ; void Init_LCD(void)
                    1953   ; {
                    1954   _Init_LCD:
                    1955   ; LCDcommand = 0x0c ;
08000CBE  13FC 000C 1956          move.b    #12,4194336
08000CC2  0040 0020 
                    1957   ; Wait3ms() ;
08000CC6  4EB9 0800 1958          jsr       _Wait3ms
08000CCA  0C8A      
                    1959   ; LCDcommand = 0x38 ;
08000CCC  13FC 0038 1960          move.b    #56,4194336
08000CD0  0040 0020 
                    1961   ; Wait3ms() ;
08000CD4  4EB9 0800 1962          jsr       _Wait3ms
08000CD8  0C8A      
08000CDA  4E75      1963          rts
                    1964   ; }
                    1965   ; /*********************************************************************************************
                    1966   ; **  Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                    1967   ; *********************************************************************************************/
                    1968   ; void Init_RS232(void)
                    1969   ; {
                    1970   _Init_RS232:
                    1971   ; RS232_Control = 0x15 ; //  %00010101 set up 6850 uses divide by 16 clock, set RTS low, 8 bits no parity, 1 stop bit, transmitter interrupt disabled
08000CDC  13FC 0015 1972          move.b    #21,4194368
08000CE0  0040 0040 
                    1973   ; RS232_Baud = 0x1 ;      // program baud rate generator 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
08000CE4  13FC 0001 1974          move.b    #1,4194372
08000CE8  0040 0044 
08000CEC  4E75      1975          rts
                    1976   ; }
                    1977   ; /*********************************************************************************************************
                    1978   ; **  Subroutine to provide a low level output function to 6850 ACIA
                    1979   ; **  This routine provides the basic functionality to output a single character to the serial Port
                    1980   ; **  to allow the board to communicate with HyperTerminal Program
                    1981   ; **
                    1982   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                    1983   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                    1984   ; **  call _putch() also
                    1985   ; *********************************************************************************************************/
                    1986   ; int _putch( int c)
                    1987   ; {
                    1988   __putch:
08000CEE  4E56 0000 1989          link      A6,#0
                    1990   ; while((RS232_Status & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                    1991   _putch_1:
08000CF2  1039 0040 1992          move.b    4194368,D0
08000CF6  0040      
08000CF8  C03C 0002 1993          and.b     #2,D0
08000CFC  0C00 0002 1994          cmp.b     #2,D0
08000D00  6702      1995          beq.s     _putch_3
08000D02  60EE      1996          bra       _putch_1
                    1997   _putch_3:
                    1998   ; ;
                    1999   ; RS232_TxData = (c & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
08000D04  202E 0008 2000          move.l    8(A6),D0
08000D08  C0BC 0000 2001          and.l     #127,D0
08000D0C  007F      
08000D0E  13C0 0040 2002          move.b    D0,4194370
08000D12  0042      
                    2003   ; return c ;                                              // putchar() expects the character to be returned
08000D14  202E 0008 2004          move.l    8(A6),D0
08000D18  4E5E      2005          unlk      A6
08000D1A  4E75      2006          rts
                    2007   ; }
                    2008   ; /*********************************************************************************************************
                    2009   ; **  Subroutine to provide a low level input function to 6850 ACIA
                    2010   ; **  This routine provides the basic functionality to input a single character from the serial Port
                    2011   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                    2012   ; **
                    2013   ; **  NOTE you do not call this function directly, instead you call the normal getchar() function
                    2014   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call getchar() so will
                    2015   ; **  call _getch() also
                    2016   ; *********************************************************************************************************/
                    2017   ; int _getch( void )
                    2018   ; {
                    2019   __getch:
08000D1C  2F02      2020          move.l    D2,-(A7)
                    2021   ; char c ;
                    2022   ; while((RS232_Status & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                    2023   _getch_1:
08000D1E  1039 0040 2024          move.b    4194368,D0
08000D22  0040      
08000D24  C03C 0001 2025          and.b     #1,D0
08000D28  0C00 0001 2026          cmp.b     #1,D0
08000D2C  6702      2027          beq.s     _getch_3
08000D2E  60EE      2028          bra       _getch_1
                    2029   _getch_3:
                    2030   ; ;
                    2031   ; c = (RS232_RxData & (char)(0x7f));
08000D30  1039 0040 2032          move.b    4194370,D0
08000D34  0042      
08000D36  C03C 007F 2033          and.b     #127,D0
08000D3A  1400      2034          move.b    D0,D2
                    2035   ; _putch(c);
08000D3C  4882      2036          ext.w     D2
08000D3E  48C2      2037          ext.l     D2
08000D40  2F02      2038          move.l    D2,-(A7)
08000D42  4EB9 0800 2039          jsr       __putch
08000D46  0CEE      
08000D48  584F      2040          addq.w    #4,A7
                    2041   ; return c;                   // read received character, mask off top bit and return as 7 bit ASCII character
08000D4A  4882      2042          ext.w     D2
08000D4C  48C2      2043          ext.l     D2
08000D4E  2002      2044          move.l    D2,D0
08000D50  241F      2045          move.l    (A7)+,D2
08000D52  4E75      2046          rts
                    2047   ; }
                    2048   ; char xtod(int c)
                    2049   ; {
                    2050   _xtod:
08000D54  4E56 0000 2051          link      A6,#0
08000D58  2F02      2052          move.l    D2,-(A7)
08000D5A  242E 0008 2053          move.l    8(A6),D2
                    2054   ; if ((char)(c) <= (char)('9'))
08000D5E  0C02 0039 2055          cmp.b     #57,D2
08000D62  6E08      2056          bgt.s     xtod_1
                    2057   ; return c - (char)(0x30);    // 0 - 9 = 0x30 - 0x39 so convert to number by sutracting 0x30
08000D64  1002      2058          move.b    D2,D0
08000D66  0400 0030 2059          sub.b     #48,D0
08000D6A  6014      2060          bra.s     xtod_3
                    2061   xtod_1:
                    2062   ; else if((char)(c) > (char)('F'))    // assume lower case
08000D6C  0C02 0046 2063          cmp.b     #70,D2
08000D70  6F08      2064          ble.s     xtod_4
                    2065   ; return c - (char)(0x57);    // a-f = 0x61-66 so needs to be converted to 0x0A - 0x0F so subtract 0x57
08000D72  1002      2066          move.b    D2,D0
08000D74  0400 0057 2067          sub.b     #87,D0
08000D78  6006      2068          bra.s     xtod_3
                    2069   xtod_4:
                    2070   ; else
                    2071   ; return c - (char)(0x37);    // A-F = 0x41-46 so needs to be converted to 0x0A - 0x0F so subtract 0x37
08000D7A  1002      2072          move.b    D2,D0
08000D7C  0400 0037 2073          sub.b     #55,D0
                    2074   xtod_3:
08000D80  241F      2075          move.l    (A7)+,D2
08000D82  4E5E      2076          unlk      A6
08000D84  4E75      2077          rts
                    2078   ; }
                    2079   ; int Get1HexDigits(char *CheckSumPtr)
                    2080   ; {
                    2081   _Get1HexDigits:
08000D86  4E56 0000 2082          link      A6,#0
08000D8A  2F02      2083          move.l    D2,-(A7)
                    2084   ; register int i = xtod(_getch());
08000D8C  2F00      2085          move.l    D0,-(A7)
08000D8E  4EB9 0800 2086          jsr       __getch
08000D92  0D1C      
08000D94  2200      2087          move.l    D0,D1
08000D96  201F      2088          move.l    (A7)+,D0
08000D98  2F01      2089          move.l    D1,-(A7)
08000D9A  4EB9 0800 2090          jsr       _xtod
08000D9E  0D54      
08000DA0  584F      2091          addq.w    #4,A7
08000DA2  C0BC 0000 2092          and.l     #255,D0
08000DA6  00FF      
08000DA8  2400      2093          move.l    D0,D2
                    2094   ; if(CheckSumPtr)
08000DAA  4AAE 0008 2095          tst.l     8(A6)
08000DAE  6706      2096          beq.s     Get1HexDigits_1
                    2097   ; *CheckSumPtr += i ;
08000DB0  206E 0008 2098          move.l    8(A6),A0
08000DB4  D510      2099          add.b     D2,(A0)
                    2100   Get1HexDigits_1:
                    2101   ; return i; 
08000DB6  2002      2102          move.l    D2,D0
08000DB8  241F      2103          move.l    (A7)+,D2
08000DBA  4E5E      2104          unlk      A6
08000DBC  4E75      2105          rts
                    2106   ; }
                    2107   ; int Get2HexDigits(char *CheckSumPtr)
                    2108   ; {
                    2109   _Get2HexDigits:
08000DBE  4E56 0000 2110          link      A6,#0
08000DC2  2F02      2111          move.l    D2,-(A7)
                    2112   ; register int i = (xtod(_getch()) << 4) | (xtod(_getch()));
08000DC4  2F00      2113          move.l    D0,-(A7)
08000DC6  4EB9 0800 2114          jsr       __getch
08000DCA  0D1C      
08000DCC  2200      2115          move.l    D0,D1
08000DCE  201F      2116          move.l    (A7)+,D0
08000DD0  2F01      2117          move.l    D1,-(A7)
08000DD2  4EB9 0800 2118          jsr       _xtod
08000DD6  0D54      
08000DD8  584F      2119          addq.w    #4,A7
08000DDA  C0BC 0000 2120          and.l     #255,D0
08000DDE  00FF      
08000DE0  E980      2121          asl.l     #4,D0
08000DE2  2F00      2122          move.l    D0,-(A7)
08000DE4  2F01      2123          move.l    D1,-(A7)
08000DE6  4EB9 0800 2124          jsr       __getch
08000DEA  0D1C      
08000DEC  221F      2125          move.l    (A7)+,D1
08000DEE  2F00      2126          move.l    D0,-(A7)
08000DF0  4EB9 0800 2127          jsr       _xtod
08000DF4  0D54      
08000DF6  584F      2128          addq.w    #4,A7
08000DF8  2200      2129          move.l    D0,D1
08000DFA  201F      2130          move.l    (A7)+,D0
08000DFC  C2BC 0000 2131          and.l     #255,D1
08000E00  00FF      
08000E02  8081      2132          or.l      D1,D0
08000E04  2400      2133          move.l    D0,D2
                    2134   ; if(CheckSumPtr)
08000E06  4AAE 0008 2135          tst.l     8(A6)
08000E0A  6706      2136          beq.s     Get2HexDigits_1
                    2137   ; *CheckSumPtr += i ;
08000E0C  206E 0008 2138          move.l    8(A6),A0
08000E10  D510      2139          add.b     D2,(A0)
                    2140   Get2HexDigits_1:
                    2141   ; return i ;
08000E12  2002      2142          move.l    D2,D0
08000E14  241F      2143          move.l    (A7)+,D2
08000E16  4E5E      2144          unlk      A6
08000E18  4E75      2145          rts
                    2146   ; }
                    2147   ; int Get4HexDigits(char *CheckSumPtr)
                    2148   ; {
                    2149   _Get4HexDigits:
08000E1A  4E56 0000 2150          link      A6,#0
                    2151   ; return (Get2HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
08000E1E  2F2E 0008 2152          move.l    8(A6),-(A7)
08000E22  4EB9 0800 2153          jsr       _Get2HexDigits
08000E26  0DBE      
08000E28  584F      2154          addq.w    #4,A7
08000E2A  E180      2155          asl.l     #8,D0
08000E2C  2F00      2156          move.l    D0,-(A7)
08000E2E  2F2E 0008 2157          move.l    8(A6),-(A7)
08000E32  4EB9 0800 2158          jsr       _Get2HexDigits
08000E36  0DBE      
08000E38  584F      2159          addq.w    #4,A7
08000E3A  2200      2160          move.l    D0,D1
08000E3C  201F      2161          move.l    (A7)+,D0
08000E3E  8081      2162          or.l      D1,D0
08000E40  4E5E      2163          unlk      A6
08000E42  4E75      2164          rts
                    2165   ; }
                    2166   ; int Get6HexDigits(char *CheckSumPtr)
                    2167   ; {
                    2168   _Get6HexDigits:
08000E44  4E56 0000 2169          link      A6,#0
                    2170   ; return (Get4HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
08000E48  2F2E 0008 2171          move.l    8(A6),-(A7)
08000E4C  4EB9 0800 2172          jsr       _Get4HexDigits
08000E50  0E1A      
08000E52  584F      2173          addq.w    #4,A7
08000E54  E180      2174          asl.l     #8,D0
08000E56  2F00      2175          move.l    D0,-(A7)
08000E58  2F2E 0008 2176          move.l    8(A6),-(A7)
08000E5C  4EB9 0800 2177          jsr       _Get2HexDigits
08000E60  0DBE      
08000E62  584F      2178          addq.w    #4,A7
08000E64  2200      2179          move.l    D0,D1
08000E66  201F      2180          move.l    (A7)+,D0
08000E68  8081      2181          or.l      D1,D0
08000E6A  4E5E      2182          unlk      A6
08000E6C  4E75      2183          rts
                    2184   ; }
                    2185   ; int Get8HexDigits(char *CheckSumPtr)
                    2186   ; {
                    2187   _Get8HexDigits:
08000E6E  4E56 0000 2188          link      A6,#0
                    2189   ; return (Get4HexDigits(CheckSumPtr) << 16) | (Get4HexDigits(CheckSumPtr));
08000E72  2F2E 0008 2190          move.l    8(A6),-(A7)
08000E76  4EB9 0800 2191          jsr       _Get4HexDigits
08000E7A  0E1A      
08000E7C  584F      2192          addq.w    #4,A7
08000E7E  E180      2193          asl.l     #8,D0
08000E80  E180      2194          asl.l     #8,D0
08000E82  2F00      2195          move.l    D0,-(A7)
08000E84  2F2E 0008 2196          move.l    8(A6),-(A7)
08000E88  4EB9 0800 2197          jsr       _Get4HexDigits
08000E8C  0E1A      
08000E8E  584F      2198          addq.w    #4,A7
08000E90  2200      2199          move.l    D0,D1
08000E92  201F      2200          move.l    (A7)+,D0
08000E94  8081      2201          or.l      D1,D0
08000E96  4E5E      2202          unlk      A6
08000E98  4E75      2203          rts
                    2204   ; }
                    2205   ; /******************************************************************************
                    2206   ; **  Subroutine to output a single character to the 2 row LCD display
                    2207   ; **  It is assumed the character is an ASCII code and it will be displayed at the
                    2208   ; **  current cursor position
                    2209   ; *******************************************************************************/
                    2210   ; void LCDOutchar(int c)
                    2211   ; {
                    2212   _LCDOutchar:
08000E9A  4E56 0000 2213          link      A6,#0
                    2214   ; LCDdata = (char)(c);
08000E9E  202E 0008 2215          move.l    8(A6),D0
08000EA2  13C0 0040 2216          move.b    D0,4194338
08000EA6  0022      
                    2217   ; Wait1ms() ;
08000EA8  4EB9 0800 2218          jsr       _Wait1ms
08000EAC  0C76      
08000EAE  4E5E      2219          unlk      A6
08000EB0  4E75      2220          rts
                    2221   ; }
                    2222   ; /**********************************************************************************
                    2223   ; *subroutine to output a message at the current cursor position of the LCD display
                    2224   ; ************************************************************************************/
                    2225   ; void LCDOutMessage(char *theMessage)
                    2226   ; {
                    2227   _LCDOutMessage:
08000EB2  4E56 FFFC 2228          link      A6,#-4
                    2229   ; char c ;
                    2230   ; while((c = *theMessage++) != 0)     // output characters from the string until NULL
                    2231   LCDOutMessage_1:
08000EB6  206E 0008 2232          move.l    8(A6),A0
08000EBA  52AE 0008 2233          addq.l    #1,8(A6)
08000EBE  1D50 FFFF 2234          move.b    (A0),-1(A6)
08000EC2  1010      2235          move.b    (A0),D0
08000EC4  6714      2236          beq.s     LCDOutMessage_3
                    2237   ; LCDOutchar(c) ;
08000EC6  122E FFFF 2238          move.b    -1(A6),D1
08000ECA  4881      2239          ext.w     D1
08000ECC  48C1      2240          ext.l     D1
08000ECE  2F01      2241          move.l    D1,-(A7)
08000ED0  4EB9 0800 2242          jsr       _LCDOutchar
08000ED4  0E9A      
08000ED6  584F      2243          addq.w    #4,A7
08000ED8  60DC      2244          bra       LCDOutMessage_1
                    2245   LCDOutMessage_3:
08000EDA  4E5E      2246          unlk      A6
08000EDC  4E75      2247          rts
                    2248   ; }
                    2249   ; /******************************************************************************
                    2250   ; *subroutine to clear the line by issuing 24 space characters
                    2251   ; *******************************************************************************/
                    2252   ; void LCDClearln(void)
                    2253   ; {
                    2254   _LCDClearln:
08000EDE  2F02      2255          move.l    D2,-(A7)
                    2256   ; int i ;
                    2257   ; for(i = 0; i < 24; i ++)
08000EE0  4282      2258          clr.l     D2
                    2259   LCDClearln_1:
08000EE2  0C82 0000 2260          cmp.l     #24,D2
08000EE6  0018      
08000EE8  6C10      2261          bge.s     LCDClearln_3
                    2262   ; LCDOutchar(' ') ;       // write a space char to the LCD display
08000EEA  4878 0020 2263          pea       32
08000EEE  4EB9 0800 2264          jsr       _LCDOutchar
08000EF2  0E9A      
08000EF4  584F      2265          addq.w    #4,A7
08000EF6  5282      2266          addq.l    #1,D2
08000EF8  60E8      2267          bra       LCDClearln_1
                    2268   LCDClearln_3:
08000EFA  241F      2269          move.l    (A7)+,D2
08000EFC  4E75      2270          rts
                    2271   ; }
                    2272   ; /******************************************************************************
                    2273   ; **  Subroutine to move the LCD cursor to the start of line 1 and clear that line
                    2274   ; *******************************************************************************/
                    2275   ; void LCDLine1Message(char *theMessage)
                    2276   ; {
                    2277   _LCDLine1Message:
08000EFE  4E56 0000 2278          link      A6,#0
                    2279   ; LCDcommand = 0x80 ;
08000F02  13FC 0080 2280          move.b    #128,4194336
08000F06  0040 0020 
                    2281   ; Wait3ms();
08000F0A  4EB9 0800 2282          jsr       _Wait3ms
08000F0E  0C8A      
                    2283   ; LCDClearln() ;
08000F10  4EB9 0800 2284          jsr       _LCDClearln
08000F14  0EDE      
                    2285   ; LCDcommand = 0x80 ;
08000F16  13FC 0080 2286          move.b    #128,4194336
08000F1A  0040 0020 
                    2287   ; Wait3ms() ;
08000F1E  4EB9 0800 2288          jsr       _Wait3ms
08000F22  0C8A      
                    2289   ; LCDOutMessage(theMessage) ;
08000F24  2F2E 0008 2290          move.l    8(A6),-(A7)
08000F28  4EB9 0800 2291          jsr       _LCDOutMessage
08000F2C  0EB2      
08000F2E  584F      2292          addq.w    #4,A7
08000F30  4E5E      2293          unlk      A6
08000F32  4E75      2294          rts
                    2295   ; }
                    2296   ; /******************************************************************************
                    2297   ; **  Subroutine to move the LCD cursor to the start of line 2 and clear that line
                    2298   ; *******************************************************************************/
                    2299   ; void LCDLine2Message(char *theMessage)
                    2300   ; {
                    2301   _LCDLine2Message:
08000F34  4E56 0000 2302          link      A6,#0
                    2303   ; LCDcommand = 0xC0 ;
08000F38  13FC 00C0 2304          move.b    #192,4194336
08000F3C  0040 0020 
                    2305   ; Wait3ms();
08000F40  4EB9 0800 2306          jsr       _Wait3ms
08000F44  0C8A      
                    2307   ; LCDClearln() ;
08000F46  4EB9 0800 2308          jsr       _LCDClearln
08000F4A  0EDE      
                    2309   ; LCDcommand = 0xC0 ;
08000F4C  13FC 00C0 2310          move.b    #192,4194336
08000F50  0040 0020 
                    2311   ; Wait3ms() ;
08000F54  4EB9 0800 2312          jsr       _Wait3ms
08000F58  0C8A      
                    2313   ; LCDOutMessage(theMessage) ;
08000F5A  2F2E 0008 2314          move.l    8(A6),-(A7)
08000F5E  4EB9 0800 2315          jsr       _LCDOutMessage
08000F62  0EB2      
08000F64  584F      2316          addq.w    #4,A7
08000F66  4E5E      2317          unlk      A6
08000F68  4E75      2318          rts
                    2319   ; }
                    2320   ; /*********************************************************************************************************************************
                    2321   ; **  IMPORTANT FUNCTION
                    2322   ; **  This function install an exception handler so you can capture and deal with any 68000 exception in your program
                    2323   ; **  You pass it the name of a function in your code that will get called in response to the exception (as the 1st parameter)
                    2324   ; **  and in the 2nd parameter, you pass it the exception number that you want to take over (see 68000 exceptions for details)
                    2325   ; **  Calling this function allows you to deal with Interrupts for example
                    2326   ; ***********************************************************************************************************************************/
                    2327   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                    2328   ; {
                    2329   _InstallExceptionHandler:
08000F6A  4E56 FFFC 2330          link      A6,#-4
                    2331   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
08000F6E  2D7C 0B00 2332          move.l    #184549376,-4(A6)
08000F72  0000 FFFC 
                    2333   ; RamVectorAddress[level] = (long int *)(function_ptr);                       // install the address of our function into the exception table
08000F76  206E FFFC 2334          move.l    -4(A6),A0
08000F7A  202E 000C 2335          move.l    12(A6),D0
08000F7E  E588      2336          lsl.l     #2,D0
08000F80  21AE 0008 2337          move.l    8(A6),0(A0,D0.L)
08000F84  0800      
08000F86  4E5E      2338          unlk      A6
08000F88  4E75      2339          rts
                    2340   ; }
                    2341   ; /******************************************************************************************************************************
                    2342   ; * Start of user program
                    2343   ; ******************************************************************************************************************************/
                    2344   ; void main()
                    2345   ; {   
                    2346   _main:
08000F8A  4E56 FF4C 2347          link      A6,#-180
08000F8E  2F0A      2348          move.l    A2,-(A7)
08000F90  45F9 0800 2349          lea       _InstallExceptionHandler.L,A2
08000F94  0F6A      
                    2350   ; unsigned int row, i=0, count=0, counter1=1;
08000F96  42AE FF50 2351          clr.l     -176(A6)
08000F9A  42AE FF54 2352          clr.l     -172(A6)
08000F9E  2D7C 0000 2353          move.l    #1,-168(A6)
08000FA2  0001 FF58 
                    2354   ; char c, text[150] ;
                    2355   ; int f;
                    2356   ; int valid;
                    2357   ; int PassFailFlag = 1 ;
08000FA6  2D7C 0000 2358          move.l    #1,-4(A6)
08000FAA  0001 FFFC 
                    2359   ; i = x = y = z = PortA_Count =0;
08000FAE  42B9 0800 2360          clr.l     _PortA_Count.L
08000FB2  200E      
08000FB4  42B9 0800 2361          clr.l     _z.L
08000FB8  200A      
08000FBA  42B9 0800 2362          clr.l     _y.L
08000FBE  2006      
08000FC0  42B9 0800 2363          clr.l     _x.L
08000FC4  2002      
08000FC6  42AE FF50 2364          clr.l     -176(A6)
                    2365   ; Timer1Count = Timer2Count = Timer3Count = Timer4Count = 0;
08000FCA  4239 0800 2366          clr.b     _Timer4Count.L
08000FCE  2018      
08000FD0  4239 0800 2367          clr.b     _Timer3Count.L
08000FD4  2016      
08000FD6  4239 0800 2368          clr.b     _Timer2Count.L
08000FDA  2014      
08000FDC  4239 0800 2369          clr.b     _Timer1Count.L
08000FE0  2012      
                    2370   ; InstallExceptionHandler(PIA_ISR, 25) ;          // install interrupt handler for PIAs 1 and 2 on level 1 IRQ
08000FE2  4878 0019 2371          pea       25
08000FE6  4879 0800 2372          pea       _PIA_ISR.L
08000FEA  0C70      
08000FEC  4E92      2373          jsr       (A2)
08000FEE  504F      2374          addq.w    #8,A7
                    2375   ; InstallExceptionHandler(ACIA_ISR, 26) ;		    // install interrupt handler for ACIA on level 2 IRQ
08000FF0  4878 001A 2376          pea       26
08000FF4  4879 0800 2377          pea       _ACIA_ISR.L
08000FF8  0C6E      
08000FFA  4E92      2378          jsr       (A2)
08000FFC  504F      2379          addq.w    #8,A7
                    2380   ; InstallExceptionHandler(Timer_ISR, 27) ;		// install interrupt handler for Timers 1-4 on level 3 IRQ
08000FFE  4878 001B 2381          pea       27
08001002  4879 0800 2382          pea       _Timer_ISR.L
08001006  0BD4      
08001008  4E92      2383          jsr       (A2)
0800100A  504F      2384          addq.w    #8,A7
                    2385   ; InstallExceptionHandler(Key2PressISR, 28) ;	    // install interrupt handler for Key Press 2 on DE1 board for level 4 IRQ
0800100C  4878 001C 2386          pea       28
08001010  4879 0800 2387          pea       _Key2PressISR.L
08001014  0C72      
08001016  4E92      2388          jsr       (A2)
08001018  504F      2389          addq.w    #8,A7
                    2390   ; InstallExceptionHandler(Key1PressISR, 29) ;	    // install interrupt handler for Key Press 1 on DE1 board for level 5 IRQ
0800101A  4878 001D 2391          pea       29
0800101E  4879 0800 2392          pea       _Key1PressISR.L
08001022  0C74      
08001024  4E92      2393          jsr       (A2)
08001026  504F      2394          addq.w    #8,A7
                    2395   ; Timer1Data = 0x10;		// program time delay into timers 1-4
08001028  13FC 0010 2396          move.b    #16,4194352
0800102C  0040 0030 
                    2397   ; Timer2Data = 0x20;
08001030  13FC 0020 2398          move.b    #32,4194356
08001034  0040 0034 
                    2399   ; Timer3Data = 0x15;
08001038  13FC 0015 2400          move.b    #21,4194360
0800103C  0040 0038 
                    2401   ; Timer4Data = 0x25;
08001040  13FC 0025 2402          move.b    #37,4194364
08001044  0040 003C 
                    2403   ; Timer1Control = 3;		// write 3 to control register to Bit0 = 1 (enable interrupt from timers) 1 - 4 and allow them to count Bit 1 = 1
08001048  13FC 0003 2404          move.b    #3,4194354
0800104C  0040 0032 
                    2405   ; Timer2Control = 3;
08001050  13FC 0003 2406          move.b    #3,4194358
08001054  0040 0036 
                    2407   ; Timer3Control = 3;
08001058  13FC 0003 2408          move.b    #3,4194362
0800105C  0040 003A 
                    2409   ; Timer4Control = 3;
08001060  13FC 0003 2410          move.b    #3,4194366
08001064  0040 003E 
                    2411   ; Init_LCD();             // initialise the LCD display to use a parallel data interface and 2 lines of display
08001068  4EB9 0800 2412          jsr       _Init_LCD
0800106C  0CBE      
                    2413   ; Init_RS232() ;          // initialise the RS232 port for use with hyper terminal
0800106E  4EB9 0800 2414          jsr       _Init_RS232
08001072  0CDC      
                    2415   ; /************************************************************************************************
                    2416   ; **  Test of scanf function
                    2417   ; ************************************************************************************************/
                    2418   ; /*scanflush() ;                       // flush any text that may have been typed ahead
                    2419   ; printf("\r\nEnter Integer: ") ;
                    2420   ; scanf("%d", &i) ;
                    2421   ; printf("You entered %d", i) ;
                    2422   ; sprintf(text, "Hello CPEN 412 Student") ;
                    2423   ; LCDLine1Message(text) ;
                    2424   ; printf("\r\nHello CPEN 412 Student\r\nYour LEDs should be Flashing") ;
                    2425   ; printf("\r\nYour LCD should be displaying") ;
                    2426   ; while(1)
                    2427   ; ;*/
                    2428   ; //printf("\r\nBig Brother is watching you");
                    2429   ; //I2C_init ();
                    2430   ; //I2C_byte_write();
                    2431   ; //I2C_byte_write();
                    2432   ; //I2C_multi_write();
                    2433   ; //I2C_byte_read();
                    2434   ; /*I2C_byte_read();
                    2435   ; I2C_byte_read();
                    2436   ; I2C_byte_read();
                    2437   ; I2C_byte_read();*/
                    2438   ; //I2C_multi_read();
                    2439   ; //DAC();
                    2440   ; //ADC();
                    2441   ; /*while(1) {
                    2442   ; valid = 0;
                    2443   ; while (!valid) {
                    2444   ; printf("\r\nWhich function you want to run?\n1.EEPROM single byte write\n2.EEPROM single byte read\n3.EEPROM page write\n4.EEPROM page read\n5.DAC->LED\n6.ADC<-sensors ");
                    2445   ; f = Get1HexDigits(0);
                    2446   ; if (f >= 1 && f <= 6) {
                    2447   ; valid = 1;
                    2448   ; } else {
                    2449   ; printf("\r\nInvalid selection! ");
                    2450   ; valid = 0;
                    2451   ; }
                    2452   ; }
                    2453   ; if (f == 1){
                    2454   ; I2C_byte_write();
                    2455   ; } else if (f == 2){
                    2456   ; I2C_byte_read();
                    2457   ; } else if (f == 3){
                    2458   ; I2C_multi_write();
                    2459   ; } else if (f == 4){
                    2460   ; I2C_multi_read();
                    2461   ; } else if (f == 5){
                    2462   ; DAC();
                    2463   ; } else if (f == 6){
                    2464   ; ADC();
                    2465   ; }
                    2466   ; }*/
                    2467   ; CanBusTest();
08001074  4EB9 0800 2468          jsr       _CanBusTest
08001078  03AA      
0800107A  245F      2469          move.l    (A7)+,A2
0800107C  4E5E      2470          unlk      A6
0800107E  4E75      2471          rts
                    2472   ; // programs should NOT exit as there is nothing to Exit TO !!!!!!
                    2473   ; // There is no OS - just press the reset button to end program and call debug
                    2474   ; }
                    2475   ULDIV:
08001080  4E56 0000 2476          link    A6,#0
08001084  48E7 C000 2477          movem.l D0/D1,-(A7)
08001088  222E 0008 2478          move.l  8(A6),D1
0800108C  202E 000C 2479          move.l  12(A6),D0
08001090  6036      2480          bra.s   ldiv_3
                    2481   LDIV:
08001092  4E56 0000 2482          link    A6,#0
08001096  48E7 C000 2483          movem.l D0/D1,-(A7)
0800109A  222E 0008 2484          move.l  8(A6),D1
0800109E  202E 000C 2485          move.l  12(A6),D0
080010A2  4A80      2486          tst.l   D0
080010A4  6A0E      2487          bpl.s   ldiv_1
080010A6  4480      2488          neg.l   D0
080010A8  4A81      2489          tst.l   D1
080010AA  6A14      2490          bpl.s   ldiv_2
080010AC  4481      2491          neg.l   D1
080010AE  612A      2492          bsr.s   dodiv
080010B0  4481      2493          neg.l   D1
080010B2  6016      2494          bra.s   ldiv_4
                    2495   ldiv_1:
080010B4  4A81      2496          tst.l   D1
080010B6  6A10      2497          bpl.s   ldiv_3
080010B8  4481      2498          neg.l   D1
080010BA  611E      2499          bsr.s   dodiv
080010BC  4480      2500          neg.l   D0
080010BE  600A      2501          bra.s   ldiv_4
                    2502   ldiv_2:
080010C0  6118      2503          bsr.s   dodiv
080010C2  4480      2504          neg.l   D0
080010C4  4481      2505          neg.l   D1
080010C6  6002      2506          bra.s   ldiv_4
                    2507   ldiv_3:
080010C8  6110      2508          bsr.s   dodiv
                    2509   ldiv_4:
080010CA  2D40 0008 2510          move.l  D0,8(A6)
080010CE  2D41 000C 2511          move.l  D1,12(A6)
080010D2  4CDF 0003 2512          movem.l (A7)+,D0/D1
080010D6  4E5E      2513          unlk    A6
080010D8  4E75      2514          rts
                    2515   dodiv:
080010DA  0C81 0000 2516          cmpi.l  #$FFFF,D1
080010DE  FFFF      
080010E0  6236      2517          bhi.s   dodiv_2
080010E2  0C80 0000 2518          cmpi.l  #$FFFF,D0
080010E6  FFFF      
080010E8  6210      2519          bhi.s   dodiv_1
080010EA  80C1      2520          divu    D1,D0
080010EC  2200      2521          move.l  D0,D1
080010EE  4241      2522          clr.w   D1
080010F0  4841      2523          swap    D1
080010F2  0280 0000 2524          andi.l  #$FFFF,D0
080010F6  FFFF      
080010F8  4E75      2525          rts
                    2526   dodiv_1:
080010FA  48A7 A000 2527          movem.w D0/D2,-(A7)
080010FE  4240      2528          clr.w   D0
08001100  4840      2529          swap    D0
08001102  80C1      2530          divu    D1,D0
08001104  3400      2531          move.w  D0,D2
08001106  301F      2532          move.w  (A7)+,D0
08001108  80C1      2533          divu    D1,D0
0800110A  4840      2534          swap    D0
0800110C  4281      2535          clr.l   D1
0800110E  3200      2536          move.w  D0,D1
08001110  3002      2537          move.w  D2,D0
08001112  4840      2538          swap    D0
08001114  341F      2539          move.w  (A7)+,D2
08001116  4E75      2540          rts
                    2541   dodiv_2:
08001118  48E7 3800 2542          movem.l D2/D3/D4,-(A7)
0800111C  2401      2543          move.l  D1,D2
0800111E  4242      2544          clr.w   D2
08001120  4842      2545          swap    D2
08001122  5282      2546          addq.l  #1,D2
08001124  2600      2547          move.l  D0,D3
08001126  2801      2548          move.l  D1,D4
08001128  2202      2549          move.l  D2,D1
0800112A  61CE      2550          bsr.s   dodiv_1
0800112C  2204      2551          move.l  D4,D1
0800112E  82C2      2552          divu    D2,D1
08001130  80C1      2553          divu    D1,D0
08001132  0280 0000 2554          andi.l  #$FFFF,D0
08001136  FFFF      
                    2555   dodiv_3:
08001138  2204      2556          move.l  D4,D1
0800113A  2404      2557          move.l  D4,D2
0800113C  4842      2558          swap    D2
0800113E  C2C0      2559          mulu    D0,D1
08001140  C4C0      2560          mulu    D0,D2
08001142  4842      2561          swap    D2
08001144  D282      2562          add.l   D2,D1
08001146  9283      2563          sub.l   D3,D1
08001148  620A      2564          bhi.s   dodiv_4
0800114A  4481      2565          neg.l   D1
0800114C  B881      2566          cmp.l   D1,D4
0800114E  6208      2567          bhi.s   dodiv_5
08001150  5280      2568          addq.l  #1,D0
08001152  60E4      2569          bra.s   dodiv_3
                    2570   dodiv_4:
08001154  5380      2571          subq.l  #1,D0
08001156  60E0      2572          bra.s   dodiv_3
                    2573   dodiv_5:
08001158  4CDF 001C 2574          movem.l (A7)+,D2/D3/D4
0800115C  4E75      2575          rts
                    2576   _printf:
0800115E  4E56 FFFC 2577          link      A6,#-4
08001162  2F02      2578          move.l    D2,-(A7)
08001164  41EE 0008 2579          lea       8(A6),A0
08001168  5848      2580          addq.w    #4,A0
0800116A  2408      2581          move.l    A0,D2
0800116C  2F02      2582          move.l    D2,-(A7)
0800116E  2F2E 0008 2583          move.l    8(A6),-(A7)
08001172  42A7      2584          clr.l     -(A7)
08001174  4EB9 0800 2585          jsr       _doprint
08001178  1236      
0800117A  DEFC 000C 2586          add.w     #12,A7
0800117E  2D40 FFFC 2587          move.l    D0,-4(A6)
08001182  4282      2588          clr.l     D2
08001184  202E FFFC 2589          move.l    -4(A6),D0
08001188  241F      2590          move.l    (A7)+,D2
0800118A  4E5E      2591          unlk      A6
0800118C  4E75      2592          rts
                    2593   @doprint_copy:
0800118E  4E56 0000 2594          link      A6,#0
08001192  206E 0008 2595          move.l    8(A6),A0
08001196  4A90      2596          tst.l     (A0)
08001198  6710      2597          beq.s     @doprint_copy_1
0800119A  202E 000C 2598          move.l    12(A6),D0
0800119E  206E 0008 2599          move.l    8(A6),A0
080011A2  2250      2600          move.l    (A0),A1
080011A4  5290      2601          addq.l    #1,(A0)
080011A6  1280      2602          move.b    D0,(A1)
080011A8  600C      2603          bra.s     @doprint_copy_2
                    2604   @doprint_copy_1:
080011AA  2F2E 000C 2605          move.l    12(A6),-(A7)
080011AE  4EB9 0800 2606          jsr       _putch
080011B2  1A88      
080011B4  584F      2607          addq.w    #4,A7
                    2608   @doprint_copy_2:
080011B6  4E5E      2609          unlk      A6
080011B8  4E75      2610          rts
                    2611   @doprint_getval:
080011BA  4E56 0000 2612          link      A6,#0
080011BE  48E7 3000 2613          movem.l   D2/D3,-(A7)
080011C2  262E 0008 2614          move.l    8(A6),D3
080011C6  4282      2615          clr.l     D2
080011C8  2043      2616          move.l    D3,A0
080011CA  2050      2617          move.l    (A0),A0
080011CC  1010      2618          move.b    (A0),D0
080011CE  0C00 002A 2619          cmp.b     #42,D0
080011D2  6612      2620          bne.s     @doprint_getval_1
080011D4  206E 000C 2621          move.l    12(A6),A0
080011D8  2250      2622          move.l    (A0),A1
080011DA  5890      2623          addq.l    #4,(A0)
080011DC  2411      2624          move.l    (A1),D2
080011DE  2043      2625          move.l    D3,A0
080011E0  5290      2626          addq.l    #1,(A0)
080011E2  6000 0048 2627          bra       @doprint_getval_5
                    2628   @doprint_getval_1:
080011E6  7001      2629          moveq     #1,D0
080011E8  2043      2630          move.l    D3,A0
080011EA  2050      2631          move.l    (A0),A0
080011EC  1210      2632          move.b    (A0),D1
080011EE  4881      2633          ext.w     D1
080011F0  48C1      2634          ext.l     D1
080011F2  D081      2635          add.l     D1,D0
080011F4  41F9 0800 2636          lea       __ctype.L,A0
080011F8  1EF0      
080011FA  1030 0800 2637          move.b    0(A0,D0.L),D0
080011FE  C03C 0004 2638          and.b     #4,D0
08001202  6728      2639          beq.s     @doprint_getval_5
08001204  2F02      2640          move.l    D2,-(A7)
08001206  4878 000A 2641          pea       10
0800120A  4EB9 0800 2642          jsr       LMUL
0800120E  19E8      
08001210  2017      2643          move.l    (A7),D0
08001212  504F      2644          addq.w    #8,A7
08001214  2043      2645          move.l    D3,A0
08001216  2250      2646          move.l    (A0),A1
08001218  5290      2647          addq.l    #1,(A0)
0800121A  1211      2648          move.b    (A1),D1
0800121C  4881      2649          ext.w     D1
0800121E  48C1      2650          ext.l     D1
08001220  D081      2651          add.l     D1,D0
08001222  0480 0000 2652          sub.l     #48,D0
08001226  0030      
08001228  2400      2653          move.l    D0,D2
0800122A  60BA      2654          bra       @doprint_getval_1
                    2655   @doprint_getval_5:
0800122C  2002      2656          move.l    D2,D0
0800122E  4CDF 000C 2657          movem.l   (A7)+,D2/D3
08001232  4E5E      2658          unlk      A6
08001234  4E75      2659          rts
                    2660   _doprint:
08001236  4E56 FFCC 2661          link      A6,#-52
0800123A  48E7 3F3C 2662          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
0800123E  45EE 0008 2663          lea       8(A6),A2
08001242  47F9 0800 2664          lea       @doprint_copy.L,A3
08001246  118E      
08001248  49F9 0800 2665          lea       _ultoa.L,A4
0800124C  1970      
0800124E  4286      2666          clr.l     D6
                    2667   doprint_1:
08001250  206E 000C 2668          move.l    12(A6),A0
08001254  4A10      2669          tst.b     (A0)
08001256  6700 05F0 2670          beq       doprint_3
0800125A  206E 000C 2671          move.l    12(A6),A0
0800125E  1010      2672          move.b    (A0),D0
08001260  0C00 0025 2673          cmp.b     #37,D0
08001264  671C      2674          beq.s     doprint_4
08001266  206E 000C 2675          move.l    12(A6),A0
0800126A  52AE 000C 2676          addq.l    #1,12(A6)
0800126E  1210      2677          move.b    (A0),D1
08001270  4881      2678          ext.w     D1
08001272  48C1      2679          ext.l     D1
08001274  2F01      2680          move.l    D1,-(A7)
08001276  2F0A      2681          move.l    A2,-(A7)
08001278  4E93      2682          jsr       (A3)
0800127A  504F      2683          addq.w    #8,A7
0800127C  5286      2684          addq.l    #1,D6
0800127E  6000 05C4 2685          bra       doprint_2
                    2686   doprint_4:
08001282  52AE 000C 2687          addq.l    #1,12(A6)
08001286  422E FFD3 2688          clr.b     -45(A6)
0800128A  422E FFD2 2689          clr.b     -46(A6)
0800128E  422E FFD0 2690          clr.b     -48(A6)
08001292  422E FFCF 2691          clr.b     -49(A6)
08001296  422E FFCE 2692          clr.b     -50(A6)
0800129A  422E FFCD 2693          clr.b     -51(A6)
0800129E  42AE FFFC 2694          clr.l     -4(A6)
080012A2  7AFF      2695          moveq     #-1,D5
080012A4  41EE FFDC 2696          lea       -36(A6),A0
080012A8  2608      2697          move.l    A0,D3
080012AA  2408      2698          move.l    A0,D2
                    2699   doprint_6:
080012AC  206E 000C 2700          move.l    12(A6),A0
080012B0  1010      2701          move.b    (A0),D0
080012B2  4880      2702          ext.w     D0
080012B4  48C0      2703          ext.l     D0
080012B6  0C80 0000 2704          cmp.l     #43,D0
080012BA  002B      
080012BC  6730      2705          beq.s     doprint_12
080012BE  6E18      2706          bgt.s     doprint_15
080012C0  0C80 0000 2707          cmp.l     #35,D0
080012C4  0023      
080012C6  6700 003E 2708          beq       doprint_14
080012CA  6E00 0046 2709          bgt       doprint_9
080012CE  0C80 0000 2710          cmp.l     #32,D0
080012D2  0020      
080012D4  6724      2711          beq.s     doprint_13
080012D6  603A      2712          bra.s     doprint_9
                    2713   doprint_15:
080012D8  0C80 0000 2714          cmp.l     #45,D0
080012DC  002D      
080012DE  6702      2715          beq.s     doprint_11
080012E0  6030      2716          bra.s     doprint_9
                    2717   doprint_11:
080012E2  1D7C 0001 2718          move.b    #1,-51(A6)
080012E6  FFCD      
080012E8  52AE 000C 2719          addq.l    #1,12(A6)
080012EC  6026      2720          bra.s     doprint_7
                    2721   doprint_12:
080012EE  1D7C 0001 2722          move.b    #1,-50(A6)
080012F2  FFCE      
080012F4  52AE 000C 2723          addq.l    #1,12(A6)
080012F8  601A      2724          bra.s     doprint_7
                    2725   doprint_13:
080012FA  1D7C 0001 2726          move.b    #1,-49(A6)
080012FE  FFCF      
08001300  52AE 000C 2727          addq.l    #1,12(A6)
08001304  600E      2728          bra.s     doprint_7
                    2729   doprint_14:
08001306  1D7C 0001 2730          move.b    #1,-48(A6)
0800130A  FFD0      
0800130C  52AE 000C 2731          addq.l    #1,12(A6)
08001310  6002      2732          bra.s     doprint_7
                    2733   doprint_9:
08001312  6002      2734          bra.s     doprint_8
                    2735   doprint_7:
08001314  6096      2736          bra       doprint_6
                    2737   doprint_8:
08001316  206E 000C 2738          move.l    12(A6),A0
0800131A  1010      2739          move.b    (A0),D0
0800131C  0C00 0030 2740          cmp.b     #48,D0
08001320  660A      2741          bne.s     doprint_16
08001322  52AE 000C 2742          addq.l    #1,12(A6)
08001326  1D7C 0001 2743          move.b    #1,-46(A6)
0800132A  FFD2      
                    2744   doprint_16:
0800132C  486E 0010 2745          pea       16(A6)
08001330  486E 000C 2746          pea       12(A6)
08001334  4EB9 0800 2747          jsr       @doprint_getval
08001338  11BA      
0800133A  504F      2748          addq.w    #8,A7
0800133C  2A40      2749          move.l    D0,A5
0800133E  206E 000C 2750          move.l    12(A6),A0
08001342  1010      2751          move.b    (A0),D0
08001344  0C00 002E 2752          cmp.b     #46,D0
08001348  6616      2753          bne.s     doprint_18
0800134A  52AE 000C 2754          addq.l    #1,12(A6)
0800134E  486E 0010 2755          pea       16(A6)
08001352  486E 000C 2756          pea       12(A6)
08001356  4EB9 0800 2757          jsr       @doprint_getval
0800135A  11BA      
0800135C  504F      2758          addq.w    #8,A7
0800135E  2A00      2759          move.l    D0,D5
                    2760   doprint_18:
08001360  206E 000C 2761          move.l    12(A6),A0
08001364  1010      2762          move.b    (A0),D0
08001366  0C00 006C 2763          cmp.b     #108,D0
0800136A  660A      2764          bne.s     doprint_20
0800136C  52AE 000C 2765          addq.l    #1,12(A6)
08001370  1D7C 0001 2766          move.b    #1,-45(A6)
08001374  FFD3      
                    2767   doprint_20:
08001376  206E 000C 2768          move.l    12(A6),A0
0800137A  1010      2769          move.b    (A0),D0
0800137C  4880      2770          ext.w     D0
0800137E  48C0      2771          ext.l     D0
08001380  0C80 0000 2772          cmp.l     #111,D0
08001384  006F      
08001386  6700 00D8 2773          beq       doprint_27
0800138A  6E34      2774          bgt.s     doprint_33
0800138C  0C80 0000 2775          cmp.l     #100,D0
08001390  0064      
08001392  6700 0054 2776          beq       doprint_24
08001396  6E1C      2777          bgt.s     doprint_34
08001398  0C80 0000 2778          cmp.l     #99,D0
0800139C  0063      
0800139E  6700 0130 2779          beq       doprint_30
080013A2  6E00 0174 2780          bgt       doprint_22
080013A6  0C80 0000 2781          cmp.l     #88,D0
080013AA  0058      
080013AC  6700 00EA 2782          beq       doprint_28
080013B0  6000 0166 2783          bra       doprint_22
                    2784   doprint_34:
080013B4  0C80 0000 2785          cmp.l     #105,D0
080013B8  0069      
080013BA  672C      2786          beq.s     doprint_24
080013BC  6000 015A 2787          bra       doprint_22
                    2788   doprint_33:
080013C0  0C80 0000 2789          cmp.l     #117,D0
080013C4  0075      
080013C6  6700 0060 2790          beq       doprint_26
080013CA  6E0E      2791          bgt.s     doprint_35
080013CC  0C80 0000 2792          cmp.l     #115,D0
080013D0  0073      
080013D2  6700 0124 2793          beq       doprint_31
080013D6  6000 0140 2794          bra       doprint_22
                    2795   doprint_35:
080013DA  0C80 0000 2796          cmp.l     #120,D0
080013DE  0078      
080013E0  6700 00B6 2797          beq       doprint_28
080013E4  6000 0132 2798          bra       doprint_22
                    2799   doprint_24:
080013E8  4A2E FFD3 2800          tst.b     -45(A6)
080013EC  671C      2801          beq.s     doprint_36
080013EE  4878 000A 2802          pea       10
080013F2  2F03      2803          move.l    D3,-(A7)
080013F4  206E 0010 2804          move.l    16(A6),A0
080013F8  58AE 0010 2805          addq.l    #4,16(A6)
080013FC  2F10      2806          move.l    (A0),-(A7)
080013FE  4EB9 0800 2807          jsr       _ltoa
08001402  18E8      
08001404  DEFC 000C 2808          add.w     #12,A7
08001408  601A      2809          bra.s     doprint_37
                    2810   doprint_36:
0800140A  4878 000A 2811          pea       10
0800140E  2F03      2812          move.l    D3,-(A7)
08001410  206E 0010 2813          move.l    16(A6),A0
08001414  58AE 0010 2814          addq.l    #4,16(A6)
08001418  2F10      2815          move.l    (A0),-(A7)
0800141A  4EB9 0800 2816          jsr       _ltoa
0800141E  18E8      
08001420  DEFC 000C 2817          add.w     #12,A7
                    2818   doprint_37:
08001424  6000 0100 2819          bra       doprint_23
                    2820   doprint_26:
08001428  4A2E FFD3 2821          tst.b     -45(A6)
0800142C  6718      2822          beq.s     doprint_38
0800142E  4878 000A 2823          pea       10
08001432  2F03      2824          move.l    D3,-(A7)
08001434  206E 0010 2825          move.l    16(A6),A0
08001438  58AE 0010 2826          addq.l    #4,16(A6)
0800143C  2F10      2827          move.l    (A0),-(A7)
0800143E  4E94      2828          jsr       (A4)
08001440  DEFC 000C 2829          add.w     #12,A7
08001444  6016      2830          bra.s     doprint_39
                    2831   doprint_38:
08001446  4878 000A 2832          pea       10
0800144A  2F03      2833          move.l    D3,-(A7)
0800144C  206E 0010 2834          move.l    16(A6),A0
08001450  58AE 0010 2835          addq.l    #4,16(A6)
08001454  2F10      2836          move.l    (A0),-(A7)
08001456  4E94      2837          jsr       (A4)
08001458  DEFC 000C 2838          add.w     #12,A7
                    2839   doprint_39:
0800145C  6000 00C8 2840          bra       doprint_23
                    2841   doprint_27:
08001460  4A2E FFD3 2842          tst.b     -45(A6)
08001464  6718      2843          beq.s     doprint_40
08001466  4878 0008 2844          pea       8
0800146A  2F03      2845          move.l    D3,-(A7)
0800146C  206E 0010 2846          move.l    16(A6),A0
08001470  58AE 0010 2847          addq.l    #4,16(A6)
08001474  2F10      2848          move.l    (A0),-(A7)
08001476  4E94      2849          jsr       (A4)
08001478  DEFC 000C 2850          add.w     #12,A7
0800147C  6016      2851          bra.s     doprint_41
                    2852   doprint_40:
0800147E  4878 0008 2853          pea       8
08001482  2F03      2854          move.l    D3,-(A7)
08001484  206E 0010 2855          move.l    16(A6),A0
08001488  58AE 0010 2856          addq.l    #4,16(A6)
0800148C  2F10      2857          move.l    (A0),-(A7)
0800148E  4E94      2858          jsr       (A4)
08001490  DEFC 000C 2859          add.w     #12,A7
                    2860   doprint_41:
08001494  6000 0090 2861          bra       doprint_23
                    2862   doprint_28:
08001498  4A2E FFD3 2863          tst.b     -45(A6)
0800149C  6718      2864          beq.s     doprint_42
0800149E  4878 0010 2865          pea       16
080014A2  2F03      2866          move.l    D3,-(A7)
080014A4  206E 0010 2867          move.l    16(A6),A0
080014A8  58AE 0010 2868          addq.l    #4,16(A6)
080014AC  2F10      2869          move.l    (A0),-(A7)
080014AE  4E94      2870          jsr       (A4)
080014B0  DEFC 000C 2871          add.w     #12,A7
080014B4  6016      2872          bra.s     doprint_43
                    2873   doprint_42:
080014B6  4878 0010 2874          pea       16
080014BA  2F03      2875          move.l    D3,-(A7)
080014BC  206E 0010 2876          move.l    16(A6),A0
080014C0  58AE 0010 2877          addq.l    #4,16(A6)
080014C4  2F10      2878          move.l    (A0),-(A7)
080014C6  4E94      2879          jsr       (A4)
080014C8  DEFC 000C 2880          add.w     #12,A7
                    2881   doprint_43:
080014CC  6000 0058 2882          bra       doprint_23
                    2883   doprint_30:
080014D0  206E 0010 2884          move.l    16(A6),A0
080014D4  58AE 0010 2885          addq.l    #4,16(A6)
080014D8  2010      2886          move.l    (A0),D0
080014DA  2042      2887          move.l    D2,A0
080014DC  5282      2888          addq.l    #1,D2
080014DE  1080      2889          move.b    D0,(A0)
080014E0  2042      2890          move.l    D2,A0
080014E2  4210      2891          clr.b     (A0)
080014E4  200D      2892          move.l    A5,D0
080014E6  6704      2893          beq.s     doprint_44
080014E8  200D      2894          move.l    A5,D0
080014EA  6006      2895          bra.s     doprint_45
                    2896   doprint_44:
080014EC  7001      2897          moveq     #1,D0
080014EE  4880      2898          ext.w     D0
080014F0  48C0      2899          ext.l     D0
                    2900   doprint_45:
080014F2  2A00      2901          move.l    D0,D5
080014F4  6000 0030 2902          bra       doprint_23
                    2903   doprint_31:
080014F8  206E 0010 2904          move.l    16(A6),A0
080014FC  58AE 0010 2905          addq.l    #4,16(A6)
08001500  2610      2906          move.l    (A0),D3
08001502  0C85 FFFF 2907          cmp.l     #-1,D5
08001506  FFFF      
08001508  660C      2908          bne.s     doprint_46
0800150A  2F03      2909          move.l    D3,-(A7)
0800150C  4EB9 0800 2910          jsr       _strlen
08001510  1A76      
08001512  584F      2911          addq.w    #4,A7
08001514  2A00      2912          move.l    D0,D5
                    2913   doprint_46:
08001516  600E      2914          bra.s     doprint_23
                    2915   doprint_22:
08001518  206E 000C 2916          move.l    12(A6),A0
0800151C  2242      2917          move.l    D2,A1
0800151E  5282      2918          addq.l    #1,D2
08001520  1290      2919          move.b    (A0),(A1)
08001522  2042      2920          move.l    D2,A0
08001524  4210      2921          clr.b     (A0)
                    2922   doprint_23:
08001526  2F03      2923          move.l    D3,-(A7)
08001528  4EB9 0800 2924          jsr       _strlen
0800152C  1A76      
0800152E  584F      2925          addq.w    #4,A7
08001530  1800      2926          move.b    D0,D4
08001532  206E 000C 2927          move.l    12(A6),A0
08001536  1010      2928          move.b    (A0),D0
08001538  0C00 0073 2929          cmp.b     #115,D0
0800153C  661C      2930          bne.s     doprint_48
0800153E  0C85 0000 2931          cmp.l     #0,D5
08001542  0000      
08001544  6D14      2932          blt.s     doprint_48
08001546  4884      2933          ext.w     D4
08001548  48C4      2934          ext.l     D4
0800154A  B885      2935          cmp.l     D5,D4
0800154C  6F04      2936          ble.s     doprint_50
0800154E  2005      2937          move.l    D5,D0
08001550  6006      2938          bra.s     doprint_51
                    2939   doprint_50:
08001552  1004      2940          move.b    D4,D0
08001554  4880      2941          ext.w     D0
08001556  48C0      2942          ext.l     D0
                    2943   doprint_51:
08001558  1800      2944          move.b    D0,D4
                    2945   doprint_48:
0800155A  206E 000C 2946          move.l    12(A6),A0
0800155E  1010      2947          move.b    (A0),D0
08001560  0C00 0058 2948          cmp.b     #88,D0
08001564  6600 0028 2949          bne       doprint_56
08001568  41EE FFDC 2950          lea       -36(A6),A0
0800156C  2408      2951          move.l    A0,D2
                    2952   doprint_54:
0800156E  2042      2953          move.l    D2,A0
08001570  4A10      2954          tst.b     (A0)
08001572  671A      2955          beq.s     doprint_56
08001574  2042      2956          move.l    D2,A0
08001576  1210      2957          move.b    (A0),D1
08001578  4881      2958          ext.w     D1
0800157A  48C1      2959          ext.l     D1
0800157C  2F01      2960          move.l    D1,-(A7)
0800157E  4EB9 0800 2961          jsr       _toupper
08001582  1AB8      
08001584  584F      2962          addq.w    #4,A7
08001586  2042      2963          move.l    D2,A0
08001588  1080      2964          move.b    D0,(A0)
0800158A  5282      2965          addq.l    #1,D2
0800158C  60E0      2966          bra       doprint_54
                    2967   doprint_56:
0800158E  7E00      2968          moveq     #0,D7
08001590  41EE FFD4 2969          lea       -44(A6),A0
08001594  2408      2970          move.l    A0,D2
08001596  206E 000C 2971          move.l    12(A6),A0
0800159A  1010      2972          move.b    (A0),D0
0800159C  0C00 0064 2973          cmp.b     #100,D0
080015A0  670E      2974          beq.s     doprint_59
080015A2  206E 000C 2975          move.l    12(A6),A0
080015A6  1010      2976          move.b    (A0),D0
080015A8  0C00 0069 2977          cmp.b     #105,D0
080015AC  6600 0068 2978          bne       doprint_65
                    2979   doprint_59:
080015B0  102E FFCE 2980          move.b    -50(A6),D0
080015B4  4880      2981          ext.w     D0
080015B6  48C0      2982          ext.l     D0
080015B8  4A80      2983          tst.l     D0
080015BA  660C      2984          bne.s     doprint_62
080015BC  2043      2985          move.l    D3,A0
080015BE  1010      2986          move.b    (A0),D0
080015C0  0C00 002D 2987          cmp.b     #45,D0
080015C4  6600 0028 2988          bne       doprint_60
                    2989   doprint_62:
080015C8  2043      2990          move.l    D3,A0
080015CA  1010      2991          move.b    (A0),D0
080015CC  0C00 002D 2992          cmp.b     #45,D0
080015D0  660E      2993          bne.s     doprint_63
080015D2  2043      2994          move.l    D3,A0
080015D4  5283      2995          addq.l    #1,D3
080015D6  2242      2996          move.l    D2,A1
080015D8  5282      2997          addq.l    #1,D2
080015DA  1290      2998          move.b    (A0),(A1)
080015DC  5304      2999          subq.b    #1,D4
080015DE  6008      3000          bra.s     doprint_64
                    3001   doprint_63:
080015E0  2042      3002          move.l    D2,A0
080015E2  5282      3003          addq.l    #1,D2
080015E4  10BC 002B 3004          move.b    #43,(A0)
                    3005   doprint_64:
080015E8  5287      3006          addq.l    #1,D7
080015EA  6000 002A 3007          bra       doprint_65
                    3008   doprint_60:
080015EE  4A2E FFCF 3009          tst.b     -49(A6)
080015F2  6722      3010          beq.s     doprint_65
080015F4  2043      3011          move.l    D3,A0
080015F6  1010      3012          move.b    (A0),D0
080015F8  0C00 002D 3013          cmp.b     #45,D0
080015FC  660E      3014          bne.s     doprint_67
080015FE  2043      3015          move.l    D3,A0
08001600  5283      3016          addq.l    #1,D3
08001602  2242      3017          move.l    D2,A1
08001604  5282      3018          addq.l    #1,D2
08001606  1290      3019          move.b    (A0),(A1)
08001608  5304      3020          subq.b    #1,D4
0800160A  6008      3021          bra.s     doprint_68
                    3022   doprint_67:
0800160C  2042      3023          move.l    D2,A0
0800160E  5282      3024          addq.l    #1,D2
08001610  10BC 0020 3025          move.b    #32,(A0)
                    3026   doprint_68:
08001614  5287      3027          addq.l    #1,D7
                    3028   doprint_65:
08001616  4A2E FFD0 3029          tst.b     -48(A6)
0800161A  6700 005A 3030          beq       doprint_77
0800161E  206E 000C 3031          move.l    12(A6),A0
08001622  1010      3032          move.b    (A0),D0
08001624  4880      3033          ext.w     D0
08001626  48C0      3034          ext.l     D0
08001628  0C80 0000 3035          cmp.l     #111,D0
0800162C  006F      
0800162E  671A      3036          beq.s     doprint_73
08001630  6E0C      3037          bgt.s     doprint_76
08001632  0C80 0000 3038          cmp.l     #88,D0
08001636  0058      
08001638  6710      3039          beq.s     doprint_73
0800163A  6000 003A 3040          bra       doprint_77
                    3041   doprint_76:
0800163E  0C80 0000 3042          cmp.l     #120,D0
08001642  0078      
08001644  6704      3043          beq.s     doprint_73
08001646  6000 002E 3044          bra       doprint_77
                    3045   doprint_73:
0800164A  2042      3046          move.l    D2,A0
0800164C  5282      3047          addq.l    #1,D2
0800164E  10BC 0030 3048          move.b    #48,(A0)
08001652  5287      3049          addq.l    #1,D7
08001654  206E 000C 3050          move.l    12(A6),A0
08001658  1010      3051          move.b    (A0),D0
0800165A  0C00 0078 3052          cmp.b     #120,D0
0800165E  670C      3053          beq.s     doprint_79
08001660  206E 000C 3054          move.l    12(A6),A0
08001664  1010      3055          move.b    (A0),D0
08001666  0C00 0058 3056          cmp.b     #88,D0
0800166A  660A      3057          bne.s     doprint_77
                    3058   doprint_79:
0800166C  2042      3059          move.l    D2,A0
0800166E  5282      3060          addq.l    #1,D2
08001670  10BC 0078 3061          move.b    #120,(A0)
08001674  5287      3062          addq.l    #1,D7
                    3063   doprint_77:
08001676  2042      3064          move.l    D2,A0
08001678  4210      3065          clr.b     (A0)
0800167A  206E 000C 3066          move.l    12(A6),A0
0800167E  1010      3067          move.b    (A0),D0
08001680  4880      3068          ext.w     D0
08001682  48C0      3069          ext.l     D0
08001684  0C80 0000 3070          cmp.l     #105,D0
08001688  0069      
0800168A  6700 0076 3071          beq       doprint_82
0800168E  6E42      3072          bgt.s     doprint_93
08001690  0C80 0000 3073          cmp.l     #99,D0
08001694  0063      
08001696  6700 0084 3074          beq       doprint_96
0800169A  6E1C      3075          bgt.s     doprint_94
0800169C  0C80 0000 3076          cmp.l     #88,D0
080016A0  0058      
080016A2  6700 005E 3077          beq       doprint_82
080016A6  6E00 0184 3078          bgt       doprint_80
080016AA  0C80 0000 3079          cmp.l     #69,D0
080016AE  0045      
080016B0  6700 0050 3080          beq       doprint_82
080016B4  6000 0176 3081          bra       doprint_80
                    3082   doprint_94:
080016B8  0C80 0000 3083          cmp.l     #101,D0
080016BC  0065      
080016BE  6700 0042 3084          beq       doprint_82
080016C2  6E00 0168 3085          bgt       doprint_80
080016C6  0C80 0000 3086          cmp.l     #100,D0
080016CA  0064      
080016CC  6734      3087          beq.s     doprint_82
080016CE  6000 015C 3088          bra       doprint_80
                    3089   doprint_93:
080016D2  0C80 0000 3090          cmp.l     #117,D0
080016D6  0075      
080016D8  6728      3091          beq.s     doprint_82
080016DA  6E1A      3092          bgt.s     doprint_95
080016DC  0C80 0000 3093          cmp.l     #115,D0
080016E0  0073      
080016E2  6700 0038 3094          beq       doprint_96
080016E6  6E00 0144 3095          bgt       doprint_80
080016EA  0C80 0000 3096          cmp.l     #111,D0
080016EE  006F      
080016F0  6710      3097          beq.s     doprint_82
080016F2  6000 0138 3098          bra       doprint_80
                    3099   doprint_95:
080016F6  0C80 0000 3100          cmp.l     #120,D0
080016FA  0078      
080016FC  6704      3101          beq.s     doprint_82
080016FE  6000 012C 3102          bra       doprint_80
                    3103   doprint_82:
08001702  4A2E FFD2 3104          tst.b     -46(A6)
08001706  6714      3105          beq.s     doprint_96
08001708  4A2E FFCD 3106          tst.b     -51(A6)
0800170C  660E      3107          bne.s     doprint_96
0800170E  200D      3108          move.l    A5,D0
08001710  9087      3109          sub.l     D7,D0
08001712  4884      3110          ext.w     D4
08001714  48C4      3111          ext.l     D4
08001716  9084      3112          sub.l     D4,D0
08001718  2D40 FFFC 3113          move.l    D0,-4(A6)
                    3114   doprint_96:
0800171C  202E FFFC 3115          move.l    -4(A6),D0
08001720  0C80 0000 3116          cmp.l     #0,D0
08001724  0000      
08001726  6C04      3117          bge.s     doprint_98
08001728  42AE FFFC 3118          clr.l     -4(A6)
                    3119   doprint_98:
0800172C  4A2E FFCD 3120          tst.b     -51(A6)
08001730  6600 0030 3121          bne       doprint_104
08001734  1004      3122          move.b    D4,D0
08001736  4880      3123          ext.w     D0
08001738  48C0      3124          ext.l     D0
0800173A  D0AE FFFC 3125          add.l     -4(A6),D0
0800173E  D087      3126          add.l     D7,D0
08001740  1D40 FFD1 3127          move.b    D0,-47(A6)
                    3128   doprint_102:
08001744  102E FFD1 3129          move.b    -47(A6),D0
08001748  4880      3130          ext.w     D0
0800174A  48C0      3131          ext.l     D0
0800174C  220D      3132          move.l    A5,D1
0800174E  534D      3133          subq.w    #1,A5
08001750  B081      3134          cmp.l     D1,D0
08001752  6C0E      3135          bge.s     doprint_104
08001754  4878 0020 3136          pea       32
08001758  2F0A      3137          move.l    A2,-(A7)
0800175A  4E93      3138          jsr       (A3)
0800175C  504F      3139          addq.w    #8,A7
0800175E  5286      3140          addq.l    #1,D6
08001760  60E2      3141          bra       doprint_102
                    3142   doprint_104:
08001762  41EE FFD4 3143          lea       -44(A6),A0
08001766  2408      3144          move.l    A0,D2
                    3145   doprint_105:
08001768  2042      3146          move.l    D2,A0
0800176A  4A10      3147          tst.b     (A0)
0800176C  6716      3148          beq.s     doprint_107
0800176E  2042      3149          move.l    D2,A0
08001770  5282      3150          addq.l    #1,D2
08001772  1210      3151          move.b    (A0),D1
08001774  4881      3152          ext.w     D1
08001776  48C1      3153          ext.l     D1
08001778  2F01      3154          move.l    D1,-(A7)
0800177A  2F0A      3155          move.l    A2,-(A7)
0800177C  4E93      3156          jsr       (A3)
0800177E  504F      3157          addq.w    #8,A7
08001780  5286      3158          addq.l    #1,D6
08001782  60E4      3159          bra       doprint_105
                    3160   doprint_107:
08001784  202E FFFC 3161          move.l    -4(A6),D0
08001788  1D40 FFD1 3162          move.b    D0,-47(A6)
                    3163   doprint_108:
0800178C  102E FFD1 3164          move.b    -47(A6),D0
08001790  532E FFD1 3165          subq.b    #1,-47(A6)
08001794  4A00      3166          tst.b     D0
08001796  670E      3167          beq.s     doprint_110
08001798  4878 0030 3168          pea       48
0800179C  2F0A      3169          move.l    A2,-(A7)
0800179E  4E93      3170          jsr       (A3)
080017A0  504F      3171          addq.w    #8,A7
080017A2  5286      3172          addq.l    #1,D6
080017A4  60E6      3173          bra       doprint_108
                    3174   doprint_110:
080017A6  2043      3175          move.l    D3,A0
080017A8  4A10      3176          tst.b     (A0)
080017AA  6700 0048 3177          beq       doprint_113
080017AE  206E 000C 3178          move.l    12(A6),A0
080017B2  1010      3179          move.b    (A0),D0
080017B4  4880      3180          ext.w     D0
080017B6  48C0      3181          ext.l     D0
080017B8  0C80 0000 3182          cmp.l     #115,D0
080017BC  0073      
080017BE  670C      3183          beq.s     doprint_116
080017C0  6E18      3184          bgt.s     doprint_119
080017C2  0C80 0000 3185          cmp.l     #99,D0
080017C6  0063      
080017C8  6702      3186          beq.s     doprint_116
080017CA  600E      3187          bra.s     doprint_119
                    3188   doprint_116:
080017CC  2005      3189          move.l    D5,D0
080017CE  5385      3190          subq.l    #1,D5
080017D0  0C80 0000 3191          cmp.l     #0,D0
080017D4  0000      
080017D6  6E02      3192          bgt.s     doprint_119
080017D8  6016      3193          bra.s     doprint_115
                    3194   doprint_119:
080017DA  2043      3195          move.l    D3,A0
080017DC  5283      3196          addq.l    #1,D3
080017DE  1210      3197          move.b    (A0),D1
080017E0  4881      3198          ext.w     D1
080017E2  48C1      3199          ext.l     D1
080017E4  2F01      3200          move.l    D1,-(A7)
080017E6  2F0A      3201          move.l    A2,-(A7)
080017E8  4E93      3202          jsr       (A3)
080017EA  504F      3203          addq.w    #8,A7
080017EC  5286      3204          addq.l    #1,D6
080017EE  6002      3205          bra.s     doprint_112
                    3206   doprint_115:
080017F0  6002      3207          bra.s     doprint_113
                    3208   doprint_112:
080017F2  60B2      3209          bra       doprint_110
                    3210   doprint_113:
080017F4  4A2E FFCD 3211          tst.b     -51(A6)
080017F8  6700 0030 3212          beq       doprint_125
080017FC  1004      3213          move.b    D4,D0
080017FE  4880      3214          ext.w     D0
08001800  48C0      3215          ext.l     D0
08001802  D0AE FFFC 3216          add.l     -4(A6),D0
08001806  D087      3217          add.l     D7,D0
08001808  1D40 FFD1 3218          move.b    D0,-47(A6)
                    3219   doprint_123:
0800180C  102E FFD1 3220          move.b    -47(A6),D0
08001810  4880      3221          ext.w     D0
08001812  48C0      3222          ext.l     D0
08001814  220D      3223          move.l    A5,D1
08001816  534D      3224          subq.w    #1,A5
08001818  B081      3225          cmp.l     D1,D0
0800181A  6C0E      3226          bge.s     doprint_125
0800181C  4878 0020 3227          pea       32
08001820  2F0A      3228          move.l    A2,-(A7)
08001822  4E93      3229          jsr       (A3)
08001824  504F      3230          addq.w    #8,A7
08001826  5386      3231          subq.l    #1,D6
08001828  60E2      3232          bra       doprint_123
                    3233   doprint_125:
0800182A  6014      3234          bra.s     doprint_81
                    3235   doprint_80:
0800182C  206E 000C 3236          move.l    12(A6),A0
08001830  1210      3237          move.b    (A0),D1
08001832  4881      3238          ext.w     D1
08001834  48C1      3239          ext.l     D1
08001836  2F01      3240          move.l    D1,-(A7)
08001838  2F0A      3241          move.l    A2,-(A7)
0800183A  4E93      3242          jsr       (A3)
0800183C  504F      3243          addq.w    #8,A7
0800183E  5286      3244          addq.l    #1,D6
                    3245   doprint_81:
08001840  52AE 000C 3246          addq.l    #1,12(A6)
                    3247   doprint_2:
08001844  6000 FA0A 3248          bra       doprint_1
                    3249   doprint_3:
08001848  4A92      3250          tst.l     (A2)
0800184A  6710      3251          beq.s     doprint_126
0800184C  4201      3252          clr.b     D1
0800184E  C2BC 0000 3253          and.l     #255,D1
08001852  00FF      
08001854  2F01      3254          move.l    D1,-(A7)
08001856  2F0A      3255          move.l    A2,-(A7)
08001858  4E93      3256          jsr       (A3)
0800185A  504F      3257          addq.w    #8,A7
                    3258   doprint_126:
0800185C  2006      3259          move.l    D6,D0
0800185E  4CDF 3CFC 3260          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
08001862  4E5E      3261          unlk      A6
08001864  4E75      3262          rts
                    3263   @itoa_convert:
08001866  4E56 0000 3264          link      A6,#0
0800186A  48E7 3C00 3265          movem.l   D2/D3/D4/D5,-(A7)
0800186E  242E 0008 3266          move.l    8(A6),D2
08001872  262E 0010 3267          move.l    16(A6),D3
08001876  2A2E 000C 3268          move.l    12(A6),D5
0800187A  2F05      3269          move.l    D5,-(A7)
0800187C  2F03      3270          move.l    D3,-(A7)
0800187E  4EB9 0800 3271          jsr       ULDIV
08001882  1080      
08001884  202F 0004 3272          move.l    4(A7),D0
08001888  504F      3273          addq.w    #8,A7
0800188A  2800      3274          move.l    D0,D4
0800188C  BA83      3275          cmp.l     D3,D5
0800188E  6520      3276          blo.s     @itoa_convert_1
08001890  2F03      3277          move.l    D3,-(A7)
08001892  2F05      3278          move.l    D5,-(A7)
08001894  2F03      3279          move.l    D3,-(A7)
08001896  4EB9 0800 3280          jsr       ULDIV
0800189A  1080      
0800189C  2217      3281          move.l    (A7),D1
0800189E  504F      3282          addq.w    #8,A7
080018A0  2F01      3283          move.l    D1,-(A7)
080018A2  2F02      3284          move.l    D2,-(A7)
080018A4  4EB9 0800 3285          jsr       @itoa_convert
080018A8  1866      
080018AA  DEFC 000C 3286          add.w     #12,A7
080018AE  2400      3287          move.l    D0,D2
                    3288   @itoa_convert_1:
080018B0  0C84 0000 3289          cmp.l     #9,D4
080018B4  0009      
080018B6  6E0E      3290          bgt.s     @itoa_convert_3
080018B8  2004      3291          move.l    D4,D0
080018BA  7230      3292          moveq     #48,D1
080018BC  C2BC 0000 3293          and.l     #255,D1
080018C0  00FF      
080018C2  D081      3294          add.l     D1,D0
080018C4  6012      3295          bra.s     @itoa_convert_4
                    3296   @itoa_convert_3:
080018C6  2004      3297          move.l    D4,D0
080018C8  7261      3298          moveq     #97,D1
080018CA  C2BC 0000 3299          and.l     #255,D1
080018CE  00FF      
080018D0  D081      3300          add.l     D1,D0
080018D2  0480 0000 3301          sub.l     #10,D0
080018D6  000A      
                    3302   @itoa_convert_4:
080018D8  2042      3303          move.l    D2,A0
080018DA  1080      3304          move.b    D0,(A0)
080018DC  2002      3305          move.l    D2,D0
080018DE  5280      3306          addq.l    #1,D0
080018E0  4CDF 003C 3307          movem.l   (A7)+,D2/D3/D4/D5
080018E4  4E5E      3308          unlk      A6
080018E6  4E75      3309          rts
                    3310   _ltoa:
080018E8  4E56 0000 3311          link      A6,#0
080018EC  48E7 3C00 3312          movem.l   D2/D3/D4/D5,-(A7)
080018F0  242E 0008 3313          move.l    8(A6),D2
080018F4  262E 000C 3314          move.l    12(A6),D3
080018F8  2A2E 0010 3315          move.l    16(A6),D5
080018FC  2803      3316          move.l    D3,D4
080018FE  0C85 0000 3317          cmp.l     #2,D5
08001902  0002      
08001904  6D08      3318          blt.s     ltoa_3
08001906  0C85 0000 3319          cmp.l     #36,D5
0800190A  0024      
0800190C  6F06      3320          ble.s     ltoa_1
                    3321   ltoa_3:
0800190E  2003      3322          move.l    D3,D0
08001910  6000 0056 3323          bra       ltoa_4
                    3324   ltoa_1:
08001914  0C85 0000 3325          cmp.l     #10,D5
08001918  000A      
0800191A  6600 0034 3326          bne       ltoa_5
0800191E  0C82 0000 3327          cmp.l     #0,D2
08001922  0000      
08001924  6C2A      3328          bge.s     ltoa_5
08001926  2002      3329          move.l    D2,D0
08001928  4480      3330          neg.l     D0
0800192A  2400      3331          move.l    D0,D2
0800192C  0C82 0000 3332          cmp.l     #0,D2
08001930  0000      
08001932  6C14      3333          bge.s     ltoa_7
08001934  4879 0800 3334          pea       @itoa_1.L
08001938  1EE4      
0800193A  2F03      3335          move.l    D3,-(A7)
0800193C  4EB9 0800 3336          jsr       _strcpy
08001940  1AD4      
08001942  504F      3337          addq.w    #8,A7
08001944  2003      3338          move.l    D3,D0
08001946  6020      3339          bra.s     ltoa_4
                    3340   ltoa_7:
08001948  2044      3341          move.l    D4,A0
0800194A  5284      3342          addq.l    #1,D4
0800194C  10BC 002D 3343          move.b    #45,(A0)
                    3344   ltoa_5:
08001950  2F05      3345          move.l    D5,-(A7)
08001952  2F02      3346          move.l    D2,-(A7)
08001954  2F04      3347          move.l    D4,-(A7)
08001956  4EB9 0800 3348          jsr       @itoa_convert
0800195A  1866      
0800195C  DEFC 000C 3349          add.w     #12,A7
08001960  2800      3350          move.l    D0,D4
08001962  2044      3351          move.l    D4,A0
08001964  4210      3352          clr.b     (A0)
08001966  2003      3353          move.l    D3,D0
                    3354   ltoa_4:
08001968  4CDF 003C 3355          movem.l   (A7)+,D2/D3/D4/D5
0800196C  4E5E      3356          unlk      A6
0800196E  4E75      3357          rts
                    3358   _ultoa:
08001970  4E56 0000 3359          link      A6,#0
08001974  48E7 3800 3360          movem.l   D2/D3/D4,-(A7)
08001978  262E 0010 3361          move.l    16(A6),D3
0800197C  282E 000C 3362          move.l    12(A6),D4
08001980  2404      3363          move.l    D4,D2
08001982  0C83 0000 3364          cmp.l     #2,D3
08001986  0002      
08001988  6D08      3365          blt.s     ultoa_3
0800198A  0C83 0000 3366          cmp.l     #36,D3
0800198E  0024      
08001990  6F04      3367          ble.s     ultoa_1
                    3368   ultoa_3:
08001992  2004      3369          move.l    D4,D0
08001994  601A      3370          bra.s     ultoa_4
                    3371   ultoa_1:
08001996  2F03      3372          move.l    D3,-(A7)
08001998  2F2E 0008 3373          move.l    8(A6),-(A7)
0800199C  2F02      3374          move.l    D2,-(A7)
0800199E  4EB9 0800 3375          jsr       @itoa_convert
080019A2  1866      
080019A4  DEFC 000C 3376          add.w     #12,A7
080019A8  2400      3377          move.l    D0,D2
080019AA  2042      3378          move.l    D2,A0
080019AC  4210      3379          clr.b     (A0)
080019AE  2004      3380          move.l    D4,D0
                    3381   ultoa_4:
080019B0  4CDF 001C 3382          movem.l   (A7)+,D2/D3/D4
080019B4  4E5E      3383          unlk      A6
080019B6  4E75      3384          rts
                    3385   _itoa:
080019B8  4E56 0000 3386          link      A6,#0
080019BC  2F2E 0010 3387          move.l    16(A6),-(A7)
080019C0  2F2E 000C 3388          move.l    12(A6),-(A7)
080019C4  2F2E 0008 3389          move.l    8(A6),-(A7)
080019C8  4EB9 0800 3390          jsr       _ltoa
080019CC  18E8      
080019CE  DEFC 000C 3391          add.w     #12,A7
080019D2  4E5E      3392          unlk      A6
080019D4  4E75      3393          rts
                    3394   ULMUL:
080019D6  4E56 0000 3395          link    A6,#0
080019DA  48E7 C000 3396          movem.l D0/D1,-(A7)
080019DE  222E 0008 3397          move.l  8(A6),D1
080019E2  202E 000C 3398          move.l  12(A6),D0
080019E6  602C      3399          bra.s   lmul_3
                    3400   LMUL:
080019E8  4E56 0000 3401          link    A6,#0
080019EC  48E7 C000 3402          movem.l D0/D1,-(A7)
080019F0  222E 0008 3403          move.l  8(A6),D1
080019F4  202E 000C 3404          move.l  12(A6),D0
080019F8  4A80      3405          tst.l   D0
080019FA  6A0A      3406          bpl.s   lmul_1
080019FC  4480      3407          neg.l   D0
080019FE  4A81      3408          tst.l   D1
08001A00  6A0A      3409          bpl.s   lmul_2
08001A02  4481      3410          neg.l   D1
08001A04  600E      3411          bra.s   lmul_3
                    3412   lmul_1:
08001A06  4A81      3413          tst.l   D1
08001A08  6A0A      3414          bpl.s   lmul_3
08001A0A  4481      3415          neg.l   D1
                    3416   lmul_2:
08001A0C  6114      3417          bsr.s   domul
08001A0E  4481      3418          neg.l   D1
08001A10  4080      3419          negx.l  D0
08001A12  6002      3420          bra.s   lmul_4
                    3421   lmul_3:
08001A14  610C      3422          bsr.s   domul
                    3423   lmul_4:
08001A16  2D41 0008 3424          move.l  D1,8(A6)
08001A1A  4CDF 0003 3425          movem.l (A7)+,D0/D1
08001A1E  4E5E      3426          unlk    A6
08001A20  4E75      3427          rts
                    3428   domul:
08001A22  0C81 0000 3429          cmpi.l  #$FFFF,D1
08001A26  FFFF      
08001A28  620C      3430          bhi.s   domul_1
08001A2A  0C80 0000 3431          cmpi.l  #$FFFF,D0
08001A2E  FFFF      
08001A30  620E      3432          bhi.s   domul_2
08001A32  C2C0      3433          mulu    D0,D1
08001A34  4E75      3434          rts
                    3435   domul_1:
08001A36  0C80 0000 3436          cmpi.l  #$FFFF,D0
08001A3A  FFFF      
08001A3C  6218      3437          bhi.s   domul_4
08001A3E  6002      3438          bra.s   domul_3
                    3439   domul_2
08001A40  C141      3440          exg     D0,D1
                    3441   domul_3:
08001A42  2F02      3442          move.l  D2,-(A7)
08001A44  2401      3443          move.l  D1,D2
08001A46  4842      3444          swap    D2
08001A48  C2C0      3445          mulu    D0,D1
08001A4A  C4C0      3446          mulu    D0,D2
08001A4C  4842      3447          swap    D2
08001A4E  4242      3448          clr.w   D2
08001A50  D282      3449          add.l   D2,D1
08001A52  241F      3450          move.l  (A7)+,D2
08001A54  4E75      3451          rts
                    3452   domul_4:
08001A56  48E7 3000 3453          movem.l D2/D3,-(A7)
08001A5A  2401      3454          move.l  D1,D2
08001A5C  2601      3455          move.l  D1,D3
08001A5E  C2C0      3456          mulu    D0,D1
08001A60  4842      3457          swap    D2
08001A62  C4C0      3458          mulu    D0,D2
08001A64  4840      3459          swap    D0
08001A66  C6C0      3460          mulu    D0,D3
08001A68  D483      3461          add.l   D3,D2
08001A6A  4842      3462          swap    D2
08001A6C  4242      3463          clr.w   D2
08001A6E  D282      3464          add.l   D2,D1
08001A70  4CDF 000C 3465          movem.l (A7)+,D2/D3
08001A74  4E75      3466          rts
                    3467   _strlen:
08001A76  206F 0004 3468          move.l    (4,A7),A0
08001A7A  2248      3469          move.l    A0,A1
                    3470   strlen_1:
08001A7C  4A19      3471          tst.b     (A1)+
08001A7E  66FC      3472          bne       strlen_1
08001A80  2009      3473          move.l    A1,D0
08001A82  9088      3474          sub.l     A0,D0
08001A84  5380      3475          subq.l    #1,D0
08001A86  4E75      3476          rts
                    3477   _putch:
08001A88  4E56 0000 3478          link      A6,#0
08001A8C  2F02      3479          move.l    D2,-(A7)
08001A8E  242E 0008 3480          move.l    8(A6),D2
08001A92  0C82 0000 3481          cmp.l     #10,D2
08001A96  000A      
08001A98  660C      3482          bne.s     putch_1
08001A9A  4878 000D 3483          pea       13
08001A9E  4EB9 0800 3484          jsr       __putch
08001AA2  0CEE      
08001AA4  584F      3485          addq.w    #4,A7
                    3486   putch_1:
08001AA6  2F02      3487          move.l    D2,-(A7)
08001AA8  4EB9 0800 3488          jsr       __putch
08001AAC  0CEE      
08001AAE  584F      3489          addq.w    #4,A7
08001AB0  2002      3490          move.l    D2,D0
08001AB2  241F      3491          move.l    (A7)+,D2
08001AB4  4E5E      3492          unlk      A6
08001AB6  4E75      3493          rts
                    3494   _toupper:
08001AB8  202F 0004 3495          move.l    4(A7),D0
08001ABC  0C80 0000 3496          cmp.l     #'a',D0
08001AC0  0061      
08001AC2  6D0E      3497          blt.s     toupper_1
08001AC4  0C80 0000 3498          cmp.l     #'z',D0
08001AC8  007A      
08001ACA  6E06      3499          bgt.s     toupper_1
08001ACC  0480 0000 3500          sub.l     #$20,D0
08001AD0  0020      
                    3501   toupper_1:
08001AD2  4E75      3502          rts
                    3503   _strcpy:
08001AD4  206F 0004 3504          move.l    (4,A7),A0
08001AD8  226F 0008 3505          move.l    (8,A7),A1
08001ADC  2008      3506          move.l    A0,D0
                    3507   strcpy_1:
08001ADE  10D9      3508          move.b    (A1)+,(A0)+
08001AE0  66FC      3509          bne.s     strcpy_1
08001AE2  4E75      3510          rts
                    3511          section   const
08001AE4            3512                   align
                    3513   
                    3514   
                    3515   @m68kus~1_1:
08001AE4  0D0A 496E 3516          dc.b      13,10,73,110,105,116,105,97,108,105,122,105
08001AE8  6974 6961 
08001AEC  6C69 7A69 
08001AF0  6E67 2043 3517          dc.b      110,103,32,67,97,110,32,99,111,110,116,114,111
08001AF4  616E 2063 
08001AF8  6F6E 7472 
08001AFC  6F        
08001AFD  6C6C 6572 3518          dc.b      108,108,101,114,32,48,0
08001B01  2030 00   
                    3519   @m68kus~1_2:
08001B04  0D0A 496E 3520          dc.b      13,10,73,110,105,116,105,97,108,105,122,105
08001B08  6974 6961 
08001B0C  6C69 7A69 
08001B10  6E67 2043 3521          dc.b      110,103,32,67,97,110,32,99,111,110,116,114,111
08001B14  616E 2063 
08001B18  6F6E 7472 
08001B1C  6F        
08001B1D  6C6C 6572 3522          dc.b      108,108,101,114,32,49,0
08001B21  2031 00   
                    3523   @m68kus~1_3:
08001B24  0D0A 5472 3524          dc.b      13,10,84,114,97,110,115,109,105,116,116,105
08001B28  616E 736D 
08001B2C  6974 7469 
08001B30  6E67 2043 3525          dc.b      110,103,32,67,97,110,32,99,111,110,116,114,111
08001B34  616E 2063 
08001B38  6F6E 7472 
08001B3C  6F        
08001B3D  6C6C 6572 3526          dc.b      108,108,101,114,32,48,0
08001B41  2030 00   
                    3527   @m68kus~1_4:
08001B44  0D0A 5472 3528          dc.b      13,10,84,114,97,110,115,109,105,116,116,105
08001B48  616E 736D 
08001B4C  6974 7469 
08001B50  6E67 2043 3529          dc.b      110,103,32,67,97,110,32,99,111,110,116,114,111
08001B54  616E 2063 
08001B58  6F6E 7472 
08001B5C  6F        
08001B5D  6C6C 6572 3530          dc.b      108,108,101,114,32,49,0
08001B61  2031 00   
                    3531   @m68kus~1_5:
08001B64  0D0A 5265 3532          dc.b      13,10,82,101,97,100,105,110,103,32,67,97,110
08001B68  6164 696E 
08001B6C  6720 4361 
08001B70  6E        
08001B71  2063 6F6E 3533          dc.b      32,99,111,110,116,114,111,108,108,101,114,32
08001B75  7472 6F6C 
08001B79  6C65 7220 
08001B7D  3000      3534          dc.b      48,0
                    3535   @m68kus~1_6:
08001B80  0D0A 2578 3536          dc.b      13,10,37,120,0
08001B84  00        
                    3537   @m68kus~1_7:
08001B86  0D0A 5265 3538          dc.b      13,10,82,101,97,100,105,110,103,32,67,97,110
08001B8A  6164 696E 
08001B8E  6720 4361 
08001B92  6E        
08001B93  2063 6F6E 3539          dc.b      32,99,111,110,116,114,111,108,108,101,114,32
08001B97  7472 6F6C 
08001B9B  6C65 7220 
08001B9F  3100      3540          dc.b      49,0
                    3541   @m68kus~1_8:
08001BA2  0D0A 0D0A 3542          dc.b      13,10,13,10,45,45,45,45,32,67,65,78,66,85,83
08001BA6  2D2D 2D2D 
08001BAA  2043 414E 
08001BAE  4255 53   
08001BB1  2054 6573 3543          dc.b      32,84,101,115,116,32,45,45,45,45,13,10,0
08001BB5  7420 2D2D 
08001BB9  2D2D 0D0A 
08001BBD  00        
                    3544   @m68kus~1_9:
08001BBE  0D0A 00   3545          dc.b      13,10,0
                    3546   @m68kus~1_10:
08001BC2  0D0A 5768 3547          dc.b      13,10,87,104,97,116,32,105,115,32,116,104,101
08001BC6  6174 2069 
08001BCA  7320 7468 
08001BCE  65        
08001BCF  2069 6E74 3548          dc.b      32,105,110,116,101,114,110,97,108,32,69,69,80
08001BD3  6572 6E61 
08001BD7  6C20 4545 
08001BDB  50        
08001BDC  524F 4D20 3549          dc.b      82,79,77,32,97,100,100,114,101,115,115,32,121
08001BE0  6164 6472 
08001BE4  6573 7320 
08001BE8  79        
08001BE9  6F75 2077 3550          dc.b      111,117,32,119,97,110,116,32,116,111,32,97,99
08001BED  616E 7420 
08001BF1  746F 2061 
08001BF5  63        
08001BF6  6365 7373 3551          dc.b      99,101,115,115,63,32,0
08001BFA  3F20 00   
                    3552   @m68kus~1_11:
08001BFE  0D0A 4164 3553          dc.b      13,10,65,100,100,114,101,115,115,32,99,97,110
08001C02  6472 6573 
08001C06  7320 6361 
08001C0A  6E        
08001C0B  6E6F 7420 3554          dc.b      110,111,116,32,98,101,32,103,114,101,97,116
08001C0F  6265 2067 
08001C13  7265 6174 
08001C17  6572 2074 3555          dc.b      101,114,32,116,104,97,110,32,48,120,48,49,102
08001C1B  6861 6E20 
08001C1F  3078 3031 
08001C23  66        
08001C24  6666 6621 3556          dc.b      102,102,102,33,32,73,110,112,117,116,32,97,103
08001C28  2049 6E70 
08001C2C  7574 2061 
08001C30  67        
08001C31  6169 6E3A 3557          dc.b      97,105,110,58,32,0
08001C35  2000      
                    3558   @m68kus~1_12:
08001C38  0D0A 5768 3559          dc.b      13,10,87,104,97,116,32,105,115,32,116,104,101
08001C3C  6174 2069 
08001C40  7320 7468 
08001C44  65        
08001C45  2064 6174 3560          dc.b      32,100,97,116,97,32,121,111,117,32,119,97,110
08001C49  6120 796F 
08001C4D  7520 7761 
08001C51  6E        
08001C52  7420 746F 3561          dc.b      116,32,116,111,32,119,114,105,116,101,32,105
08001C56  2077 7269 
08001C5A  7465 2069 
08001C5E  6E74 6F20 3562          dc.b      110,116,111,32,116,104,101,32,69,69,80,82,79
08001C62  7468 6520 
08001C66  4545 5052 
08001C6A  4F        
08001C6B  4D3F 2000 3563          dc.b      77,63,32,0
                    3564   @m68kus~1_13:
08001C70  0D0A 5261 3565          dc.b      13,10,82,97,110,100,111,109,32,69,69,80,82,79
08001C74  6E64 6F6D 
08001C78  2045 4550 
08001C7C  524F      
08001C7E  4D20 6279 3566          dc.b      77,32,98,121,116,101,32,119,114,105,116,101
08001C82  7465 2077 
08001C86  7269 7465 
08001C8A  00        3567          dc.b      0
                    3568   @m68kus~1_14:
08001C8C  0D0A 4545 3569          dc.b      13,10,69,69,80,82,79,77,32,119,114,105,116,116
08001C90  5052 4F4D 
08001C94  2077 7269 
08001C98  7474      
08001C9A  696E 6720 3570          dc.b      105,110,103,32,100,111,110,101,33,0
08001C9E  646F 6E65 
08001CA2  2100      
                    3571   @m68kus~1_15:
08001CA4  0D0A 5261 3572          dc.b      13,10,82,97,110,100,111,109,32,69,69,80,82,79
08001CA8  6E64 6F6D 
08001CAC  2045 4550 
08001CB0  524F      
08001CB2  4D20 6279 3573          dc.b      77,32,98,121,116,101,32,114,101,97,100,0
08001CB6  7465 2072 
08001CBA  6561 6400 
                    3574   @m68kus~1_16:
08001CBE  0D0A 4545 3575          dc.b      13,10,69,69,80,82,79,77,32,114,101,97,100,105
08001CC2  5052 4F4D 
08001CC6  2072 6561 
08001CCA  6469      
08001CCC  6E67 2064 3576          dc.b      110,103,32,100,111,110,101,33,32,37,120,0
08001CD0  6F6E 6521 
08001CD4  2025 7800 
                    3577   @m68kus~1_17:
08001CD8  0D0A 5768 3578          dc.b      13,10,87,104,97,116,32,105,115,32,116,104,101
08001CDC  6174 2069 
08001CE0  7320 7468 
08001CE4  65        
08001CE5  2045 4550 3579          dc.b      32,69,69,80,82,79,77,32,97,100,100,114,101,115
08001CE9  524F 4D20 
08001CED  6164 6472 
08001CF1  6573      
08001CF3  7320 7261 3580          dc.b      115,32,114,97,110,103,101,32,115,105,122,101
08001CF7  6E67 6520 
08001CFB  7369 7A65 
08001CFF  2028 696E 3581          dc.b      32,40,105,110,32,104,101,120,41,32,121,111,117
08001D03  2068 6578 
08001D07  2920 796F 
08001D0B  75        
08001D0C  2077 616E 3582          dc.b      32,119,97,110,116,32,116,111,32,97,99,99,101
08001D10  7420 746F 
08001D14  2061 6363 
08001D18  65        
08001D19  7373 3F20 3583          dc.b      115,115,63,32,0
08001D1D  00        
                    3584   @m68kus~1_18:
08001D1E  0D0A 5369 3585          dc.b      13,10,83,105,122,101,32,99,97,110,110,111,116
08001D22  7A65 2063 
08001D26  616E 6E6F 
08001D2A  74        
08001D2B  2062 6520 3586          dc.b      32,98,101,32,108,97,114,103,101,114,32,116,104
08001D2F  6C61 7267 
08001D33  6572 2074 
08001D37  68        
08001D38  616E 2027 3587          dc.b      97,110,32,39,104,48,50,48,48,48,48,32,40,49
08001D3C  6830 3230 
08001D40  3030 3020 
08001D44  2831      
08001D46  3238 4B20 3588          dc.b      50,56,75,32,98,121,116,101,115,41,44,32,105
08001D4A  6279 7465 
08001D4E  7329 2C20 
08001D52  69        
08001D53  6E70 7574 3589          dc.b      110,112,117,116,32,97,103,97,105,110,58,32,0
08001D57  2061 6761 
08001D5B  696E 3A20 
08001D5F  00        
                    3590   @m68kus~1_19:
08001D60  0D0A 5369 3591          dc.b      13,10,83,105,122,101,32,99,97,110,110,111,116
08001D64  7A65 2063 
08001D68  616E 6E6F 
08001D6C  74        
08001D6D  2062 6520 3592          dc.b      32,98,101,32,48,44,32,116,104,101,32,109,105
08001D71  302C 2074 
08001D75  6865 206D 
08001D79  69        
08001D7A  6E69 6D75 3593          dc.b      110,105,109,117,109,32,115,105,122,101,32,105
08001D7E  6D20 7369 
08001D82  7A65 2069 
08001D86  7320 2768 3594          dc.b      115,32,39,104,48,48,48,48,48,49,32,40,49,32
08001D8A  3030 3030 
08001D8E  3031 2028 
08001D92  3120      
08001D94  6279 7465 3595          dc.b      98,121,116,101,41,44,32,105,110,112,117,116
08001D98  292C 2069 
08001D9C  6E70 7574 
08001DA0  2061 6761 3596          dc.b      32,97,103,97,105,110,58,32,0
08001DA4  696E 3A20 
08001DA8  00        
                    3597   @m68kus~1_20:
08001DAA  0D0A 4D75 3598          dc.b      13,10,77,117,108,116,105,112,101,32,98,121,116
08001DAE  6C74 6970 
08001DB2  6520 6279 
08001DB6  74        
08001DB7  6573 2045 3599          dc.b      101,115,32,69,69,80,82,79,77,32,119,114,105
08001DBB  4550 524F 
08001DBF  4D20 7772 
08001DC3  69        
08001DC4  7465 00   3600          dc.b      116,101,0
                    3601   @m68kus~1_21:
08001DC8  0D0A 5772 3602          dc.b      13,10,87,114,105,116,116,105,110,103,46,46,46
08001DCC  6974 7469 
08001DD0  6E67 2E2E 
08001DD4  2E        
08001DD5  00        3603          dc.b      0
                    3604   @m68kus~1_22:
08001DD6  0D0A 4D75 3605          dc.b      13,10,77,117,108,116,105,112,108,101,32,98,121
08001DDA  6C74 6970 
08001DDE  6C65 2062 
08001DE2  79        
08001DE3  7465 7320 3606          dc.b      116,101,115,32,119,114,105,116,116,105,110,103
08001DE7  7772 6974 
08001DEB  7469 6E67 
08001DEF  2064 6F6E 3607          dc.b      32,100,111,110,101,0
08001DF3  6500      
                    3608   @m68kus~1_23:
08001DF6  0D0A 4D75 3609          dc.b      13,10,77,117,108,116,105,112,108,101,32,98,121
08001DFA  6C74 6970 
08001DFE  6C65 2062 
08001E02  79        
08001E03  7465 7320 3610          dc.b      116,101,115,32,69,69,80,82,79,77,32,114,101
08001E07  4545 5052 
08001E0B  4F4D 2072 
08001E0F  65        
08001E10  6164 00   3611          dc.b      97,100,0
                    3612   @m68kus~1_24:
08001E14  0D0A 4164 3613          dc.b      13,10,65,100,100,114,101,115,115,58,32,37,120
08001E18  6472 6573 
08001E1C  733A 2025 
08001E20  78        
08001E21  2C20 5265 3614          dc.b      44,32,82,101,97,100,32,100,97,116,97,58,32,37
08001E25  6164 2064 
08001E29  6174 613A 
08001E2D  2025      
08001E2F  7800      3615          dc.b      120,0
                    3616   @m68kus~1_25:
08001E32  0D0A 5573 3617          dc.b      13,10,85,115,105,110,103,32,68,65,67,32,116
08001E36  696E 6720 
08001E3A  4441 4320 
08001E3E  74        
08001E3F  6F20 636F 3618          dc.b      111,32,99,111,110,116,114,111,108,32,76,69,68
08001E43  6E74 726F 
08001E47  6C20 4C45 
08001E4B  44        
08001E4C  00        3619          dc.b      0
                    3620   @m68kus~1_26:
08001E4E  0D0A 5265 3621          dc.b      13,10,82,101,97,100,105,110,103,32,118,97,108
08001E52  6164 696E 
08001E56  6720 7661 
08001E5A  6C        
08001E5B  7565 7320 3622          dc.b      117,101,115,32,102,114,111,109,32,116,104,101
08001E5F  6672 6F6D 
08001E63  2074 6865 
08001E67  2041 4443 3623          dc.b      32,65,68,67,0
08001E6B  00        
                    3624   @m68kus~1_27:
08001E6C  0D0A 5265 3625          dc.b      13,10,82,101,97,100,32,100,97,116,97,58,32,37
08001E70  6164 2064 
08001E74  6174 613A 
08001E78  2025      
08001E7A  7800      3626          dc.b      120,0
                    3627   @m68kus~1_28:
08001E7C  0D0A 5768 3628          dc.b      13,10,87,104,105,99,104,32,99,104,97,110,110
08001E80  6963 6820 
08001E84  6368 616E 
08001E88  6E        
08001E89  656C 2079 3629          dc.b      101,108,32,121,111,117,32,119,97,110,116,32
08001E8D  6F75 2077 
08001E91  616E 7420 
08001E95  746F 2072 3630          dc.b      116,111,32,114,101,97,100,63,32,49,46,32,80
08001E99  6561 643F 
08001E9D  2031 2E20 
08001EA1  50        
08001EA2  6F74 656E 3631          dc.b      111,116,101,110,116,105,111,109,101,116,101
08001EA6  7469 6F6D 
08001EAA  6574 65   
08001EAD  7220 322E 3632          dc.b      114,32,50,46,80,104,111,116,111,114,101,115
08001EB1  5068 6F74 
08001EB5  6F72 6573 
08001EB9  6973 746F 3633          dc.b      105,115,116,111,114,32,51,46,84,104,101,114
08001EBD  7220 332E 
08001EC1  5468 6572 
08001EC5  6D69 7374 3634          dc.b      109,105,115,116,111,114,32,0
08001EC9  6F72 2000 
                    3635   @m68kus~1_29:
08001ECE  0D0A 496E 3636          dc.b      13,10,73,110,118,97,108,105,100,32,115,101,108
08001ED2  7661 6C69 
08001ED6  6420 7365 
08001EDA  6C        
08001EDB  6563 7469 3637          dc.b      101,99,116,105,111,110,33,0
08001EDF  6F6E 2100 
                    3638   @itoa_1:
08001EE4  2D32 3134 3639          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
08001EE8  3734 3833 
08001EEC  3634 3800 
                    3640   __ctype:
08001EF0  0040 4040 3641          dc.b      0,64,64,64,64,64,64,64,64,64,80,80,80,80,80
08001EF4  4040 4040 
08001EF8  4040 5050 
08001EFC  5050 50   
08001EFF  4040 4040 3642          dc.b      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
08001F03  4040 4040 
08001F07  4040 4040 
08001F0B  4040 40   
08001F0E  4040 40D0 3643          dc.b      64,64,64,208,160,160,160,160,160,160,160,160
08001F12  A0A0 A0A0 
08001F16  A0A0 A0A0 
08001F1A  A0A0 A0A0 3644          dc.b      160,160,160,160,160,160,160,140,140,140,140
08001F1E  A0A0 A08C 
08001F22  8C8C 8C   
08001F25  8C8C 8C8C 3645          dc.b      140,140,140,140,140,140,160,160,160,160,160
08001F29  8C8C A0A0 
08001F2D  A0A0 A0   
08001F30  A0A0 8A8A 3646          dc.b      160,160,138,138,138,138,138,138,130,130,130
08001F34  8A8A 8A8A 
08001F38  8282 82   
08001F3B  8282 8282 3647          dc.b      130,130,130,130,130,130,130,130,130,130,130
08001F3F  8282 8282 
08001F43  8282 82   
08001F46  8282 8282 3648          dc.b      130,130,130,130,130,130,160,160,160,160,160
08001F4A  8282 A0A0 
08001F4E  A0A0 A0   
08001F51  A089 8989 3649          dc.b      160,137,137,137,137,137,137,129,129,129,129
08001F55  8989 8981 
08001F59  8181 81   
08001F5C  8181 8181 3650          dc.b      129,129,129,129,129,129,129,129,129,129,129
08001F60  8181 8181 
08001F64  8181 81   
08001F67  8181 8181 3651          dc.b      129,129,129,129,129,160,160,160,160,64,0,0,0
08001F6B  81A0 A0A0 
08001F6F  A040 0000 
08001F73  00        
08001F74  0000 0000 3652          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
08001F78  0000 0000 
08001F7C  0000 0000 
08001F80  0000 0000 
08001F84  0000 0000 
08001F88  0000      
08001F8A  0000 0000 3653          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
08001F8E  0000 0000 
08001F92  0000 0000 
08001F96  0000 0000 
08001F9A  0000 0000 
08001F9E  0000      
08001FA0  0000 0000 3654          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
08001FA4  0000 0000 
08001FA8  0000 0000 
08001FAC  0000 0000 
08001FB0  0000 0000 
08001FB4  0000      
08001FB6  0000 0000 3655          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
08001FBA  0000 0000 
08001FBE  0000 0000 
08001FC2  0000 0000 
08001FC6  0000 0000 
08001FCA  0000      
08001FCC  0000 0000 3656          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
08001FD0  0000 0000 
08001FD4  0000 0000 
08001FD8  0000 0000 
08001FDC  0000 0000 
08001FE0  0000      
08001FE2  0000 0000 3657          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
08001FE6  0000 0000 
08001FEA  0000 0000 
08001FEE  0000 00   
                    3658          section   data
08001FF2            3659                   align
                    3660   
                    3661   *********************************************************************************************************************************************************
                    3662   * Section for Initialised Data (in theory should be copied to Ram at startup) but is part of program code as we copy whole program to ram at startup
                    3663   ********************************************************************************************************************************************************
                    3664   
          0800 1FF2 3665   DataStart       equ       *
08001FF2            3666   __ungetbuf:     ds.l      1                    ungetbuffer for stdio functions
08001FF6            3667   __allocp:       ds.l      1                    start of free memory block list
08001FFA            3668   __heap:         ds.l      1                    begin of free memory
                    3669   
                    3670   
                    3671          section   bss
08001FFE            3672                   align
                    3673   
          0800 1FFE 3674   DataEnd         equ       *                    this label will equate to the address of the last byte of global variable in it
          0000 000C 3675   DataLength      equ       DataEnd-DataStart    length of data needed to copy to Ram on bootup
                    3676   
                    3677   *********************************************************************************************************
                    3678   * Section for uninitialised Data which is set to zero, i.e. we should set this space to zero at starup
                    3679   *********************************************************************************************************
          0800 1FFE 3680   BssStart       equ       *
                    3681   
                    3682   _i:
08001FFE            3683          ds.b      4
                    3684   _x:
08002002            3685          ds.b      4
                    3686   _y:
08002006            3687          ds.b      4
                    3688   _z:
0800200A            3689          ds.b      4
                    3690   _PortA_Count:
0800200E            3691          ds.b      4
                    3692   _Timer1Count:
08002012            3693          ds.b      1
                    3694   _Timer2Count:
08002014            3695          ds.b      1
                    3696   _Timer3Count:
08002016            3697          ds.b      1
                    3698   _Timer4Count:
08002018            3699          ds.b      1
                    3700          section   heap
0800201A            3701                  align
                    3702   
          0800 201A 3703   BssEnd         equ       *
          0000 001C 3704   BssLength      equ       BssEnd-BssStart       length of zeroed data needed to copy to Ram on bootup
                    3705   
                    3706   *********************************************************************************************************
                    3707   * Section for Heap
                    3708   *********************************************************************************************************
                    3709   
          0800 201A 3710   heap           equ       *
0800201A            3711                  align
          0800 0000

Assembly errors: 0
