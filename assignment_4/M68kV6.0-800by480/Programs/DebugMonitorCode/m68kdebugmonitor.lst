680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 03 Mar 2023      Time: 15:38:57          Source: C:\M68KV6.0-800BY480\PROGRAMS\DEBUGMONITORCODE\M68KDEBUGMONITOR.SRC

                       1          section   code
                       2   ; for initial stack use $08040000 if your system uses SRAM for main memory (top of 256kbyte SRAM space)
                       3   ; When your system is converted to use DRAM for main memory set this constant to $0C000000 (top of 64MByte DRAM space
                       4   
                       5   ;StackPointerVal     equ $08040000      when using sram
          0C00 0000    6   StackPointerVal     equ $0C000000      when using dram
                       7   
                       8   ; define RamVectorTable as $0803000 if your system uses SRAM for main memory
                       9   ; When your system is converted to use DRAM for main memory define RamVectorTable constant as $0B000000 (top of 64MByte DRAM space)
                      10   
                      11   ;RamVectorTable      equ $08030000      when using sram
          0B00 0000   12   RamVectorTable      equ $0B000000      when using dram
                      13   
                      14   
                      15   
                      16   ; CSTART.ASM  -  C startup-code for Debug Monitor
00000000              17                   align
                      18   
00000000              19                   org $00000000          ;start of rom based vector table, 68k hard wired to expect this at $0
                      20   
00000000  0C00 0000   21   InitialSP       dc.l StackPointerVal   ;initial supervisor state stack pointer(stack decrements first before being used)
00000004  0000 0400   22   InitialPC       dc.l start             ;address of 1st instruction of program after a reset
00000008  0000 0808   23   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 081A   24   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 082C   25   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 083E   26   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 0850   27   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 0862   28   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 0874   29   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0886   30   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0898   31   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 08AA   32   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 08BC   33   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 08BC   34   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 08BC   35   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 08BC   36   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 08BC   37   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 08BC   38   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 08BC   39   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 08BC   40   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 08BC   41   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 08BC   42   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 08BC   43   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 08BC   44   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 08BC   45   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      46   *
                      47   *
00000064  0000 04A0   48   Level1IRQ       dc.l Level1RamISR
00000068  0000 04B2   49   Level2IRQ       dc.l Level2RamISR
0000006C  0000 04C4   50   Level3IRQ       dc.l Level3RamISR
00000070  0000 04D6   51   Level4IRQ       dc.l Level4RamISR
00000074  0000 04E8   52   Level5IRQ       dc.l Level5RamISR
00000078  0000 05F2   53   Level6IRQ       dc.l Level6RamISR
0000007C  0000 0604   54   Level7IRQ       dc.l Level7RamISR
                      55   *
                      56   *
00000080  0000 0616   57   Trap0           dc.l Trap0RamISR        ; User installed trap handler
00000084  0000 0628   58   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 063A   59   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 064C   60   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 065E   61   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 0670   62   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 0682   63   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 0694   64   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 06A6   65   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 06B8   66   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 06CA   67   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 06DC   68   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 06EE   69   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 0700   70   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 0712   71   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 0802   72   Trap15          dc.l Trap15RamISR       ; User installed trap handler
                      73   
                      74   *
                      75   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                      76   *
                      77   
00000400              78                   org       $00000400 
                      79   
00000400  46FC 2700   80   start:          move.w     #$2700,SR             set interrupts to disable until later
                      81   
                      82   *************************************************************************************
                      83   ** add some 68000 instruction to read and write to memory, IO etc. This doesn't do anything
                      84   ** important, it just creates read and write bus cycles to specific addresses which
                      85   ** help with debugging hardware in Quartus simulations
                      86   **************************************************************************************
                      87   
                      88                   ; perform some dummy read/write of 32 bit values to memory to see waveforms during a simulation
                      89   
                      90                   ;move.l     #$11223344,$08060000 write 32 bits, to memory
                      91                   ;move.l     $08060000,d0         read 32 bits back
00000404  23FC 0000   92                   move.l     #$6666,$08060002       
00000408  6666 0806 
0000040C  0002      
0000040E  2039 0806   93                   move.l     $08060002,d0
00000412  0002      
00000414  2039 0806   94                   move.l     $08060003,d0
00000418  0003      
0000041A  13FC 0000   95                   move.b     #$00,$00400000         write to the output ports
0000041E  0040 0000 
00000422  13FC 0000   96                   move.b     #$00,$00400002         write to the output ports
00000426  0040 0002 
0000042A  13FC 0000   97                   move.b     #$00,$00400004         write to the output ports
0000042E  0040 0004 
00000432  13FC 0000   98                   move.b     #$00,$00400006         write to the output ports
00000436  0040 0006 
0000043A  13FC 0000   99                   move.b     #$00,$00400008         write to the output ports
0000043E  0040 0008 
00000442  13FC 0000  100                   move.b     #$00,$00400010         write to the hex display ports
00000446  0040 0010 
0000044A  13FC 0000  101                   move.b     #$00,$00400012         write to the hex display ports
0000044E  0040 0012 
00000452  13FC 0000  102                   move.b     #$00,$00400014         write to the hex display ports
00000456  0040 0014 
0000045A  13FC 0000  103                   move.b     #0,$00400020         write to the LCD
0000045E  0040 0020 
00000462  13FC 0000  104                   move.b     #0,$00400022         write to the LCD
00000466  0040 0022 
0000046A  13FC 0000  105                   move.b     #0,$00400030         write to the Timer1 Data
0000046E  0040 0030 
00000472  13FC 0000  106                   move.b     #0,$00400032         write to the Timer1 Control
00000476  0040 0032 
                     107   
                     108                   ; some important initialisation do not modify
0000047A  23FC FFFF  109                   move.l    #-1,__ungetbuf  ; unget-buffer for keyboard input
0000047E  FFFF 0B00 
00000482  00C0      
00000484  23FC 0000  110                   move.l    #0,__allocp     ; pointer to allocated memory for malloc-function
00000488  0000 0B00 
0000048C  00C4      
0000048E  23FC 0B00  111                   move.l    #heap,__heap    ; pointer to free memory
00000492  0546 0B00 
00000496  00C4      
                     112   
                     113   
00000498  4EB9 0000  114   mainloop        jsr       _main
0000049C  2F7A      
0000049E  60F8       115                   bra       mainloop
                     116   
                     117   *********************************************************************************************************
                     118   * Code to call Ram Based Interrupt handler and other exeception handler code
                     119   *********************************************************************************************************
000004A0  48E7 FFFE  120   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004A4  2079 0B00  121                   move.l    VL1IRQ,a0               get ram based address into a0
000004A8  0064      
000004AA  4E90       122                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004AC  4CDF 7FFF  123                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004B0  4E73       124                   rte
000004B2  48E7 FFFE  125   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B6  2079 0B00  126                   move.l    VL2IRQ,a0               get ram based address into a0
000004BA  0068      
000004BC  4E90       127                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004BE  4CDF 7FFF  128                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004C2  4E73       129                   rte
000004C4  48E7 FFFE  130   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C8  2079 0B00  131                   move.l    VL3IRQ,a0               get ram based address into a0
000004CC  006C      
000004CE  4E90       132                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004D0  4CDF 7FFF  133                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004D4  4E73       134                   rte
000004D6  48E7 FFFE  135   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004DA  2079 0B00  136                   move.l    VL4IRQ,a0               get ram based address into a0
000004DE  0070      
000004E0  4E90       137                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004E2  4CDF 7FFF  138                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E6  4E73       139                   rte
                     140   
                     141   * Trace trap Handler
                     142   
                     143   Level5RamISR
                     144   *
                     145   **         Copy 68000 registers from debug monitor Variables,
                     146   *
                     147   *
000004E8  23FC 0000  148                   move.l    #1,_Trace              switch on Trace Mode
000004EC  0001 0B00 
000004F0  00D8      
000004F2  13FC 0000  149                   move.b    #$0,$0040000A          turn off a trace exception so we don't when generate a trace when disassembling instruction in the register dump (disassembling causes access to use program)
000004F6  0040 000A 
000004FA  33DF 0B00  150                   move.w    (sp)+,_SR              get at the users status register pointed to by stack pointer and copy
000004FE  012C      
00000500  23DF 0B00  151                   move.l    (sp)+,_PC              get at the users program counter and copy
00000504  0120      
                     152   *
00000506  23CF 0B00  153                   move.l    SP,_SSP                copy system stack pointer to debug monitor variable
0000050A  0124      
0000050C  23C0 0B00  154                   move.l    d0,_d0
00000510  00E4      
00000512  23C1 0B00  155                   move.l    d1,_d1
00000516  00E8      
00000518  23C2 0B00  156                   move.l    d2,_d2
0000051C  00EC      
0000051E  23C3 0B00  157                   move.l    d3,_d3
00000522  00F0      
00000524  23C4 0B00  158                   move.l    d4,_d4
00000528  00F4      
0000052A  23C5 0B00  159                   move.l    d5,_d5
0000052E  00F8      
00000530  23C6 0B00  160                   move.l    d6,_d6
00000534  00FC      
00000536  23C7 0B00  161                   move.l    d7,_d7
0000053A  0100      
                     162   *
0000053C  23C8 0B00  163                   move.l    a0,_a0
00000540  0104      
00000542  23C9 0B00  164                   move.l    a1,_a1
00000546  0108      
00000548  23CA 0B00  165                   move.l    a2,_a2
0000054C  010C      
0000054E  23CB 0B00  166                   move.l    a3,_a3
00000552  0110      
00000554  23CC 0B00  167                   move.l    a4,_a4
00000558  0114      
0000055A  23CD 0B00  168                   move.l    a5,_a5
0000055E  0118      
00000560  23CE 0B00  169                   move.l    a6,_a6
00000564  011C      
00000566  4E68       170                   move.l    usp,a0
00000568  23C8 0B00  171                   move.l    a0,_USP
0000056C  0128      
                     172   *
0000056E  2079 0B00  173                   move.l    VL5IRQ,a0              get ram based address into a0, trace exception for next instruction will be generated in Menu SPACE command
00000572  0074      
00000574  4E90       174                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     175   
                     176   ** After trace, reload 68000 registers with new values before continuing
                     177   
00000576  2039 0B00  178                   move.l   _d0,d0
0000057A  00E4      
0000057C  2239 0B00  179                   move.l   _d1,d1
00000580  00E8      
00000582  2439 0B00  180                   move.l   _d2,d2
00000586  00EC      
00000588  2639 0B00  181                   move.l   _d3,d3
0000058C  00F0      
0000058E  2839 0B00  182                   move.l   _d4,d4
00000592  00F4      
00000594  2A39 0B00  183                   move.l   _d5,d5
00000598  00F8      
0000059A  2C39 0B00  184                   move.l   _d6,d6
0000059E  00FC      
000005A0  2E39 0B00  185                   move.l   _d7,d7
000005A4  0100      
                     186   
000005A6  2079 0B00  187                   move.l   _USP,a0
000005AA  0128      
000005AC  4E60       188                   move.l   a0,USP                     load user stack pointer
000005AE  2079 0B00  189                   move.l   _a0,a0
000005B2  0104      
000005B4  2279 0B00  190                   move.l   _a1,a1
000005B8  0108      
000005BA  2479 0B00  191                   move.l   _a2,a2
000005BE  010C      
000005C0  2679 0B00  192                   move.l   _a3,a3
000005C4  0110      
000005C6  2879 0B00  193                   move.l   _a4,a4
000005CA  0114      
000005CC  2A79 0B00  194                   move.l   _a5,a5
000005D0  0118      
000005D2  2C79 0B00  195                   move.l   _a6,a6
000005D6  011C      
                     196   
000005D8  2E79 0B00  197                   move.l   _SSP,sp
000005DC  0124      
000005DE  2F39 0B00  198                   move.l   _PC,-(sp)
000005E2  0120      
000005E4  3F39 0B00  199                   move.w   _SR,-(sp)
000005E8  012C      
000005EA  11F8 0074  200                   move.b    $00000074,$0	          read trace exception vector after accessing disassembly to reset the trace request causes by disassembling program above
000005EE  0000      
000005F0  4E73       201                   rte
                     202   
                     203   * address trap handler
                     204   
000005F2  48E7 FFFE  205   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005F6  2079 0B00  206                   move.l    VL6IRQ,a0               get ram based address into a0
000005FA  0078      
000005FC  4E90       207                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000005FE  4CDF 7FFF  208                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000602  4E73       209                   rte
                     210   
00000604  48E7 FFFE  211   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000608  2079 0B00  212                   move.l    VL7IRQ,a0               get ram based address into a0
0000060C  007C      
0000060E  4E90       213                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000610  4CDF 7FFF  214                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000614  4E73       215                   rte
                     216   
                     217   
                     218   ********************************************************************************************************
                     219   * Ram based Trap handler and other exeception handler code
                     220   *********************************************************************************************************
                     221   
00000616  48E7 FFFE  222   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000061A  2079 0B00  223                   move.l    VTrap0,a0                get ram based address into a0
0000061E  0080      
00000620  4E90       224                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000622  4CDF 7FFF  225                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000626  4E73       226                   rte
                     227   
00000628  48E7 FFFE  228   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000062C  2079 0B00  229                   move.l    VTrap1,a0                get ram based address into a0
00000630  0084      
00000632  4E90       230                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000634  4CDF 7FFF  231                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000638  4E73       232                   rte
                     233   
0000063A  48E7 FFFE  234   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000063E  2079 0B00  235                   move.l    VTrap2,a0                get ram based address into a0
00000642  0088      
00000644  4E90       236                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000646  4CDF 7FFF  237                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000064A  4E73       238                   rte
                     239   
0000064C  48E7 FFFE  240   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000650  2079 0B00  241                   move.l    VTrap3,a0                get ram based address into a0
00000654  008C      
00000656  4E90       242                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000658  4CDF 7FFF  243                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000065C  4E73       244                   rte
                     245   
0000065E  48E7 FFFE  246   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000662  2079 0B00  247                   move.l    VTrap4,a0                get ram based address into a0
00000666  0090      
00000668  4E90       248                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000066A  4CDF 7FFF  249                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000066E  4E73       250                   rte
                     251   
00000670  48E7 FFFE  252   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000674  2079 0B00  253                   move.l    VTrap5,a0                get ram based address into a0
00000678  0094      
0000067A  4E90       254                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000067C  4CDF 7FFF  255                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000680  4E73       256                   rte
                     257   
00000682  48E7 FFFE  258   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000686  2079 0B00  259                   move.l    VTrap6,a0                get ram based address into a0
0000068A  0098      
0000068C  4E90       260                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000068E  4CDF 7FFF  261                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000692  4E73       262                   rte
                     263   
00000694  48E7 FFFE  264   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000698  2079 0B00  265                   move.l    VTrap7,a0                get ram based address into a0
0000069C  009C      
0000069E  4E90       266                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006A0  4CDF 7FFF  267                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006A4  4E73       268                   rte
                     269   
000006A6  48E7 FFFE  270   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006AA  2079 0B00  271                   move.l    VTrap8,a0                get ram based address into a0
000006AE  00A0      
000006B0  4E90       272                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006B2  4CDF 7FFF  273                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006B6  4E73       274                   rte
                     275   
000006B8  48E7 FFFE  276   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006BC  2079 0B00  277                   move.l    VTrap9,a0                get ram based address into a0
000006C0  00A4      
000006C2  4E90       278                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006C4  4CDF 7FFF  279                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006C8  4E73       280                   rte
                     281   
000006CA  48E7 FFFE  282   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006CE  2079 0B00  283                   move.l    VTrap10,a0                get ram based address into a0
000006D2  00A8      
000006D4  4E90       284                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006D6  4CDF 7FFF  285                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006DA  4E73       286                   rte
                     287   
000006DC  48E7 FFFE  288   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006E0  2079 0B00  289                   move.l    VTrap11,a0                get ram based address into a0
000006E4  00AC      
000006E6  4E90       290                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006E8  4CDF 7FFF  291                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006EC  4E73       292                   rte
                     293   
000006EE  48E7 FFFE  294   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006F2  2079 0B00  295                   move.l    VTrap12,a0                get ram based address into a0
000006F6  00B0      
000006F8  4E90       296                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006FA  4CDF 7FFF  297                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006FE  4E73       298                   rte
                     299   
00000700  48E7 FFFE  300   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000704  2079 0B00  301                   move.l    VTrap13,a0                get ram based address into a0
00000708  00B4      
0000070A  4E90       302                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000070C  4CDF 7FFF  303                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000710  4E73       304                   rte
                     305   
                     306   Trap14RamISR    ;Break Point Handler
                     307   *
                     308   **         Copy 68000 registers from debug monitor Variables
                     309   *
00000712  23FC 0000  310                   move.l    #1,_Trace      switch on Trace Mode
00000716  0001 0B00 
0000071A  00D8      
0000071C  33DF 0B00  311                   move.w    (sp)+,_SR       get at the users status register pointed to by stack pointer and copy
00000720  012C      
00000722  23DF 0B00  312                   move.l    (sp)+,_PC      get at the users program counter and copy
00000726  0120      
                     313   *
00000728  23C0 0B00  314                   move.l    d0,_d0
0000072C  00E4      
0000072E  23C1 0B00  315                   move.l    d1,_d1
00000732  00E8      
00000734  23C2 0B00  316                   move.l    d2,_d2
00000738  00EC      
0000073A  23C3 0B00  317                   move.l    d3,_d3
0000073E  00F0      
00000740  23C4 0B00  318                   move.l    d4,_d4
00000744  00F4      
00000746  23C5 0B00  319                   move.l    d5,_d5
0000074A  00F8      
0000074C  23C6 0B00  320                   move.l    d6,_d6
00000750  00FC      
00000752  23C7 0B00  321                   move.l    d7,_d7
00000756  0100      
                     322   *
00000758  23C8 0B00  323                   move.l    a0,_a0
0000075C  0104      
0000075E  23C9 0B00  324                   move.l    a1,_a1
00000762  0108      
00000764  23CA 0B00  325                   move.l    a2,_a2
00000768  010C      
0000076A  23CB 0B00  326                   move.l    a3,_a3
0000076E  0110      
00000770  23CC 0B00  327                   move.l    a4,_a4
00000774  0114      
00000776  23CD 0B00  328                   move.l    a5,_a5
0000077A  0118      
0000077C  23CE 0B00  329                   move.l    a6,_a6
00000780  011C      
00000782  4E68       330                   move.l    USP,a0
00000784  23C8 0B00  331                   move.l    a0,_USP
00000788  0128      
                     332   *
0000078A  2079 0B00  333                   move.l    VTrap14,a0             get ram based address into a0
0000078E  00B8      
00000790  4E90       334                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     335   
                     336   ** After breakpoint reload 68000 registers with new values before continuing
                     337   
                     338   *                move.b    #$ff,$0040000A     generate a trace exception for the next instruction
00000792  2039 0B00  339                   move.l   _d0,d0
00000796  00E4      
00000798  2239 0B00  340                   move.l   _d1,d1
0000079C  00E8      
0000079E  2439 0B00  341                   move.l   _d2,d2
000007A2  00EC      
000007A4  2639 0B00  342                   move.l   _d3,d3
000007A8  00F0      
000007AA  2839 0B00  343                   move.l   _d4,d4
000007AE  00F4      
000007B0  2A39 0B00  344                   move.l   _d5,d5
000007B4  00F8      
000007B6  2C39 0B00  345                   move.l   _d6,d6
000007BA  00FC      
000007BC  2E39 0B00  346                   move.l   _d7,d7
000007C0  0100      
                     347   
000007C2  2079 0B00  348                   move.l   _USP,a0
000007C6  0128      
000007C8  4E60       349                   move.l   a0,USP        load user stack pointer A7
000007CA  2079 0B00  350                   move.l   _a0,a0
000007CE  0104      
000007D0  2279 0B00  351                   move.l   _a1,a1
000007D4  0108      
000007D6  2479 0B00  352                   move.l   _a2,a2
000007DA  010C      
000007DC  2679 0B00  353                   move.l   _a3,a3
000007E0  0110      
000007E2  2879 0B00  354                   move.l   _a4,a4
000007E6  0114      
000007E8  2A79 0B00  355                   move.l   _a5,a5
000007EC  0118      
000007EE  2C79 0B00  356                   move.l   _a6,a6
000007F2  011C      
                     357   
000007F4  2F39 0B00  358                   move.l   _PC,-(sp)
000007F8  0120      
000007FA  3F39 0B00  359                   move.w   _SR,-(sp)
000007FE  012C      
00000800  4E73       360                   rte
                     361   
00000802  4EF9 0000  362   Trap15RamISR    jmp     _CallDebugMonitor
00000806  2302      
                     363   *                movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                     364   *                move.l    VTrap15,a0                get ram based address into a0
                     365   *                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                     366   *                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                     367   *                rte
                     368   
                     369   *********************************************************************************************************
                     370   *Default exception handler for everything without a specific handler
                     371   *********************************************************************************************************
                     372   
                     373   *
                     374   **              Jump here for each unhandled exception
                     375   **              If you need to, MAKE SURE YOU SAVE ALL IMPORTANT REGISTERS AND RESTORE THEM BEFORE RETURNING (IF APPROPRIATE)
                     376   *
                     377   
00000808  48E7 FFFE  378   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000080C  2079 0B00  379                   move.l    VBusError,a0            get ram based address into a0
00000810  0008      
00000812  4E90       380                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000814  4CDF 7FFF  381                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000818  4E73       382                   rte
0000081A  48E7 FFFE  383   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000081E  2079 0B00  384                   move.l    VAddressError,a0        get ram based address into a0
00000822  000C      
00000824  4E90       385                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000826  4CDF 7FFF  386                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000082A  4E73       387                   rte
0000082C  48E7 FFFE  388   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000830  2079 0B00  389                   move.l    VIllegalInstr,a0        get ram based address into a0
00000834  0010      
00000836  4E90       390                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000838  4CDF 7FFF  391                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000083C  4E73       392                   rte
0000083E  48E7 FFFE  393   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000842  2079 0B00  394                   move.l    VDividebyZero,a0        get ram based address into a0
00000846  0014      
00000848  4E90       395                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000084A  4CDF 7FFF  396                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000084E  4E73       397                   rte
00000850  48E7 FFFE  398   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000854  2079 0B00  399                   move.l    VCheck,a0               get ram based address into a0
00000858  0018      
0000085A  4E90       400                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000085C  4CDF 7FFF  401                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000860  4E73       402                   rte
00000862  48E7 FFFE  403   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000866  2079 0B00  404                   move.l    VTrapV,a0               get ram based address into a0
0000086A  001C      
0000086C  4E90       405                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000086E  4CDF 7FFF  406                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000872  4E73       407                   rte
00000874  48E7 FFFE  408   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000878  2079 0B00  409                   move.l    VPrivilege,a0           get ram based address into a0
0000087C  0020      
0000087E  4E90       410                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000880  4CDF 7FFF  411                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000884  4E73       412                   rte
00000886  48E7 FFFE  413   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000088A  2079 0B00  414                   move.l    VTrace,a0               get ram based address into a0
0000088E  0024      
00000890  4E90       415                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000892  4CDF 7FFF  416                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000896  4E73       417                   rte
00000898  48E7 FFFE  418   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000089C  2079 0B00  419                   move.l    VLine1010emul,a0        get ram based address into a0
000008A0  0028      
000008A2  4E90       420                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000008A4  4CDF 7FFF  421                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008A8  4E73       422                   rte
000008AA  48E7 FFFE  423   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000008AE  2079 0B00  424                   move.l    VLine1111emul,a0        get ram based address into a0
000008B2  002C      
000008B4  4E90       425                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000008B6  4CDF 7FFF  426                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008BA  4E73       427                   rte
                     428   E_Unnas1
                     429   E_Unnas2
                     430   E_Unnas3
                     431   E_UnitI
                     432   E_Unnas4
                     433   E_Unnas5
                     434   E_Unnas6
                     435   E_Unnas7
                     436   E_Unnas8
                     437   E_Unnas9
                     438   E_Unnas10
                     439   E_Unnas11
                     440   E_Spuri
000008BC  60FE       441   _stop            bra _stop                         stop
                     442   ***************************************************************************************************
                     443   * Go() function in debug monitor
                     444   ***************************************************************************************************
                     445   _go
000008BE  2E79 0B00  446                   move.l   _SSP,a7        load system stack pointer (remember we are in supervisor mode when running this so a7 is the System stack pointer)
000008C2  0124      
000008C4  2F39 0B00  447                   move.l   _PC,-(sp)      copy debug monitor PC variable to the stack
000008C8  0120      
000008CA  3F39 0B00  448                   move.w   _SR,-(sp)      copy debug monitor status reg to the stack
000008CE  012C      
                     449   
000008D0  1038 0078  450                   move.b   $00000078,d0  remove any spurious address exception arising after power on
000008D4  2039 0B00  451                   move.l   _d0,d0
000008D8  00E4      
000008DA  2239 0B00  452                   move.l   _d1,d1
000008DE  00E8      
000008E0  2439 0B00  453                   move.l   _d2,d2
000008E4  00EC      
000008E6  2639 0B00  454                   move.l   _d3,d3
000008EA  00F0      
000008EC  2839 0B00  455                   move.l   _d4,d4
000008F0  00F4      
000008F2  2A39 0B00  456                   move.l   _d5,d5
000008F6  00F8      
000008F8  2C39 0B00  457                   move.l   _d6,d6
000008FC  00FC      
000008FE  2E39 0B00  458                   move.l   _d7,d7
00000902  0100      
                     459   
00000904  2079 0B00  460                   move.l   _USP,a0
00000908  0128      
0000090A  4E60       461                   move.l   a0,USP        load user stack pointer (remember we are in supervisor mode when running this, so a7 is the System stack pointer)
0000090C  2079 0B00  462                   move.l   _a0,a0
00000910  0104      
00000912  2279 0B00  463                   move.l   _a1,a1
00000916  0108      
00000918  2479 0B00  464                   move.l   _a2,a2
0000091C  010C      
0000091E  2679 0B00  465                   move.l   _a3,a3
00000922  0110      
00000924  2879 0B00  466                   move.l   _a4,a4
00000928  0114      
0000092A  2A79 0B00  467                   move.l   _a5,a5
0000092E  0118      
00000930  2C79 0B00  468                   move.l   _a6,a6
00000934  011C      
00000936  4E73       469                   rte                    load the status reg and PC from the stack and commence running
                     470                                          *used to be rte but this didn't load the status byte
                     471   
                     472   ; C:\M68KV6.0-800BY480\PROGRAMS\DEBUGMONITORCODE\M68KDEBUG (NO DISASSEMBLER).C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     473   ; #include "DebugMonitor.h"
                     474   ; // use 08030000 for a system running from sram or 0B000000 for system running from dram
                     475   ; //#define StartOfExceptionVectorTable 0x08030000
                     476   ; #define StartOfExceptionVectorTable 0x0B000000
                     477   ; // use 0C000000 for dram or hex 08040000 for sram
                     478   ; //#define TopOfStack 0x08040000
                     479   ; #define TopOfStack 0x0C000000
                     480   ; // the start address of the sdram
                     481   ; #define start_of_dram 0x08000000
                     482   ; /*************************************************************
                     483   ; ** SPI Controller registers
                     484   ; **************************************************************/
                     485   ; // SPI Registers
                     486   ; #define SPI_Control         (*(volatile unsigned char *)(0x00408020))
                     487   ; #define SPI_Status          (*(volatile unsigned char *)(0x00408022))
                     488   ; #define SPI_Data            (*(volatile unsigned char *)(0x00408024))
                     489   ; #define SPI_Ext             (*(volatile unsigned char *)(0x00408026))
                     490   ; #define SPI_CS              (*(volatile unsigned char *)(0x00408028))
                     491   ; // these two macros enable or disable the flash memory chip enable off SSN_O[7..0]
                     492   ; // in this case we assume there is only 1 device connected to SSN_O[0] so we can
                     493   ; // write hex FE to the SPI_CS to enable it (the enable on the flash chip is active low)
                     494   ; // and write FF to disable it
                     495   ; #define   Enable_SPI_CS()             SPI_CS = 0xFE
                     496   ; #define   Disable_SPI_CS()            SPI_CS = 0xFF
                     497   ; // SPI flash chip commands
                     498   ; #define write_enable_cmd 0x06
                     499   ; #define erasing_cmd  0xc7
                     500   ; #define read_cmd  0x03
                     501   ; #define write_cmd  0x02
                     502   ; #define check_status_cmd 0x05
                     503   ; /* DO NOT INITIALISE GLOBAL VARIABLES - DO IT in MAIN() */
                     504   ; unsigned int i, x, y, z, PortA_Count;
                     505   ; int     Trace, GoFlag, Echo;                       // used in tracing/single stepping
                     506   ; // 68000 register dump and preintialise value (these can be changed by the user program when it is running, e.g. stack pointer, registers etc
                     507   ; unsigned int d0,d1,d2,d3,d4,d5,d6,d7 ;
                     508   ; unsigned int a0,a1,a2,a3,a4,a5,a6 ;
                     509   ; unsigned int PC, SSP, USP ;
                     510   ; unsigned short int SR;
                     511   ; // Breakpoint variables
                     512   ; unsigned int BreakPointAddress[8];                      //array of 8 breakpoint addresses
                     513   ; unsigned short int BreakPointInstruction[8] ;           // to hold the instruction opcode at the breakpoint
                     514   ; unsigned int BreakPointSetOrCleared[8] ;
                     515   ; unsigned int InstructionSize ;
                     516   ; // watchpoint variables
                     517   ; unsigned int WatchPointAddress[8];                      //array of 8 breakpoint addresses
                     518   ; unsigned int WatchPointSetOrCleared[8] ;
                     519   ; char WatchPointString[8][100] ;
                     520   ; char    TempString[100] ; 
                     521   ; /************************************************************************************
                     522   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                     523   ; ************************************************************************************/
                     524   ; void Wait1ms(void)
                     525   ; {
                     526   _Wait1ms:
00000938  2F02       527          move.l    D2,-(A7)
                     528   ; long int  i ;
                     529   ; for(i = 0; i < 1000; i ++)
0000093A  4282       530          clr.l     D2
                     531   Wait1ms_1:
0000093C  0C82 0000  532          cmp.l     #1000,D2
00000940  03E8      
00000942  6C04       533          bge.s     Wait1ms_3
00000944  5282       534          addq.l    #1,D2
00000946  60F4       535          bra       Wait1ms_1
                     536   Wait1ms_3:
00000948  241F       537          move.l    (A7)+,D2
0000094A  4E75       538          rts
                     539   ; ;
                     540   ; }
                     541   ; /************************************************************************************
                     542   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                     543   ; **************************************************************************************/
                     544   ; void Wait3ms(void)
                     545   ; {
                     546   _Wait3ms:
0000094C  2F02       547          move.l    D2,-(A7)
                     548   ; int i ;
                     549   ; for(i = 0; i < 3; i++)
0000094E  4282       550          clr.l     D2
                     551   Wait3ms_1:
00000950  0C82 0000  552          cmp.l     #3,D2
00000954  0003      
00000956  6C08       553          bge.s     Wait3ms_3
                     554   ; Wait1ms() ;
00000958  4EB8 0938  555          jsr       _Wait1ms
0000095C  5282       556          addq.l    #1,D2
0000095E  60F0       557          bra       Wait3ms_1
                     558   Wait3ms_3:
00000960  241F       559          move.l    (A7)+,D2
00000962  4E75       560          rts
                     561   ; }
                     562   ; /*********************************************************************************************
                     563   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                     564   ; *********************************************************************************************/
                     565   ; void Init_LCD(void)
                     566   ; {
                     567   _Init_LCD:
                     568   ; LCDcommand = (char)(0x0c) ;
00000964  13FC 000C  569          move.b    #12,4194336
00000968  0040 0020 
                     570   ; Wait3ms() ;
0000096C  4EB8 094C  571          jsr       _Wait3ms
                     572   ; LCDcommand = (char)(0x38) ;
00000970  13FC 0038  573          move.b    #56,4194336
00000974  0040 0020 
                     574   ; Wait3ms() ;
00000978  4EB8 094C  575          jsr       _Wait3ms
0000097C  4E75       576          rts
                     577   ; }
                     578   ; /******************************************************************************
                     579   ; *subroutine to output a single character held in d1 to the LCD display
                     580   ; *it is assumed the character is an ASCII code and it will be displayed at the
                     581   ; *current cursor position
                     582   ; *******************************************************************************/
                     583   ; void Outchar(int c)
                     584   ; {
                     585   _Outchar:
0000097E  4E56 0000  586          link      A6,#0
                     587   ; LCDdata = (char)(c);
00000982  202E 0008  588          move.l    8(A6),D0
00000986  13C0 0040  589          move.b    D0,4194338
0000098A  0022      
                     590   ; Wait1ms() ;
0000098C  4EB8 0938  591          jsr       _Wait1ms
00000990  4E5E       592          unlk      A6
00000992  4E75       593          rts
                     594   ; }
                     595   ; /**********************************************************************************
                     596   ; *subroutine to output a message at the current cursor position of the LCD display
                     597   ; ************************************************************************************/
                     598   ; void OutMess(char *theMessage)
                     599   ; {
                     600   _OutMess:
00000994  4E56 FFFC  601          link      A6,#-4
                     602   ; char c ;
                     603   ; while((c = *theMessage++) != (char)(0))
                     604   OutMess_1:
00000998  206E 0008  605          move.l    8(A6),A0
0000099C  52AE 0008  606          addq.l    #1,8(A6)
000009A0  1D50 FFFF  607          move.b    (A0),-1(A6)
000009A4  1010       608          move.b    (A0),D0
000009A6  6712       609          beq.s     OutMess_3
                     610   ; Outchar(c) ;
000009A8  122E FFFF  611          move.b    -1(A6),D1
000009AC  4881       612          ext.w     D1
000009AE  48C1       613          ext.l     D1
000009B0  2F01       614          move.l    D1,-(A7)
000009B2  4EB8 097E  615          jsr       _Outchar
000009B6  584F       616          addq.w    #4,A7
000009B8  60DE       617          bra       OutMess_1
                     618   OutMess_3:
000009BA  4E5E       619          unlk      A6
000009BC  4E75       620          rts
                     621   ; }
                     622   ; /******************************************************************************
                     623   ; *subroutine to clear the line by issuing 24 space characters
                     624   ; *******************************************************************************/
                     625   ; void Clearln(void)
                     626   ; {
                     627   _Clearln:
000009BE  2F02       628          move.l    D2,-(A7)
                     629   ; unsigned char i ;
                     630   ; for(i = 0; i < 24; i ++)
000009C0  4202       631          clr.b     D2
                     632   Clearln_1:
000009C2  0C02 0018  633          cmp.b     #24,D2
000009C6  640E       634          bhs.s     Clearln_3
                     635   ; Outchar(' ') ;  /* write a space char to the LCD display */
000009C8  4878 0020  636          pea       32
000009CC  4EB8 097E  637          jsr       _Outchar
000009D0  584F       638          addq.w    #4,A7
000009D2  5202       639          addq.b    #1,D2
000009D4  60EC       640          bra       Clearln_1
                     641   Clearln_3:
000009D6  241F       642          move.l    (A7)+,D2
000009D8  4E75       643          rts
                     644   ; }
                     645   ; /******************************************************************************
                     646   ; *subroutine to move the cursor to the start of line 1 and clear that line
                     647   ; *******************************************************************************/
                     648   ; void Oline0(char *theMessage)
                     649   ; {
                     650   _Oline0:
000009DA  4E56 0000  651          link      A6,#0
                     652   ; LCDcommand = (char)(0x80) ;
000009DE  13FC 0080  653          move.b    #128,4194336
000009E2  0040 0020 
                     654   ; Wait3ms();
000009E6  4EB8 094C  655          jsr       _Wait3ms
                     656   ; Clearln() ;
000009EA  4EB8 09BE  657          jsr       _Clearln
                     658   ; LCDcommand = (char)(0x80) ;
000009EE  13FC 0080  659          move.b    #128,4194336
000009F2  0040 0020 
                     660   ; Wait3ms() ;
000009F6  4EB8 094C  661          jsr       _Wait3ms
                     662   ; OutMess(theMessage) ;
000009FA  2F2E 0008  663          move.l    8(A6),-(A7)
000009FE  4EB8 0994  664          jsr       _OutMess
00000A02  584F       665          addq.w    #4,A7
00000A04  4E5E       666          unlk      A6
00000A06  4E75       667          rts
                     668   ; }
                     669   ; /******************************************************************************
                     670   ; *subroutine to move the cursor to the start of line 2 and clear that line
                     671   ; *******************************************************************************/
                     672   ; void Oline1(char *theMessage)
                     673   ; {
                     674   _Oline1:
00000A08  4E56 0000  675          link      A6,#0
                     676   ; LCDcommand = (char)(0xC0) ;
00000A0C  13FC 00C0  677          move.b    #192,4194336
00000A10  0040 0020 
                     678   ; Wait3ms();
00000A14  4EB8 094C  679          jsr       _Wait3ms
                     680   ; Clearln() ;
00000A18  4EB8 09BE  681          jsr       _Clearln
                     682   ; LCDcommand = (char)(0xC0) ;
00000A1C  13FC 00C0  683          move.b    #192,4194336
00000A20  0040 0020 
                     684   ; Wait3ms() ;
00000A24  4EB8 094C  685          jsr       _Wait3ms
                     686   ; OutMess(theMessage) ;
00000A28  2F2E 0008  687          move.l    8(A6),-(A7)
00000A2C  4EB8 0994  688          jsr       _OutMess
00000A30  584F       689          addq.w    #4,A7
00000A32  4E5E       690          unlk      A6
00000A34  4E75       691          rts
                     692   ; }
                     693   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                     694   ; {
                     695   _InstallExceptionHandler:
00000A36  4E56 FFFC  696          link      A6,#-4
                     697   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
00000A3A  2D7C 0B00  698          move.l    #184549376,-4(A6)
00000A3E  0000 FFFC 
                     699   ; RamVectorAddress[level] = (long int *)(function_ptr);
00000A42  206E FFFC  700          move.l    -4(A6),A0
00000A46  202E 000C  701          move.l    12(A6),D0
00000A4A  E588       702          lsl.l     #2,D0
00000A4C  21AE 0008  703          move.l    8(A6),0(A0,D0.L)
00000A50  0800      
00000A52  4E5E       704          unlk      A6
00000A54  4E75       705          rts
                     706   ; }
                     707   ; void TestLEDS(void)
                     708   ; {
                     709   _TestLEDS:
00000A56  48E7 3000  710          movem.l   D2/D3,-(A7)
                     711   ; int delay ;
                     712   ; unsigned char count = 0 ;
00000A5A  4202       713          clr.b     D2
                     714   ; while(1)    {
                     715   TestLEDS_1:
                     716   ; PortA = PortB = PortC = PortD = HEX_A = HEX_B = HEX_C = HEX_D = ((count << 4) + (count & 0x0f)) ;
00000A5C  1002       717          move.b    D2,D0
00000A5E  E908       718          lsl.b     #4,D0
00000A60  1202       719          move.b    D2,D1
00000A62  C23C 000F  720          and.b     #15,D1
00000A66  D001       721          add.b     D1,D0
00000A68  13C0 0040  722          move.b    D0,4194326
00000A6C  0016      
00000A6E  13C0 0040  723          move.b    D0,4194324
00000A72  0014      
00000A74  13C0 0040  724          move.b    D0,4194322
00000A78  0012      
00000A7A  13C0 0040  725          move.b    D0,4194320
00000A7E  0010      
00000A80  13C0 0040  726          move.b    D0,4194310
00000A84  0006      
00000A86  13C0 0040  727          move.b    D0,4194308
00000A8A  0004      
00000A8C  13C0 0040  728          move.b    D0,4194306
00000A90  0002      
00000A92  13C0 0040  729          move.b    D0,4194304
00000A96  0000      
                     730   ; for(delay = 0; delay < 200000; delay ++)
00000A98  4283       731          clr.l     D3
                     732   TestLEDS_4:
00000A9A  0C83 0003  733          cmp.l     #200000,D3
00000A9E  0D40      
00000AA0  6C04       734          bge.s     TestLEDS_6
00000AA2  5283       735          addq.l    #1,D3
00000AA4  60F4       736          bra       TestLEDS_4
                     737   TestLEDS_6:
                     738   ; ;
                     739   ; count ++;
00000AA6  5202       740          addq.b    #1,D2
00000AA8  60B2       741          bra       TestLEDS_1
                     742   ; }
                     743   ; }
                     744   ; void SwitchTest(void)
                     745   ; {
                     746   _SwitchTest:
00000AAA  48E7 3020  747          movem.l   D2/D3/A2,-(A7)
00000AAE  45F9 0000  748          lea       _printf.L,A2
00000AB2  343A      
                     749   ; int i, switches = 0 ;
00000AB4  4283       750          clr.l     D3
                     751   ; printf("\r\n") ;
00000AB6  4879 0000  752          pea       @m68kde~1_1.L
00000ABA  3D8A      
00000ABC  4E92       753          jsr       (A2)
00000ABE  584F       754          addq.w    #4,A7
                     755   ; while(1)    {
                     756   SwitchTest_1:
                     757   ; switches = (PortB << 8) | (PortA) ;
00000AC0  1039 0040  758          move.b    4194306,D0
00000AC4  0002      
00000AC6  C0BC 0000  759          and.l     #255,D0
00000ACA  00FF      
00000ACC  E188       760          lsl.l     #8,D0
00000ACE  1239 0040  761          move.b    4194304,D1
00000AD2  0000      
00000AD4  C2BC 0000  762          and.l     #255,D1
00000AD8  00FF      
00000ADA  8081       763          or.l      D1,D0
00000ADC  2600       764          move.l    D0,D3
                     765   ; printf("\rSwitches SW[7-0] = ") ;
00000ADE  4879 0000  766          pea       @m68kde~1_2.L
00000AE2  3D8E      
00000AE4  4E92       767          jsr       (A2)
00000AE6  584F       768          addq.w    #4,A7
                     769   ; for( i = (int)(0x00000080); i > 0; i = i >> 1)  {
00000AE8  243C 0000  770          move.l    #128,D2
00000AEC  0080      
                     771   SwitchTest_4:
00000AEE  0C82 0000  772          cmp.l     #0,D2
00000AF2  0000      
00000AF4  6F20       773          ble.s     SwitchTest_6
                     774   ; if((switches & i) == 0)
00000AF6  2003       775          move.l    D3,D0
00000AF8  C082       776          and.l     D2,D0
00000AFA  660C       777          bne.s     SwitchTest_7
                     778   ; printf("0") ;
00000AFC  4879 0000  779          pea       @m68kde~1_3.L
00000B00  3DA4      
00000B02  4E92       780          jsr       (A2)
00000B04  584F       781          addq.w    #4,A7
00000B06  600A       782          bra.s     SwitchTest_8
                     783   SwitchTest_7:
                     784   ; else
                     785   ; printf("1") ;
00000B08  4879 0000  786          pea       @m68kde~1_4.L
00000B0C  3DA6      
00000B0E  4E92       787          jsr       (A2)
00000B10  584F       788          addq.w    #4,A7
                     789   SwitchTest_8:
00000B12  E282       790          asr.l     #1,D2
00000B14  60D8       791          bra       SwitchTest_4
                     792   SwitchTest_6:
00000B16  60A8       793          bra       SwitchTest_1
                     794   ; }
                     795   ; }
                     796   ; }
                     797   ; /*********************************************************************************************
                     798   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                     799   ; *********************************************************************************************/
                     800   ; void Init_RS232(void)
                     801   ; {
                     802   _Init_RS232:
                     803   ; RS232_Control = (char)(0x15) ; //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00000B18  13FC 0015  804          move.b    #21,4194368
00000B1C  0040 0040 
                     805   ; RS232_Baud = (char)(0x1) ;      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00000B20  13FC 0001  806          move.b    #1,4194372
00000B24  0040 0044 
00000B28  4E75       807          rts
                     808   ; }
                     809   ; int kbhit(void)
                     810   ; {
                     811   _kbhit:
                     812   ; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // wait for Rx bit in status register to be '1'
00000B2A  1039 0040  813          move.b    4194368,D0
00000B2E  0040      
00000B30  C03C 0001  814          and.b     #1,D0
00000B34  0C00 0001  815          cmp.b     #1,D0
00000B38  6604       816          bne.s     kbhit_1
                     817   ; return 1 ;
00000B3A  7001       818          moveq     #1,D0
00000B3C  6002       819          bra.s     kbhit_3
                     820   kbhit_1:
                     821   ; else
                     822   ; return 0 ;
00000B3E  4280       823          clr.l     D0
                     824   kbhit_3:
00000B40  4E75       825          rts
                     826   ; }
                     827   ; /*********************************************************************************************************
                     828   ; **  Subroutine to provide a low level output function to 6850 ACIA
                     829   ; **  This routine provides the basic functionality to output a single character to the serial Port
                     830   ; **  to allow the board to communicate with HyperTerminal Program
                     831   ; **
                     832   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                     833   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                     834   ; **  call _putch() also
                     835   ; *********************************************************************************************************/
                     836   ; int _putch( int c)
                     837   ; {
                     838   __putch:
00000B42  4E56 0000  839          link      A6,#0
                     840   ; while(((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                     841   _putch_1:
00000B46  1039 0040  842          move.b    4194368,D0
00000B4A  0040      
00000B4C  C03C 0002  843          and.b     #2,D0
00000B50  0C00 0002  844          cmp.b     #2,D0
00000B54  6702       845          beq.s     _putch_3
00000B56  60EE       846          bra       _putch_1
                     847   _putch_3:
                     848   ; ;
                     849   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00000B58  202E 0008  850          move.l    8(A6),D0
00000B5C  C03C 007F  851          and.b     #127,D0
00000B60  13C0 0040  852          move.b    D0,4194370
00000B64  0042      
                     853   ; return c ;                                              // putchar() expects the character to be returned
00000B66  202E 0008  854          move.l    8(A6),D0
00000B6A  4E5E       855          unlk      A6
00000B6C  4E75       856          rts
                     857   ; }
                     858   ; /*********************************************************************************************************
                     859   ; **  Subroutine to provide a low level input function to 6850 ACIA
                     860   ; **  This routine provides the basic functionality to input a single character from the serial Port
                     861   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                     862   ; **
                     863   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                     864   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                     865   ; **  call _getch() also
                     866   ; *********************************************************************************************************/
                     867   ; int _getch( void )
                     868   ; {
                     869   __getch:
00000B6E  2F02       870          move.l    D2,-(A7)
                     871   ; int c ;
                     872   ; while(((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                     873   _getch_1:
00000B70  1039 0040  874          move.b    4194368,D0
00000B74  0040      
00000B76  C03C 0001  875          and.b     #1,D0
00000B7A  0C00 0001  876          cmp.b     #1,D0
00000B7E  6702       877          beq.s     _getch_3
00000B80  60EE       878          bra       _getch_1
                     879   _getch_3:
                     880   ; ;
                     881   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00000B82  1039 0040  882          move.b    4194370,D0
00000B86  0042      
00000B88  C0BC 0000  883          and.l     #255,D0
00000B8C  00FF      
00000B8E  C0BC 0000  884          and.l     #127,D0
00000B92  007F      
00000B94  2400       885          move.l    D0,D2
                     886   ; // shall we echo the character? Echo is set to TRUE at reset, but for speed we don't want to echo when downloading code with the 'L' debugger command
                     887   ; if(Echo)
00000B96  4AB9 0B00  888          tst.l     _Echo.L
00000B9A  00E0      
00000B9C  6708       889          beq.s     _getch_4
                     890   ; _putch(c);
00000B9E  2F02       891          move.l    D2,-(A7)
00000BA0  4EB8 0B42  892          jsr       __putch
00000BA4  584F       893          addq.w    #4,A7
                     894   _getch_4:
                     895   ; return c ;
00000BA6  2002       896          move.l    D2,D0
00000BA8  241F       897          move.l    (A7)+,D2
00000BAA  4E75       898          rts
                     899   ; }
                     900   ; // flush the input stream for any unread characters
                     901   ; void FlushKeyboard(void)
                     902   ; {
                     903   _FlushKeyboard:
00000BAC  4E56 FFFC  904          link      A6,#-4
                     905   ; char c ;
                     906   ; while(1)    {
                     907   FlushKeyboard_1:
                     908   ; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // if Rx bit in status register is '1'
00000BB0  1039 0040  909          move.b    4194368,D0
00000BB4  0040      
00000BB6  C03C 0001  910          and.b     #1,D0
00000BBA  0C00 0001  911          cmp.b     #1,D0
00000BBE  6610       912          bne.s     FlushKeyboard_4
                     913   ; c = ((char)(RS232_RxData) & (char)(0x7f)) ;
00000BC0  1039 0040  914          move.b    4194370,D0
00000BC4  0042      
00000BC6  C03C 007F  915          and.b     #127,D0
00000BCA  1D40 FFFF  916          move.b    D0,-1(A6)
00000BCE  6002       917          bra.s     FlushKeyboard_5
                     918   FlushKeyboard_4:
                     919   ; else
                     920   ; return ;
00000BD0  6002       921          bra.s     FlushKeyboard_6
                     922   FlushKeyboard_5:
00000BD2  60DC       923          bra       FlushKeyboard_1
                     924   FlushKeyboard_6:
00000BD4  4E5E       925          unlk      A6
00000BD6  4E75       926          rts
                     927   ; }
                     928   ; }
                     929   ; // converts hex char to 4 bit binary equiv in range 0000-1111 (0-F)
                     930   ; // char assumed to be a valid hex char 0-9, a-f, A-F
                     931   ; char xtod(int c)
                     932   ; {
                     933   _xtod:
00000BD8  4E56 0000  934          link      A6,#0
00000BDC  2F02       935          move.l    D2,-(A7)
00000BDE  242E 0008  936          move.l    8(A6),D2
                     937   ; if ((char)(c) <= (char)('9'))
00000BE2  0C02 0039  938          cmp.b     #57,D2
00000BE6  6E08       939          bgt.s     xtod_1
                     940   ; return c - (char)(0x30);    // 0 - 9 = 0x30 - 0x39 so convert to number by sutracting 0x30
00000BE8  1002       941          move.b    D2,D0
00000BEA  0400 0030  942          sub.b     #48,D0
00000BEE  6014       943          bra.s     xtod_3
                     944   xtod_1:
                     945   ; else if((char)(c) > (char)('F'))    // assume lower case
00000BF0  0C02 0046  946          cmp.b     #70,D2
00000BF4  6F08       947          ble.s     xtod_4
                     948   ; return c - (char)(0x57);    // a-f = 0x61-66 so needs to be converted to 0x0A - 0x0F so subtract 0x57
00000BF6  1002       949          move.b    D2,D0
00000BF8  0400 0057  950          sub.b     #87,D0
00000BFC  6006       951          bra.s     xtod_3
                     952   xtod_4:
                     953   ; else
                     954   ; return c - (char)(0x37);    // A-F = 0x41-46 so needs to be converted to 0x0A - 0x0F so subtract 0x37
00000BFE  1002       955          move.b    D2,D0
00000C00  0400 0037  956          sub.b     #55,D0
                     957   xtod_3:
00000C04  241F       958          move.l    (A7)+,D2
00000C06  4E5E       959          unlk      A6
00000C08  4E75       960          rts
                     961   ; }
                     962   ; int Get1HexDigits(char *CheckSumPtr)
                     963   ; {
                     964   _Get1HexDigits:
00000C0A  4E56 0000  965          link      A6,#0
00000C0E  2F02       966          move.l    D2,-(A7)
                     967   ; register int i = xtod(_getch());
00000C10  2F00       968          move.l    D0,-(A7)
00000C12  4EB8 0B6E  969          jsr       __getch
00000C16  2200       970          move.l    D0,D1
00000C18  201F       971          move.l    (A7)+,D0
00000C1A  2F01       972          move.l    D1,-(A7)
00000C1C  4EB8 0BD8  973          jsr       _xtod
00000C20  584F       974          addq.w    #4,A7
00000C22  C0BC 0000  975          and.l     #255,D0
00000C26  00FF      
00000C28  2400       976          move.l    D0,D2
                     977   ; if(CheckSumPtr)
00000C2A  4AAE 0008  978          tst.l     8(A6)
00000C2E  6706       979          beq.s     Get1HexDigits_1
                     980   ; *CheckSumPtr += i ;
00000C30  206E 0008  981          move.l    8(A6),A0
00000C34  D510       982          add.b     D2,(A0)
                     983   Get1HexDigits_1:
                     984   ; return i; 
00000C36  2002       985          move.l    D2,D0
00000C38  241F       986          move.l    (A7)+,D2
00000C3A  4E5E       987          unlk      A6
00000C3C  4E75       988          rts
                     989   ; }
                     990   ; int Get2HexDigits(char *CheckSumPtr)
                     991   ; {
                     992   _Get2HexDigits:
00000C3E  4E56 0000  993          link      A6,#0
00000C42  2F02       994          move.l    D2,-(A7)
                     995   ; register int i = (xtod(_getch()) << 4) | (xtod(_getch()));
00000C44  2F00       996          move.l    D0,-(A7)
00000C46  4EB8 0B6E  997          jsr       __getch
00000C4A  2200       998          move.l    D0,D1
00000C4C  201F       999          move.l    (A7)+,D0
00000C4E  2F01      1000          move.l    D1,-(A7)
00000C50  4EB8 0BD8 1001          jsr       _xtod
00000C54  584F      1002          addq.w    #4,A7
00000C56  C0BC 0000 1003          and.l     #255,D0
00000C5A  00FF      
00000C5C  E980      1004          asl.l     #4,D0
00000C5E  2F00      1005          move.l    D0,-(A7)
00000C60  2F01      1006          move.l    D1,-(A7)
00000C62  4EB8 0B6E 1007          jsr       __getch
00000C66  221F      1008          move.l    (A7)+,D1
00000C68  2F00      1009          move.l    D0,-(A7)
00000C6A  4EB8 0BD8 1010          jsr       _xtod
00000C6E  584F      1011          addq.w    #4,A7
00000C70  2200      1012          move.l    D0,D1
00000C72  201F      1013          move.l    (A7)+,D0
00000C74  C2BC 0000 1014          and.l     #255,D1
00000C78  00FF      
00000C7A  8081      1015          or.l      D1,D0
00000C7C  2400      1016          move.l    D0,D2
                    1017   ; if(CheckSumPtr)
00000C7E  4AAE 0008 1018          tst.l     8(A6)
00000C82  6706      1019          beq.s     Get2HexDigits_1
                    1020   ; *CheckSumPtr += i ;
00000C84  206E 0008 1021          move.l    8(A6),A0
00000C88  D510      1022          add.b     D2,(A0)
                    1023   Get2HexDigits_1:
                    1024   ; return i ;
00000C8A  2002      1025          move.l    D2,D0
00000C8C  241F      1026          move.l    (A7)+,D2
00000C8E  4E5E      1027          unlk      A6
00000C90  4E75      1028          rts
                    1029   ; }
                    1030   ; int Get4HexDigits(char *CheckSumPtr)
                    1031   ; {
                    1032   _Get4HexDigits:
00000C92  4E56 0000 1033          link      A6,#0
                    1034   ; return (Get2HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000C96  2F2E 0008 1035          move.l    8(A6),-(A7)
00000C9A  4EB8 0C3E 1036          jsr       _Get2HexDigits
00000C9E  584F      1037          addq.w    #4,A7
00000CA0  E180      1038          asl.l     #8,D0
00000CA2  2F00      1039          move.l    D0,-(A7)
00000CA4  2F2E 0008 1040          move.l    8(A6),-(A7)
00000CA8  4EB8 0C3E 1041          jsr       _Get2HexDigits
00000CAC  584F      1042          addq.w    #4,A7
00000CAE  2200      1043          move.l    D0,D1
00000CB0  201F      1044          move.l    (A7)+,D0
00000CB2  8081      1045          or.l      D1,D0
00000CB4  4E5E      1046          unlk      A6
00000CB6  4E75      1047          rts
                    1048   ; }
                    1049   ; int Get6HexDigits(char *CheckSumPtr)
                    1050   ; {
                    1051   _Get6HexDigits:
00000CB8  4E56 0000 1052          link      A6,#0
                    1053   ; return (Get4HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000CBC  2F2E 0008 1054          move.l    8(A6),-(A7)
00000CC0  4EB8 0C92 1055          jsr       _Get4HexDigits
00000CC4  584F      1056          addq.w    #4,A7
00000CC6  E180      1057          asl.l     #8,D0
00000CC8  2F00      1058          move.l    D0,-(A7)
00000CCA  2F2E 0008 1059          move.l    8(A6),-(A7)
00000CCE  4EB8 0C3E 1060          jsr       _Get2HexDigits
00000CD2  584F      1061          addq.w    #4,A7
00000CD4  2200      1062          move.l    D0,D1
00000CD6  201F      1063          move.l    (A7)+,D0
00000CD8  8081      1064          or.l      D1,D0
00000CDA  4E5E      1065          unlk      A6
00000CDC  4E75      1066          rts
                    1067   ; }
                    1068   ; int Get8HexDigits(char *CheckSumPtr)
                    1069   ; {
                    1070   _Get8HexDigits:
00000CDE  4E56 0000 1071          link      A6,#0
                    1072   ; return (Get4HexDigits(CheckSumPtr) << 16) | (Get4HexDigits(CheckSumPtr));
00000CE2  2F2E 0008 1073          move.l    8(A6),-(A7)
00000CE6  4EB8 0C92 1074          jsr       _Get4HexDigits
00000CEA  584F      1075          addq.w    #4,A7
00000CEC  E180      1076          asl.l     #8,D0
00000CEE  E180      1077          asl.l     #8,D0
00000CF0  2F00      1078          move.l    D0,-(A7)
00000CF2  2F2E 0008 1079          move.l    8(A6),-(A7)
00000CF6  4EB8 0C92 1080          jsr       _Get4HexDigits
00000CFA  584F      1081          addq.w    #4,A7
00000CFC  2200      1082          move.l    D0,D1
00000CFE  201F      1083          move.l    (A7)+,D0
00000D00  8081      1084          or.l      D1,D0
00000D02  4E5E      1085          unlk      A6
00000D04  4E75      1086          rts
                    1087   ; }
                    1088   ; void DumpMemory(void)   // simple dump memory fn
                    1089   ; {
                    1090   _DumpMemory:
00000D06  48E7 3C30 1091          movem.l   D2/D3/D4/D5/A2/A3,-(A7)
00000D0A  45F9 0000 1092          lea       _printf.L,A2
00000D0E  343A      
00000D10  47F9 0000 1093          lea       _putch.L,A3
00000D14  332C      
                    1094   ; int i, j ;
                    1095   ; unsigned char *RamPtr,c ; // pointer to where the program is download (assumed)
                    1096   ; printf("\r\nDump Memory Block: <ESC> to Abort, <SPACE> to Continue") ;
00000D16  4879 0000 1097          pea       @m68kde~1_5.L
00000D1A  3DA8      
00000D1C  4E92      1098          jsr       (A2)
00000D1E  584F      1099          addq.w    #4,A7
                    1100   ; printf("\r\nEnter Start Address: ") ;
00000D20  4879 0000 1101          pea       @m68kde~1_6.L
00000D24  3DE2      
00000D26  4E92      1102          jsr       (A2)
00000D28  584F      1103          addq.w    #4,A7
                    1104   ; RamPtr = Get8HexDigits(0) ;
00000D2A  42A7      1105          clr.l     -(A7)
00000D2C  4EB8 0CDE 1106          jsr       _Get8HexDigits
00000D30  584F      1107          addq.w    #4,A7
00000D32  2600      1108          move.l    D0,D3
                    1109   ; while(1)    {
                    1110   DumpMemory_1:
                    1111   ; for(i = 0; i < 16; i ++)    {
00000D34  4285      1112          clr.l     D5
                    1113   DumpMemory_4:
00000D36  0C85 0000 1114          cmp.l     #16,D5
00000D3A  0010      
00000D3C  6C00 0096 1115          bge       DumpMemory_6
                    1116   ; printf("\r\n%08x ", RamPtr) ;
00000D40  2F03      1117          move.l    D3,-(A7)
00000D42  4879 0000 1118          pea       @m68kde~1_7.L
00000D46  3DFA      
00000D48  4E92      1119          jsr       (A2)
00000D4A  504F      1120          addq.w    #8,A7
                    1121   ; for(j=0; j < 16; j ++)  {
00000D4C  4282      1122          clr.l     D2
                    1123   DumpMemory_7:
00000D4E  0C82 0000 1124          cmp.l     #16,D2
00000D52  0010      
00000D54  6C24      1125          bge.s     DumpMemory_9
                    1126   ; printf("%02X",RamPtr[j]) ;
00000D56  2043      1127          move.l    D3,A0
00000D58  1230 2800 1128          move.b    0(A0,D2.L),D1
00000D5C  C2BC 0000 1129          and.l     #255,D1
00000D60  00FF      
00000D62  2F01      1130          move.l    D1,-(A7)
00000D64  4879 0000 1131          pea       @m68kde~1_8.L
00000D68  3E02      
00000D6A  4E92      1132          jsr       (A2)
00000D6C  504F      1133          addq.w    #8,A7
                    1134   ; putchar(' ') ;
00000D6E  4878 0020 1135          pea       32
00000D72  4E93      1136          jsr       (A3)
00000D74  584F      1137          addq.w    #4,A7
00000D76  5282      1138          addq.l    #1,D2
00000D78  60D4      1139          bra       DumpMemory_7
                    1140   DumpMemory_9:
                    1141   ; }
                    1142   ; // now display the data as ASCII at the end
                    1143   ; printf("  ") ;
00000D7A  4879 0000 1144          pea       @m68kde~1_9.L
00000D7E  3E08      
00000D80  4E92      1145          jsr       (A2)
00000D82  584F      1146          addq.w    #4,A7
                    1147   ; for(j = 0; j < 16; j++) {
00000D84  4282      1148          clr.l     D2
                    1149   DumpMemory_10:
00000D86  0C82 0000 1150          cmp.l     #16,D2
00000D8A  0010      
00000D8C  6C00 003A 1151          bge       DumpMemory_12
                    1152   ; c = ((char)(RamPtr[j]) & 0x7f) ;
00000D90  2043      1153          move.l    D3,A0
00000D92  1030 2800 1154          move.b    0(A0,D2.L),D0
00000D96  C03C 007F 1155          and.b     #127,D0
00000D9A  1800      1156          move.b    D0,D4
                    1157   ; if((c > (char)(0x7f)) || (c < ' '))
00000D9C  0C04 007F 1158          cmp.b     #127,D4
00000DA0  6206      1159          bhi.s     DumpMemory_15
00000DA2  0C04 0020 1160          cmp.b     #32,D4
00000DA6  640A      1161          bhs.s     DumpMemory_13
                    1162   DumpMemory_15:
                    1163   ; putchar('.') ;
00000DA8  4878 002E 1164          pea       46
00000DAC  4E93      1165          jsr       (A3)
00000DAE  584F      1166          addq.w    #4,A7
00000DB0  6012      1167          bra.s     DumpMemory_14
                    1168   DumpMemory_13:
                    1169   ; else
                    1170   ; putchar(RamPtr[j]) ;
00000DB2  2043      1171          move.l    D3,A0
00000DB4  1230 2800 1172          move.b    0(A0,D2.L),D1
00000DB8  C2BC 0000 1173          and.l     #255,D1
00000DBC  00FF      
00000DBE  2F01      1174          move.l    D1,-(A7)
00000DC0  4E93      1175          jsr       (A3)
00000DC2  584F      1176          addq.w    #4,A7
                    1177   DumpMemory_14:
00000DC4  5282      1178          addq.l    #1,D2
00000DC6  60BE      1179          bra       DumpMemory_10
                    1180   DumpMemory_12:
                    1181   ; }
                    1182   ; RamPtr = RamPtr + 16 ;
00000DC8  0683 0000 1183          add.l     #16,D3
00000DCC  0010      
00000DCE  5285      1184          addq.l    #1,D5
00000DD0  6000 FF64 1185          bra       DumpMemory_4
                    1186   DumpMemory_6:
                    1187   ; }
                    1188   ; printf("\r\n") ;
00000DD4  4879 0000 1189          pea       @m68kde~1_1.L
00000DD8  3D8A      
00000DDA  4E92      1190          jsr       (A2)
00000DDC  584F      1191          addq.w    #4,A7
                    1192   ; c = _getch() ;
00000DDE  4EB8 0B6E 1193          jsr       __getch
00000DE2  1800      1194          move.b    D0,D4
                    1195   ; if(c == 0x1b)          // break on ESC
00000DE4  0C04 001B 1196          cmp.b     #27,D4
00000DE8  6602      1197          bne.s     DumpMemory_16
                    1198   ; break ;
00000DEA  6004      1199          bra.s     DumpMemory_3
                    1200   DumpMemory_16:
00000DEC  6000 FF46 1201          bra       DumpMemory_1
                    1202   DumpMemory_3:
00000DF0  4CDF 0C3C 1203          movem.l   (A7)+,D2/D3/D4/D5/A2/A3
00000DF4  4E75      1204          rts
                    1205   ; }
                    1206   ; }
                    1207   ; void FillMemory()
                    1208   ; {
                    1209   _FillMemory:
00000DF6  48E7 3820 1210          movem.l   D2/D3/D4/A2,-(A7)
00000DFA  45F9 0000 1211          lea       _printf.L,A2
00000DFE  343A      
                    1212   ; char *StartRamPtr, *EndRamPtr ;
                    1213   ; unsigned char FillData ;
                    1214   ; printf("\r\nFill Memory Block") ;
00000E00  4879 0000 1215          pea       @m68kde~1_10.L
00000E04  3E0C      
00000E06  4E92      1216          jsr       (A2)
00000E08  584F      1217          addq.w    #4,A7
                    1218   ; printf("\r\nEnter Start Address: ") ;
00000E0A  4879 0000 1219          pea       @m68kde~1_6.L
00000E0E  3DE2      
00000E10  4E92      1220          jsr       (A2)
00000E12  584F      1221          addq.w    #4,A7
                    1222   ; StartRamPtr = Get8HexDigits(0) ;
00000E14  42A7      1223          clr.l     -(A7)
00000E16  4EB8 0CDE 1224          jsr       _Get8HexDigits
00000E1A  584F      1225          addq.w    #4,A7
00000E1C  2400      1226          move.l    D0,D2
                    1227   ; printf("\r\nEnter End Address: ") ;
00000E1E  4879 0000 1228          pea       @m68kde~1_11.L
00000E22  3E20      
00000E24  4E92      1229          jsr       (A2)
00000E26  584F      1230          addq.w    #4,A7
                    1231   ; EndRamPtr = Get8HexDigits(0) ;
00000E28  42A7      1232          clr.l     -(A7)
00000E2A  4EB8 0CDE 1233          jsr       _Get8HexDigits
00000E2E  584F      1234          addq.w    #4,A7
00000E30  2800      1235          move.l    D0,D4
                    1236   ; printf("\r\nEnter Fill Data: ") ;
00000E32  4879 0000 1237          pea       @m68kde~1_12.L
00000E36  3E36      
00000E38  4E92      1238          jsr       (A2)
00000E3A  584F      1239          addq.w    #4,A7
                    1240   ; FillData = Get2HexDigits(0) ;
00000E3C  42A7      1241          clr.l     -(A7)
00000E3E  4EB8 0C3E 1242          jsr       _Get2HexDigits
00000E42  584F      1243          addq.w    #4,A7
00000E44  1600      1244          move.b    D0,D3
                    1245   ; printf("\r\nFilling Addresses [$%08X - $%08X] with $%02X", StartRamPtr, EndRamPtr, FillData) ;
00000E46  C6BC 0000 1246          and.l     #255,D3
00000E4A  00FF      
00000E4C  2F03      1247          move.l    D3,-(A7)
00000E4E  2F04      1248          move.l    D4,-(A7)
00000E50  2F02      1249          move.l    D2,-(A7)
00000E52  4879 0000 1250          pea       @m68kde~1_13.L
00000E56  3E4A      
00000E58  4E92      1251          jsr       (A2)
00000E5A  DEFC 0010 1252          add.w     #16,A7
                    1253   ; while(StartRamPtr < EndRamPtr)
                    1254   FillMemory_1:
00000E5E  B484      1255          cmp.l     D4,D2
00000E60  6408      1256          bhs.s     FillMemory_3
                    1257   ; *StartRamPtr++ = FillData ;
00000E62  2042      1258          move.l    D2,A0
00000E64  5282      1259          addq.l    #1,D2
00000E66  1083      1260          move.b    D3,(A0)
00000E68  60F4      1261          bra       FillMemory_1
                    1262   FillMemory_3:
00000E6A  4CDF 041C 1263          movem.l   (A7)+,D2/D3/D4/A2
00000E6E  4E75      1264          rts
                    1265   ; }
                    1266   ; void Load_SRecordFile()
                    1267   ; {
                    1268   _Load_SRecordFile:
00000E70  4E56 FFDC 1269          link      A6,#-36
00000E74  48E7 3F3C 1270          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00000E78  45EE FFFA 1271          lea       -6(A6),A2
00000E7C  47F8 0C3E 1272          lea       _Get2HexDigits.L,A3
00000E80  49F9 0000 1273          lea       _printf.L,A4
00000E84  343A      
                    1274   ; int i, Address, AddressSize, DataByte, NumDataBytesToRead, LoadFailed, FailedAddress, AddressFail, SRecordCount = 0, ByteTotal = 0 ;
00000E86  42AE FFEE 1275          clr.l     -18(A6)
00000E8A  3A7C 0000 1276          move.w    #0,A5
                    1277   ; int result, ByteCount ;
                    1278   ; char c, CheckSum, ReadCheckSum, HeaderType ;
                    1279   ; char *RamPtr ;                          // pointer to Memory where downloaded program will be stored
                    1280   ; LoadFailed = 0 ;                        //assume LOAD operation will pass
00000E8E  7E00      1281          moveq     #0,D7
                    1282   ; AddressFail = 0 ;
00000E90  42AE FFEA 1283          clr.l     -22(A6)
                    1284   ; Echo = 0 ;                              // don't echo S records during download
00000E94  42B9 0B00 1285          clr.l     _Echo.L
00000E98  00E0      
                    1286   ; printf("\r\nUse HyperTerminal to Send Text File (.hex)\r\n") ;
00000E9A  4879 0000 1287          pea       @m68kde~1_14.L
00000E9E  3E7A      
00000EA0  4E94      1288          jsr       (A4)
00000EA2  584F      1289          addq.w    #4,A7
                    1290   ; while(1)    {
                    1291   Load_SRecordFile_1:
                    1292   ; CheckSum = 0 ;
00000EA4  4212      1293          clr.b     (A2)
                    1294   ; do {
                    1295   Load_SRecordFile_4:
                    1296   ; c = toupper(_getch()) ;
00000EA6  2F00      1297          move.l    D0,-(A7)
00000EA8  4EB8 0B6E 1298          jsr       __getch
00000EAC  2200      1299          move.l    D0,D1
00000EAE  201F      1300          move.l    (A7)+,D0
00000EB0  2F01      1301          move.l    D1,-(A7)
00000EB2  4EB9 0000 1302          jsr       _toupper
00000EB6  340E      
00000EB8  584F      1303          addq.w    #4,A7
00000EBA  1C00      1304          move.b    D0,D6
                    1305   ; if(c == 0x1b )      // if break
00000EBC  0C06 001B 1306          cmp.b     #27,D6
00000EC0  6604      1307          bne.s     Load_SRecordFile_6
                    1308   ; return;
00000EC2  6000 0132 1309          bra       Load_SRecordFile_8
                    1310   Load_SRecordFile_6:
00000EC6  0C06 0053 1311          cmp.b     #83,D6
00000ECA  66DA      1312          bne       Load_SRecordFile_4
                    1313   ; }while(c != (char)('S'));   // wait for S start of header
                    1314   ; HeaderType = _getch() ;
00000ECC  4EB8 0B6E 1315          jsr       __getch
00000ED0  1600      1316          move.b    D0,D3
                    1317   ; if(HeaderType == (char)('0') || HeaderType == (char)('5'))       // ignore s0, s5 records
00000ED2  0C03 0030 1318          cmp.b     #48,D3
00000ED6  6706      1319          beq.s     Load_SRecordFile_11
00000ED8  0C03 0035 1320          cmp.b     #53,D3
00000EDC  6604      1321          bne.s     Load_SRecordFile_9
                    1322   Load_SRecordFile_11:
                    1323   ; continue ;
00000EDE  6000 00D2 1324          bra       Load_SRecordFile_23
                    1325   Load_SRecordFile_9:
                    1326   ; if(HeaderType >= (char)('7'))
00000EE2  0C03 0037 1327          cmp.b     #55,D3
00000EE6  6D04      1328          blt.s     Load_SRecordFile_12
                    1329   ; break ;                 // end load on s7,s8,s9 records
00000EE8  6000 00CC 1330          bra       Load_SRecordFile_3
                    1331   Load_SRecordFile_12:
                    1332   ; // get the bytecount
                    1333   ; ByteCount = Get2HexDigits(&CheckSum) ;
00000EEC  2F0A      1334          move.l    A2,-(A7)
00000EEE  4E93      1335          jsr       (A3)
00000EF0  584F      1336          addq.w    #4,A7
00000EF2  2D40 FFF6 1337          move.l    D0,-10(A6)
                    1338   ; // get the address, 4 digits for s1, 6 digits for s2, and 8 digits for s3 record
                    1339   ; if(HeaderType == (char)('1')) {
00000EF6  0C03 0031 1340          cmp.b     #49,D3
00000EFA  660E      1341          bne.s     Load_SRecordFile_14
                    1342   ; AddressSize = 2 ;       // 2 byte address
00000EFC  7A02      1343          moveq     #2,D5
                    1344   ; Address = Get4HexDigits(&CheckSum);
00000EFE  2F0A      1345          move.l    A2,-(A7)
00000F00  4EB8 0C92 1346          jsr       _Get4HexDigits
00000F04  584F      1347          addq.w    #4,A7
00000F06  2800      1348          move.l    D0,D4
00000F08  6020      1349          bra.s     Load_SRecordFile_17
                    1350   Load_SRecordFile_14:
                    1351   ; }
                    1352   ; else if (HeaderType == (char)('2')) {
00000F0A  0C03 0032 1353          cmp.b     #50,D3
00000F0E  660E      1354          bne.s     Load_SRecordFile_16
                    1355   ; AddressSize = 3 ;       // 3 byte address
00000F10  7A03      1356          moveq     #3,D5
                    1357   ; Address = Get6HexDigits(&CheckSum) ;
00000F12  2F0A      1358          move.l    A2,-(A7)
00000F14  4EB8 0CB8 1359          jsr       _Get6HexDigits
00000F18  584F      1360          addq.w    #4,A7
00000F1A  2800      1361          move.l    D0,D4
00000F1C  600C      1362          bra.s     Load_SRecordFile_17
                    1363   Load_SRecordFile_16:
                    1364   ; }
                    1365   ; else    {
                    1366   ; AddressSize = 4 ;       // 4 byte address
00000F1E  7A04      1367          moveq     #4,D5
                    1368   ; Address = Get8HexDigits(&CheckSum) ;
00000F20  2F0A      1369          move.l    A2,-(A7)
00000F22  4EB8 0CDE 1370          jsr       _Get8HexDigits
00000F26  584F      1371          addq.w    #4,A7
00000F28  2800      1372          move.l    D0,D4
                    1373   Load_SRecordFile_17:
                    1374   ; }
                    1375   ; RamPtr = (char *)(Address) ;                            // point to download area
00000F2A  2D44 FFFC 1376          move.l    D4,-4(A6)
                    1377   ; NumDataBytesToRead = ByteCount - AddressSize - 1 ;
00000F2E  202E FFF6 1378          move.l    -10(A6),D0
00000F32  9085      1379          sub.l     D5,D0
00000F34  5380      1380          subq.l    #1,D0
00000F36  2D40 FFE2 1381          move.l    D0,-30(A6)
                    1382   ; for(i = 0; i < NumDataBytesToRead; i ++) {     // read in remaining data bytes (ignore address and checksum at the end
00000F3A  4282      1383          clr.l     D2
                    1384   Load_SRecordFile_18:
00000F3C  B4AE FFE2 1385          cmp.l     -30(A6),D2
00000F40  6C1E      1386          bge.s     Load_SRecordFile_20
                    1387   ; DataByte = Get2HexDigits(&CheckSum) ;
00000F42  2F0A      1388          move.l    A2,-(A7)
00000F44  4E93      1389          jsr       (A3)
00000F46  584F      1390          addq.w    #4,A7
00000F48  2D40 FFDE 1391          move.l    D0,-34(A6)
                    1392   ; *RamPtr++ = DataByte ;                      // store downloaded byte in Ram at specified address
00000F4C  202E FFDE 1393          move.l    -34(A6),D0
00000F50  206E FFFC 1394          move.l    -4(A6),A0
00000F54  52AE FFFC 1395          addq.l    #1,-4(A6)
00000F58  1080      1396          move.b    D0,(A0)
                    1397   ; ByteTotal++;
00000F5A  524D      1398          addq.w    #1,A5
00000F5C  5282      1399          addq.l    #1,D2
00000F5E  60DC      1400          bra       Load_SRecordFile_18
                    1401   Load_SRecordFile_20:
                    1402   ; }
                    1403   ; // checksum is the 1's complement of the sum of all data pairs following the bytecount, i.e. it includes the address and the data itself
                    1404   ; ReadCheckSum = Get2HexDigits(0) ;
00000F60  42A7      1405          clr.l     -(A7)
00000F62  4E93      1406          jsr       (A3)
00000F64  584F      1407          addq.w    #4,A7
00000F66  1D40 FFFB 1408          move.b    D0,-5(A6)
                    1409   ; if((~CheckSum&0Xff) != (ReadCheckSum&0Xff))   {
00000F6A  1012      1410          move.b    (A2),D0
00000F6C  4600      1411          not.b     D0
00000F6E  4880      1412          ext.w     D0
00000F70  C07C 00FF 1413          and.w     #255,D0
00000F74  122E FFFB 1414          move.b    -5(A6),D1
00000F78  4881      1415          ext.w     D1
00000F7A  C27C 00FF 1416          and.w     #255,D1
00000F7E  B041      1417          cmp.w     D1,D0
00000F80  6708      1418          beq.s     Load_SRecordFile_21
                    1419   ; LoadFailed = 1 ;
00000F82  7E01      1420          moveq     #1,D7
                    1421   ; FailedAddress = Address ;
00000F84  2D44 FFE6 1422          move.l    D4,-26(A6)
                    1423   ; break;
00000F88  602C      1424          bra.s     Load_SRecordFile_3
                    1425   Load_SRecordFile_21:
                    1426   ; }
                    1427   ; SRecordCount++ ;
00000F8A  52AE FFEE 1428          addq.l    #1,-18(A6)
                    1429   ; // display feedback on progress
                    1430   ; if(SRecordCount % 25 == 0)
00000F8E  2F2E FFEE 1431          move.l    -18(A6),-(A7)
00000F92  4878 0019 1432          pea       25
00000F96  4EB9 0000 1433          jsr       LDIV
00000F9A  3260      
00000F9C  202F 0004 1434          move.l    4(A7),D0
00000FA0  504F      1435          addq.w    #8,A7
00000FA2  4A80      1436          tst.l     D0
00000FA4  660C      1437          bne.s     Load_SRecordFile_23
                    1438   ; putchar('.') ;
00000FA6  4878 002E 1439          pea       46
00000FAA  4EB9 0000 1440          jsr       _putch
00000FAE  332C      
00000FB0  584F      1441          addq.w    #4,A7
                    1442   Load_SRecordFile_23:
00000FB2  6000 FEF0 1443          bra       Load_SRecordFile_1
                    1444   Load_SRecordFile_3:
                    1445   ; }
                    1446   ; if(LoadFailed == 1) {
00000FB6  0C87 0000 1447          cmp.l     #1,D7
00000FBA  0001      
00000FBC  6610      1448          bne.s     Load_SRecordFile_25
                    1449   ; printf("\r\nLoad Failed at Address = [$%08X]\r\n", FailedAddress) ;
00000FBE  2F2E FFE6 1450          move.l    -26(A6),-(A7)
00000FC2  4879 0000 1451          pea       @m68kde~1_15.L
00000FC6  3EAA      
00000FC8  4E94      1452          jsr       (A4)
00000FCA  504F      1453          addq.w    #8,A7
00000FCC  600C      1454          bra.s     Load_SRecordFile_26
                    1455   Load_SRecordFile_25:
                    1456   ; }
                    1457   ; else
                    1458   ; printf("\r\nSuccess: Downloaded %d bytes\r\n", ByteTotal) ;
00000FCE  2F0D      1459          move.l    A5,-(A7)
00000FD0  4879 0000 1460          pea       @m68kde~1_16.L
00000FD4  3ED0      
00000FD6  4E94      1461          jsr       (A4)
00000FD8  504F      1462          addq.w    #8,A7
                    1463   Load_SRecordFile_26:
                    1464   ; // pause at the end to wait for download to finish transmitting at the end of S8 etc
                    1465   ; for(i = 0; i < 400000; i ++)
00000FDA  4282      1466          clr.l     D2
                    1467   Load_SRecordFile_27:
00000FDC  0C82 0006 1468          cmp.l     #400000,D2
00000FE0  1A80      
00000FE2  6C04      1469          bge.s     Load_SRecordFile_29
00000FE4  5282      1470          addq.l    #1,D2
00000FE6  60F4      1471          bra       Load_SRecordFile_27
                    1472   Load_SRecordFile_29:
                    1473   ; ;
                    1474   ; FlushKeyboard() ;
00000FE8  4EB8 0BAC 1475          jsr       _FlushKeyboard
                    1476   ; Echo = 1;
00000FEC  23FC 0000 1477          move.l    #1,_Echo.L
00000FF0  0001 0B00 
00000FF4  00E0      
                    1478   Load_SRecordFile_8:
00000FF6  4CDF 3CFC 1479          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00000FFA  4E5E      1480          unlk      A6
00000FFC  4E75      1481          rts
                    1482   ; }
                    1483   ; void MemoryChange(void)
                    1484   ; {
                    1485   _MemoryChange:
00000FFE  48E7 3820 1486          movem.l   D2/D3/D4/A2,-(A7)
00001002  45F9 0000 1487          lea       _printf.L,A2
00001006  343A      
                    1488   ; unsigned char *RamPtr,c ; // pointer to memory
                    1489   ; int Data ;
                    1490   ; printf("\r\nExamine and Change Memory") ;
00001008  4879 0000 1491          pea       @m68kde~1_17.L
0000100C  3EF2      
0000100E  4E92      1492          jsr       (A2)
00001010  584F      1493          addq.w    #4,A7
                    1494   ; printf("\r\n<ESC> to Stop, <SPACE> to Advance, '-' to Go Back, <DATA> to change") ;
00001012  4879 0000 1495          pea       @m68kde~1_18.L
00001016  3F0E      
00001018  4E92      1496          jsr       (A2)
0000101A  584F      1497          addq.w    #4,A7
                    1498   ; printf("\r\nEnter Address: ") ;
0000101C  4879 0000 1499          pea       @m68kde~1_19.L
00001020  3F54      
00001022  4E92      1500          jsr       (A2)
00001024  584F      1501          addq.w    #4,A7
                    1502   ; RamPtr = Get8HexDigits(0) ;
00001026  42A7      1503          clr.l     -(A7)
00001028  4EB8 0CDE 1504          jsr       _Get8HexDigits
0000102C  584F      1505          addq.w    #4,A7
0000102E  2600      1506          move.l    D0,D3
                    1507   ; while(1)    {
                    1508   MemoryChange_1:
                    1509   ; printf("\r\n[%08x] : %02x  ", RamPtr, *RamPtr) ;
00001030  2043      1510          move.l    D3,A0
00001032  1210      1511          move.b    (A0),D1
00001034  C2BC 0000 1512          and.l     #255,D1
00001038  00FF      
0000103A  2F01      1513          move.l    D1,-(A7)
0000103C  2F03      1514          move.l    D3,-(A7)
0000103E  4879 0000 1515          pea       @m68kde~1_20.L
00001042  3F66      
00001044  4E92      1516          jsr       (A2)
00001046  DEFC 000C 1517          add.w     #12,A7
                    1518   ; c = tolower(_getch()) ;
0000104A  2F00      1519          move.l    D0,-(A7)
0000104C  4EB8 0B6E 1520          jsr       __getch
00001050  2200      1521          move.l    D0,D1
00001052  201F      1522          move.l    (A7)+,D0
00001054  2F01      1523          move.l    D1,-(A7)
00001056  4EB9 0000 1524          jsr       _tolower
0000105A  3398      
0000105C  584F      1525          addq.w    #4,A7
0000105E  1400      1526          move.b    D0,D2
                    1527   ; if(c == (char)(0x1b))
00001060  0C02 001B 1528          cmp.b     #27,D2
00001064  6604      1529          bne.s     MemoryChange_4
                    1530   ; return ;                                // abort on escape
00001066  6000 0090 1531          bra       MemoryChange_6
                    1532   MemoryChange_4:
                    1533   ; else if((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {  // are we trying to change data at this location by entering a hex char
0000106A  0C02 0030 1534          cmp.b     #48,D2
0000106E  6506      1535          blo.s     MemoryChange_10
00001070  0C02 0039 1536          cmp.b     #57,D2
00001074  6310      1537          bls.s     MemoryChange_9
                    1538   MemoryChange_10:
00001076  0C02 0061 1539          cmp.b     #97,D2
0000107A  6500 006E 1540          blo       MemoryChange_7
0000107E  0C02 0066 1541          cmp.b     #102,D2
00001082  6200 0066 1542          bhi       MemoryChange_7
                    1543   MemoryChange_9:
                    1544   ; Data = (xtod(c) << 4) | (xtod(_getch()));
00001086  C4BC 0000 1545          and.l     #255,D2
0000108A  00FF      
0000108C  2F02      1546          move.l    D2,-(A7)
0000108E  4EB8 0BD8 1547          jsr       _xtod
00001092  584F      1548          addq.w    #4,A7
00001094  C0BC 0000 1549          and.l     #255,D0
00001098  00FF      
0000109A  E980      1550          asl.l     #4,D0
0000109C  2F00      1551          move.l    D0,-(A7)
0000109E  2F01      1552          move.l    D1,-(A7)
000010A0  4EB8 0B6E 1553          jsr       __getch
000010A4  221F      1554          move.l    (A7)+,D1
000010A6  2F00      1555          move.l    D0,-(A7)
000010A8  4EB8 0BD8 1556          jsr       _xtod
000010AC  584F      1557          addq.w    #4,A7
000010AE  2200      1558          move.l    D0,D1
000010B0  201F      1559          move.l    (A7)+,D0
000010B2  C2BC 0000 1560          and.l     #255,D1
000010B6  00FF      
000010B8  8081      1561          or.l      D1,D0
000010BA  2800      1562          move.l    D0,D4
                    1563   ; *RamPtr = (char)(Data) ;
000010BC  2043      1564          move.l    D3,A0
000010BE  1084      1565          move.b    D4,(A0)
                    1566   ; if(*RamPtr != Data) {
000010C0  2043      1567          move.l    D3,A0
000010C2  1010      1568          move.b    (A0),D0
000010C4  C0BC 0000 1569          and.l     #255,D0
000010C8  00FF      
000010CA  B084      1570          cmp.l     D4,D0
000010CC  671A      1571          beq.s     MemoryChange_11
                    1572   ; printf("\r\nWarning Change Failed: Wrote [%02x], Read [%02x]", Data, *RamPtr) ;
000010CE  2043      1573          move.l    D3,A0
000010D0  1210      1574          move.b    (A0),D1
000010D2  C2BC 0000 1575          and.l     #255,D1
000010D6  00FF      
000010D8  2F01      1576          move.l    D1,-(A7)
000010DA  2F04      1577          move.l    D4,-(A7)
000010DC  4879 0000 1578          pea       @m68kde~1_21.L
000010E0  3F78      
000010E2  4E92      1579          jsr       (A2)
000010E4  DEFC 000C 1580          add.w     #12,A7
                    1581   MemoryChange_11:
000010E8  6008      1582          bra.s     MemoryChange_13
                    1583   MemoryChange_7:
                    1584   ; }
                    1585   ; }
                    1586   ; else if(c == (char)('-'))
000010EA  0C02 002D 1587          cmp.b     #45,D2
000010EE  6602      1588          bne.s     MemoryChange_13
                    1589   ; RamPtr -= 2 ; ;
000010F0  5583      1590          subq.l    #2,D3
                    1591   MemoryChange_13:
                    1592   ; RamPtr ++ ;
000010F2  5283      1593          addq.l    #1,D3
000010F4  6000 FF3A 1594          bra       MemoryChange_1
                    1595   MemoryChange_6:
000010F8  4CDF 041C 1596          movem.l   (A7)+,D2/D3/D4/A2
000010FC  4E75      1597          rts
                    1598   ; }
                    1599   ; }
                    1600   ; /******************************************************************************************
                    1601   ; ** The following code is for the SPI controller
                    1602   ; *******************************************************************************************/
                    1603   ; // return true if the SPI has finished transmitting a byte (to say the Flash chip) return false otherwise
                    1604   ; // this can be used in a polling algorithm to know when the controller is busy or idle.
                    1605   ; int TestForSPITransmitDataComplete(void)    {
                    1606   _TestForSPITransmitDataComplete:
000010FE  4E56 FFF8 1607          link      A6,#-8
                    1608   ; /* TODO replace 0 below with a test for status register SPIF bit and if set, return true */
                    1609   ; int result; 
                    1610   ; int status;
                    1611   ; status = SPI_Status;
00001102  1039 0040 1612          move.b    4227106,D0
00001106  8022      
00001108  C0BC 0000 1613          and.l     #255,D0
0000110C  00FF      
0000110E  2D40 FFFC 1614          move.l    D0,-4(A6)
                    1615   ; //printf("\r\nSPI status reg: %d",status); 
                    1616   ; result = status & 0x80; // get the SPIF bit, if SPIF == 1, then transmit is completed, if 0, then not completed. 
00001112  202E FFFC 1617          move.l    -4(A6),D0
00001116  C0BC 0000 1618          and.l     #128,D0
0000111A  0080      
0000111C  2D40 FFF8 1619          move.l    D0,-8(A6)
                    1620   ; return result;
00001120  202E FFF8 1621          move.l    -8(A6),D0
00001124  4E5E      1622          unlk      A6
00001126  4E75      1623          rts
                    1624   ; }
                    1625   ; /************************************************************************************
                    1626   ; ** initialises the SPI controller chip to set speed, interrupt capability etc.
                    1627   ; ************************************************************************************/
                    1628   ; void SPI_Init(void)
                    1629   ; {
                    1630   _SPI_Init:
                    1631   ; //TODO
                    1632   ; //
                    1633   ; // Program the SPI Control, EXT, CS and Status registers to initialise the SPI controller
                    1634   ; // Don't forget to call this routine from main() before you do anything else with SPI
                    1635   ; //
                    1636   ; // Here are some settings we want to create
                    1637   ; //
                    1638   ; // Control Reg     - interrupts disabled, core enabled, Master mode, Polarity and Phase of clock = [0,0], speed =  divide by 32 = approx 700Khz
                    1639   ; // Ext Reg         - in conjunction with control reg, sets speed above and also sets interrupt flag after every completed transfer (each byte)
                    1640   ; // SPI_CS Reg      - control selection of slave SPI chips via their CS# signals
                    1641   ; // Status Reg      - status of SPI controller chip and used to clear any write collision and interrupt on transmit complete flag
                    1642   ; SPI_Control = 0x53;
00001128  13FC 0053 1643          move.b    #83,4227104
0000112C  0040 8020 
                    1644   ; SPI_Ext = 0x00;
00001130  4239 0040 1645          clr.b     4227110
00001134  8026      
                    1646   ; Disable_SPI_CS(); // Disable the flash chip during initialisation 
00001136  13FC 00FF 1647          move.b    #255,4227112
0000113A  0040 8028 
                    1648   ; SPI_Status = 0xc0;
0000113E  13FC 00C0 1649          move.b    #192,4227106
00001142  0040 8022 
00001146  4E75      1650          rts
                    1651   ; }
                    1652   ; /************************************************************************************
                    1653   ; ** return ONLY when the SPI controller has finished transmitting a byte
                    1654   ; ************************************************************************************/
                    1655   ; void WaitForSPITransmitComplete(void)
                    1656   ; {
                    1657   _WaitForSPITransmitComplete:
00001148  2F02      1658          move.l    D2,-(A7)
                    1659   ; // TODO : poll the status register SPIF bit looking for completion of transmission
                    1660   ; // once transmission is complete, clear the write collision and interrupt on transmit complete flags in the status register (read documentation)
                    1661   ; // just in case they were set
                    1662   ; int SPITransmitComplete = 0;
0000114A  4282      1663          clr.l     D2
                    1664   ; while (!SPITransmitComplete)
                    1665   WaitForSPITransmitComplete_1:
0000114C  4A82      1666          tst.l     D2
0000114E  6608      1667          bne.s     WaitForSPITransmitComplete_3
                    1668   ; {
                    1669   ; SPITransmitComplete = TestForSPITransmitDataComplete();
00001150  4EB8 10FE 1670          jsr       _TestForSPITransmitDataComplete
00001154  2400      1671          move.l    D0,D2
00001156  60F4      1672          bra       WaitForSPITransmitComplete_1
                    1673   WaitForSPITransmitComplete_3:
                    1674   ; //printf("\r\nSPI data transmit complete: %d", SPITransmitComplete);
                    1675   ; }
                    1676   ; SPI_Status = 0xc0;
00001158  13FC 00C0 1677          move.b    #192,4227106
0000115C  0040 8022 
00001160  241F      1678          move.l    (A7)+,D2
00001162  4E75      1679          rts
                    1680   ; }
                    1681   ; /************************************************************************************
                    1682   ; ** Write a byte to the SPI flash chip via the controller and returns (reads) whatever was
                    1683   ; ** given back by SPI device at the same time (removes the read byte from the FIFO)
                    1684   ; ************************************************************************************/
                    1685   ; int WriteSPIChar(int c)
                    1686   ; {
                    1687   _WriteSPIChar:
00001164  4E56 0000 1688          link      A6,#0
00001168  2F02      1689          move.l    D2,-(A7)
                    1690   ; // todo - write the byte in parameter 'c' to the SPI data register, this will start it transmitting to the flash device
                    1691   ; // wait for completion of transmission
                    1692   ; // return the received data from Flash chip (which may not be relevent depending upon what we are doing)
                    1693   ; // by reading fom the SPI controller Data Register.
                    1694   ; // note however that in order to get data from an SPI slave device (e.g. flash) chip we have to write a dummy byte to it
                    1695   ; //
                    1696   ; // modify '0' below to return back read byte from data register
                    1697   ; //
                    1698   ; int read_data = 0; 
0000116A  4282      1699          clr.l     D2
                    1700   ; SPI_Data = c; 
0000116C  202E 0008 1701          move.l    8(A6),D0
00001170  13C0 0040 1702          move.b    D0,4227108
00001174  8024      
                    1703   ; WaitForSPITransmitComplete();
00001176  4EB8 1148 1704          jsr       _WaitForSPITransmitComplete
                    1705   ; read_data = SPI_Data;
0000117A  1039 0040 1706          move.b    4227108,D0
0000117E  8024      
00001180  C0BC 0000 1707          and.l     #255,D0
00001184  00FF      
00001186  2400      1708          move.l    D0,D2
                    1709   ; return read_data;                   
00001188  2002      1710          move.l    D2,D0
0000118A  241F      1711          move.l    (A7)+,D2
0000118C  4E5E      1712          unlk      A6
0000118E  4E75      1713          rts
                    1714   ; }
                    1715   ; // send a command to the flash chip 
                    1716   ; void send_spi_cmd(int c){
                    1717   _send_spi_cmd:
00001190  4E56 FFFC 1718          link      A6,#-4
                    1719   ; int read_data;
                    1720   ; Enable_SPI_CS();
00001194  13FC 00FE 1721          move.b    #254,4227112
00001198  0040 8028 
                    1722   ; read_data = WriteSPIChar(c);
0000119C  2F2E 0008 1723          move.l    8(A6),-(A7)
000011A0  4EB8 1164 1724          jsr       _WriteSPIChar
000011A4  584F      1725          addq.w    #4,A7
000011A6  2D40 FFFC 1726          move.l    D0,-4(A6)
                    1727   ; Disable_SPI_CS();
000011AA  13FC 00FF 1728          move.b    #255,4227112
000011AE  0040 8028 
000011B2  4E5E      1729          unlk      A6
000011B4  4E75      1730          rts
                    1731   ; }
                    1732   ; /*Check the flash chip's status register*/
                    1733   ; void wait_for_flash_status_done(void)
                    1734   ; {
                    1735   _wait_for_flash_status_done:
000011B6  4E56 FFFC 1736          link      A6,#-4
                    1737   ; int dummy_byte = 0x00;
000011BA  42AE FFFC 1738          clr.l     -4(A6)
                    1739   ; Enable_SPI_CS();
000011BE  13FC 00FE 1740          move.b    #254,4227112
000011C2  0040 8028 
                    1741   ; WriteSPIChar(check_status_cmd); // send the check flash status register cmd
000011C6  4878 0005 1742          pea       5
000011CA  4EB8 1164 1743          jsr       _WriteSPIChar
000011CE  584F      1744          addq.w    #4,A7
                    1745   ; while(WriteSPIChar(dummy_byte) & 0x01){
                    1746   wait_for_flash_status_done_1:
000011D0  2F2E FFFC 1747          move.l    -4(A6),-(A7)
000011D4  4EB8 1164 1748          jsr       _WriteSPIChar
000011D8  584F      1749          addq.w    #4,A7
000011DA  C0BC 0000 1750          and.l     #1,D0
000011DE  0001      
000011E0  6702      1751          beq.s     wait_for_flash_status_done_3
                    1752   ; }
000011E2  60EC      1753          bra       wait_for_flash_status_done_1
                    1754   wait_for_flash_status_done_3:
                    1755   ; Disable_SPI_CS();
000011E4  13FC 00FF 1756          move.b    #255,4227112
000011E8  0040 8028 
000011EC  4E5E      1757          unlk      A6
000011EE  4E75      1758          rts
                    1759   ; }
                    1760   ; void write_256_bytes(int spi_start_address)
                    1761   ; {
                    1762   _write_256_bytes:
000011F0  4E56 FFF4 1763          link      A6,#-12
000011F4  48E7 3020 1764          movem.l   D2/D3/A2,-(A7)
000011F8  45F8 1164 1765          lea       _WriteSPIChar.L,A2
000011FC  262E 0008 1766          move.l    8(A6),D3
                    1767   ; int i;
                    1768   ; unsigned char write_data;
                    1769   ; volatile unsigned char* current_address;
                    1770   ; volatile unsigned char* dram_start_address = (volatile unsigned char*) (start_of_dram);
00001200  2D7C 0800 1771          move.l    #134217728,-4(A6)
00001204  0000 FFFC 
                    1772   ; send_spi_cmd(write_enable_cmd);
00001208  4878 0006 1773          pea       6
0000120C  4EB8 1190 1774          jsr       _send_spi_cmd
00001210  584F      1775          addq.w    #4,A7
                    1776   ; Enable_SPI_CS();
00001212  13FC 00FE 1777          move.b    #254,4227112
00001216  0040 8028 
                    1778   ; WriteSPIChar(write_cmd); // write cmd
0000121A  4878 0002 1779          pea       2
0000121E  4E92      1780          jsr       (A2)
00001220  584F      1781          addq.w    #4,A7
                    1782   ; // 24 bit address, send the upper 8 bits first, then middle 8 bits, then lower 8 bits
                    1783   ; WriteSPIChar(spi_start_address >> 8); 
00001222  2203      1784          move.l    D3,D1
00001224  E081      1785          asr.l     #8,D1
00001226  2F01      1786          move.l    D1,-(A7)
00001228  4E92      1787          jsr       (A2)
0000122A  584F      1788          addq.w    #4,A7
                    1789   ; WriteSPIChar(spi_start_address & 0xff); // make sure it's 8 bits
0000122C  2203      1790          move.l    D3,D1
0000122E  C2BC 0000 1791          and.l     #255,D1
00001232  00FF      
00001234  2F01      1792          move.l    D1,-(A7)
00001236  4E92      1793          jsr       (A2)
00001238  584F      1794          addq.w    #4,A7
                    1795   ; WriteSPIChar(0x00); // keep lower 8 bits 0 as required by flash chip's data sheet
0000123A  42A7      1796          clr.l     -(A7)
0000123C  4E92      1797          jsr       (A2)
0000123E  584F      1798          addq.w    #4,A7
                    1799   ; for (i=0;i<256;i++){
00001240  4282      1800          clr.l     D2
                    1801   write_256_bytes_1:
00001242  0C82 0000 1802          cmp.l     #256,D2
00001246  0100      
00001248  6C2C      1803          bge.s     write_256_bytes_3
                    1804   ; current_address = dram_start_address + (spi_start_address << 8) + i;
0000124A  202E FFFC 1805          move.l    -4(A6),D0
0000124E  2203      1806          move.l    D3,D1
00001250  E181      1807          asl.l     #8,D1
00001252  D081      1808          add.l     D1,D0
00001254  D082      1809          add.l     D2,D0
00001256  2D40 FFF8 1810          move.l    D0,-8(A6)
                    1811   ; write_data = *current_address; 
0000125A  206E FFF8 1812          move.l    -8(A6),A0
0000125E  1D50 FFF7 1813          move.b    (A0),-9(A6)
                    1814   ; WriteSPIChar((int)(write_data)); // write 256 bytes (1 page) to the flash
00001262  122E FFF7 1815          move.b    -9(A6),D1
00001266  C2BC 0000 1816          and.l     #255,D1
0000126A  00FF      
0000126C  2F01      1817          move.l    D1,-(A7)
0000126E  4E92      1818          jsr       (A2)
00001270  584F      1819          addq.w    #4,A7
00001272  5282      1820          addq.l    #1,D2
00001274  60CC      1821          bra       write_256_bytes_1
                    1822   write_256_bytes_3:
                    1823   ; }
                    1824   ; Disable_SPI_CS();
00001276  13FC 00FF 1825          move.b    #255,4227112
0000127A  0040 8028 
                    1826   ; // check if the writting is completed
                    1827   ; wait_for_flash_status_done();
0000127E  4EB8 11B6 1828          jsr       _wait_for_flash_status_done
00001282  4CDF 040C 1829          movem.l   (A7)+,D2/D3/A2
00001286  4E5E      1830          unlk      A6
00001288  4E75      1831          rts
                    1832   ; }
                    1833   ; int read_256k_bytes(void){
                    1834   _read_256k_bytes:
0000128A  4E56 FFF8 1835          link      A6,#-8
0000128E  48E7 3C20 1836          movem.l   D2/D3/D4/D5/A2,-(A7)
00001292  45F8 1164 1837          lea       _WriteSPIChar.L,A2
                    1838   ; int i;
                    1839   ; unsigned char dram_data;
                    1840   ; int flash_data;
                    1841   ; int dummy_byte = 0x00;
00001296  42AE FFF8 1842          clr.l     -8(A6)
                    1843   ; volatile unsigned char* current_address;
                    1844   ; volatile unsigned char* dram_start_address = (volatile unsigned char*) (start_of_dram);
0000129A  2D7C 0800 1845          move.l    #134217728,-4(A6)
0000129E  0000 FFFC 
                    1846   ; Enable_SPI_CS();
000012A2  13FC 00FE 1847          move.b    #254,4227112
000012A6  0040 8028 
                    1848   ; WriteSPIChar(read_cmd); // read cmd
000012AA  4878 0003 1849          pea       3
000012AE  4E92      1850          jsr       (A2)
000012B0  584F      1851          addq.w    #4,A7
                    1852   ; WriteSPIChar(0x00); // read from 0 address of the flash
000012B2  42A7      1853          clr.l     -(A7)
000012B4  4E92      1854          jsr       (A2)
000012B6  584F      1855          addq.w    #4,A7
                    1856   ; WriteSPIChar(0x00);
000012B8  42A7      1857          clr.l     -(A7)
000012BA  4E92      1858          jsr       (A2)
000012BC  584F      1859          addq.w    #4,A7
                    1860   ; WriteSPIChar(0x00);
000012BE  42A7      1861          clr.l     -(A7)
000012C0  4E92      1862          jsr       (A2)
000012C2  584F      1863          addq.w    #4,A7
                    1864   ; // 256*1024 = 262144 
                    1865   ; for (i=0;i<262144;i++){
000012C4  4282      1866          clr.l     D2
                    1867   read_256k_bytes_1:
000012C6  0C82 0004 1868          cmp.l     #262144,D2
000012CA  0000      
000012CC  6C00 006C 1869          bge       read_256k_bytes_3
                    1870   ; current_address = dram_start_address + i;
000012D0  202E FFFC 1871          move.l    -4(A6),D0
000012D4  D082      1872          add.l     D2,D0
000012D6  2A00      1873          move.l    D0,D5
                    1874   ; dram_data = *current_address; 
000012D8  2045      1875          move.l    D5,A0
000012DA  1810      1876          move.b    (A0),D4
                    1877   ; flash_data = WriteSPIChar(dummy_byte); // read 256k bytes from the flash
000012DC  2F2E FFF8 1878          move.l    -8(A6),-(A7)
000012E0  4E92      1879          jsr       (A2)
000012E2  584F      1880          addq.w    #4,A7
000012E4  2600      1881          move.l    D0,D3
                    1882   ; if (dram_data != flash_data) {
000012E6  C8BC 0000 1883          and.l     #255,D4
000012EA  00FF      
000012EC  B883      1884          cmp.l     D3,D4
000012EE  6720      1885          beq.s     read_256k_bytes_4
                    1886   ; printf("\r\nData discrepancy at location: %x SDRAM data: %x Flash data: %x",current_address, dram_data, flash_data);
000012F0  2F03      1887          move.l    D3,-(A7)
000012F2  C8BC 0000 1888          and.l     #255,D4
000012F6  00FF      
000012F8  2F04      1889          move.l    D4,-(A7)
000012FA  2F05      1890          move.l    D5,-(A7)
000012FC  4879 0000 1891          pea       @m68kde~1_22.L
00001300  3FAC      
00001302  4EB9 0000 1892          jsr       _printf
00001306  343A      
00001308  DEFC 0010 1893          add.w     #16,A7
                    1894   ; return 0;
0000130C  4280      1895          clr.l     D0
0000130E  6034      1896          bra.s     read_256k_bytes_6
                    1897   read_256k_bytes_4:
                    1898   ; } else if (i%65536 == 0) { // if no data discrepancy, print the progress every 16^4 address
00001310  2002      1899          move.l    D2,D0
00001312  C0BC 0000 1900          and.l     #65535,D0
00001316  FFFF      
00001318  661C      1901          bne.s     read_256k_bytes_7
                    1902   ; printf("\r\nlocation: %x SDRAM data: %x Flash data: %x",current_address, dram_data, flash_data);
0000131A  2F03      1903          move.l    D3,-(A7)
0000131C  C8BC 0000 1904          and.l     #255,D4
00001320  00FF      
00001322  2F04      1905          move.l    D4,-(A7)
00001324  2F05      1906          move.l    D5,-(A7)
00001326  4879 0000 1907          pea       @m68kde~1_23.L
0000132A  3FEE      
0000132C  4EB9 0000 1908          jsr       _printf
00001330  343A      
00001332  DEFC 0010 1909          add.w     #16,A7
                    1910   read_256k_bytes_7:
00001336  5282      1911          addq.l    #1,D2
00001338  608C      1912          bra       read_256k_bytes_1
                    1913   read_256k_bytes_3:
                    1914   ; } 
                    1915   ; }
                    1916   ; Disable_SPI_CS();
0000133A  13FC 00FF 1917          move.b    #255,4227112
0000133E  0040 8028 
                    1918   ; return 1;
00001342  7001      1919          moveq     #1,D0
                    1920   read_256k_bytes_6:
00001344  4CDF 043C 1921          movem.l   (A7)+,D2/D3/D4/D5/A2
00001348  4E5E      1922          unlk      A6
0000134A  4E75      1923          rts
                    1924   ; }
                    1925   ; void load_sdram_from_spi_flash(void){
                    1926   _load_sdram_from_spi_flash:
0000134C  4E56 FFF0 1927          link      A6,#-16
00001350  48E7 2020 1928          movem.l   D2/A2,-(A7)
00001354  45F8 1164 1929          lea       _WriteSPIChar.L,A2
                    1930   ; int i;
                    1931   ; int dummy_byte = 0x00;
00001358  42AE FFF0 1932          clr.l     -16(A6)
                    1933   ; int data;
                    1934   ; volatile unsigned char* current_address;
                    1935   ; volatile unsigned char* dram_start_address = (volatile unsigned char*) (start_of_dram);
0000135C  2D7C 0800 1936          move.l    #134217728,-4(A6)
00001360  0000 FFFC 
                    1937   ; Enable_SPI_CS();
00001364  13FC 00FE 1938          move.b    #254,4227112
00001368  0040 8028 
                    1939   ; WriteSPIChar(read_cmd); // read cmd
0000136C  4878 0003 1940          pea       3
00001370  4E92      1941          jsr       (A2)
00001372  584F      1942          addq.w    #4,A7
                    1943   ; WriteSPIChar(0x00); // read from 0 address of the flash
00001374  42A7      1944          clr.l     -(A7)
00001376  4E92      1945          jsr       (A2)
00001378  584F      1946          addq.w    #4,A7
                    1947   ; WriteSPIChar(0x00);
0000137A  42A7      1948          clr.l     -(A7)
0000137C  4E92      1949          jsr       (A2)
0000137E  584F      1950          addq.w    #4,A7
                    1951   ; WriteSPIChar(0x00);
00001380  42A7      1952          clr.l     -(A7)
00001382  4E92      1953          jsr       (A2)
00001384  584F      1954          addq.w    #4,A7
                    1955   ; // 256*1024 = 262144 
                    1956   ; for (i=0;i<262144;i++){
00001386  4282      1957          clr.l     D2
                    1958   load_sdram_from_spi_flash_1:
00001388  0C82 0004 1959          cmp.l     #262144,D2
0000138C  0000      
0000138E  6C24      1960          bge.s     load_sdram_from_spi_flash_3
                    1961   ; current_address = dram_start_address + i; 
00001390  202E FFFC 1962          move.l    -4(A6),D0
00001394  D082      1963          add.l     D2,D0
00001396  2D40 FFF8 1964          move.l    D0,-8(A6)
                    1965   ; data = WriteSPIChar(dummy_byte); // read a byte from spi flash and write to sdram
0000139A  2F2E FFF0 1966          move.l    -16(A6),-(A7)
0000139E  4E92      1967          jsr       (A2)
000013A0  584F      1968          addq.w    #4,A7
000013A2  2D40 FFF4 1969          move.l    D0,-12(A6)
                    1970   ; //printf("\r\nread from SPI flash: %x", data);
                    1971   ; *current_address =  data;
000013A6  202E FFF4 1972          move.l    -12(A6),D0
000013AA  206E FFF8 1973          move.l    -8(A6),A0
000013AE  1080      1974          move.b    D0,(A0)
000013B0  5282      1975          addq.l    #1,D2
000013B2  60D4      1976          bra       load_sdram_from_spi_flash_1
                    1977   load_sdram_from_spi_flash_3:
                    1978   ; //printf("\r\nread from dram: %x", *current_address);
                    1979   ; }
                    1980   ; Disable_SPI_CS();
000013B4  13FC 00FF 1981          move.b    #255,4227112
000013B8  0040 8028 
000013BC  4CDF 0404 1982          movem.l   (A7)+,D2/A2
000013C0  4E5E      1983          unlk      A6
000013C2  4E75      1984          rts
                    1985   ; }
                    1986   ; /*******************************************************************
                    1987   ; ** Write a program to SPI Flash Chip from memory and verify by reading back
                    1988   ; ********************************************************************/
                    1989   ; void ProgramFlashChip(void)
                    1990   ; {
                    1991   _ProgramFlashChip:
000013C4  4E56 FFE4 1992          link      A6,#-28
000013C8  48E7 2020 1993          movem.l   D2/A2,-(A7)
000013CC  45F9 0000 1994          lea       _printf.L,A2
000013D0  343A      
                    1995   ; //
                    1996   ; // TODO : put your code here to program the 1st 256k of ram (where user program is held at hex 08000000) to SPI flash chip
                    1997   ; // TODO : then verify by reading it back and comparing to memory
                    1998   ; //
                    1999   ; int read_data; 
                    2000   ; int dummy_byte = 0x00;
000013D2  42AE FFEA 2001          clr.l     -22(A6)
                    2002   ; int i, j; 
                    2003   ; volatile unsigned char* current_address;
                    2004   ; volatile unsigned char* dram_start_address = (volatile unsigned char*) (start_of_dram);
000013D6  2D7C 0800 2005          move.l    #134217728,-6(A6)
000013DA  0000 FFFA 
                    2006   ; int address_counter;
                    2007   ; unsigned char write_data;
                    2008   ; SPI_Init(); // initialise the SPI controller
000013DE  4EB8 1128 2009          jsr       _SPI_Init
                    2010   ; // send write enble command to the flash chip
                    2011   ; send_spi_cmd(write_enable_cmd);
000013E2  4878 0006 2012          pea       6
000013E6  4EB8 1190 2013          jsr       _send_spi_cmd
000013EA  584F      2014          addq.w    #4,A7
                    2015   ; // erasing the flash chip
                    2016   ; printf("\r\nErasing SPI flash....");
000013EC  4879 0000 2017          pea       @m68kde~1_24.L
000013F0  401C      
000013F2  4E92      2018          jsr       (A2)
000013F4  584F      2019          addq.w    #4,A7
                    2020   ; send_spi_cmd(erasing_cmd);
000013F6  4878 00C7 2021          pea       199
000013FA  4EB8 1190 2022          jsr       _send_spi_cmd
000013FE  584F      2023          addq.w    #4,A7
                    2024   ; // check if the erasing is completed
                    2025   ; wait_for_flash_status_done();
00001400  4EB8 11B6 2026          jsr       _wait_for_flash_status_done
                    2027   ; // send write enble command to the flash chip
                    2028   ; // write
                    2029   ; printf("\r\nWritting the SPI flash using SDRAM data....");
00001404  4879 0000 2030          pea       @m68kde~1_25.L
00001408  4034      
0000140A  4E92      2031          jsr       (A2)
0000140C  584F      2032          addq.w    #4,A7
                    2033   ; for (address_counter=0; address_counter<1024; address_counter++) {
0000140E  4282      2034          clr.l     D2
                    2035   ProgramFlashChip_1:
00001410  0C82 0000 2036          cmp.l     #1024,D2
00001414  0400      
00001416  6C0C      2037          bge.s     ProgramFlashChip_3
                    2038   ; write_256_bytes(address_counter);
00001418  2F02      2039          move.l    D2,-(A7)
0000141A  4EB8 11F0 2040          jsr       _write_256_bytes
0000141E  584F      2041          addq.w    #4,A7
00001420  5282      2042          addq.l    #1,D2
00001422  60EC      2043          bra       ProgramFlashChip_1
                    2044   ProgramFlashChip_3:
                    2045   ; } 
                    2046   ; // TO DO: write a read program similar to the write program, print results every 16^4 address
                    2047   ; printf("\r\nReading the SPI flash data and comparing to SDRAM....") ;
00001424  4879 0000 2048          pea       @m68kde~1_26.L
00001428  4062      
0000142A  4E92      2049          jsr       (A2)
0000142C  584F      2050          addq.w    #4,A7
                    2051   ; read_256k_bytes();
0000142E  4EB8 128A 2052          jsr       _read_256k_bytes
00001432  4CDF 0404 2053          movem.l   (A7)+,D2/A2
00001436  4E5E      2054          unlk      A6
00001438  4E75      2055          rts
                    2056   ; }
                    2057   ; /*************************************************************************
                    2058   ; ** Load a program from SPI Flash Chip and copy to Dram
                    2059   ; **************************************************************************/
                    2060   ; void LoadFromFlashChip(void)
                    2061   ; {
                    2062   _LoadFromFlashChip:
                    2063   ; printf("\r\nLoading Program From SPI Flash....") ;
0000143A  4879 0000 2064          pea       @m68kde~1_27.L
0000143E  409A      
00001440  4EB9 0000 2065          jsr       _printf
00001444  343A      
00001446  584F      2066          addq.w    #4,A7
                    2067   ; SPI_Init(); // initialise the SPI controller
00001448  4EB8 1128 2068          jsr       _SPI_Init
                    2069   ; load_sdram_from_spi_flash(); 
0000144C  4EB8 134C 2070          jsr       _load_sdram_from_spi_flash
00001450  4E75      2071          rts
                    2072   ; //
                    2073   ; // TODO : put your code here to read 256k of data from SPI flash chip and store in user ram starting at hex 08000000
                    2074   ; //
                    2075   ; }
                    2076   ; //////////////////////////////////////////////////////////////////////////////////////////////////
                    2077   ; // IMPORTANT
                    2078   ; // TG68 does not support the Native Trace mode of the original 68000 so tracing
                    2079   ; // has to be done with an interrupt (IRQ Level 6)
                    2080   ; //
                    2081   ; // To allow the 68000 to execute one more instruction after each pseudo trace (IRQ6)
                    2082   ; // the IRQ is removed in hardware once the TG68 reads the IRQ autovector (i.e. acknowledges the IRQ)
                    2083   ; //
                    2084   ; // on return from the IRQ service handler, the first access to the user memory program space
                    2085   ; // generates a fresh IRQ (in hardware) to generate a new trace, this allows the tg68 to
                    2086   ; // execute one more new instruction (without it the TG68 would trace on the same instruction
                    2087   ; // each time and not after the next one). It also means it doesn't simgle step outside the user
                    2088   ; // program area
                    2089   ; //
                    2090   ; // The bottom line is the Trace handler, which includes the Dump registers below
                    2091   ; // cannot access the user memory to display for example the Instruction Opcode or to disassemble etc
                    2092   ; // as this would lead to a new IRQ being reset and the TG68 would trace on same instruction
                    2093   ; // NOT SURE THIS IS TRUE NOW THAT TRACE HANDLER HAS BEEN MODIVIED TO NOT AUTOMATICALLY GENERATE A TRACE EXCEPTION
                    2094   ; // INSTEAD IT IS DONE IN THE 'N' COMMAND FOR NEXT
                    2095   ; /////////////////////////////////////////////////////////////////////////////////////////////////////
                    2096   ; void DumpRegisters()
                    2097   ; {
                    2098   _DumpRegisters:
00001452  48E7 3F3C 2099          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00001456  45F9 0000 2100          lea       _putch.L,A2
0000145A  332C      
0000145C  47F9 0000 2101          lea       _printf.L,A3
00001460  343A      
00001462  49F9 0B00 2102          lea       _SR.L,A4
00001466  012C      
00001468  4BF9 0B00 2103          lea       _WatchPointString.L,A5
0000146C  01C2      
                    2104   ; short i, x, j, k ;
                    2105   ; unsigned char c, *BytePointer;
                    2106   ; // buld up strings for displaying watchpoints
                    2107   ; for(x = 0; x < (short)(8); x++)
0000146E  4242      2108          clr.w     D2
                    2109   DumpRegisters_1:
00001470  0C42 0008 2110          cmp.w     #8,D2
00001474  6C00 01C6 2111          bge       DumpRegisters_3
                    2112   ; {
                    2113   ; if(WatchPointSetOrCleared[x] == 1)
00001478  48C2      2114          ext.l     D2
0000147A  2002      2115          move.l    D2,D0
0000147C  E588      2116          lsl.l     #2,D0
0000147E  41F9 0B00 2117          lea       _WatchPointSetOrCleared.L,A0
00001482  01A2      
00001484  2030 0800 2118          move.l    0(A0,D0.L),D0
00001488  0C80 0000 2119          cmp.l     #1,D0
0000148C  0001      
0000148E  6600 0186 2120          bne       DumpRegisters_4
                    2121   ; {
                    2122   ; sprintf(WatchPointString[x], "$%08X  ", WatchPointAddress[x]) ;
00001492  48C2      2123          ext.l     D2
00001494  2202      2124          move.l    D2,D1
00001496  E589      2125          lsl.l     #2,D1
00001498  41F9 0B00 2126          lea       _WatchPointAddress.L,A0
0000149C  0182      
0000149E  2F30 1800 2127          move.l    0(A0,D1.L),-(A7)
000014A2  4879 0000 2128          pea       @m68kde~1_28.L
000014A6  40C0      
000014A8  220D      2129          move.l    A5,D1
000014AA  48C2      2130          ext.l     D2
000014AC  2F00      2131          move.l    D0,-(A7)
000014AE  2002      2132          move.l    D2,D0
000014B0  C1FC 0064 2133          muls      #100,D0
000014B4  D280      2134          add.l     D0,D1
000014B6  201F      2135          move.l    (A7)+,D0
000014B8  2F01      2136          move.l    D1,-(A7)
000014BA  4EB9 0000 2137          jsr       _sprintf
000014BE  33C4      
000014C0  DEFC 000C 2138          add.w     #12,A7
                    2139   ; BytePointer = (char *)(WatchPointAddress[x]) ;
000014C4  48C2      2140          ext.l     D2
000014C6  2002      2141          move.l    D2,D0
000014C8  E588      2142          lsl.l     #2,D0
000014CA  41F9 0B00 2143          lea       _WatchPointAddress.L,A0
000014CE  0182      
000014D0  2A30 0800 2144          move.l    0(A0,D0.L),D5
                    2145   ; for(j = 0; j < (short)(16); j+=2)
000014D4  4243      2146          clr.w     D3
                    2147   DumpRegisters_6:
000014D6  0C43 0010 2148          cmp.w     #16,D3
000014DA  6C00 0082 2149          bge       DumpRegisters_8
                    2150   ; {
                    2151   ; for(k = 0; k < (short)(2); k++)
000014DE  4246      2152          clr.w     D6
                    2153   DumpRegisters_9:
000014E0  0C46 0002 2154          cmp.w     #2,D6
000014E4  6C00 0052 2155          bge       DumpRegisters_11
                    2156   ; {
                    2157   ; sprintf(TempString, "%02X", BytePointer[j+k]) ;
000014E8  2045      2158          move.l    D5,A0
000014EA  48C3      2159          ext.l     D3
000014EC  2203      2160          move.l    D3,D1
000014EE  48C6      2161          ext.l     D6
000014F0  D286      2162          add.l     D6,D1
000014F2  1230 1800 2163          move.b    0(A0,D1.L),D1
000014F6  C2BC 0000 2164          and.l     #255,D1
000014FA  00FF      
000014FC  2F01      2165          move.l    D1,-(A7)
000014FE  4879 0000 2166          pea       @m68kde~1_8.L
00001502  3E02      
00001504  4879 0B00 2167          pea       _TempString.L
00001508  04E2      
0000150A  4EB9 0000 2168          jsr       _sprintf
0000150E  33C4      
00001510  DEFC 000C 2169          add.w     #12,A7
                    2170   ; strcat(WatchPointString[x], TempString) ;
00001514  4879 0B00 2171          pea       _TempString.L
00001518  04E2      
0000151A  220D      2172          move.l    A5,D1
0000151C  48C2      2173          ext.l     D2
0000151E  2F00      2174          move.l    D0,-(A7)
00001520  2002      2175          move.l    D2,D0
00001522  C1FC 0064 2176          muls      #100,D0
00001526  D280      2177          add.l     D0,D1
00001528  201F      2178          move.l    (A7)+,D0
0000152A  2F01      2179          move.l    D1,-(A7)
0000152C  4EB9 0000 2180          jsr       _strcat
00001530  33F8      
00001532  504F      2181          addq.w    #8,A7
00001534  5246      2182          addq.w    #1,D6
00001536  60A8      2183          bra       DumpRegisters_9
                    2184   DumpRegisters_11:
                    2185   ; }
                    2186   ; strcat(WatchPointString[x]," ") ;
00001538  4879 0000 2187          pea       @m68kde~1_29.L
0000153C  40C8      
0000153E  220D      2188          move.l    A5,D1
00001540  48C2      2189          ext.l     D2
00001542  2F00      2190          move.l    D0,-(A7)
00001544  2002      2191          move.l    D2,D0
00001546  C1FC 0064 2192          muls      #100,D0
0000154A  D280      2193          add.l     D0,D1
0000154C  201F      2194          move.l    (A7)+,D0
0000154E  2F01      2195          move.l    D1,-(A7)
00001550  4EB9 0000 2196          jsr       _strcat
00001554  33F8      
00001556  504F      2197          addq.w    #8,A7
00001558  5443      2198          addq.w    #2,D3
0000155A  6000 FF7A 2199          bra       DumpRegisters_6
                    2200   DumpRegisters_8:
                    2201   ; }
                    2202   ; strcat(WatchPointString[x], "  ") ;
0000155E  4879 0000 2203          pea       @m68kde~1_9.L
00001562  3E08      
00001564  220D      2204          move.l    A5,D1
00001566  48C2      2205          ext.l     D2
00001568  2F00      2206          move.l    D0,-(A7)
0000156A  2002      2207          move.l    D2,D0
0000156C  C1FC 0064 2208          muls      #100,D0
00001570  D280      2209          add.l     D0,D1
00001572  201F      2210          move.l    (A7)+,D0
00001574  2F01      2211          move.l    D1,-(A7)
00001576  4EB9 0000 2212          jsr       _strcat
0000157A  33F8      
0000157C  504F      2213          addq.w    #8,A7
                    2214   ; BytePointer = (char *)(WatchPointAddress[x]) ;
0000157E  48C2      2215          ext.l     D2
00001580  2002      2216          move.l    D2,D0
00001582  E588      2217          lsl.l     #2,D0
00001584  41F9 0B00 2218          lea       _WatchPointAddress.L,A0
00001588  0182      
0000158A  2A30 0800 2219          move.l    0(A0,D0.L),D5
                    2220   ; for(j = 0; j < (short)(16); j++)
0000158E  4243      2221          clr.w     D3
                    2222   DumpRegisters_12:
00001590  0C43 0010 2223          cmp.w     #16,D3
00001594  6C00 007E 2224          bge       DumpRegisters_14
                    2225   ; {
                    2226   ; c = ((char)(BytePointer[j]) & 0x7f) ;
00001598  2045      2227          move.l    D5,A0
0000159A  48C3      2228          ext.l     D3
0000159C  1030 3800 2229          move.b    0(A0,D3.L),D0
000015A0  C03C 007F 2230          and.b     #127,D0
000015A4  1E00      2231          move.b    D0,D7
                    2232   ; if((c > (char)(0x7f)) || (c < (char)(' ')))
000015A6  0C07 007F 2233          cmp.b     #127,D7
000015AA  6206      2234          bhi.s     DumpRegisters_17
000015AC  0C07 0020 2235          cmp.b     #32,D7
000015B0  6416      2236          bhs.s     DumpRegisters_15
                    2237   DumpRegisters_17:
                    2238   ; sprintf(TempString, ".") ;
000015B2  4879 0000 2239          pea       @m68kde~1_30.L
000015B6  40CA      
000015B8  4879 0B00 2240          pea       _TempString.L
000015BC  04E2      
000015BE  4EB9 0000 2241          jsr       _sprintf
000015C2  33C4      
000015C4  504F      2242          addq.w    #8,A7
000015C6  6026      2243          bra.s     DumpRegisters_16
                    2244   DumpRegisters_15:
                    2245   ; else
                    2246   ; sprintf(TempString, "%c", BytePointer[j]) ;
000015C8  2045      2247          move.l    D5,A0
000015CA  48C3      2248          ext.l     D3
000015CC  1230 3800 2249          move.b    0(A0,D3.L),D1
000015D0  C2BC 0000 2250          and.l     #255,D1
000015D4  00FF      
000015D6  2F01      2251          move.l    D1,-(A7)
000015D8  4879 0000 2252          pea       @m68kde~1_31.L
000015DC  40CC      
000015DE  4879 0B00 2253          pea       _TempString.L
000015E2  04E2      
000015E4  4EB9 0000 2254          jsr       _sprintf
000015E8  33C4      
000015EA  DEFC 000C 2255          add.w     #12,A7
                    2256   DumpRegisters_16:
                    2257   ; strcat(WatchPointString[x], TempString) ;
000015EE  4879 0B00 2258          pea       _TempString.L
000015F2  04E2      
000015F4  220D      2259          move.l    A5,D1
000015F6  48C2      2260          ext.l     D2
000015F8  2F00      2261          move.l    D0,-(A7)
000015FA  2002      2262          move.l    D2,D0
000015FC  C1FC 0064 2263          muls      #100,D0
00001600  D280      2264          add.l     D0,D1
00001602  201F      2265          move.l    (A7)+,D0
00001604  2F01      2266          move.l    D1,-(A7)
00001606  4EB9 0000 2267          jsr       _strcat
0000160A  33F8      
0000160C  504F      2268          addq.w    #8,A7
0000160E  5243      2269          addq.w    #1,D3
00001610  6000 FF7E 2270          bra       DumpRegisters_12
                    2271   DumpRegisters_14:
00001614  6020      2272          bra.s     DumpRegisters_5
                    2273   DumpRegisters_4:
                    2274   ; }
                    2275   ; }
                    2276   ; else
                    2277   ; strcpy(WatchPointString[x], "") ;
00001616  4879 0000 2278          pea       @m68kde~1_32.L
0000161A  40D0      
0000161C  220D      2279          move.l    A5,D1
0000161E  48C2      2280          ext.l     D2
00001620  2F00      2281          move.l    D0,-(A7)
00001622  2002      2282          move.l    D2,D0
00001624  C1FC 0064 2283          muls      #100,D0
00001628  D280      2284          add.l     D0,D1
0000162A  201F      2285          move.l    (A7)+,D0
0000162C  2F01      2286          move.l    D1,-(A7)
0000162E  4EB9 0000 2287          jsr       _strcpy
00001632  323E      
00001634  504F      2288          addq.w    #8,A7
                    2289   DumpRegisters_5:
00001636  5242      2290          addq.w    #1,D2
00001638  6000 FE36 2291          bra       DumpRegisters_1
                    2292   DumpRegisters_3:
                    2293   ; }
                    2294   ; printf("\r\n\r\n D0 = $%08X  A0 = $%08X",d0,a0) ;
0000163C  2F39 0B00 2295          move.l    _a0.L,-(A7)
00001640  0104      
00001642  2F39 0B00 2296          move.l    _d0.L,-(A7)
00001646  00E4      
00001648  4879 0000 2297          pea       @m68kde~1_33.L
0000164C  40D2      
0000164E  4E93      2298          jsr       (A3)
00001650  DEFC 000C 2299          add.w     #12,A7
                    2300   ; printf("\r\n D1 = $%08X  A1 = $%08X",d1,a1) ;
00001654  2F39 0B00 2301          move.l    _a1.L,-(A7)
00001658  0108      
0000165A  2F39 0B00 2302          move.l    _d1.L,-(A7)
0000165E  00E8      
00001660  4879 0000 2303          pea       @m68kde~1_34.L
00001664  40EE      
00001666  4E93      2304          jsr       (A3)
00001668  DEFC 000C 2305          add.w     #12,A7
                    2306   ; printf("\r\n D2 = $%08X  A2 = $%08X",d2,a2) ;
0000166C  2F39 0B00 2307          move.l    _a2.L,-(A7)
00001670  010C      
00001672  2F39 0B00 2308          move.l    _d2.L,-(A7)
00001676  00EC      
00001678  4879 0000 2309          pea       @m68kde~1_35.L
0000167C  4108      
0000167E  4E93      2310          jsr       (A3)
00001680  DEFC 000C 2311          add.w     #12,A7
                    2312   ; printf("\r\n D3 = $%08X  A3 = $%08X",d3,a3) ;
00001684  2F39 0B00 2313          move.l    _a3.L,-(A7)
00001688  0110      
0000168A  2F39 0B00 2314          move.l    _d3.L,-(A7)
0000168E  00F0      
00001690  4879 0000 2315          pea       @m68kde~1_36.L
00001694  4122      
00001696  4E93      2316          jsr       (A3)
00001698  DEFC 000C 2317          add.w     #12,A7
                    2318   ; printf("\r\n D4 = $%08X  A4 = $%08X",d4,a4) ;
0000169C  2F39 0B00 2319          move.l    _a4.L,-(A7)
000016A0  0114      
000016A2  2F39 0B00 2320          move.l    _d4.L,-(A7)
000016A6  00F4      
000016A8  4879 0000 2321          pea       @m68kde~1_37.L
000016AC  413C      
000016AE  4E93      2322          jsr       (A3)
000016B0  DEFC 000C 2323          add.w     #12,A7
                    2324   ; printf("\r\n D5 = $%08X  A5 = $%08X",d5,a5) ;
000016B4  2F39 0B00 2325          move.l    _a5.L,-(A7)
000016B8  0118      
000016BA  2F39 0B00 2326          move.l    _d5.L,-(A7)
000016BE  00F8      
000016C0  4879 0000 2327          pea       @m68kde~1_38.L
000016C4  4156      
000016C6  4E93      2328          jsr       (A3)
000016C8  DEFC 000C 2329          add.w     #12,A7
                    2330   ; printf("\r\n D6 = $%08X  A6 = $%08X",d6,a6) ;
000016CC  2F39 0B00 2331          move.l    _a6.L,-(A7)
000016D0  011C      
000016D2  2F39 0B00 2332          move.l    _d6.L,-(A7)
000016D6  00FC      
000016D8  4879 0000 2333          pea       @m68kde~1_39.L
000016DC  4170      
000016DE  4E93      2334          jsr       (A3)
000016E0  DEFC 000C 2335          add.w     #12,A7
                    2336   ; printf("\r\n D7 = $%08X  A7 = $%08X",d7,((SR & (unsigned short int)(0x2000)) == ((unsigned short int)(0x2000))) ? SSP : USP) ;
000016E4  3214      2337          move.w    (A4),D1
000016E6  C27C 2000 2338          and.w     #8192,D1
000016EA  0C41 2000 2339          cmp.w     #8192,D1
000016EE  6608      2340          bne.s     DumpRegisters_18
000016F0  2239 0B00 2341          move.l    _SSP.L,D1
000016F4  0124      
000016F6  6006      2342          bra.s     DumpRegisters_19
                    2343   DumpRegisters_18:
000016F8  2239 0B00 2344          move.l    _USP.L,D1
000016FC  0128      
                    2345   DumpRegisters_19:
000016FE  2F01      2346          move.l    D1,-(A7)
00001700  2F39 0B00 2347          move.l    _d7.L,-(A7)
00001704  0100      
00001706  4879 0000 2348          pea       @m68kde~1_40.L
0000170A  418A      
0000170C  4E93      2349          jsr       (A3)
0000170E  DEFC 000C 2350          add.w     #12,A7
                    2351   ; printf("\r\n\r\nUSP = $%08X  (A7) User SP", USP ) ;
00001712  2F39 0B00 2352          move.l    _USP.L,-(A7)
00001716  0128      
00001718  4879 0000 2353          pea       @m68kde~1_41.L
0000171C  41A4      
0000171E  4E93      2354          jsr       (A3)
00001720  504F      2355          addq.w    #8,A7
                    2356   ; printf("\r\nSSP = $%08X  (A7) Supervisor SP", SSP) ;
00001722  2F39 0B00 2357          move.l    _SSP.L,-(A7)
00001726  0124      
00001728  4879 0000 2358          pea       @m68kde~1_42.L
0000172C  41C2      
0000172E  4E93      2359          jsr       (A3)
00001730  504F      2360          addq.w    #8,A7
                    2361   ; printf("\r\n SR = $%04X   ",SR) ;
00001732  3214      2362          move.w    (A4),D1
00001734  C2BC 0000 2363          and.l     #65535,D1
00001738  FFFF      
0000173A  2F01      2364          move.l    D1,-(A7)
0000173C  4879 0000 2365          pea       @m68kde~1_43.L
00001740  41E4      
00001742  4E93      2366          jsr       (A3)
00001744  504F      2367          addq.w    #8,A7
                    2368   ; // display the status word in characters etc.
                    2369   ; printf("   [") ;
00001746  4879 0000 2370          pea       @m68kde~1_44.L
0000174A  41F6      
0000174C  4E93      2371          jsr       (A3)
0000174E  584F      2372          addq.w    #4,A7
                    2373   ; if((SR & (unsigned short int)(0x8000)) == (unsigned short int)(0x8000)) putchar('T') ; else putchar('-') ;      // Trace bit(bit 15)
00001750  3014      2374          move.w    (A4),D0
00001752  C07C 8000 2375          and.w     #32768,D0
00001756  0C40 8000 2376          cmp.w     #32768,D0
0000175A  660A      2377          bne.s     DumpRegisters_20
0000175C  4878 0054 2378          pea       84
00001760  4E92      2379          jsr       (A2)
00001762  584F      2380          addq.w    #4,A7
00001764  6008      2381          bra.s     DumpRegisters_21
                    2382   DumpRegisters_20:
00001766  4878 002D 2383          pea       45
0000176A  4E92      2384          jsr       (A2)
0000176C  584F      2385          addq.w    #4,A7
                    2386   DumpRegisters_21:
                    2387   ; if((SR & (unsigned short int)(0x2000)) == (unsigned short int)(0x2000)) putchar('S') ; else putchar('U') ;      // supervisor bit  (bit 13)
0000176E  3014      2388          move.w    (A4),D0
00001770  C07C 2000 2389          and.w     #8192,D0
00001774  0C40 2000 2390          cmp.w     #8192,D0
00001778  660A      2391          bne.s     DumpRegisters_22
0000177A  4878 0053 2392          pea       83
0000177E  4E92      2393          jsr       (A2)
00001780  584F      2394          addq.w    #4,A7
00001782  6008      2395          bra.s     DumpRegisters_23
                    2396   DumpRegisters_22:
00001784  4878 0055 2397          pea       85
00001788  4E92      2398          jsr       (A2)
0000178A  584F      2399          addq.w    #4,A7
                    2400   DumpRegisters_23:
                    2401   ; if((SR & (unsigned short int)(0x0400)) == (unsigned short int)(0x0400)) putchar('1') ; else putchar('0') ;      // IRQ2 Bit (bit 10)
0000178C  3014      2402          move.w    (A4),D0
0000178E  C07C 0400 2403          and.w     #1024,D0
00001792  0C40 0400 2404          cmp.w     #1024,D0
00001796  660A      2405          bne.s     DumpRegisters_24
00001798  4878 0031 2406          pea       49
0000179C  4E92      2407          jsr       (A2)
0000179E  584F      2408          addq.w    #4,A7
000017A0  6008      2409          bra.s     DumpRegisters_25
                    2410   DumpRegisters_24:
000017A2  4878 0030 2411          pea       48
000017A6  4E92      2412          jsr       (A2)
000017A8  584F      2413          addq.w    #4,A7
                    2414   DumpRegisters_25:
                    2415   ; if((SR & (unsigned short int)(0x0200)) == (unsigned short int)(0x0200)) putchar('1') ; else putchar('0') ;      // IRQ1 Bit (bit 9)
000017AA  3014      2416          move.w    (A4),D0
000017AC  C07C 0200 2417          and.w     #512,D0
000017B0  0C40 0200 2418          cmp.w     #512,D0
000017B4  660A      2419          bne.s     DumpRegisters_26
000017B6  4878 0031 2420          pea       49
000017BA  4E92      2421          jsr       (A2)
000017BC  584F      2422          addq.w    #4,A7
000017BE  6008      2423          bra.s     DumpRegisters_27
                    2424   DumpRegisters_26:
000017C0  4878 0030 2425          pea       48
000017C4  4E92      2426          jsr       (A2)
000017C6  584F      2427          addq.w    #4,A7
                    2428   DumpRegisters_27:
                    2429   ; if((SR & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100)) putchar('1') ; else putchar('0') ;      // IRQ0 Bit (bit 8)
000017C8  3014      2430          move.w    (A4),D0
000017CA  C07C 0100 2431          and.w     #256,D0
000017CE  0C40 0100 2432          cmp.w     #256,D0
000017D2  660A      2433          bne.s     DumpRegisters_28
000017D4  4878 0031 2434          pea       49
000017D8  4E92      2435          jsr       (A2)
000017DA  584F      2436          addq.w    #4,A7
000017DC  6008      2437          bra.s     DumpRegisters_29
                    2438   DumpRegisters_28:
000017DE  4878 0030 2439          pea       48
000017E2  4E92      2440          jsr       (A2)
000017E4  584F      2441          addq.w    #4,A7
                    2442   DumpRegisters_29:
                    2443   ; if((SR & (unsigned short int)(0x0010)) == (unsigned short int)(0x0010)) putchar('X') ; else putchar('-') ;      // X Bit (bit 4)
000017E6  3014      2444          move.w    (A4),D0
000017E8  C07C 0010 2445          and.w     #16,D0
000017EC  0C40 0010 2446          cmp.w     #16,D0
000017F0  660A      2447          bne.s     DumpRegisters_30
000017F2  4878 0058 2448          pea       88
000017F6  4E92      2449          jsr       (A2)
000017F8  584F      2450          addq.w    #4,A7
000017FA  6008      2451          bra.s     DumpRegisters_31
                    2452   DumpRegisters_30:
000017FC  4878 002D 2453          pea       45
00001800  4E92      2454          jsr       (A2)
00001802  584F      2455          addq.w    #4,A7
                    2456   DumpRegisters_31:
                    2457   ; if((SR & (unsigned short int)(0x0008)) == (unsigned short int)(0x0008)) putchar('N') ; else putchar('-') ;      // N Bit (bit 3)
00001804  3014      2458          move.w    (A4),D0
00001806  C07C 0008 2459          and.w     #8,D0
0000180A  0C40 0008 2460          cmp.w     #8,D0
0000180E  660A      2461          bne.s     DumpRegisters_32
00001810  4878 004E 2462          pea       78
00001814  4E92      2463          jsr       (A2)
00001816  584F      2464          addq.w    #4,A7
00001818  6008      2465          bra.s     DumpRegisters_33
                    2466   DumpRegisters_32:
0000181A  4878 002D 2467          pea       45
0000181E  4E92      2468          jsr       (A2)
00001820  584F      2469          addq.w    #4,A7
                    2470   DumpRegisters_33:
                    2471   ; if((SR & (unsigned short int)(0x0004)) == (unsigned short int)(0x0004)) putchar('Z') ; else putchar('-') ;      // Z Bit (bit 2)
00001822  3014      2472          move.w    (A4),D0
00001824  C07C 0004 2473          and.w     #4,D0
00001828  0C40 0004 2474          cmp.w     #4,D0
0000182C  660A      2475          bne.s     DumpRegisters_34
0000182E  4878 005A 2476          pea       90
00001832  4E92      2477          jsr       (A2)
00001834  584F      2478          addq.w    #4,A7
00001836  6008      2479          bra.s     DumpRegisters_35
                    2480   DumpRegisters_34:
00001838  4878 002D 2481          pea       45
0000183C  4E92      2482          jsr       (A2)
0000183E  584F      2483          addq.w    #4,A7
                    2484   DumpRegisters_35:
                    2485   ; if((SR & (unsigned short int)(0x0002)) == (unsigned short int)(0x0002)) putchar('V') ; else putchar('-') ;      // V Bit (bit 1)
00001840  3014      2486          move.w    (A4),D0
00001842  C07C 0002 2487          and.w     #2,D0
00001846  0C40 0002 2488          cmp.w     #2,D0
0000184A  660A      2489          bne.s     DumpRegisters_36
0000184C  4878 0056 2490          pea       86
00001850  4E92      2491          jsr       (A2)
00001852  584F      2492          addq.w    #4,A7
00001854  6008      2493          bra.s     DumpRegisters_37
                    2494   DumpRegisters_36:
00001856  4878 002D 2495          pea       45
0000185A  4E92      2496          jsr       (A2)
0000185C  584F      2497          addq.w    #4,A7
                    2498   DumpRegisters_37:
                    2499   ; if((SR & (unsigned short int)(0x0001)) == (unsigned short int)(0x0001)) putchar('C') ; else putchar('-') ;      // C Bit (bit 0)
0000185E  3014      2500          move.w    (A4),D0
00001860  C07C 0001 2501          and.w     #1,D0
00001864  0C40 0001 2502          cmp.w     #1,D0
00001868  660A      2503          bne.s     DumpRegisters_38
0000186A  4878 0043 2504          pea       67
0000186E  4E92      2505          jsr       (A2)
00001870  584F      2506          addq.w    #4,A7
00001872  6008      2507          bra.s     DumpRegisters_39
                    2508   DumpRegisters_38:
00001874  4878 002D 2509          pea       45
00001878  4E92      2510          jsr       (A2)
0000187A  584F      2511          addq.w    #4,A7
                    2512   DumpRegisters_39:
                    2513   ; putchar(']') ;
0000187C  4878 005D 2514          pea       93
00001880  4E92      2515          jsr       (A2)
00001882  584F      2516          addq.w    #4,A7
                    2517   ; printf("\r\n PC = $%08X  ", PC) ;
00001884  2F39 0B00 2518          move.l    _PC.L,-(A7)
00001888  0120      
0000188A  4879 0000 2519          pea       @m68kde~1_45.L
0000188E  41FC      
00001890  4E93      2520          jsr       (A3)
00001892  504F      2521          addq.w    #8,A7
                    2522   ; if(*(unsigned short int *)(PC) == 0x4e4e)
00001894  2039 0B00 2523          move.l    _PC.L,D0
00001898  0120      
0000189A  2040      2524          move.l    D0,A0
0000189C  3010      2525          move.w    (A0),D0
0000189E  0C40 4E4E 2526          cmp.w     #20046,D0
000018A2  660A      2527          bne.s     DumpRegisters_40
                    2528   ; printf("[@ BREAKPOINT]") ;
000018A4  4879 0000 2529          pea       @m68kde~1_46.L
000018A8  420C      
000018AA  4E93      2530          jsr       (A3)
000018AC  584F      2531          addq.w    #4,A7
                    2532   DumpRegisters_40:
                    2533   ; printf("\r\n") ;
000018AE  4879 0000 2534          pea       @m68kde~1_1.L
000018B2  3D8A      
000018B4  4E93      2535          jsr       (A3)
000018B6  584F      2536          addq.w    #4,A7
                    2537   ; for(i=0; i < 8; i++)    {
000018B8  4244      2538          clr.w     D4
                    2539   DumpRegisters_42:
000018BA  0C44 0008 2540          cmp.w     #8,D4
000018BE  6C00 0040 2541          bge       DumpRegisters_44
                    2542   ; if(WatchPointSetOrCleared[i] == 1)
000018C2  48C4      2543          ext.l     D4
000018C4  2004      2544          move.l    D4,D0
000018C6  E588      2545          lsl.l     #2,D0
000018C8  41F9 0B00 2546          lea       _WatchPointSetOrCleared.L,A0
000018CC  01A2      
000018CE  2030 0800 2547          move.l    0(A0,D0.L),D0
000018D2  0C80 0000 2548          cmp.l     #1,D0
000018D6  0001      
000018D8  6622      2549          bne.s     DumpRegisters_45
                    2550   ; printf("\r\nWP%d = %s", i, WatchPointString[i]) ;
000018DA  220D      2551          move.l    A5,D1
000018DC  48C4      2552          ext.l     D4
000018DE  2F00      2553          move.l    D0,-(A7)
000018E0  2004      2554          move.l    D4,D0
000018E2  C1FC 0064 2555          muls      #100,D0
000018E6  D280      2556          add.l     D0,D1
000018E8  201F      2557          move.l    (A7)+,D0
000018EA  2F01      2558          move.l    D1,-(A7)
000018EC  48C4      2559          ext.l     D4
000018EE  2F04      2560          move.l    D4,-(A7)
000018F0  4879 0000 2561          pea       @m68kde~1_47.L
000018F4  421C      
000018F6  4E93      2562          jsr       (A3)
000018F8  DEFC 000C 2563          add.w     #12,A7
                    2564   DumpRegisters_45:
000018FC  5244      2565          addq.w    #1,D4
000018FE  60BA      2566          bra       DumpRegisters_42
                    2567   DumpRegisters_44:
00001900  4CDF 3CFC 2568          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00001904  4E75      2569          rts
                    2570   ; }
                    2571   ; }
                    2572   ; // Trace Exception Handler
                    2573   ; void DumpRegistersandPause(void)
                    2574   ; {
                    2575   _DumpRegistersandPause:
00001906  2F0A      2576          move.l    A2,-(A7)
00001908  45F9 0000 2577          lea       _printf.L,A2
0000190C  343A      
                    2578   ; printf("\r\n\r\n\r\n\r\n\r\n\r\nSingle Step  :[ON]") ;
0000190E  4879 0000 2579          pea       @m68kde~1_48.L
00001912  4228      
00001914  4E92      2580          jsr       (A2)
00001916  584F      2581          addq.w    #4,A7
                    2582   ; printf("\r\nBreak Points :[Disabled]") ;
00001918  4879 0000 2583          pea       @m68kde~1_49.L
0000191C  4248      
0000191E  4E92      2584          jsr       (A2)
00001920  584F      2585          addq.w    #4,A7
                    2586   ; DumpRegisters() ;
00001922  4EB8 1452 2587          jsr       _DumpRegisters
                    2588   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
00001926  4879 0000 2589          pea       @m68kde~1_50.L
0000192A  4264      
0000192C  4E92      2590          jsr       (A2)
0000192E  584F      2591          addq.w    #4,A7
                    2592   ; printf("\r\nPress <ESC> to Resume Program") ;
00001930  4879 0000 2593          pea       @m68kde~1_51.L
00001934  4290      
00001936  4E92      2594          jsr       (A2)
00001938  584F      2595          addq.w    #4,A7
                    2596   ; menu() ;
0000193A  4EB9 0000 2597          jsr       _menu
0000193E  24EA      
00001940  245F      2598          move.l    (A7)+,A2
00001942  4E75      2599          rts
                    2600   ; }
                    2601   ; void ChangeRegisters(void)
                    2602   ; {
                    2603   _ChangeRegisters:
00001944  4E56 FFFC 2604          link      A6,#-4
00001948  48E7 303C 2605          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
0000194C  45F9 0000 2606          lea       _printf.L,A2
00001950  343A      
00001952  47EE FFFC 2607          lea       -4(A6),A3
00001956  49F8 0CDE 2608          lea       _Get8HexDigits.L,A4
0000195A  4BF8 0B6E 2609          lea       __getch.L,A5
                    2610   ; // get register name d0-d7, a0-a7, up, sp, sr, pc
                    2611   ; int reg_val ;
                    2612   ; char c, reg[3] ;
                    2613   ; reg[0] = tolower(_getch()) ;
0000195E  2F00      2614          move.l    D0,-(A7)
00001960  4E95      2615          jsr       (A5)
00001962  2200      2616          move.l    D0,D1
00001964  201F      2617          move.l    (A7)+,D0
00001966  2F01      2618          move.l    D1,-(A7)
00001968  4EB9 0000 2619          jsr       _tolower
0000196C  3398      
0000196E  584F      2620          addq.w    #4,A7
00001970  1680      2621          move.b    D0,(A3)
                    2622   ; reg[1] = c = tolower(_getch()) ;
00001972  2F00      2623          move.l    D0,-(A7)
00001974  4E95      2624          jsr       (A5)
00001976  2200      2625          move.l    D0,D1
00001978  201F      2626          move.l    (A7)+,D0
0000197A  2F01      2627          move.l    D1,-(A7)
0000197C  4EB9 0000 2628          jsr       _tolower
00001980  3398      
00001982  584F      2629          addq.w    #4,A7
00001984  1400      2630          move.b    D0,D2
00001986  1740 0001 2631          move.b    D0,1(A3)
                    2632   ; if(reg[0] == (char)('d'))  {    // change data register
0000198A  1013      2633          move.b    (A3),D0
0000198C  0C00 0064 2634          cmp.b     #100,D0
00001990  6600 00AE 2635          bne       ChangeRegisters_1
                    2636   ; if((reg[1] > (char)('7')) || (reg[1] < (char)('0'))) {
00001994  102B 0001 2637          move.b    1(A3),D0
00001998  0C00 0037 2638          cmp.b     #55,D0
0000199C  6E0A      2639          bgt.s     ChangeRegisters_5
0000199E  102B 0001 2640          move.b    1(A3),D0
000019A2  0C00 0030 2641          cmp.b     #48,D0
000019A6  6C0E      2642          bge.s     ChangeRegisters_3
                    2643   ChangeRegisters_5:
                    2644   ; printf("\r\nIllegal Data Register : Use D0-D7.....\r\n") ;
000019A8  4879 0000 2645          pea       @m68kde~1_52.L
000019AC  42B0      
000019AE  4E92      2646          jsr       (A2)
000019B0  584F      2647          addq.w    #4,A7
                    2648   ; return ;
000019B2  6000 0244 2649          bra       ChangeRegisters_6
                    2650   ChangeRegisters_3:
                    2651   ; }
                    2652   ; else {
                    2653   ; printf("\r\nD%c = ", c) ;
000019B6  4882      2654          ext.w     D2
000019B8  48C2      2655          ext.l     D2
000019BA  2F02      2656          move.l    D2,-(A7)
000019BC  4879 0000 2657          pea       @m68kde~1_53.L
000019C0  42DC      
000019C2  4E92      2658          jsr       (A2)
000019C4  504F      2659          addq.w    #8,A7
                    2660   ; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
000019C6  42A7      2661          clr.l     -(A7)
000019C8  4E94      2662          jsr       (A4)
000019CA  584F      2663          addq.w    #4,A7
000019CC  2600      2664          move.l    D0,D3
                    2665   ; }
                    2666   ; // bit cludgy but d0-d7 not stored as an array for good reason
                    2667   ; if(c == (char)('0'))
000019CE  0C02 0030 2668          cmp.b     #48,D2
000019D2  660A      2669          bne.s     ChangeRegisters_7
                    2670   ; d0 = reg_val ;
000019D4  23C3 0B00 2671          move.l    D3,_d0.L
000019D8  00E4      
000019DA  6000 0060 2672          bra       ChangeRegisters_20
                    2673   ChangeRegisters_7:
                    2674   ; else if(c == (char)('1'))
000019DE  0C02 0031 2675          cmp.b     #49,D2
000019E2  660A      2676          bne.s     ChangeRegisters_9
                    2677   ; d1 = reg_val ;
000019E4  23C3 0B00 2678          move.l    D3,_d1.L
000019E8  00E8      
000019EA  6000 0050 2679          bra       ChangeRegisters_20
                    2680   ChangeRegisters_9:
                    2681   ; else if(c == (char)('2'))
000019EE  0C02 0032 2682          cmp.b     #50,D2
000019F2  660A      2683          bne.s     ChangeRegisters_11
                    2684   ; d2 = reg_val ;
000019F4  23C3 0B00 2685          move.l    D3,_d2.L
000019F8  00EC      
000019FA  6000 0040 2686          bra       ChangeRegisters_20
                    2687   ChangeRegisters_11:
                    2688   ; else if(c == (char)('3'))
000019FE  0C02 0033 2689          cmp.b     #51,D2
00001A02  6608      2690          bne.s     ChangeRegisters_13
                    2691   ; d3 = reg_val ;
00001A04  23C3 0B00 2692          move.l    D3,_d3.L
00001A08  00F0      
00001A0A  6030      2693          bra.s     ChangeRegisters_20
                    2694   ChangeRegisters_13:
                    2695   ; else if(c == (char)('4'))
00001A0C  0C02 0034 2696          cmp.b     #52,D2
00001A10  6608      2697          bne.s     ChangeRegisters_15
                    2698   ; d4 = reg_val ;
00001A12  23C3 0B00 2699          move.l    D3,_d4.L
00001A16  00F4      
00001A18  6022      2700          bra.s     ChangeRegisters_20
                    2701   ChangeRegisters_15:
                    2702   ; else if(c == (char)('5'))
00001A1A  0C02 0035 2703          cmp.b     #53,D2
00001A1E  6608      2704          bne.s     ChangeRegisters_17
                    2705   ; d5 = reg_val ;
00001A20  23C3 0B00 2706          move.l    D3,_d5.L
00001A24  00F8      
00001A26  6014      2707          bra.s     ChangeRegisters_20
                    2708   ChangeRegisters_17:
                    2709   ; else if(c == (char)('6'))
00001A28  0C02 0036 2710          cmp.b     #54,D2
00001A2C  6608      2711          bne.s     ChangeRegisters_19
                    2712   ; d6 = reg_val ;
00001A2E  23C3 0B00 2713          move.l    D3,_d6.L
00001A32  00FC      
00001A34  6006      2714          bra.s     ChangeRegisters_20
                    2715   ChangeRegisters_19:
                    2716   ; else
                    2717   ; d7 = reg_val ;
00001A36  23C3 0B00 2718          move.l    D3,_d7.L
00001A3A  0100      
                    2719   ChangeRegisters_20:
00001A3C  6000 01B6 2720          bra       ChangeRegisters_51
                    2721   ChangeRegisters_1:
                    2722   ; }
                    2723   ; else if(reg[0] == (char)('a'))  {    // change address register, a7 is the user stack pointer, sp is the system stack pointer
00001A40  1013      2724          move.b    (A3),D0
00001A42  0C00 0061 2725          cmp.b     #97,D0
00001A46  6600 00A6 2726          bne       ChangeRegisters_21
                    2727   ; if((c > (char)('7')) || (c < (char)('0'))) {
00001A4A  0C02 0037 2728          cmp.b     #55,D2
00001A4E  6E06      2729          bgt.s     ChangeRegisters_25
00001A50  0C02 0030 2730          cmp.b     #48,D2
00001A54  6C0E      2731          bge.s     ChangeRegisters_23
                    2732   ChangeRegisters_25:
                    2733   ; printf("\r\nIllegal Address Register : Use A0-A7.....\r\n") ;
00001A56  4879 0000 2734          pea       @m68kde~1_54.L
00001A5A  42E6      
00001A5C  4E92      2735          jsr       (A2)
00001A5E  584F      2736          addq.w    #4,A7
                    2737   ; return ;
00001A60  6000 0196 2738          bra       ChangeRegisters_6
                    2739   ChangeRegisters_23:
                    2740   ; }
                    2741   ; else {
                    2742   ; printf("\r\nA%c = ", c) ;
00001A64  4882      2743          ext.w     D2
00001A66  48C2      2744          ext.l     D2
00001A68  2F02      2745          move.l    D2,-(A7)
00001A6A  4879 0000 2746          pea       @m68kde~1_55.L
00001A6E  4314      
00001A70  4E92      2747          jsr       (A2)
00001A72  504F      2748          addq.w    #8,A7
                    2749   ; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001A74  42A7      2750          clr.l     -(A7)
00001A76  4E94      2751          jsr       (A4)
00001A78  584F      2752          addq.w    #4,A7
00001A7A  2600      2753          move.l    D0,D3
                    2754   ; }
                    2755   ; // bit cludgy but a0-a7 not stored as an array for good reason
                    2756   ; if(c == (char)('0'))
00001A7C  0C02 0030 2757          cmp.b     #48,D2
00001A80  660A      2758          bne.s     ChangeRegisters_26
                    2759   ; a0 = reg_val ;
00001A82  23C3 0B00 2760          move.l    D3,_a0.L
00001A86  0104      
00001A88  6000 0060 2761          bra       ChangeRegisters_39
                    2762   ChangeRegisters_26:
                    2763   ; else if(c == (char)('1'))
00001A8C  0C02 0031 2764          cmp.b     #49,D2
00001A90  660A      2765          bne.s     ChangeRegisters_28
                    2766   ; a1 = reg_val ;
00001A92  23C3 0B00 2767          move.l    D3,_a1.L
00001A96  0108      
00001A98  6000 0050 2768          bra       ChangeRegisters_39
                    2769   ChangeRegisters_28:
                    2770   ; else if(c == (char)('2'))
00001A9C  0C02 0032 2771          cmp.b     #50,D2
00001AA0  660A      2772          bne.s     ChangeRegisters_30
                    2773   ; a2 = reg_val ;
00001AA2  23C3 0B00 2774          move.l    D3,_a2.L
00001AA6  010C      
00001AA8  6000 0040 2775          bra       ChangeRegisters_39
                    2776   ChangeRegisters_30:
                    2777   ; else if(c == (char)('3'))
00001AAC  0C02 0033 2778          cmp.b     #51,D2
00001AB0  6608      2779          bne.s     ChangeRegisters_32
                    2780   ; a3 = reg_val ;
00001AB2  23C3 0B00 2781          move.l    D3,_a3.L
00001AB6  0110      
00001AB8  6030      2782          bra.s     ChangeRegisters_39
                    2783   ChangeRegisters_32:
                    2784   ; else if(c == (char)('4'))
00001ABA  0C02 0034 2785          cmp.b     #52,D2
00001ABE  6608      2786          bne.s     ChangeRegisters_34
                    2787   ; a4 = reg_val ;
00001AC0  23C3 0B00 2788          move.l    D3,_a4.L
00001AC4  0114      
00001AC6  6022      2789          bra.s     ChangeRegisters_39
                    2790   ChangeRegisters_34:
                    2791   ; else if(c == (char)('5'))
00001AC8  0C02 0035 2792          cmp.b     #53,D2
00001ACC  6608      2793          bne.s     ChangeRegisters_36
                    2794   ; a5 = reg_val ;
00001ACE  23C3 0B00 2795          move.l    D3,_a5.L
00001AD2  0118      
00001AD4  6014      2796          bra.s     ChangeRegisters_39
                    2797   ChangeRegisters_36:
                    2798   ; else if(c == (char)('6'))
00001AD6  0C02 0036 2799          cmp.b     #54,D2
00001ADA  6608      2800          bne.s     ChangeRegisters_38
                    2801   ; a6 = reg_val ;
00001ADC  23C3 0B00 2802          move.l    D3,_a6.L
00001AE0  011C      
00001AE2  6006      2803          bra.s     ChangeRegisters_39
                    2804   ChangeRegisters_38:
                    2805   ; else
                    2806   ; USP = reg_val ;
00001AE4  23C3 0B00 2807          move.l    D3,_USP.L
00001AE8  0128      
                    2808   ChangeRegisters_39:
00001AEA  6000 0108 2809          bra       ChangeRegisters_51
                    2810   ChangeRegisters_21:
                    2811   ; }
                    2812   ; else if((reg[0] == (char)('u')) && (c == (char)('s')))  {
00001AEE  1013      2813          move.b    (A3),D0
00001AF0  0C00 0075 2814          cmp.b     #117,D0
00001AF4  6600 004E 2815          bne       ChangeRegisters_40
00001AF8  0C02 0073 2816          cmp.b     #115,D2
00001AFC  6600 0046 2817          bne       ChangeRegisters_40
                    2818   ; if(tolower(_getch()) == 'p')  {    // change user stack pointer
00001B00  2F00      2819          move.l    D0,-(A7)
00001B02  4E95      2820          jsr       (A5)
00001B04  2200      2821          move.l    D0,D1
00001B06  201F      2822          move.l    (A7)+,D0
00001B08  2F01      2823          move.l    D1,-(A7)
00001B0A  4EB9 0000 2824          jsr       _tolower
00001B0E  3398      
00001B10  584F      2825          addq.w    #4,A7
00001B12  0C80 0000 2826          cmp.l     #112,D0
00001B16  0070      
00001B18  6618      2827          bne.s     ChangeRegisters_42
                    2828   ; printf("\r\nUser SP = ") ;
00001B1A  4879 0000 2829          pea       @m68kde~1_56.L
00001B1E  431E      
00001B20  4E92      2830          jsr       (A2)
00001B22  584F      2831          addq.w    #4,A7
                    2832   ; USP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001B24  42A7      2833          clr.l     -(A7)
00001B26  4E94      2834          jsr       (A4)
00001B28  584F      2835          addq.w    #4,A7
00001B2A  23C0 0B00 2836          move.l    D0,_USP.L
00001B2E  0128      
00001B30  600E      2837          bra.s     ChangeRegisters_43
                    2838   ChangeRegisters_42:
                    2839   ; }
                    2840   ; else {
                    2841   ; printf("\r\nIllegal Register....") ;
00001B32  4879 0000 2842          pea       @m68kde~1_57.L
00001B36  432C      
00001B38  4E92      2843          jsr       (A2)
00001B3A  584F      2844          addq.w    #4,A7
                    2845   ; return ;
00001B3C  6000 00BA 2846          bra       ChangeRegisters_6
                    2847   ChangeRegisters_43:
00001B40  6000 00B2 2848          bra       ChangeRegisters_51
                    2849   ChangeRegisters_40:
                    2850   ; }
                    2851   ; }
                    2852   ; else if((reg[0] == (char)('s')) && (c == (char)('s')))  {
00001B44  1013      2853          move.b    (A3),D0
00001B46  0C00 0073 2854          cmp.b     #115,D0
00001B4A  6600 004E 2855          bne       ChangeRegisters_44
00001B4E  0C02 0073 2856          cmp.b     #115,D2
00001B52  6600 0046 2857          bne       ChangeRegisters_44
                    2858   ; if(tolower(_getch()) == 'p')  {    // change system stack pointer
00001B56  2F00      2859          move.l    D0,-(A7)
00001B58  4E95      2860          jsr       (A5)
00001B5A  2200      2861          move.l    D0,D1
00001B5C  201F      2862          move.l    (A7)+,D0
00001B5E  2F01      2863          move.l    D1,-(A7)
00001B60  4EB9 0000 2864          jsr       _tolower
00001B64  3398      
00001B66  584F      2865          addq.w    #4,A7
00001B68  0C80 0000 2866          cmp.l     #112,D0
00001B6C  0070      
00001B6E  6618      2867          bne.s     ChangeRegisters_46
                    2868   ; printf("\r\nSystem SP = ") ;
00001B70  4879 0000 2869          pea       @m68kde~1_58.L
00001B74  4344      
00001B76  4E92      2870          jsr       (A2)
00001B78  584F      2871          addq.w    #4,A7
                    2872   ; SSP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001B7A  42A7      2873          clr.l     -(A7)
00001B7C  4E94      2874          jsr       (A4)
00001B7E  584F      2875          addq.w    #4,A7
00001B80  23C0 0B00 2876          move.l    D0,_SSP.L
00001B84  0124      
00001B86  600E      2877          bra.s     ChangeRegisters_47
                    2878   ChangeRegisters_46:
                    2879   ; }
                    2880   ; else {
                    2881   ; printf("\r\nIllegal Register....") ;
00001B88  4879 0000 2882          pea       @m68kde~1_57.L
00001B8C  432C      
00001B8E  4E92      2883          jsr       (A2)
00001B90  584F      2884          addq.w    #4,A7
                    2885   ; return ;
00001B92  6000 0064 2886          bra       ChangeRegisters_6
                    2887   ChangeRegisters_47:
00001B96  6000 005C 2888          bra       ChangeRegisters_51
                    2889   ChangeRegisters_44:
                    2890   ; }
                    2891   ; }
                    2892   ; else if((reg[0] == (char)('p')) && (c == (char)('c')))  {    // change program counter
00001B9A  1013      2893          move.b    (A3),D0
00001B9C  0C00 0070 2894          cmp.b     #112,D0
00001BA0  6620      2895          bne.s     ChangeRegisters_48
00001BA2  0C02 0063 2896          cmp.b     #99,D2
00001BA6  661A      2897          bne.s     ChangeRegisters_48
                    2898   ; printf("\r\nPC = ") ;
00001BA8  4879 0000 2899          pea       @m68kde~1_59.L
00001BAC  4354      
00001BAE  4E92      2900          jsr       (A2)
00001BB0  584F      2901          addq.w    #4,A7
                    2902   ; PC = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001BB2  42A7      2903          clr.l     -(A7)
00001BB4  4E94      2904          jsr       (A4)
00001BB6  584F      2905          addq.w    #4,A7
00001BB8  23C0 0B00 2906          move.l    D0,_PC.L
00001BBC  0120      
00001BBE  6000 0034 2907          bra       ChangeRegisters_51
                    2908   ChangeRegisters_48:
                    2909   ; }
                    2910   ; else if((reg[0] == (char)('s')) && (c == (char)('r')))  {    // change status register
00001BC2  1013      2911          move.b    (A3),D0
00001BC4  0C00 0073 2912          cmp.b     #115,D0
00001BC8  6620      2913          bne.s     ChangeRegisters_50
00001BCA  0C02 0072 2914          cmp.b     #114,D2
00001BCE  661A      2915          bne.s     ChangeRegisters_50
                    2916   ; printf("\r\nSR = ") ;
00001BD0  4879 0000 2917          pea       @m68kde~1_60.L
00001BD4  435C      
00001BD6  4E92      2918          jsr       (A2)
00001BD8  584F      2919          addq.w    #4,A7
                    2920   ; SR = Get4HexDigits(0) ;    // read 16 bit value from user keyboard
00001BDA  42A7      2921          clr.l     -(A7)
00001BDC  4EB8 0C92 2922          jsr       _Get4HexDigits
00001BE0  584F      2923          addq.w    #4,A7
00001BE2  33C0 0B00 2924          move.w    D0,_SR.L
00001BE6  012C      
00001BE8  600A      2925          bra.s     ChangeRegisters_51
                    2926   ChangeRegisters_50:
                    2927   ; }
                    2928   ; else
                    2929   ; printf("\r\nIllegal Register: Use A0-A7, D0-D7, SSP, USP, PC or SR\r\n") ;
00001BEA  4879 0000 2930          pea       @m68kde~1_61.L
00001BEE  4364      
00001BF0  4E92      2931          jsr       (A2)
00001BF2  584F      2932          addq.w    #4,A7
                    2933   ChangeRegisters_51:
                    2934   ; DumpRegisters() ;
00001BF4  4EB8 1452 2935          jsr       _DumpRegisters
                    2936   ChangeRegisters_6:
00001BF8  4CDF 3C0C 2937          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00001BFC  4E5E      2938          unlk      A6
00001BFE  4E75      2939          rts
                    2940   ; }
                    2941   ; void BreakPointDisplay(void)
                    2942   ; {
                    2943   _BreakPointDisplay:
00001C00  48E7 3030 2944          movem.l   D2/D3/A2/A3,-(A7)
00001C04  45F9 0000 2945          lea       _printf.L,A2
00001C08  343A      
00001C0A  47F9 0B00 2946          lea       _BreakPointAddress.L,A3
00001C0E  012E      
                    2947   ; int i, BreakPointsSet = 0 ;
00001C10  4283      2948          clr.l     D3
                    2949   ; // any break points  set
                    2950   ; for(i = 0; i < 8; i++)  {
00001C12  4282      2951          clr.l     D2
                    2952   BreakPointDisplay_1:
00001C14  0C82 0000 2953          cmp.l     #8,D2
00001C18  0008      
00001C1A  6C1C      2954          bge.s     BreakPointDisplay_3
                    2955   ; if(BreakPointSetOrCleared[i] == 1)
00001C1C  2002      2956          move.l    D2,D0
00001C1E  E588      2957          lsl.l     #2,D0
00001C20  41F9 0B00 2958          lea       _BreakPointSetOrCleared.L,A0
00001C24  015E      
00001C26  2030 0800 2959          move.l    0(A0,D0.L),D0
00001C2A  0C80 0000 2960          cmp.l     #1,D0
00001C2E  0001      
00001C30  6602      2961          bne.s     BreakPointDisplay_4
                    2962   ; BreakPointsSet = 1;
00001C32  7601      2963          moveq     #1,D3
                    2964   BreakPointDisplay_4:
00001C34  5282      2965          addq.l    #1,D2
00001C36  60DC      2966          bra       BreakPointDisplay_1
                    2967   BreakPointDisplay_3:
                    2968   ; }
                    2969   ; if(BreakPointsSet == 1) {
00001C38  0C83 0000 2970          cmp.l     #1,D3
00001C3C  0001      
00001C3E  6616      2971          bne.s     BreakPointDisplay_6
                    2972   ; printf("\r\n\r\nNum     Address      Instruction") ;
00001C40  4879 0000 2973          pea       @m68kde~1_62.L
00001C44  43A0      
00001C46  4E92      2974          jsr       (A2)
00001C48  584F      2975          addq.w    #4,A7
                    2976   ; printf("\r\n---     ---------    -----------") ;
00001C4A  4879 0000 2977          pea       @m68kde~1_63.L
00001C4E  43C6      
00001C50  4E92      2978          jsr       (A2)
00001C52  584F      2979          addq.w    #4,A7
00001C54  600A      2980          bra.s     BreakPointDisplay_7
                    2981   BreakPointDisplay_6:
                    2982   ; }
                    2983   ; else
                    2984   ; printf("\r\nNo BreakPoints Set") ;
00001C56  4879 0000 2985          pea       @m68kde~1_64.L
00001C5A  43EA      
00001C5C  4E92      2986          jsr       (A2)
00001C5E  584F      2987          addq.w    #4,A7
                    2988   BreakPointDisplay_7:
                    2989   ; for(i = 0; i < 8; i++)  {
00001C60  4282      2990          clr.l     D2
                    2991   BreakPointDisplay_8:
00001C62  0C82 0000 2992          cmp.l     #8,D2
00001C66  0008      
00001C68  6C00 005A 2993          bge       BreakPointDisplay_10
                    2994   ; // put opcode back, then put break point back
                    2995   ; if(BreakPointSetOrCleared[i] == 1)  {
00001C6C  2002      2996          move.l    D2,D0
00001C6E  E588      2997          lsl.l     #2,D0
00001C70  41F9 0B00 2998          lea       _BreakPointSetOrCleared.L,A0
00001C74  015E      
00001C76  2030 0800 2999          move.l    0(A0,D0.L),D0
00001C7A  0C80 0000 3000          cmp.l     #1,D0
00001C7E  0001      
00001C80  6600 003E 3001          bne       BreakPointDisplay_11
                    3002   ; *(unsigned short int *)(BreakPointAddress[i]) = BreakPointInstruction[i];
00001C84  2002      3003          move.l    D2,D0
00001C86  E388      3004          lsl.l     #1,D0
00001C88  41F9 0B00 3005          lea       _BreakPointInstruction.L,A0
00001C8C  014E      
00001C8E  2202      3006          move.l    D2,D1
00001C90  E589      3007          lsl.l     #2,D1
00001C92  2233 1800 3008          move.l    0(A3,D1.L),D1
00001C96  2241      3009          move.l    D1,A1
00001C98  32B0 0800 3010          move.w    0(A0,D0.L),(A1)
                    3011   ; *(unsigned short int *)(BreakPointAddress[i]) = (unsigned short int)(0x4e4e) ;
00001C9C  2002      3012          move.l    D2,D0
00001C9E  E588      3013          lsl.l     #2,D0
00001CA0  2033 0800 3014          move.l    0(A3,D0.L),D0
00001CA4  2040      3015          move.l    D0,A0
00001CA6  30BC 4E4E 3016          move.w    #20046,(A0)
                    3017   ; printf("\r\n%3d     $%08x",i, BreakPointAddress[i]) ;
00001CAA  2202      3018          move.l    D2,D1
00001CAC  E589      3019          lsl.l     #2,D1
00001CAE  2F33 1800 3020          move.l    0(A3,D1.L),-(A7)
00001CB2  2F02      3021          move.l    D2,-(A7)
00001CB4  4879 0000 3022          pea       @m68kde~1_65.L
00001CB8  4400      
00001CBA  4E92      3023          jsr       (A2)
00001CBC  DEFC 000C 3024          add.w     #12,A7
                    3025   BreakPointDisplay_11:
00001CC0  5282      3026          addq.l    #1,D2
00001CC2  609E      3027          bra       BreakPointDisplay_8
                    3028   BreakPointDisplay_10:
                    3029   ; }
                    3030   ; }
                    3031   ; printf("\r\n") ;
00001CC4  4879 0000 3032          pea       @m68kde~1_1.L
00001CC8  3D8A      
00001CCA  4E92      3033          jsr       (A2)
00001CCC  584F      3034          addq.w    #4,A7
00001CCE  4CDF 0C0C 3035          movem.l   (A7)+,D2/D3/A2/A3
00001CD2  4E75      3036          rts
                    3037   ; }
                    3038   ; void WatchPointDisplay(void)
                    3039   ; {
                    3040   _WatchPointDisplay:
00001CD4  48E7 3020 3041          movem.l   D2/D3/A2,-(A7)
00001CD8  45F9 0000 3042          lea       _printf.L,A2
00001CDC  343A      
                    3043   ; int i ;
                    3044   ; int WatchPointsSet = 0 ;
00001CDE  4283      3045          clr.l     D3
                    3046   ; // any watchpoints set
                    3047   ; for(i = 0; i < 8; i++)  {
00001CE0  4282      3048          clr.l     D2
                    3049   WatchPointDisplay_1:
00001CE2  0C82 0000 3050          cmp.l     #8,D2
00001CE6  0008      
00001CE8  6C1C      3051          bge.s     WatchPointDisplay_3
                    3052   ; if(WatchPointSetOrCleared[i] == 1)
00001CEA  2002      3053          move.l    D2,D0
00001CEC  E588      3054          lsl.l     #2,D0
00001CEE  41F9 0B00 3055          lea       _WatchPointSetOrCleared.L,A0
00001CF2  01A2      
00001CF4  2030 0800 3056          move.l    0(A0,D0.L),D0
00001CF8  0C80 0000 3057          cmp.l     #1,D0
00001CFC  0001      
00001CFE  6602      3058          bne.s     WatchPointDisplay_4
                    3059   ; WatchPointsSet = 1;
00001D00  7601      3060          moveq     #1,D3
                    3061   WatchPointDisplay_4:
00001D02  5282      3062          addq.l    #1,D2
00001D04  60DC      3063          bra       WatchPointDisplay_1
                    3064   WatchPointDisplay_3:
                    3065   ; }
                    3066   ; if(WatchPointsSet == 1) {
00001D06  0C83 0000 3067          cmp.l     #1,D3
00001D0A  0001      
00001D0C  6616      3068          bne.s     WatchPointDisplay_6
                    3069   ; printf("\r\nNum     Address") ;
00001D0E  4879 0000 3070          pea       @m68kde~1_66.L
00001D12  4410      
00001D14  4E92      3071          jsr       (A2)
00001D16  584F      3072          addq.w    #4,A7
                    3073   ; printf("\r\n---     ---------") ;
00001D18  4879 0000 3074          pea       @m68kde~1_67.L
00001D1C  4422      
00001D1E  4E92      3075          jsr       (A2)
00001D20  584F      3076          addq.w    #4,A7
00001D22  600A      3077          bra.s     WatchPointDisplay_7
                    3078   WatchPointDisplay_6:
                    3079   ; }
                    3080   ; else
                    3081   ; printf("\r\nNo WatchPoints Set") ;
00001D24  4879 0000 3082          pea       @m68kde~1_68.L
00001D28  4436      
00001D2A  4E92      3083          jsr       (A2)
00001D2C  584F      3084          addq.w    #4,A7
                    3085   WatchPointDisplay_7:
                    3086   ; for(i = 0; i < 8; i++)  {
00001D2E  4282      3087          clr.l     D2
                    3088   WatchPointDisplay_8:
00001D30  0C82 0000 3089          cmp.l     #8,D2
00001D34  0008      
00001D36  6C00 0038 3090          bge       WatchPointDisplay_10
                    3091   ; if(WatchPointSetOrCleared[i] == 1)
00001D3A  2002      3092          move.l    D2,D0
00001D3C  E588      3093          lsl.l     #2,D0
00001D3E  41F9 0B00 3094          lea       _WatchPointSetOrCleared.L,A0
00001D42  01A2      
00001D44  2030 0800 3095          move.l    0(A0,D0.L),D0
00001D48  0C80 0000 3096          cmp.l     #1,D0
00001D4C  0001      
00001D4E  661C      3097          bne.s     WatchPointDisplay_11
                    3098   ; printf("\r\n%3d     $%08x",i, WatchPointAddress[i]) ;
00001D50  2202      3099          move.l    D2,D1
00001D52  E589      3100          lsl.l     #2,D1
00001D54  41F9 0B00 3101          lea       _WatchPointAddress.L,A0
00001D58  0182      
00001D5A  2F30 1800 3102          move.l    0(A0,D1.L),-(A7)
00001D5E  2F02      3103          move.l    D2,-(A7)
00001D60  4879 0000 3104          pea       @m68kde~1_65.L
00001D64  4400      
00001D66  4E92      3105          jsr       (A2)
00001D68  DEFC 000C 3106          add.w     #12,A7
                    3107   WatchPointDisplay_11:
00001D6C  5282      3108          addq.l    #1,D2
00001D6E  60C0      3109          bra       WatchPointDisplay_8
                    3110   WatchPointDisplay_10:
                    3111   ; }
                    3112   ; printf("\r\n") ;
00001D70  4879 0000 3113          pea       @m68kde~1_1.L
00001D74  3D8A      
00001D76  4E92      3114          jsr       (A2)
00001D78  584F      3115          addq.w    #4,A7
00001D7A  4CDF 040C 3116          movem.l   (A7)+,D2/D3/A2
00001D7E  4E75      3117          rts
                    3118   ; }
                    3119   ; void BreakPointClear(void)
                    3120   ; {
                    3121   _BreakPointClear:
00001D80  4E56 FFFC 3122          link      A6,#-4
00001D84  48E7 2020 3123          movem.l   D2/A2,-(A7)
00001D88  45F9 0000 3124          lea       _printf.L,A2
00001D8C  343A      
                    3125   ; unsigned int i ;
                    3126   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3127   ; BreakPointDisplay() ;
00001D8E  4EB8 1C00 3128          jsr       _BreakPointDisplay
                    3129   ; printf("\r\nEnter Break Point Number: ") ;
00001D92  4879 0000 3130          pea       @m68kde~1_69.L
00001D96  444C      
00001D98  4E92      3131          jsr       (A2)
00001D9A  584F      3132          addq.w    #4,A7
                    3133   ; i = xtod(_getch()) ;           // get break pointer number
00001D9C  2F00      3134          move.l    D0,-(A7)
00001D9E  4EB8 0B6E 3135          jsr       __getch
00001DA2  2200      3136          move.l    D0,D1
00001DA4  201F      3137          move.l    (A7)+,D0
00001DA6  2F01      3138          move.l    D1,-(A7)
00001DA8  4EB8 0BD8 3139          jsr       _xtod
00001DAC  584F      3140          addq.w    #4,A7
00001DAE  C0BC 0000 3141          and.l     #255,D0
00001DB2  00FF      
00001DB4  2400      3142          move.l    D0,D2
                    3143   ; if((i < 0) || (i > 7))   {
00001DB6  0C82 0000 3144          cmp.l     #0,D2
00001DBA  0000      
00001DBC  6508      3145          blo.s     BreakPointClear_3
00001DBE  0C82 0000 3146          cmp.l     #7,D2
00001DC2  0007      
00001DC4  630E      3147          bls.s     BreakPointClear_1
                    3148   BreakPointClear_3:
                    3149   ; printf("\r\nIllegal Range : Use 0 - 7") ;
00001DC6  4879 0000 3150          pea       @m68kde~1_70.L
00001DCA  446A      
00001DCC  4E92      3151          jsr       (A2)
00001DCE  584F      3152          addq.w    #4,A7
                    3153   ; return ;
00001DD0  6000 0080 3154          bra       BreakPointClear_4
                    3155   BreakPointClear_1:
                    3156   ; }
                    3157   ; if(BreakPointSetOrCleared[i] == 1)  {       // if break point set
00001DD4  2002      3158          move.l    D2,D0
00001DD6  E588      3159          lsl.l     #2,D0
00001DD8  41F9 0B00 3160          lea       _BreakPointSetOrCleared.L,A0
00001DDC  015E      
00001DDE  2030 0800 3161          move.l    0(A0,D0.L),D0
00001DE2  0C80 0000 3162          cmp.l     #1,D0
00001DE6  0001      
00001DE8  6600 005A 3163          bne       BreakPointClear_5
                    3164   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program we are about to change
00001DEC  2002      3165          move.l    D2,D0
00001DEE  E588      3166          lsl.l     #2,D0
00001DF0  41F9 0B00 3167          lea       _BreakPointAddress.L,A0
00001DF4  012E      
00001DF6  2D70 0800 3168          move.l    0(A0,D0.L),-4(A6)
00001DFA  FFFC      
                    3169   ; BreakPointAddress[i] = 0 ;
00001DFC  2002      3170          move.l    D2,D0
00001DFE  E588      3171          lsl.l     #2,D0
00001E00  41F9 0B00 3172          lea       _BreakPointAddress.L,A0
00001E04  012E      
00001E06  42B0 0800 3173          clr.l     0(A0,D0.L)
                    3174   ; BreakPointSetOrCleared[i] = 0 ;
00001E0A  2002      3175          move.l    D2,D0
00001E0C  E588      3176          lsl.l     #2,D0
00001E0E  41F9 0B00 3177          lea       _BreakPointSetOrCleared.L,A0
00001E12  015E      
00001E14  42B0 0800 3178          clr.l     0(A0,D0.L)
                    3179   ; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
00001E18  2002      3180          move.l    D2,D0
00001E1A  E388      3181          lsl.l     #1,D0
00001E1C  41F9 0B00 3182          lea       _BreakPointInstruction.L,A0
00001E20  014E      
00001E22  226E FFFC 3183          move.l    -4(A6),A1
00001E26  32B0 0800 3184          move.w    0(A0,D0.L),(A1)
                    3185   ; BreakPointInstruction[i] = 0 ;
00001E2A  2002      3186          move.l    D2,D0
00001E2C  E388      3187          lsl.l     #1,D0
00001E2E  41F9 0B00 3188          lea       _BreakPointInstruction.L,A0
00001E32  014E      
00001E34  4270 0800 3189          clr.w     0(A0,D0.L)
                    3190   ; printf("\r\nBreak Point Cleared.....\r\n") ;
00001E38  4879 0000 3191          pea       @m68kde~1_71.L
00001E3C  4486      
00001E3E  4E92      3192          jsr       (A2)
00001E40  584F      3193          addq.w    #4,A7
00001E42  600A      3194          bra.s     BreakPointClear_6
                    3195   BreakPointClear_5:
                    3196   ; }
                    3197   ; else
                    3198   ; printf("\r\nBreak Point wasn't Set.....") ;
00001E44  4879 0000 3199          pea       @m68kde~1_72.L
00001E48  44A4      
00001E4A  4E92      3200          jsr       (A2)
00001E4C  584F      3201          addq.w    #4,A7
                    3202   BreakPointClear_6:
                    3203   ; BreakPointDisplay() ;
00001E4E  4EB8 1C00 3204          jsr       _BreakPointDisplay
                    3205   ; return ;
                    3206   BreakPointClear_4:
00001E52  4CDF 0404 3207          movem.l   (A7)+,D2/A2
00001E56  4E5E      3208          unlk      A6
00001E58  4E75      3209          rts
                    3210   ; }
                    3211   ; void WatchPointClear(void)
                    3212   ; {
                    3213   _WatchPointClear:
00001E5A  48E7 2020 3214          movem.l   D2/A2,-(A7)
00001E5E  45F9 0000 3215          lea       _printf.L,A2
00001E62  343A      
                    3216   ; unsigned int i ;
                    3217   ; WatchPointDisplay() ;
00001E64  4EB8 1CD4 3218          jsr       _WatchPointDisplay
                    3219   ; printf("\r\nEnter Watch Point Number: ") ;
00001E68  4879 0000 3220          pea       @m68kde~1_73.L
00001E6C  44C2      
00001E6E  4E92      3221          jsr       (A2)
00001E70  584F      3222          addq.w    #4,A7
                    3223   ; i = xtod(_getch()) ;           // get watch pointer number
00001E72  2F00      3224          move.l    D0,-(A7)
00001E74  4EB8 0B6E 3225          jsr       __getch
00001E78  2200      3226          move.l    D0,D1
00001E7A  201F      3227          move.l    (A7)+,D0
00001E7C  2F01      3228          move.l    D1,-(A7)
00001E7E  4EB8 0BD8 3229          jsr       _xtod
00001E82  584F      3230          addq.w    #4,A7
00001E84  C0BC 0000 3231          and.l     #255,D0
00001E88  00FF      
00001E8A  2400      3232          move.l    D0,D2
                    3233   ; if((i < 0) || (i > 7))   {
00001E8C  0C82 0000 3234          cmp.l     #0,D2
00001E90  0000      
00001E92  6508      3235          blo.s     WatchPointClear_3
00001E94  0C82 0000 3236          cmp.l     #7,D2
00001E98  0007      
00001E9A  630E      3237          bls.s     WatchPointClear_1
                    3238   WatchPointClear_3:
                    3239   ; printf("\r\nIllegal Range : Use 0 - 7") ;
00001E9C  4879 0000 3240          pea       @m68kde~1_70.L
00001EA0  446A      
00001EA2  4E92      3241          jsr       (A2)
00001EA4  584F      3242          addq.w    #4,A7
                    3243   ; return ;
00001EA6  6000 004E 3244          bra       WatchPointClear_4
                    3245   WatchPointClear_1:
                    3246   ; }
                    3247   ; if(WatchPointSetOrCleared[i] == 1)  {       // if watch point set
00001EAA  2002      3248          move.l    D2,D0
00001EAC  E588      3249          lsl.l     #2,D0
00001EAE  41F9 0B00 3250          lea       _WatchPointSetOrCleared.L,A0
00001EB2  01A2      
00001EB4  2030 0800 3251          move.l    0(A0,D0.L),D0
00001EB8  0C80 0000 3252          cmp.l     #1,D0
00001EBC  0001      
00001EBE  6628      3253          bne.s     WatchPointClear_5
                    3254   ; WatchPointAddress[i] = 0 ;
00001EC0  2002      3255          move.l    D2,D0
00001EC2  E588      3256          lsl.l     #2,D0
00001EC4  41F9 0B00 3257          lea       _WatchPointAddress.L,A0
00001EC8  0182      
00001ECA  42B0 0800 3258          clr.l     0(A0,D0.L)
                    3259   ; WatchPointSetOrCleared[i] = 0 ;
00001ECE  2002      3260          move.l    D2,D0
00001ED0  E588      3261          lsl.l     #2,D0
00001ED2  41F9 0B00 3262          lea       _WatchPointSetOrCleared.L,A0
00001ED6  01A2      
00001ED8  42B0 0800 3263          clr.l     0(A0,D0.L)
                    3264   ; printf("\r\nWatch Point Cleared.....\r\n") ;
00001EDC  4879 0000 3265          pea       @m68kde~1_74.L
00001EE0  44E0      
00001EE2  4E92      3266          jsr       (A2)
00001EE4  584F      3267          addq.w    #4,A7
00001EE6  600A      3268          bra.s     WatchPointClear_6
                    3269   WatchPointClear_5:
                    3270   ; }
                    3271   ; else
                    3272   ; printf("\r\nWatch Point Was not Set.....") ;
00001EE8  4879 0000 3273          pea       @m68kde~1_75.L
00001EEC  44FE      
00001EEE  4E92      3274          jsr       (A2)
00001EF0  584F      3275          addq.w    #4,A7
                    3276   WatchPointClear_6:
                    3277   ; WatchPointDisplay() ;
00001EF2  4EB8 1CD4 3278          jsr       _WatchPointDisplay
                    3279   ; return ;
                    3280   WatchPointClear_4:
00001EF6  4CDF 0404 3281          movem.l   (A7)+,D2/A2
00001EFA  4E75      3282          rts
                    3283   ; }
                    3284   ; void DisableBreakPoints(void)
                    3285   ; {
                    3286   _DisableBreakPoints:
00001EFC  4E56 FFFC 3287          link      A6,#-4
00001F00  2F02      3288          move.l    D2,-(A7)
                    3289   ; int i ;
                    3290   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3291   ; for(i = 0; i < 8; i++)  {
00001F02  4282      3292          clr.l     D2
                    3293   DisableBreakPoints_1:
00001F04  0C82 0000 3294          cmp.l     #8,D2
00001F08  0008      
00001F0A  6C00 003E 3295          bge       DisableBreakPoints_3
                    3296   ; if(BreakPointSetOrCleared[i] == 1)    {                                                    // if break point set
00001F0E  2002      3297          move.l    D2,D0
00001F10  E588      3298          lsl.l     #2,D0
00001F12  41F9 0B00 3299          lea       _BreakPointSetOrCleared.L,A0
00001F16  015E      
00001F18  2030 0800 3300          move.l    0(A0,D0.L),D0
00001F1C  0C80 0000 3301          cmp.l     #1,D0
00001F20  0001      
00001F22  6622      3302          bne.s     DisableBreakPoints_4
                    3303   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00001F24  2002      3304          move.l    D2,D0
00001F26  E588      3305          lsl.l     #2,D0
00001F28  41F9 0B00 3306          lea       _BreakPointAddress.L,A0
00001F2C  012E      
00001F2E  2D70 0800 3307          move.l    0(A0,D0.L),-4(A6)
00001F32  FFFC      
                    3308   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program overwritting the $4e4e
00001F34  2002      3309          move.l    D2,D0
00001F36  E388      3310          lsl.l     #1,D0
00001F38  41F9 0B00 3311          lea       _BreakPointInstruction.L,A0
00001F3C  014E      
00001F3E  226E FFFC 3312          move.l    -4(A6),A1
00001F42  32B0 0800 3313          move.w    0(A0,D0.L),(A1)
                    3314   DisableBreakPoints_4:
00001F46  5282      3315          addq.l    #1,D2
00001F48  60BA      3316          bra       DisableBreakPoints_1
                    3317   DisableBreakPoints_3:
00001F4A  241F      3318          move.l    (A7)+,D2
00001F4C  4E5E      3319          unlk      A6
00001F4E  4E75      3320          rts
                    3321   ; }
                    3322   ; }
                    3323   ; }
                    3324   ; void EnableBreakPoints(void)
                    3325   ; {
                    3326   _EnableBreakPoints:
00001F50  4E56 FFFC 3327          link      A6,#-4
00001F54  2F02      3328          move.l    D2,-(A7)
                    3329   ; int i ;
                    3330   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3331   ; for(i = 0; i < 8; i++)  {
00001F56  4282      3332          clr.l     D2
                    3333   EnableBreakPoints_1:
00001F58  0C82 0000 3334          cmp.l     #8,D2
00001F5C  0008      
00001F5E  6C32      3335          bge.s     EnableBreakPoints_3
                    3336   ; if(BreakPointSetOrCleared[i] == 1)    {                                                     // if break point set
00001F60  2002      3337          move.l    D2,D0
00001F62  E588      3338          lsl.l     #2,D0
00001F64  41F9 0B00 3339          lea       _BreakPointSetOrCleared.L,A0
00001F68  015E      
00001F6A  2030 0800 3340          move.l    0(A0,D0.L),D0
00001F6E  0C80 0000 3341          cmp.l     #1,D0
00001F72  0001      
00001F74  6618      3342          bne.s     EnableBreakPoints_4
                    3343   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00001F76  2002      3344          move.l    D2,D0
00001F78  E588      3345          lsl.l     #2,D0
00001F7A  41F9 0B00 3346          lea       _BreakPointAddress.L,A0
00001F7E  012E      
00001F80  2D70 0800 3347          move.l    0(A0,D0.L),-4(A6)
00001F84  FFFC      
                    3348   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e);                              // put the breakpoint back in user program
00001F86  206E FFFC 3349          move.l    -4(A6),A0
00001F8A  30BC 4E4E 3350          move.w    #20046,(A0)
                    3351   EnableBreakPoints_4:
00001F8E  5282      3352          addq.l    #1,D2
00001F90  60C6      3353          bra       EnableBreakPoints_1
                    3354   EnableBreakPoints_3:
00001F92  241F      3355          move.l    (A7)+,D2
00001F94  4E5E      3356          unlk      A6
00001F96  4E75      3357          rts
                    3358   ; }
                    3359   ; }
                    3360   ; }
                    3361   ; void KillAllBreakPoints(void)
                    3362   ; {
                    3363   _KillAllBreakPoints:
00001F98  4E56 FFFC 3364          link      A6,#-4
00001F9C  2F02      3365          move.l    D2,-(A7)
                    3366   ; int i ;
                    3367   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3368   ; for(i = 0; i < 8; i++)  {
00001F9E  4282      3369          clr.l     D2
                    3370   KillAllBreakPoints_1:
00001FA0  0C82 0000 3371          cmp.l     #8,D2
00001FA4  0008      
00001FA6  6C00 0052 3372          bge       KillAllBreakPoints_3
                    3373   ; // clear BP
                    3374   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00001FAA  2002      3375          move.l    D2,D0
00001FAC  E588      3376          lsl.l     #2,D0
00001FAE  41F9 0B00 3377          lea       _BreakPointAddress.L,A0
00001FB2  012E      
00001FB4  2D70 0800 3378          move.l    0(A0,D0.L),-4(A6)
00001FB8  FFFC      
                    3379   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program
00001FBA  2002      3380          move.l    D2,D0
00001FBC  E388      3381          lsl.l     #1,D0
00001FBE  41F9 0B00 3382          lea       _BreakPointInstruction.L,A0
00001FC2  014E      
00001FC4  226E FFFC 3383          move.l    -4(A6),A1
00001FC8  32B0 0800 3384          move.w    0(A0,D0.L),(A1)
                    3385   ; BreakPointAddress[i] = 0 ;                                                             // set BP address to NULL
00001FCC  2002      3386          move.l    D2,D0
00001FCE  E588      3387          lsl.l     #2,D0
00001FD0  41F9 0B00 3388          lea       _BreakPointAddress.L,A0
00001FD4  012E      
00001FD6  42B0 0800 3389          clr.l     0(A0,D0.L)
                    3390   ; BreakPointInstruction[i] = 0 ;
00001FDA  2002      3391          move.l    D2,D0
00001FDC  E388      3392          lsl.l     #1,D0
00001FDE  41F9 0B00 3393          lea       _BreakPointInstruction.L,A0
00001FE2  014E      
00001FE4  4270 0800 3394          clr.w     0(A0,D0.L)
                    3395   ; BreakPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
00001FE8  2002      3396          move.l    D2,D0
00001FEA  E588      3397          lsl.l     #2,D0
00001FEC  41F9 0B00 3398          lea       _BreakPointSetOrCleared.L,A0
00001FF0  015E      
00001FF2  42B0 0800 3399          clr.l     0(A0,D0.L)
00001FF6  5282      3400          addq.l    #1,D2
00001FF8  60A6      3401          bra       KillAllBreakPoints_1
                    3402   KillAllBreakPoints_3:
00001FFA  241F      3403          move.l    (A7)+,D2
00001FFC  4E5E      3404          unlk      A6
00001FFE  4E75      3405          rts
                    3406   ; }
                    3407   ; //BreakPointDisplay() ;       // display the break points
                    3408   ; }
                    3409   ; void KillAllWatchPoints(void)
                    3410   ; {
                    3411   _KillAllWatchPoints:
00002000  2F02      3412          move.l    D2,-(A7)
                    3413   ; int i ;
                    3414   ; for(i = 0; i < 8; i++)  {
00002002  4282      3415          clr.l     D2
                    3416   KillAllWatchPoints_1:
00002004  0C82 0000 3417          cmp.l     #8,D2
00002008  0008      
0000200A  6C20      3418          bge.s     KillAllWatchPoints_3
                    3419   ; WatchPointAddress[i] = 0 ;                                                             // set BP address to NULL
0000200C  2002      3420          move.l    D2,D0
0000200E  E588      3421          lsl.l     #2,D0
00002010  41F9 0B00 3422          lea       _WatchPointAddress.L,A0
00002014  0182      
00002016  42B0 0800 3423          clr.l     0(A0,D0.L)
                    3424   ; WatchPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
0000201A  2002      3425          move.l    D2,D0
0000201C  E588      3426          lsl.l     #2,D0
0000201E  41F9 0B00 3427          lea       _WatchPointSetOrCleared.L,A0
00002022  01A2      
00002024  42B0 0800 3428          clr.l     0(A0,D0.L)
00002028  5282      3429          addq.l    #1,D2
0000202A  60D8      3430          bra       KillAllWatchPoints_1
                    3431   KillAllWatchPoints_3:
0000202C  241F      3432          move.l    (A7)+,D2
0000202E  4E75      3433          rts
                    3434   ; }
                    3435   ; //WatchPointDisplay() ;       // display the break points
                    3436   ; }
                    3437   ; void SetBreakPoint(void)
                    3438   ; {
                    3439   _SetBreakPoint:
00002030  4E56 FFFC 3440          link      A6,#-4
00002034  48E7 3830 3441          movem.l   D2/D3/D4/A2/A3,-(A7)
00002038  45F9 0000 3442          lea       _printf.L,A2
0000203C  343A      
0000203E  47F9 0B00 3443          lea       _BreakPointSetOrCleared.L,A3
00002042  015E      
                    3444   ; int i ;
                    3445   ; int BPNumber;
                    3446   ; int BPAddress;
                    3447   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3448   ; // see if any free break points
                    3449   ; for(i = 0; i < 8; i ++) {
00002044  4282      3450          clr.l     D2
                    3451   SetBreakPoint_1:
00002046  0C82 0000 3452          cmp.l     #8,D2
0000204A  0008      
0000204C  6C10      3453          bge.s     SetBreakPoint_3
                    3454   ; if( BreakPointSetOrCleared[i] == 0)
0000204E  2002      3455          move.l    D2,D0
00002050  E588      3456          lsl.l     #2,D0
00002052  2033 0800 3457          move.l    0(A3,D0.L),D0
00002056  6602      3458          bne.s     SetBreakPoint_4
                    3459   ; break ;         // if spare BP found allow user to set it
00002058  6004      3460          bra.s     SetBreakPoint_3
                    3461   SetBreakPoint_4:
0000205A  5282      3462          addq.l    #1,D2
0000205C  60E8      3463          bra       SetBreakPoint_1
                    3464   SetBreakPoint_3:
                    3465   ; }
                    3466   ; if(i == 8) {
0000205E  0C82 0000 3467          cmp.l     #8,D2
00002062  0008      
00002064  660E      3468          bne.s     SetBreakPoint_6
                    3469   ; printf("\r\nNo FREE Break Points.....") ;
00002066  4879 0000 3470          pea       @m68kde~1_76.L
0000206A  451E      
0000206C  4E92      3471          jsr       (A2)
0000206E  584F      3472          addq.w    #4,A7
                    3473   ; return ;
00002070  6000 00D6 3474          bra       SetBreakPoint_15
                    3475   SetBreakPoint_6:
                    3476   ; }
                    3477   ; printf("\r\nBreak Point Address: ") ;
00002074  4879 0000 3478          pea       @m68kde~1_77.L
00002078  453A      
0000207A  4E92      3479          jsr       (A2)
0000207C  584F      3480          addq.w    #4,A7
                    3481   ; BPAddress = Get8HexDigits(0) ;
0000207E  42A7      3482          clr.l     -(A7)
00002080  4EB8 0CDE 3483          jsr       _Get8HexDigits
00002084  584F      3484          addq.w    #4,A7
00002086  2600      3485          move.l    D0,D3
                    3486   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BPAddress) ;     // point to the instruction in the user program we are about to change
00002088  2803      3487          move.l    D3,D4
                    3488   ; if((BPAddress & 0x00000001) == 0x00000001)  {   // cannot set BP at an odd address
0000208A  2003      3489          move.l    D3,D0
0000208C  C0BC 0000 3490          and.l     #1,D0
00002090  0001      
00002092  0C80 0000 3491          cmp.l     #1,D0
00002096  0001      
00002098  660E      3492          bne.s     SetBreakPoint_9
                    3493   ; printf("\r\nError : Break Points CANNOT be set at ODD addresses") ;
0000209A  4879 0000 3494          pea       @m68kde~1_78.L
0000209E  4552      
000020A0  4E92      3495          jsr       (A2)
000020A2  584F      3496          addq.w    #4,A7
                    3497   ; return ;
000020A4  6000 00A2 3498          bra       SetBreakPoint_15
                    3499   SetBreakPoint_9:
                    3500   ; }
                    3501   ; if(BPAddress < 0x00008000)  {   // cannot set BP in ROM
000020A8  0C83 0000 3502          cmp.l     #32768,D3
000020AC  8000      
000020AE  640E      3503          bhs.s     SetBreakPoint_11
                    3504   ; printf("\r\nError : Break Points CANNOT be set for ROM in Range : [$0-$00007FFF]") ;
000020B0  4879 0000 3505          pea       @m68kde~1_79.L
000020B4  4588      
000020B6  4E92      3506          jsr       (A2)
000020B8  584F      3507          addq.w    #4,A7
                    3508   ; return ;
000020BA  6000 008C 3509          bra       SetBreakPoint_15
                    3510   SetBreakPoint_11:
                    3511   ; }
                    3512   ; // search for first free bp or existing same BP
                    3513   ; for(i = 0; i < 8; i++)  {
000020BE  4282      3514          clr.l     D2
                    3515   SetBreakPoint_13:
000020C0  0C82 0000 3516          cmp.l     #8,D2
000020C4  0008      
000020C6  6C00 0080 3517          bge       SetBreakPoint_15
                    3518   ; if(BreakPointAddress[i] == BPAddress)   {
000020CA  2002      3519          move.l    D2,D0
000020CC  E588      3520          lsl.l     #2,D0
000020CE  41F9 0B00 3521          lea       _BreakPointAddress.L,A0
000020D2  012E      
000020D4  B6B0 0800 3522          cmp.l     0(A0,D0.L),D3
000020D8  6610      3523          bne.s     SetBreakPoint_16
                    3524   ; printf("\r\nError: Break Point Already Exists at Address : %08x\r\n", BPAddress) ;
000020DA  2F03      3525          move.l    D3,-(A7)
000020DC  4879 0000 3526          pea       @m68kde~1_80.L
000020E0  45D0      
000020E2  4E92      3527          jsr       (A2)
000020E4  504F      3528          addq.w    #8,A7
                    3529   ; return ;
000020E6  6000 0060 3530          bra       SetBreakPoint_15
                    3531   SetBreakPoint_16:
                    3532   ; }
                    3533   ; if(BreakPointSetOrCleared[i] == 0) {
000020EA  2002      3534          move.l    D2,D0
000020EC  E588      3535          lsl.l     #2,D0
000020EE  2033 0800 3536          move.l    0(A3,D0.L),D0
000020F2  6600 004E 3537          bne       SetBreakPoint_18
                    3538   ; // set BP here
                    3539   ; BreakPointSetOrCleared[i] = 1 ;                                 // mark this breakpoint as set
000020F6  2002      3540          move.l    D2,D0
000020F8  E588      3541          lsl.l     #2,D0
000020FA  27BC 0000 3542          move.l    #1,0(A3,D0.L)
000020FE  0001 0800 
                    3543   ; BreakPointInstruction[i] = *ProgramBreakPointAddress ;          // copy the user program instruction here so we can put it back afterwards
00002102  2044      3544          move.l    D4,A0
00002104  2002      3545          move.l    D2,D0
00002106  E388      3546          lsl.l     #1,D0
00002108  43F9 0B00 3547          lea       _BreakPointInstruction.L,A1
0000210C  014E      
0000210E  3390 0800 3548          move.w    (A0),0(A1,D0.L)
                    3549   ; printf("\r\nBreak Point Set at Address: [$%08x]", ProgramBreakPointAddress) ;
00002112  2F04      3550          move.l    D4,-(A7)
00002114  4879 0000 3551          pea       @m68kde~1_81.L
00002118  4608      
0000211A  4E92      3552          jsr       (A2)
0000211C  504F      3553          addq.w    #8,A7
                    3554   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e)    ;   // put a Trap14 instruction at the user specified address
0000211E  2044      3555          move.l    D4,A0
00002120  30BC 4E4E 3556          move.w    #20046,(A0)
                    3557   ; BreakPointAddress[i] = BPAddress ;                              // record the address of this break point in the debugger
00002124  2002      3558          move.l    D2,D0
00002126  E588      3559          lsl.l     #2,D0
00002128  41F9 0B00 3560          lea       _BreakPointAddress.L,A0
0000212C  012E      
0000212E  2183 0800 3561          move.l    D3,0(A0,D0.L)
                    3562   ; printf("\r\n") ;
00002132  4879 0000 3563          pea       @m68kde~1_1.L
00002136  3D8A      
00002138  4E92      3564          jsr       (A2)
0000213A  584F      3565          addq.w    #4,A7
                    3566   ; BreakPointDisplay() ;       // display the break points
0000213C  4EB8 1C00 3567          jsr       _BreakPointDisplay
                    3568   ; return ;
00002140  6006      3569          bra.s     SetBreakPoint_15
                    3570   SetBreakPoint_18:
00002142  5282      3571          addq.l    #1,D2
00002144  6000 FF7A 3572          bra       SetBreakPoint_13
                    3573   SetBreakPoint_15:
00002148  4CDF 0C1C 3574          movem.l   (A7)+,D2/D3/D4/A2/A3
0000214C  4E5E      3575          unlk      A6
0000214E  4E75      3576          rts
                    3577   ; }
                    3578   ; }
                    3579   ; }
                    3580   ; void SetWatchPoint(void)
                    3581   ; {
                    3582   _SetWatchPoint:
00002150  4E56 FFF8 3583          link      A6,#-8
00002154  48E7 3030 3584          movem.l   D2/D3/A2/A3,-(A7)
00002158  45F9 0000 3585          lea       _printf.L,A2
0000215C  343A      
0000215E  47F9 0B00 3586          lea       _WatchPointSetOrCleared.L,A3
00002162  01A2      
                    3587   ; int i ;
                    3588   ; int WPNumber;
                    3589   ; int WPAddress;
                    3590   ; volatile unsigned short int *ProgramWatchPointAddress ;
                    3591   ; // see if any free break points
                    3592   ; for(i = 0; i < 8; i ++) {
00002164  4282      3593          clr.l     D2
                    3594   SetWatchPoint_1:
00002166  0C82 0000 3595          cmp.l     #8,D2
0000216A  0008      
0000216C  6C10      3596          bge.s     SetWatchPoint_3
                    3597   ; if( WatchPointSetOrCleared[i] == 0)
0000216E  2002      3598          move.l    D2,D0
00002170  E588      3599          lsl.l     #2,D0
00002172  2033 0800 3600          move.l    0(A3,D0.L),D0
00002176  6602      3601          bne.s     SetWatchPoint_4
                    3602   ; break ;         // if spare WP found allow user to set it
00002178  6004      3603          bra.s     SetWatchPoint_3
                    3604   SetWatchPoint_4:
0000217A  5282      3605          addq.l    #1,D2
0000217C  60E8      3606          bra       SetWatchPoint_1
                    3607   SetWatchPoint_3:
                    3608   ; }
                    3609   ; if(i == 8) {
0000217E  0C82 0000 3610          cmp.l     #8,D2
00002182  0008      
00002184  660E      3611          bne.s     SetWatchPoint_6
                    3612   ; printf("\r\nNo FREE Watch Points.....") ;
00002186  4879 0000 3613          pea       @m68kde~1_82.L
0000218A  462E      
0000218C  4E92      3614          jsr       (A2)
0000218E  584F      3615          addq.w    #4,A7
                    3616   ; return ;
00002190  6000 008C 3617          bra       SetWatchPoint_11
                    3618   SetWatchPoint_6:
                    3619   ; }
                    3620   ; printf("\r\nWatch Point Address: ") ;
00002194  4879 0000 3621          pea       @m68kde~1_83.L
00002198  464A      
0000219A  4E92      3622          jsr       (A2)
0000219C  584F      3623          addq.w    #4,A7
                    3624   ; WPAddress = Get8HexDigits(0) ;
0000219E  42A7      3625          clr.l     -(A7)
000021A0  4EB8 0CDE 3626          jsr       _Get8HexDigits
000021A4  584F      3627          addq.w    #4,A7
000021A6  2600      3628          move.l    D0,D3
                    3629   ; // search for first free wp or existing same wp
                    3630   ; for(i = 0; i < 8; i++)  {
000021A8  4282      3631          clr.l     D2
                    3632   SetWatchPoint_9:
000021AA  0C82 0000 3633          cmp.l     #8,D2
000021AE  0008      
000021B0  6C00 006C 3634          bge       SetWatchPoint_11
                    3635   ; if(WatchPointAddress[i] == WPAddress && WPAddress != 0)   {     //so we can set a wp at 0
000021B4  2002      3636          move.l    D2,D0
000021B6  E588      3637          lsl.l     #2,D0
000021B8  41F9 0B00 3638          lea       _WatchPointAddress.L,A0
000021BC  0182      
000021BE  B6B0 0800 3639          cmp.l     0(A0,D0.L),D3
000021C2  6614      3640          bne.s     SetWatchPoint_12
000021C4  4A83      3641          tst.l     D3
000021C6  6710      3642          beq.s     SetWatchPoint_12
                    3643   ; printf("\r\nError: Watch Point Already Set at Address : %08x\r\n", WPAddress) ;
000021C8  2F03      3644          move.l    D3,-(A7)
000021CA  4879 0000 3645          pea       @m68kde~1_84.L
000021CE  4662      
000021D0  4E92      3646          jsr       (A2)
000021D2  504F      3647          addq.w    #8,A7
                    3648   ; return ;
000021D4  6000 0048 3649          bra       SetWatchPoint_11
                    3650   SetWatchPoint_12:
                    3651   ; }
                    3652   ; if(WatchPointSetOrCleared[i] == 0) {
000021D8  2002      3653          move.l    D2,D0
000021DA  E588      3654          lsl.l     #2,D0
000021DC  2033 0800 3655          move.l    0(A3,D0.L),D0
000021E0  6600 0038 3656          bne       SetWatchPoint_14
                    3657   ; WatchPointSetOrCleared[i] = 1 ;                                 // mark this watchpoint as set
000021E4  2002      3658          move.l    D2,D0
000021E6  E588      3659          lsl.l     #2,D0
000021E8  27BC 0000 3660          move.l    #1,0(A3,D0.L)
000021EC  0001 0800 
                    3661   ; printf("\r\nWatch Point Set at Address: [$%08x]", WPAddress) ;
000021F0  2F03      3662          move.l    D3,-(A7)
000021F2  4879 0000 3663          pea       @m68kde~1_85.L
000021F6  4698      
000021F8  4E92      3664          jsr       (A2)
000021FA  504F      3665          addq.w    #8,A7
                    3666   ; WatchPointAddress[i] = WPAddress ;                              // record the address of this watch point in the debugger
000021FC  2002      3667          move.l    D2,D0
000021FE  E588      3668          lsl.l     #2,D0
00002200  41F9 0B00 3669          lea       _WatchPointAddress.L,A0
00002204  0182      
00002206  2183 0800 3670          move.l    D3,0(A0,D0.L)
                    3671   ; printf("\r\n") ;
0000220A  4879 0000 3672          pea       @m68kde~1_1.L
0000220E  3D8A      
00002210  4E92      3673          jsr       (A2)
00002212  584F      3674          addq.w    #4,A7
                    3675   ; WatchPointDisplay() ;       // display the break points
00002214  4EB8 1CD4 3676          jsr       _WatchPointDisplay
                    3677   ; return ;
00002218  6004      3678          bra.s     SetWatchPoint_11
                    3679   SetWatchPoint_14:
0000221A  5282      3680          addq.l    #1,D2
0000221C  608C      3681          bra       SetWatchPoint_9
                    3682   SetWatchPoint_11:
0000221E  4CDF 0C0C 3683          movem.l   (A7)+,D2/D3/A2/A3
00002222  4E5E      3684          unlk      A6
00002224  4E75      3685          rts
                    3686   ; }
                    3687   ; }
                    3688   ; }
                    3689   ; void HandleBreakPoint(void)
                    3690   ; {
                    3691   _HandleBreakPoint:
00002226  4E56 FFFC 3692          link      A6,#-4
0000222A  48E7 0038 3693          movem.l   A2/A3/A4,-(A7)
0000222E  45F9 0B00 3694          lea       _i.L,A2
00002232  00C4      
00002234  47F9 0000 3695          lea       _printf.L,A3
00002238  343A      
0000223A  49F9 0B00 3696          lea       _PC.L,A4
0000223E  0120      
                    3697   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3698   ; // now we have to put the break point back to run the instruction
                    3699   ; // PC will contain the address of the TRAP instruction but advanced by two bytes so lets play with that
                    3700   ; PC = PC - 2 ;  // ready for user to resume after reaching breakpoint
00002240  5594      3701          subq.l    #2,(A4)
                    3702   ; printf("\r\n\r\n\r\n\r\n@BREAKPOINT") ;
00002242  4879 0000 3703          pea       @m68kde~1_86.L
00002246  46BE      
00002248  4E93      3704          jsr       (A3)
0000224A  584F      3705          addq.w    #4,A7
                    3706   ; printf("\r\nSingle Step : [ON]") ;
0000224C  4879 0000 3707          pea       @m68kde~1_87.L
00002250  46D2      
00002252  4E93      3708          jsr       (A3)
00002254  584F      3709          addq.w    #4,A7
                    3710   ; printf("\r\nBreakPoints : [Enabled]") ;
00002256  4879 0000 3711          pea       @m68kde~1_88.L
0000225A  46E8      
0000225C  4E93      3712          jsr       (A3)
0000225E  584F      3713          addq.w    #4,A7
                    3714   ; // now clear the break point (put original instruction back)
                    3715   ; ProgramBreakPointAddress = PC ;
00002260  2D54 FFFC 3716          move.l    (A4),-4(A6)
                    3717   ; for(i = 0; i < 8; i ++) {
00002264  4292      3718          clr.l     (A2)
                    3719   HandleBreakPoint_1:
00002266  2012      3720          move.l    (A2),D0
00002268  0C80 0000 3721          cmp.l     #8,D0
0000226C  0008      
0000226E  6400 0056 3722          bhs       HandleBreakPoint_3
                    3723   ; if(BreakPointAddress[i] == PC) {        // if we have found the breakpoint
00002272  2012      3724          move.l    (A2),D0
00002274  E588      3725          lsl.l     #2,D0
00002276  41F9 0B00 3726          lea       _BreakPointAddress.L,A0
0000227A  012E      
0000227C  2230 0800 3727          move.l    0(A0,D0.L),D1
00002280  B294      3728          cmp.l     (A4),D1
00002282  6600 003E 3729          bne       HandleBreakPoint_4
                    3730   ; BreakPointAddress[i] = 0 ;
00002286  2012      3731          move.l    (A2),D0
00002288  E588      3732          lsl.l     #2,D0
0000228A  41F9 0B00 3733          lea       _BreakPointAddress.L,A0
0000228E  012E      
00002290  42B0 0800 3734          clr.l     0(A0,D0.L)
                    3735   ; BreakPointSetOrCleared[i] = 0 ;
00002294  2012      3736          move.l    (A2),D0
00002296  E588      3737          lsl.l     #2,D0
00002298  41F9 0B00 3738          lea       _BreakPointSetOrCleared.L,A0
0000229C  015E      
0000229E  42B0 0800 3739          clr.l     0(A0,D0.L)
                    3740   ; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
000022A2  2012      3741          move.l    (A2),D0
000022A4  E388      3742          lsl.l     #1,D0
000022A6  41F9 0B00 3743          lea       _BreakPointInstruction.L,A0
000022AA  014E      
000022AC  226E FFFC 3744          move.l    -4(A6),A1
000022B0  32B0 0800 3745          move.w    0(A0,D0.L),(A1)
                    3746   ; BreakPointInstruction[i] = 0 ;
000022B4  2012      3747          move.l    (A2),D0
000022B6  E388      3748          lsl.l     #1,D0
000022B8  41F9 0B00 3749          lea       _BreakPointInstruction.L,A0
000022BC  014E      
000022BE  4270 0800 3750          clr.w     0(A0,D0.L)
                    3751   HandleBreakPoint_4:
000022C2  5292      3752          addq.l    #1,(A2)
000022C4  60A0      3753          bra       HandleBreakPoint_1
                    3754   HandleBreakPoint_3:
                    3755   ; }
                    3756   ; }
                    3757   ; DumpRegisters() ;
000022C6  4EB8 1452 3758          jsr       _DumpRegisters
                    3759   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
000022CA  4879 0000 3760          pea       @m68kde~1_50.L
000022CE  4264      
000022D0  4E93      3761          jsr       (A3)
000022D2  584F      3762          addq.w    #4,A7
                    3763   ; printf("\r\nPress <ESC> to Resume User Program\r\n") ;
000022D4  4879 0000 3764          pea       @m68kde~1_89.L
000022D8  4702      
000022DA  4E93      3765          jsr       (A3)
000022DC  584F      3766          addq.w    #4,A7
                    3767   ; menu() ;
000022DE  4EB9 0000 3768          jsr       _menu
000022E2  24EA      
000022E4  4CDF 1C00 3769          movem.l   (A7)+,A2/A3/A4
000022E8  4E5E      3770          unlk      A6
000022EA  4E75      3771          rts
                    3772   ; }
                    3773   ; void UnknownCommand()
                    3774   ; {
                    3775   _UnknownCommand:
                    3776   ; printf("\r\nUnknown Command.....\r\n") ;
000022EC  4879 0000 3777          pea       @m68kde~1_90.L
000022F0  472A      
000022F2  4EB9 0000 3778          jsr       _printf
000022F6  343A      
000022F8  584F      3779          addq.w    #4,A7
                    3780   ; Help() ;
000022FA  4EB9 0000 3781          jsr       _Help
000022FE  2410      
00002300  4E75      3782          rts
                    3783   ; }
                    3784   ; // system when the users program executes a TRAP #15 instruction to halt program and return to debug monitor
                    3785   ; void CallDebugMonitor(void)
                    3786   ; {
                    3787   _CallDebugMonitor:
                    3788   ; printf("\r\nProgram Ended (TRAP #15)....") ;
00002302  4879 0000 3789          pea       @m68kde~1_91.L
00002306  4744      
00002308  4EB9 0000 3790          jsr       _printf
0000230C  343A      
0000230E  584F      3791          addq.w    #4,A7
                    3792   ; menu();
00002310  4EB9 0000 3793          jsr       _menu
00002314  24EA      
00002316  4E75      3794          rts
                    3795   ; }
                    3796   ; void Breakpoint(void)
                    3797   ; {
                    3798   _Breakpoint:
00002318  2F02      3799          move.l    D2,-(A7)
                    3800   ; char c;
                    3801   ; c = toupper(_getch());
0000231A  2F00      3802          move.l    D0,-(A7)
0000231C  4EB8 0B6E 3803          jsr       __getch
00002320  2200      3804          move.l    D0,D1
00002322  201F      3805          move.l    (A7)+,D0
00002324  2F01      3806          move.l    D1,-(A7)
00002326  4EB9 0000 3807          jsr       _toupper
0000232A  340E      
0000232C  584F      3808          addq.w    #4,A7
0000232E  1400      3809          move.b    D0,D2
                    3810   ; if( c == (char)('D'))                                      // BreakPoint Display
00002330  0C02 0044 3811          cmp.b     #68,D2
00002334  6608      3812          bne.s     Breakpoint_1
                    3813   ; BreakPointDisplay() ;
00002336  4EB8 1C00 3814          jsr       _BreakPointDisplay
0000233A  6000 0054 3815          bra       Breakpoint_10
                    3816   Breakpoint_1:
                    3817   ; else if(c == (char)('K')) {                                 // breakpoint Kill
0000233E  0C02 004B 3818          cmp.b     #75,D2
00002342  6630      3819          bne.s     Breakpoint_3
                    3820   ; printf("\r\nKill All Break Points...(y/n)?") ;
00002344  4879 0000 3821          pea       @m68kde~1_92.L
00002348  4764      
0000234A  4EB9 0000 3822          jsr       _printf
0000234E  343A      
00002350  584F      3823          addq.w    #4,A7
                    3824   ; c = toupper(_getch());
00002352  2F00      3825          move.l    D0,-(A7)
00002354  4EB8 0B6E 3826          jsr       __getch
00002358  2200      3827          move.l    D0,D1
0000235A  201F      3828          move.l    (A7)+,D0
0000235C  2F01      3829          move.l    D1,-(A7)
0000235E  4EB9 0000 3830          jsr       _toupper
00002362  340E      
00002364  584F      3831          addq.w    #4,A7
00002366  1400      3832          move.b    D0,D2
                    3833   ; if(c == (char)('Y'))
00002368  0C02 0059 3834          cmp.b     #89,D2
0000236C  6604      3835          bne.s     Breakpoint_5
                    3836   ; KillAllBreakPoints() ;
0000236E  4EB8 1F98 3837          jsr       _KillAllBreakPoints
                    3838   Breakpoint_5:
00002372  601C      3839          bra.s     Breakpoint_10
                    3840   Breakpoint_3:
                    3841   ; }
                    3842   ; else if(c == (char)('S')) {
00002374  0C02 0053 3843          cmp.b     #83,D2
00002378  6606      3844          bne.s     Breakpoint_7
                    3845   ; SetBreakPoint() ;
0000237A  4EB8 2030 3846          jsr       _SetBreakPoint
0000237E  6010      3847          bra.s     Breakpoint_10
                    3848   Breakpoint_7:
                    3849   ; }
                    3850   ; else if(c == (char)('C')) {
00002380  0C02 0043 3851          cmp.b     #67,D2
00002384  6606      3852          bne.s     Breakpoint_9
                    3853   ; BreakPointClear() ;
00002386  4EB8 1D80 3854          jsr       _BreakPointClear
0000238A  6004      3855          bra.s     Breakpoint_10
                    3856   Breakpoint_9:
                    3857   ; }
                    3858   ; else
                    3859   ; UnknownCommand() ;
0000238C  4EB8 22EC 3860          jsr       _UnknownCommand
                    3861   Breakpoint_10:
00002390  241F      3862          move.l    (A7)+,D2
00002392  4E75      3863          rts
                    3864   ; }
                    3865   ; void Watchpoint(void)
                    3866   ; {
                    3867   _Watchpoint:
00002394  2F02      3868          move.l    D2,-(A7)
                    3869   ; char c;
                    3870   ; c = toupper(_getch());
00002396  2F00      3871          move.l    D0,-(A7)
00002398  4EB8 0B6E 3872          jsr       __getch
0000239C  2200      3873          move.l    D0,D1
0000239E  201F      3874          move.l    (A7)+,D0
000023A0  2F01      3875          move.l    D1,-(A7)
000023A2  4EB9 0000 3876          jsr       _toupper
000023A6  340E      
000023A8  584F      3877          addq.w    #4,A7
000023AA  1400      3878          move.b    D0,D2
                    3879   ; if( c == (char)('D'))                                      // WatchPoint Display
000023AC  0C02 0044 3880          cmp.b     #68,D2
000023B0  6608      3881          bne.s     Watchpoint_1
                    3882   ; WatchPointDisplay() ;
000023B2  4EB8 1CD4 3883          jsr       _WatchPointDisplay
000023B6  6000 0054 3884          bra       Watchpoint_10
                    3885   Watchpoint_1:
                    3886   ; else if(c == (char)('K')) {                                 // wtahcpoint Kill
000023BA  0C02 004B 3887          cmp.b     #75,D2
000023BE  6630      3888          bne.s     Watchpoint_3
                    3889   ; printf("\r\nKill All Watch Points...(y/n)?") ;
000023C0  4879 0000 3890          pea       @m68kde~1_93.L
000023C4  4786      
000023C6  4EB9 0000 3891          jsr       _printf
000023CA  343A      
000023CC  584F      3892          addq.w    #4,A7
                    3893   ; c = toupper(_getch());
000023CE  2F00      3894          move.l    D0,-(A7)
000023D0  4EB8 0B6E 3895          jsr       __getch
000023D4  2200      3896          move.l    D0,D1
000023D6  201F      3897          move.l    (A7)+,D0
000023D8  2F01      3898          move.l    D1,-(A7)
000023DA  4EB9 0000 3899          jsr       _toupper
000023DE  340E      
000023E0  584F      3900          addq.w    #4,A7
000023E2  1400      3901          move.b    D0,D2
                    3902   ; if(c == (char)('Y'))
000023E4  0C02 0059 3903          cmp.b     #89,D2
000023E8  6604      3904          bne.s     Watchpoint_5
                    3905   ; KillAllWatchPoints() ;
000023EA  4EB8 2000 3906          jsr       _KillAllWatchPoints
                    3907   Watchpoint_5:
000023EE  601C      3908          bra.s     Watchpoint_10
                    3909   Watchpoint_3:
                    3910   ; }
                    3911   ; else if(c == (char)('S')) {
000023F0  0C02 0053 3912          cmp.b     #83,D2
000023F4  6606      3913          bne.s     Watchpoint_7
                    3914   ; SetWatchPoint() ;
000023F6  4EB8 2150 3915          jsr       _SetWatchPoint
000023FA  6010      3916          bra.s     Watchpoint_10
                    3917   Watchpoint_7:
                    3918   ; }
                    3919   ; else if(c == (char)('C')) {
000023FC  0C02 0043 3920          cmp.b     #67,D2
00002400  6606      3921          bne.s     Watchpoint_9
                    3922   ; WatchPointClear() ;
00002402  4EB8 1E5A 3923          jsr       _WatchPointClear
00002406  6004      3924          bra.s     Watchpoint_10
                    3925   Watchpoint_9:
                    3926   ; }
                    3927   ; else
                    3928   ; UnknownCommand() ;
00002408  4EB8 22EC 3929          jsr       _UnknownCommand
                    3930   Watchpoint_10:
0000240C  241F      3931          move.l    (A7)+,D2
0000240E  4E75      3932          rts
                    3933   ; }
                    3934   ; void Help(void)
                    3935   ; {
                    3936   _Help:
00002410  48E7 2020 3937          movem.l   D2/A2,-(A7)
00002414  45F9 0000 3938          lea       _printf.L,A2
00002418  343A      
                    3939   ; char *banner = "\r\n----------------------------------------------------------------" ;
0000241A  41F9 0000 3940          lea       @m68kde~1_94.L,A0
0000241E  47A8      
00002420  2408      3941          move.l    A0,D2
                    3942   ; printf(banner) ;
00002422  2F02      3943          move.l    D2,-(A7)
00002424  4E92      3944          jsr       (A2)
00002426  584F      3945          addq.w    #4,A7
                    3946   ; printf("\r\n  Debugger Command Summary") ;
00002428  4879 0000 3947          pea       @m68kde~1_95.L
0000242C  47EC      
0000242E  4E92      3948          jsr       (A2)
00002430  584F      3949          addq.w    #4,A7
                    3950   ; printf(banner) ;
00002432  2F02      3951          move.l    D2,-(A7)
00002434  4E92      3952          jsr       (A2)
00002436  584F      3953          addq.w    #4,A7
                    3954   ; printf("\r\n  .(reg)       - Change Registers: e.g A0-A7,D0-D7,PC,SSP,USP,SR");
00002438  4879 0000 3955          pea       @m68kde~1_96.L
0000243C  480A      
0000243E  4E92      3956          jsr       (A2)
00002440  584F      3957          addq.w    #4,A7
                    3958   ; printf("\r\n  BD/BS/BC/BK  - Break Point: Display/Set/Clear/Kill") ;
00002442  4879 0000 3959          pea       @m68kde~1_97.L
00002446  484E      
00002448  4E92      3960          jsr       (A2)
0000244A  584F      3961          addq.w    #4,A7
                    3962   ; printf("\r\n  C            - Copy Program from Flash to Main Memory") ;
0000244C  4879 0000 3963          pea       @m68kde~1_98.L
00002450  4886      
00002452  4E92      3964          jsr       (A2)
00002454  584F      3965          addq.w    #4,A7
                    3966   ; printf("\r\n  D            - Dump Memory Contents to Screen") ;
00002456  4879 0000 3967          pea       @m68kde~1_99.L
0000245A  48C0      
0000245C  4E92      3968          jsr       (A2)
0000245E  584F      3969          addq.w    #4,A7
                    3970   ; printf("\r\n  E            - Enter String into Memory") ;
00002460  4879 0000 3971          pea       @m68kde~1_100.L
00002464  48F2      
00002466  4E92      3972          jsr       (A2)
00002468  584F      3973          addq.w    #4,A7
                    3974   ; printf("\r\n  F            - Fill Memory with Data") ;
0000246A  4879 0000 3975          pea       @m68kde~1_101.L
0000246E  491E      
00002470  4E92      3976          jsr       (A2)
00002472  584F      3977          addq.w    #4,A7
                    3978   ; printf("\r\n  G            - Go Program Starting at Address: $%08X", PC) ;
00002474  2F39 0B00 3979          move.l    _PC.L,-(A7)
00002478  0120      
0000247A  4879 0000 3980          pea       @m68kde~1_102.L
0000247E  4948      
00002480  4E92      3981          jsr       (A2)
00002482  504F      3982          addq.w    #8,A7
                    3983   ; printf("\r\n  L            - Load Program (.HEX file) from Laptop") ;
00002484  4879 0000 3984          pea       @m68kde~1_103.L
00002488  4982      
0000248A  4E92      3985          jsr       (A2)
0000248C  584F      3986          addq.w    #4,A7
                    3987   ; printf("\r\n  M            - Memory Examine and Change");
0000248E  4879 0000 3988          pea       @m68kde~1_104.L
00002492  49BA      
00002494  4E92      3989          jsr       (A2)
00002496  584F      3990          addq.w    #4,A7
                    3991   ; printf("\r\n  P            - Program Flash Memory with User Program") ;
00002498  4879 0000 3992          pea       @m68kde~1_105.L
0000249C  49E8      
0000249E  4E92      3993          jsr       (A2)
000024A0  584F      3994          addq.w    #4,A7
                    3995   ; printf("\r\n  R            - Display 68000 Registers") ;
000024A2  4879 0000 3996          pea       @m68kde~1_106.L
000024A6  4A22      
000024A8  4E92      3997          jsr       (A2)
000024AA  584F      3998          addq.w    #4,A7
                    3999   ; printf("\r\n  S            - Toggle ON/OFF Single Step Mode") ;
000024AC  4879 0000 4000          pea       @m68kde~1_107.L
000024B0  4A4E      
000024B2  4E92      4001          jsr       (A2)
000024B4  584F      4002          addq.w    #4,A7
                    4003   ; printf("\r\n  TM           - Test Memory") ;
000024B6  4879 0000 4004          pea       @m68kde~1_108.L
000024BA  4A80      
000024BC  4E92      4005          jsr       (A2)
000024BE  584F      4006          addq.w    #4,A7
                    4007   ; printf("\r\n  TS           - Test Switches: SW7-0") ;
000024C0  4879 0000 4008          pea       @m68kde~1_109.L
000024C4  4AA0      
000024C6  4E92      4009          jsr       (A2)
000024C8  584F      4010          addq.w    #4,A7
                    4011   ; printf("\r\n  TD           - Test Displays: LEDs and 7-Segment") ;
000024CA  4879 0000 4012          pea       @m68kde~1_110.L
000024CE  4AC8      
000024D0  4E92      4013          jsr       (A2)
000024D2  584F      4014          addq.w    #4,A7
                    4015   ; printf("\r\n  WD/WS/WC/WK  - Watch Point: Display/Set/Clear/Kill") ;
000024D4  4879 0000 4016          pea       @m68kde~1_111.L
000024D8  4AFE      
000024DA  4E92      4017          jsr       (A2)
000024DC  584F      4018          addq.w    #4,A7
                    4019   ; printf(banner) ;
000024DE  2F02      4020          move.l    D2,-(A7)
000024E0  4E92      4021          jsr       (A2)
000024E2  584F      4022          addq.w    #4,A7
000024E4  4CDF 0404 4023          movem.l   (A7)+,D2/A2
000024E8  4E75      4024          rts
                    4025   ; }
                    4026   ; void menu(void)
                    4027   ; {
                    4028   _menu:
000024EA  48E7 303C 4029          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
000024EE  45F9 0000 4030          lea       _printf.L,A2
000024F2  343A      
000024F4  47F9 0B00 4031          lea       _Trace.L,A3
000024F8  00D8      
000024FA  49F9 0B00 4032          lea       _x.L,A4
000024FE  00C8      
00002500  4BF9 0B00 4033          lea       _SR.L,A5
00002504  012C      
                    4034   ; char c,c1 ;
                    4035   ; while(1)    {
                    4036   menu_1:
                    4037   ; FlushKeyboard() ;               // dump unread characters from keyboard
00002506  4EB8 0BAC 4038          jsr       _FlushKeyboard
                    4039   ; printf("\r\n#") ;
0000250A  4879 0000 4040          pea       @m68kde~1_112.L
0000250E  4B36      
00002510  4E92      4041          jsr       (A2)
00002512  584F      4042          addq.w    #4,A7
                    4043   ; c = toupper(_getch());
00002514  2F00      4044          move.l    D0,-(A7)
00002516  4EB8 0B6E 4045          jsr       __getch
0000251A  2200      4046          move.l    D0,D1
0000251C  201F      4047          move.l    (A7)+,D0
0000251E  2F01      4048          move.l    D1,-(A7)
00002520  4EB9 0000 4049          jsr       _toupper
00002524  340E      
00002526  584F      4050          addq.w    #4,A7
00002528  1400      4051          move.b    D0,D2
                    4052   ; if( c == (char)('L'))                  // load s record file
0000252A  0C02 004C 4053          cmp.b     #76,D2
0000252E  6608      4054          bne.s     menu_4
                    4055   ; Load_SRecordFile() ;
00002530  4EB8 0E70 4056          jsr       _Load_SRecordFile
00002534  6000 021E 4057          bra       menu_46
                    4058   menu_4:
                    4059   ; else if( c == (char)('D'))             // dump memory
00002538  0C02 0044 4060          cmp.b     #68,D2
0000253C  6608      4061          bne.s     menu_6
                    4062   ; DumpMemory() ;
0000253E  4EB8 0D06 4063          jsr       _DumpMemory
00002542  6000 0210 4064          bra       menu_46
                    4065   menu_6:
                    4066   ; else if( c == (char)('E'))             // Enter String into memory
00002546  0C02 0045 4067          cmp.b     #69,D2
0000254A  660A      4068          bne.s     menu_8
                    4069   ; EnterString() ;
0000254C  4EB9 0000 4070          jsr       _EnterString
00002550  289C      
00002552  6000 0200 4071          bra       menu_46
                    4072   menu_8:
                    4073   ; else if( c == (char)('F'))             // fill memory
00002556  0C02 0046 4074          cmp.b     #70,D2
0000255A  6608      4075          bne.s     menu_10
                    4076   ; FillMemory() ;
0000255C  4EB8 0DF6 4077          jsr       _FillMemory
00002560  6000 01F2 4078          bra       menu_46
                    4079   menu_10:
                    4080   ; else if( c == (char)('G'))  {           // go user program
00002564  0C02 0047 4081          cmp.b     #71,D2
00002568  6626      4082          bne.s     menu_12
                    4083   ; printf("\r\nProgram Running.....") ;
0000256A  4879 0000 4084          pea       @m68kde~1_113.L
0000256E  4B3A      
00002570  4E92      4085          jsr       (A2)
00002572  584F      4086          addq.w    #4,A7
                    4087   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop") ;
00002574  4879 0000 4088          pea       @m68kde~1_114.L
00002578  4B52      
0000257A  4E92      4089          jsr       (A2)
0000257C  584F      4090          addq.w    #4,A7
                    4091   ; GoFlag = 1 ;
0000257E  23FC 0000 4092          move.l    #1,_GoFlag.L
00002582  0001 0B00 
00002586  00DC      
                    4093   ; go() ;
00002588  4EB8 08BE 4094          jsr       _go
0000258C  6000 01C6 4095          bra       menu_46
                    4096   menu_12:
                    4097   ; }
                    4098   ; else if( c == (char)('M'))           // memory examine and modify
00002590  0C02 004D 4099          cmp.b     #77,D2
00002594  6608      4100          bne.s     menu_14
                    4101   ; MemoryChange() ;
00002596  4EB8 0FFE 4102          jsr       _MemoryChange
0000259A  6000 01B8 4103          bra       menu_46
                    4104   menu_14:
                    4105   ; else if( c == (char)('P'))            // Program Flash Chip
0000259E  0C02 0050 4106          cmp.b     #80,D2
000025A2  6608      4107          bne.s     menu_16
                    4108   ; ProgramFlashChip() ;
000025A4  4EB8 13C4 4109          jsr       _ProgramFlashChip
000025A8  6000 01AA 4110          bra       menu_46
                    4111   menu_16:
                    4112   ; else if( c == (char)('C'))             // copy flash chip to ram and go
000025AC  0C02 0043 4113          cmp.b     #67,D2
000025B0  6608      4114          bne.s     menu_18
                    4115   ; LoadFromFlashChip();
000025B2  4EB8 143A 4116          jsr       _LoadFromFlashChip
000025B6  6000 019C 4117          bra       menu_46
                    4118   menu_18:
                    4119   ; else if( c == (char)('R'))             // dump registers
000025BA  0C02 0052 4120          cmp.b     #82,D2
000025BE  6608      4121          bne.s     menu_20
                    4122   ; DumpRegisters() ;
000025C0  4EB8 1452 4123          jsr       _DumpRegisters
000025C4  6000 018E 4124          bra       menu_46
                    4125   menu_20:
                    4126   ; else if( c == (char)('.'))           // change registers
000025C8  0C02 002E 4127          cmp.b     #46,D2
000025CC  6608      4128          bne.s     menu_22
                    4129   ; ChangeRegisters() ;
000025CE  4EB8 1944 4130          jsr       _ChangeRegisters
000025D2  6000 0180 4131          bra       menu_46
                    4132   menu_22:
                    4133   ; else if( c == (char)('B'))              // breakpoint command
000025D6  0C02 0042 4134          cmp.b     #66,D2
000025DA  6608      4135          bne.s     menu_24
                    4136   ; Breakpoint() ;
000025DC  4EB8 2318 4137          jsr       _Breakpoint
000025E0  6000 0172 4138          bra       menu_46
                    4139   menu_24:
                    4140   ; else if( c == (char)('T'))  {          // Test command
000025E4  0C02 0054 4141          cmp.b     #84,D2
000025E8  6600 0046 4142          bne       menu_26
                    4143   ; c1 = toupper(_getch()) ;
000025EC  2F00      4144          move.l    D0,-(A7)
000025EE  4EB8 0B6E 4145          jsr       __getch
000025F2  2200      4146          move.l    D0,D1
000025F4  201F      4147          move.l    (A7)+,D0
000025F6  2F01      4148          move.l    D1,-(A7)
000025F8  4EB9 0000 4149          jsr       _toupper
000025FC  340E      
000025FE  584F      4150          addq.w    #4,A7
00002600  1600      4151          move.b    D0,D3
                    4152   ; if(c1 == (char)('M'))                    // memory test
00002602  0C03 004D 4153          cmp.b     #77,D3
00002606  6608      4154          bne.s     menu_28
                    4155   ; MemoryTest() ;
00002608  4EB9 0000 4156          jsr       _MemoryTest
0000260C  2E1C      
0000260E  601C      4157          bra.s     menu_33
                    4158   menu_28:
                    4159   ; else if( c1 == (char)('S'))              // Switch Test command
00002610  0C03 0053 4160          cmp.b     #83,D3
00002614  6606      4161          bne.s     menu_30
                    4162   ; SwitchTest() ;
00002616  4EB8 0AAA 4163          jsr       _SwitchTest
0000261A  6010      4164          bra.s     menu_33
                    4165   menu_30:
                    4166   ; else if( c1 == (char)('D'))              // display Test command
0000261C  0C03 0044 4167          cmp.b     #68,D3
00002620  6606      4168          bne.s     menu_32
                    4169   ; TestLEDS() ;
00002622  4EB8 0A56 4170          jsr       _TestLEDS
00002626  6004      4171          bra.s     menu_33
                    4172   menu_32:
                    4173   ; else
                    4174   ; UnknownCommand() ;
00002628  4EB8 22EC 4175          jsr       _UnknownCommand
                    4176   menu_33:
0000262C  6000 0126 4177          bra       menu_46
                    4178   menu_26:
                    4179   ; }
                    4180   ; else if( c == (char)(' ')) {             // Next instruction command
00002630  0C02 0020 4181          cmp.b     #32,D2
00002634  6636      4182          bne.s     menu_34
                    4183   ; DisableBreakPoints() ;
00002636  4EB8 1EFC 4184          jsr       _DisableBreakPoints
                    4185   ; if(Trace == 1 && GoFlag == 1)   {    // if the program is running and trace mode on then 'N' is valid
0000263A  2013      4186          move.l    (A3),D0
0000263C  0C80 0000 4187          cmp.l     #1,D0
00002640  0001      
00002642  661A      4188          bne.s     menu_36
00002644  2039 0B00 4189          move.l    _GoFlag.L,D0
00002648  00DC      
0000264A  0C80 0000 4190          cmp.l     #1,D0
0000264E  0001      
00002650  660C      4191          bne.s     menu_36
                    4192   ; TraceException = 1 ;             // generate a trace exception for the next instruction if user wants to single step though next instruction
00002652  13FC 0001 4193          move.b    #1,4194314
00002656  0040 000A 
                    4194   ; return ;
0000265A  6000 00FC 4195          bra       menu_38
                    4196   menu_36:
                    4197   ; }
                    4198   ; else
                    4199   ; printf("\r\nError: Press 'G' first to start program") ;
0000265E  4879 0000 4200          pea       @m68kde~1_115.L
00002662  4B80      
00002664  4E92      4201          jsr       (A2)
00002666  584F      4202          addq.w    #4,A7
00002668  6000 00EA 4203          bra       menu_46
                    4204   menu_34:
                    4205   ; }
                    4206   ; else if( c == (char)('S')) {             // single step
0000266C  0C02 0053 4207          cmp.b     #83,D2
00002670  6600 008C 4208          bne       menu_39
                    4209   ; if(Trace == 0) {
00002674  2013      4210          move.l    (A3),D0
00002676  6600 0050 4211          bne       menu_41
                    4212   ; DisableBreakPoints() ;
0000267A  4EB8 1EFC 4213          jsr       _DisableBreakPoints
                    4214   ; printf("\r\nSingle Step  :[ON]") ;
0000267E  4879 0000 4215          pea       @m68kde~1_116.L
00002682  4BAA      
00002684  4E92      4216          jsr       (A2)
00002686  584F      4217          addq.w    #4,A7
                    4218   ; printf("\r\nBreak Points :[Disabled]") ;
00002688  4879 0000 4219          pea       @m68kde~1_49.L
0000268C  4248      
0000268E  4E92      4220          jsr       (A2)
00002690  584F      4221          addq.w    #4,A7
                    4222   ; SR = SR | (unsigned short int)(0x8000) ;    // set T bit in status register
00002692  0055 8000 4223          or.w      #32768,(A5)
                    4224   ; printf("\r\nPress 'G' to Trace Program from address $%X.....",PC) ;
00002696  2F39 0B00 4225          move.l    _PC.L,-(A7)
0000269A  0120      
0000269C  4879 0000 4226          pea       @m68kde~1_117.L
000026A0  4BC0      
000026A2  4E92      4227          jsr       (A2)
000026A4  504F      4228          addq.w    #8,A7
                    4229   ; printf("\r\nPush <RESET Button> to Stop.....") ;
000026A6  4879 0000 4230          pea       @m68kde~1_118.L
000026AA  4BF4      
000026AC  4E92      4231          jsr       (A2)
000026AE  584F      4232          addq.w    #4,A7
                    4233   ; DumpRegisters() ;
000026B0  4EB8 1452 4234          jsr       _DumpRegisters
                    4235   ; Trace = 1;
000026B4  26BC 0000 4236          move.l    #1,(A3)
000026B8  0001      
                    4237   ; TraceException = 1;
000026BA  13FC 0001 4238          move.b    #1,4194314
000026BE  0040 000A 
                    4239   ; x = *(unsigned int *)(0x00000074) ;       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
000026C2  28B8 0074 4240          move.l    116,(A4)
000026C6  6032      4241          bra.s     menu_42
                    4242   menu_41:
                    4243   ; }
                    4244   ; else {
                    4245   ; Trace = 0 ;
000026C8  4293      4246          clr.l     (A3)
                    4247   ; TraceException = 0 ;
000026CA  4239 0040 4248          clr.b     4194314
000026CE  000A      
                    4249   ; x = *(unsigned int *)(0x00000074) ;       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
000026D0  28B8 0074 4250          move.l    116,(A4)
                    4251   ; EnableBreakPoints() ;
000026D4  4EB8 1F50 4252          jsr       _EnableBreakPoints
                    4253   ; SR = SR & (unsigned short int)(0x7FFF) ;    // clear T bit in status register
000026D8  0255 7FFF 4254          and.w     #32767,(A5)
                    4255   ; printf("\r\nSingle Step : [OFF]") ;
000026DC  4879 0000 4256          pea       @m68kde~1_119.L
000026E0  4C18      
000026E2  4E92      4257          jsr       (A2)
000026E4  584F      4258          addq.w    #4,A7
                    4259   ; printf("\r\nBreak Points :[Enabled]") ;
000026E6  4879 0000 4260          pea       @m68kde~1_120.L
000026EA  4C2E      
000026EC  4E92      4261          jsr       (A2)
000026EE  584F      4262          addq.w    #4,A7
                    4263   ; printf("\r\nPress <ESC> to Resume User Program.....") ;
000026F0  4879 0000 4264          pea       @m68kde~1_121.L
000026F4  4C48      
000026F6  4E92      4265          jsr       (A2)
000026F8  584F      4266          addq.w    #4,A7
                    4267   menu_42:
000026FA  6000 0058 4268          bra       menu_46
                    4269   menu_39:
                    4270   ; }
                    4271   ; }
                    4272   ; else if(c == (char)(0x1b))  {   // if user choses to end trace and run program
000026FE  0C02 001B 4273          cmp.b     #27,D2
00002702  6600 0040 4274          bne       menu_43
                    4275   ; Trace = 0;
00002706  4293      4276          clr.l     (A3)
                    4277   ; TraceException = 0;
00002708  4239 0040 4278          clr.b     4194314
0000270C  000A      
                    4279   ; x = *(unsigned int *)(0x00000074) ;   // read IRQ 5 vector to reset trace vector generator
0000270E  28B8 0074 4280          move.l    116,(A4)
                    4281   ; EnableBreakPoints() ;
00002712  4EB8 1F50 4282          jsr       _EnableBreakPoints
                    4283   ; SR = SR & (unsigned short int)(0x7FFF) ;    // clear T bit in status register
00002716  0255 7FFF 4284          and.w     #32767,(A5)
                    4285   ; printf("\r\nSingle Step  :[OFF]") ;
0000271A  4879 0000 4286          pea       @m68kde~1_122.L
0000271E  4C72      
00002720  4E92      4287          jsr       (A2)
00002722  584F      4288          addq.w    #4,A7
                    4289   ; printf("\r\nBreak Points :[Enabled]");
00002724  4879 0000 4290          pea       @m68kde~1_120.L
00002728  4C2E      
0000272A  4E92      4291          jsr       (A2)
0000272C  584F      4292          addq.w    #4,A7
                    4293   ; printf("\r\nProgram Running.....") ;
0000272E  4879 0000 4294          pea       @m68kde~1_113.L
00002732  4B3A      
00002734  4E92      4295          jsr       (A2)
00002736  584F      4296          addq.w    #4,A7
                    4297   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop") ;
00002738  4879 0000 4298          pea       @m68kde~1_114.L
0000273C  4B52      
0000273E  4E92      4299          jsr       (A2)
00002740  584F      4300          addq.w    #4,A7
                    4301   ; return ;
00002742  6014      4302          bra.s     menu_38
                    4303   menu_43:
                    4304   ; }
                    4305   ; else if( c == (char)('W'))              // Watchpoint command
00002744  0C02 0057 4306          cmp.b     #87,D2
00002748  6606      4307          bne.s     menu_45
                    4308   ; Watchpoint() ;
0000274A  4EB8 2394 4309          jsr       _Watchpoint
0000274E  6004      4310          bra.s     menu_46
                    4311   menu_45:
                    4312   ; else
                    4313   ; UnknownCommand() ;
00002750  4EB8 22EC 4314          jsr       _UnknownCommand
                    4315   menu_46:
00002754  6000 FDB0 4316          bra       menu_1
                    4317   menu_38:
00002758  4CDF 3C0C 4318          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
0000275C  4E75      4319          rts
                    4320   ; }
                    4321   ; }
                    4322   ; void PrintErrorMessageandAbort(char *string) {
                    4323   _PrintErrorMessageandAbort:
0000275E  4E56 0000 4324          link      A6,#0
                    4325   ; printf("\r\n\r\nProgram ABORT !!!!!!\r\n") ;
00002762  4879 0000 4326          pea       @m68kde~1_123.L
00002766  4C88      
00002768  4EB9 0000 4327          jsr       _printf
0000276C  343A      
0000276E  584F      4328          addq.w    #4,A7
                    4329   ; printf("%s\r\n", string) ;
00002770  2F2E 0008 4330          move.l    8(A6),-(A7)
00002774  4879 0000 4331          pea       @m68kde~1_124.L
00002778  4CA4      
0000277A  4EB9 0000 4332          jsr       _printf
0000277E  343A      
00002780  504F      4333          addq.w    #8,A7
                    4334   ; menu() ;
00002782  4EB8 24EA 4335          jsr       _menu
00002786  4E5E      4336          unlk      A6
00002788  4E75      4337          rts
                    4338   ; }
                    4339   ; void IRQMessage(int level) {
                    4340   _IRQMessage:
0000278A  4E56 0000 4341          link      A6,#0
                    4342   ; printf("\r\n\r\nProgram ABORT !!!!!");
0000278E  4879 0000 4343          pea       @m68kde~1_125.L
00002792  4CAA      
00002794  4EB9 0000 4344          jsr       _printf
00002798  343A      
0000279A  584F      4345          addq.w    #4,A7
                    4346   ; printf("\r\nUnhandled Interrupt: IRQ%d !!!!!", level) ;
0000279C  2F2E 0008 4347          move.l    8(A6),-(A7)
000027A0  4879 0000 4348          pea       @m68kde~1_126.L
000027A4  4CC2      
000027A6  4EB9 0000 4349          jsr       _printf
000027AA  343A      
000027AC  504F      4350          addq.w    #8,A7
                    4351   ; menu() ;
000027AE  4EB8 24EA 4352          jsr       _menu
000027B2  4E5E      4353          unlk      A6
000027B4  4E75      4354          rts
                    4355   ; }
                    4356   ; void UnhandledIRQ1(void) {
                    4357   _UnhandledIRQ1:
                    4358   ; IRQMessage(1);
000027B6  4878 0001 4359          pea       1
000027BA  4EB8 278A 4360          jsr       _IRQMessage
000027BE  584F      4361          addq.w    #4,A7
000027C0  4E75      4362          rts
                    4363   ; }
                    4364   ; void UnhandledIRQ2(void) {
                    4365   _UnhandledIRQ2:
                    4366   ; IRQMessage(2);
000027C2  4878 0002 4367          pea       2
000027C6  4EB8 278A 4368          jsr       _IRQMessage
000027CA  584F      4369          addq.w    #4,A7
000027CC  4E75      4370          rts
                    4371   ; }
                    4372   ; void UnhandledIRQ3(void){
                    4373   _UnhandledIRQ3:
                    4374   ; IRQMessage(3);
000027CE  4878 0003 4375          pea       3
000027D2  4EB8 278A 4376          jsr       _IRQMessage
000027D6  584F      4377          addq.w    #4,A7
000027D8  4E75      4378          rts
                    4379   ; }
                    4380   ; void UnhandledIRQ4(void) {
                    4381   _UnhandledIRQ4:
                    4382   ; IRQMessage(4);
000027DA  4878 0004 4383          pea       4
000027DE  4EB8 278A 4384          jsr       _IRQMessage
000027E2  584F      4385          addq.w    #4,A7
000027E4  4E75      4386          rts
                    4387   ; }
                    4388   ; void UnhandledIRQ5(void) {
                    4389   _UnhandledIRQ5:
                    4390   ; IRQMessage(5);
000027E6  4878 0005 4391          pea       5
000027EA  4EB8 278A 4392          jsr       _IRQMessage
000027EE  584F      4393          addq.w    #4,A7
000027F0  4E75      4394          rts
                    4395   ; }
                    4396   ; void UnhandledIRQ6(void) {
                    4397   _UnhandledIRQ6:
                    4398   ; PrintErrorMessageandAbort("ADDRESS ERROR: 16 or 32 Bit Transfer to/from an ODD Address....") ;
000027F2  4879 0000 4399          pea       @m68kde~1_127.L
000027F6  4CE6      
000027F8  4EB8 275E 4400          jsr       _PrintErrorMessageandAbort
000027FC  584F      4401          addq.w    #4,A7
                    4402   ; menu() ;
000027FE  4EB8 24EA 4403          jsr       _menu
00002802  4E75      4404          rts
                    4405   ; }
                    4406   ; void UnhandledIRQ7(void) {
                    4407   _UnhandledIRQ7:
                    4408   ; IRQMessage(7);
00002804  4878 0007 4409          pea       7
00002808  4EB8 278A 4410          jsr       _IRQMessage
0000280C  584F      4411          addq.w    #4,A7
0000280E  4E75      4412          rts
                    4413   ; }
                    4414   ; void UnhandledTrap(void) {
                    4415   _UnhandledTrap:
                    4416   ; PrintErrorMessageandAbort("Unhandled Trap !!!!!") ;
00002810  4879 0000 4417          pea       @m68kde~1_128.L
00002814  4D26      
00002816  4EB8 275E 4418          jsr       _PrintErrorMessageandAbort
0000281A  584F      4419          addq.w    #4,A7
0000281C  4E75      4420          rts
                    4421   ; }
                    4422   ; void BusError() {
                    4423   _BusError:
                    4424   ; PrintErrorMessageandAbort("BUS Error!") ;
0000281E  4879 0000 4425          pea       @m68kde~1_129.L
00002822  4D3C      
00002824  4EB8 275E 4426          jsr       _PrintErrorMessageandAbort
00002828  584F      4427          addq.w    #4,A7
0000282A  4E75      4428          rts
                    4429   ; }
                    4430   ; void AddressError() {
                    4431   _AddressError:
                    4432   ; PrintErrorMessageandAbort("ADDRESS Error!") ;
0000282C  4879 0000 4433          pea       @m68kde~1_130.L
00002830  4D48      
00002832  4EB8 275E 4434          jsr       _PrintErrorMessageandAbort
00002836  584F      4435          addq.w    #4,A7
00002838  4E75      4436          rts
                    4437   ; }
                    4438   ; void IllegalInstruction() {
                    4439   _IllegalInstruction:
                    4440   ; PrintErrorMessageandAbort("ILLEGAL INSTRUCTION") ;
0000283A  4879 0000 4441          pea       @m68kde~1_131.L
0000283E  4D58      
00002840  4EB8 275E 4442          jsr       _PrintErrorMessageandAbort
00002844  584F      4443          addq.w    #4,A7
00002846  4E75      4444          rts
                    4445   ; }
                    4446   ; void Dividebyzero() {
                    4447   _Dividebyzero:
                    4448   ; PrintErrorMessageandAbort("DIVIDE BY ZERO") ;
00002848  4879 0000 4449          pea       @m68kde~1_132.L
0000284C  4D6C      
0000284E  4EB8 275E 4450          jsr       _PrintErrorMessageandAbort
00002852  584F      4451          addq.w    #4,A7
00002854  4E75      4452          rts
                    4453   ; }
                    4454   ; void Check() {
                    4455   _Check:
                    4456   ; PrintErrorMessageandAbort("'CHK' INSTRUCTION") ;
00002856  4879 0000 4457          pea       @m68kde~1_133.L
0000285A  4D7C      
0000285C  4EB8 275E 4458          jsr       _PrintErrorMessageandAbort
00002860  584F      4459          addq.w    #4,A7
00002862  4E75      4460          rts
                    4461   ; }
                    4462   ; void Trapv() {
                    4463   _Trapv:
                    4464   ; PrintErrorMessageandAbort("TRAPV INSTRUCTION") ;
00002864  4879 0000 4465          pea       @m68kde~1_134.L
00002868  4D8E      
0000286A  4EB8 275E 4466          jsr       _PrintErrorMessageandAbort
0000286E  584F      4467          addq.w    #4,A7
00002870  4E75      4468          rts
                    4469   ; }
                    4470   ; void PrivError() {
                    4471   _PrivError:
                    4472   ; PrintErrorMessageandAbort("PRIVILEGE VIOLATION") ;
00002872  4879 0000 4473          pea       @m68kde~1_135.L
00002876  4DA0      
00002878  4EB8 275E 4474          jsr       _PrintErrorMessageandAbort
0000287C  584F      4475          addq.w    #4,A7
0000287E  4E75      4476          rts
                    4477   ; }
                    4478   ; void UnitIRQ() {
                    4479   _UnitIRQ:
                    4480   ; PrintErrorMessageandAbort("UNINITIALISED IRQ") ;
00002880  4879 0000 4481          pea       @m68kde~1_136.L
00002884  4DB4      
00002886  4EB8 275E 4482          jsr       _PrintErrorMessageandAbort
0000288A  584F      4483          addq.w    #4,A7
0000288C  4E75      4484          rts
                    4485   ; }
                    4486   ; void Spurious() {
                    4487   _Spurious:
                    4488   ; PrintErrorMessageandAbort("SPURIOUS IRQ") ;
0000288E  4879 0000 4489          pea       @m68kde~1_137.L
00002892  4DC6      
00002894  4EB8 275E 4490          jsr       _PrintErrorMessageandAbort
00002898  584F      4491          addq.w    #4,A7
0000289A  4E75      4492          rts
                    4493   ; }
                    4494   ; void EnterString(void)
                    4495   ; {
                    4496   _EnterString:
0000289C  4E56 FFFC 4497          link      A6,#-4
000028A0  2F02      4498          move.l    D2,-(A7)
                    4499   ; unsigned char *Start;
                    4500   ; unsigned char c;
                    4501   ; printf("\r\nStart Address in Memory: ") ;
000028A2  4879 0000 4502          pea       @m68kde~1_138.L
000028A6  4DD4      
000028A8  4EB9 0000 4503          jsr       _printf
000028AC  343A      
000028AE  584F      4504          addq.w    #4,A7
                    4505   ; Start = Get8HexDigits(0) ;
000028B0  42A7      4506          clr.l     -(A7)
000028B2  4EB8 0CDE 4507          jsr       _Get8HexDigits
000028B6  584F      4508          addq.w    #4,A7
000028B8  2400      4509          move.l    D0,D2
                    4510   ; printf("\r\nEnter String (ESC to end) :") ;
000028BA  4879 0000 4511          pea       @m68kde~1_139.L
000028BE  4DF0      
000028C0  4EB9 0000 4512          jsr       _printf
000028C4  343A      
000028C6  584F      4513          addq.w    #4,A7
                    4514   ; while((c = getchar()) != 0x1b)
                    4515   EnterString_1:
000028C8  4EB9 0000 4516          jsr       _getch
000028CC  335C      
000028CE  1D40 FFFF 4517          move.b    D0,-1(A6)
000028D2  0C00 001B 4518          cmp.b     #27,D0
000028D6  670A      4519          beq.s     EnterString_3
                    4520   ; *Start++ = c ;
000028D8  2042      4521          move.l    D2,A0
000028DA  5282      4522          addq.l    #1,D2
000028DC  10AE FFFF 4523          move.b    -1(A6),(A0)
000028E0  60E6      4524          bra       EnterString_1
                    4525   EnterString_3:
                    4526   ; *Start = 0x00;  // terminate with a null
000028E2  2042      4527          move.l    D2,A0
000028E4  4210      4528          clr.b     (A0)
000028E6  241F      4529          move.l    (A7)+,D2
000028E8  4E5E      4530          unlk      A6
000028EA  4E75      4531          rts
                    4532   ; }
                    4533   ; // Returning an array containing the start and the end address of the test (two hex numbers)
                    4534   ; void ask_addr_range_sram (unsigned int* addr_array, int data_length) {
                    4535   _ask_addr_range_sram:
000028EC  4E56 0000 4536          link      A6,#0
000028F0  48E7 3820 4537          movem.l   D2/D3/D4/A2,-(A7)
000028F4  45F9 0000 4538          lea       _printf.L,A2
000028F8  343A      
000028FA  242E 0008 4539          move.l    8(A6),D2
                    4540   ; int start_addr_valid = 0;
000028FE  4284      4541          clr.l     D4
                    4542   ; int end_addr_valid = 0;
00002900  4283      4543          clr.l     D3
                    4544   ; while (!start_addr_valid) {
                    4545   ask_addr_range_sram_1:
00002902  4A84      4546          tst.l     D4
00002904  6600 008C 4547          bne       ask_addr_range_sram_3
                    4548   ; printf("\r\nProvide the start address of the test.\n");
00002908  4879 0000 4549          pea       @m68kde~1_140.L
0000290C  4E0E      
0000290E  4E92      4550          jsr       (A2)
00002910  584F      4551          addq.w    #4,A7
                    4552   ; //scanf("%x", addr_array);
                    4553   ; addr_array[0] = Get8HexDigits(0);
00002912  42A7      4554          clr.l     -(A7)
00002914  4EB8 0CDE 4555          jsr       _Get8HexDigits
00002918  584F      4556          addq.w    #4,A7
0000291A  2042      4557          move.l    D2,A0
0000291C  2080      4558          move.l    D0,(A0)
                    4559   ; if (addr_array[0] < 4026531840) {
0000291E  2042      4560          move.l    D2,A0
00002920  2010      4561          move.l    (A0),D0
00002922  0C80 F000 4562          cmp.l     #-268435456,D0
00002926  0000      
00002928  640E      4563          bhs.s     ask_addr_range_sram_4
                    4564   ; printf ("The start address is smaller than 0xf0000000, invalid!\n");
0000292A  4879 0000 4565          pea       @m68kde~1_141.L
0000292E  4E38      
00002930  4E92      4566          jsr       (A2)
00002932  584F      4567          addq.w    #4,A7
00002934  6000 0058 4568          bra       ask_addr_range_sram_9
                    4569   ask_addr_range_sram_4:
                    4570   ; } else if (addr_array[0] > 4026793983) {
00002938  2042      4571          move.l    D2,A0
0000293A  2010      4572          move.l    (A0),D0
0000293C  0C80 F003 4573          cmp.l     #-268173313,D0
00002940  FFFF      
00002942  630E      4574          bls.s     ask_addr_range_sram_6
                    4575   ; printf ("The start address is bigger than 0xf003ffff, invalid!\n");
00002944  4879 0000 4576          pea       @m68kde~1_142.L
00002948  4E70      
0000294A  4E92      4577          jsr       (A2)
0000294C  584F      4578          addq.w    #4,A7
0000294E  6000 003E 4579          bra       ask_addr_range_sram_9
                    4580   ask_addr_range_sram_6:
                    4581   ; } else { // If the data length is words or long words, check whether the start address is odd 
                    4582   ; if (data_length > 1 && addr_array[0] % 2 != 0) {
00002952  202E 000C 4583          move.l    12(A6),D0
00002956  0C80 0000 4584          cmp.l     #1,D0
0000295A  0001      
0000295C  6F24      4585          ble.s     ask_addr_range_sram_8
0000295E  2042      4586          move.l    D2,A0
00002960  2F10      4587          move.l    (A0),-(A7)
00002962  4878 0002 4588          pea       2
00002966  4EB9 0000 4589          jsr       ULDIV
0000296A  324E      
0000296C  202F 0004 4590          move.l    4(A7),D0
00002970  504F      4591          addq.w    #8,A7
00002972  4A80      4592          tst.l     D0
00002974  670C      4593          beq.s     ask_addr_range_sram_8
                    4594   ; printf("The start address provided is odd, need an even one!\n");
00002976  4879 0000 4595          pea       @m68kde~1_143.L
0000297A  4EA8      
0000297C  4E92      4596          jsr       (A2)
0000297E  584F      4597          addq.w    #4,A7
00002980  600C      4598          bra.s     ask_addr_range_sram_9
                    4599   ask_addr_range_sram_8:
                    4600   ; } else {
                    4601   ; printf ("Start address valid.\n");
00002982  4879 0000 4602          pea       @m68kde~1_144.L
00002986  4EDE      
00002988  4E92      4603          jsr       (A2)
0000298A  584F      4604          addq.w    #4,A7
                    4605   ; start_addr_valid = 1;
0000298C  7801      4606          moveq     #1,D4
                    4607   ask_addr_range_sram_9:
0000298E  6000 FF72 4608          bra       ask_addr_range_sram_1
                    4609   ask_addr_range_sram_3:
                    4610   ; } 
                    4611   ; }
                    4612   ; }
                    4613   ; while (!end_addr_valid) {
                    4614   ask_addr_range_sram_10:
00002992  4A83      4615          tst.l     D3
00002994  6600 0094 4616          bne       ask_addr_range_sram_12
                    4617   ; printf("\r\nProvide the end address of the test.\n");
00002998  4879 0000 4618          pea       @m68kde~1_145.L
0000299C  4EF4      
0000299E  4E92      4619          jsr       (A2)
000029A0  584F      4620          addq.w    #4,A7
                    4621   ; //scanf("%x", addr_array+1);
                    4622   ; addr_array[1] = Get8HexDigits(0);
000029A2  42A7      4623          clr.l     -(A7)
000029A4  4EB8 0CDE 4624          jsr       _Get8HexDigits
000029A8  584F      4625          addq.w    #4,A7
000029AA  2042      4626          move.l    D2,A0
000029AC  2140 0004 4627          move.l    D0,4(A0)
                    4628   ; if (addr_array[1] < 4026531840) {
000029B0  2042      4629          move.l    D2,A0
000029B2  2028 0004 4630          move.l    4(A0),D0
000029B6  0C80 F000 4631          cmp.l     #-268435456,D0
000029BA  0000      
000029BC  640E      4632          bhs.s     ask_addr_range_sram_13
                    4633   ; printf ("The end address is smaller than 0xf0000000, invalid!\n");
000029BE  4879 0000 4634          pea       @m68kde~1_146.L
000029C2  4F1C      
000029C4  4E92      4635          jsr       (A2)
000029C6  584F      4636          addq.w    #4,A7
000029C8  6000 005C 4637          bra       ask_addr_range_sram_18
                    4638   ask_addr_range_sram_13:
                    4639   ; } else if (addr_array[1] > 4026793983)
000029CC  2042      4640          move.l    D2,A0
000029CE  2028 0004 4641          move.l    4(A0),D0
000029D2  0C80 F003 4642          cmp.l     #-268173313,D0
000029D6  FFFF      
000029D8  630E      4643          bls.s     ask_addr_range_sram_15
                    4644   ; {
                    4645   ; printf ("The end address is bigger than 0xf003ffff, invalid!\n");
000029DA  4879 0000 4646          pea       @m68kde~1_147.L
000029DE  4F52      
000029E0  4E92      4647          jsr       (A2)
000029E2  584F      4648          addq.w    #4,A7
000029E4  6000 0040 4649          bra       ask_addr_range_sram_18
                    4650   ask_addr_range_sram_15:
                    4651   ; } else { 
                    4652   ; if (data_length > 1 && addr_array[1] % 2 != 0) {
000029E8  202E 000C 4653          move.l    12(A6),D0
000029EC  0C80 0000 4654          cmp.l     #1,D0
000029F0  0001      
000029F2  6F26      4655          ble.s     ask_addr_range_sram_17
000029F4  2042      4656          move.l    D2,A0
000029F6  2F28 0004 4657          move.l    4(A0),-(A7)
000029FA  4878 0002 4658          pea       2
000029FE  4EB9 0000 4659          jsr       ULDIV
00002A02  324E      
00002A04  202F 0004 4660          move.l    4(A7),D0
00002A08  504F      4661          addq.w    #8,A7
00002A0A  4A80      4662          tst.l     D0
00002A0C  670C      4663          beq.s     ask_addr_range_sram_17
                    4664   ; printf("The end address provided is odd, need an even one!\n");
00002A0E  4879 0000 4665          pea       @m68kde~1_148.L
00002A12  4F88      
00002A14  4E92      4666          jsr       (A2)
00002A16  584F      4667          addq.w    #4,A7
00002A18  600C      4668          bra.s     ask_addr_range_sram_18
                    4669   ask_addr_range_sram_17:
                    4670   ; } else {
                    4671   ; printf ("End address valid.\n");
00002A1A  4879 0000 4672          pea       @m68kde~1_149.L
00002A1E  4FBC      
00002A20  4E92      4673          jsr       (A2)
00002A22  584F      4674          addq.w    #4,A7
                    4675   ; end_addr_valid = 1;
00002A24  7601      4676          moveq     #1,D3
                    4677   ask_addr_range_sram_18:
00002A26  6000 FF6A 4678          bra       ask_addr_range_sram_10
                    4679   ask_addr_range_sram_12:
00002A2A  4CDF 041C 4680          movem.l   (A7)+,D2/D3/D4/A2
00002A2E  4E5E      4681          unlk      A6
00002A30  4E75      4682          rts
                    4683   ; } 
                    4684   ; }
                    4685   ; }
                    4686   ; }
                    4687   ; void ask_addr_range_sdram(unsigned int* addr_array, int data_length) {
                    4688   _ask_addr_range_sdram:
00002A32  4E56 0000 4689          link      A6,#0
00002A36  48E7 3820 4690          movem.l   D2/D3/D4/A2,-(A7)
00002A3A  45F9 0000 4691          lea       _printf.L,A2
00002A3E  343A      
00002A40  242E 0008 4692          move.l    8(A6),D2
                    4693   ; int start_addr_valid = 0;
00002A44  4284      4694          clr.l     D4
                    4695   ; int end_addr_valid = 0;
00002A46  4283      4696          clr.l     D3
                    4697   ; while (!start_addr_valid) {
                    4698   ask_addr_range_sdram_1:
00002A48  4A84      4699          tst.l     D4
00002A4A  6600 008C 4700          bne       ask_addr_range_sdram_3
                    4701   ; printf("\r\nProvide the start address of the test.\n");
00002A4E  4879 0000 4702          pea       @m68kde~1_140.L
00002A52  4E0E      
00002A54  4E92      4703          jsr       (A2)
00002A56  584F      4704          addq.w    #4,A7
                    4705   ; //scanf("%x", addr_array);
                    4706   ; addr_array[0] = Get8HexDigits(0);
00002A58  42A7      4707          clr.l     -(A7)
00002A5A  4EB8 0CDE 4708          jsr       _Get8HexDigits
00002A5E  584F      4709          addq.w    #4,A7
00002A60  2042      4710          move.l    D2,A0
00002A62  2080      4711          move.l    D0,(A0)
                    4712   ; if (addr_array[0] < 134217728) {
00002A64  2042      4713          move.l    D2,A0
00002A66  2010      4714          move.l    (A0),D0
00002A68  0C80 0800 4715          cmp.l     #134217728,D0
00002A6C  0000      
00002A6E  640E      4716          bhs.s     ask_addr_range_sdram_4
                    4717   ; printf ("The start address is smaller than 0x08000000, invalid!\n");
00002A70  4879 0000 4718          pea       @m68kde~1_150.L
00002A74  4FD0      
00002A76  4E92      4719          jsr       (A2)
00002A78  584F      4720          addq.w    #4,A7
00002A7A  6000 0058 4721          bra       ask_addr_range_sdram_9
                    4722   ask_addr_range_sdram_4:
                    4723   ; } else if (addr_array[0] > 201326591) {
00002A7E  2042      4724          move.l    D2,A0
00002A80  2010      4725          move.l    (A0),D0
00002A82  0C80 0BFF 4726          cmp.l     #201326591,D0
00002A86  FFFF      
00002A88  630E      4727          bls.s     ask_addr_range_sdram_6
                    4728   ; printf ("The start address is bigger than 0x0bffffff, invalid!\n");
00002A8A  4879 0000 4729          pea       @m68kde~1_151.L
00002A8E  5008      
00002A90  4E92      4730          jsr       (A2)
00002A92  584F      4731          addq.w    #4,A7
00002A94  6000 003E 4732          bra       ask_addr_range_sdram_9
                    4733   ask_addr_range_sdram_6:
                    4734   ; } else { // If the data length is words or long words, check whether the start address is odd 
                    4735   ; if (data_length > 1 && addr_array[0] % 2 != 0) {
00002A98  202E 000C 4736          move.l    12(A6),D0
00002A9C  0C80 0000 4737          cmp.l     #1,D0
00002AA0  0001      
00002AA2  6F24      4738          ble.s     ask_addr_range_sdram_8
00002AA4  2042      4739          move.l    D2,A0
00002AA6  2F10      4740          move.l    (A0),-(A7)
00002AA8  4878 0002 4741          pea       2
00002AAC  4EB9 0000 4742          jsr       ULDIV
00002AB0  324E      
00002AB2  202F 0004 4743          move.l    4(A7),D0
00002AB6  504F      4744          addq.w    #8,A7
00002AB8  4A80      4745          tst.l     D0
00002ABA  670C      4746          beq.s     ask_addr_range_sdram_8
                    4747   ; printf("The start address provided is odd, need an even one!\n");
00002ABC  4879 0000 4748          pea       @m68kde~1_143.L
00002AC0  4EA8      
00002AC2  4E92      4749          jsr       (A2)
00002AC4  584F      4750          addq.w    #4,A7
00002AC6  600C      4751          bra.s     ask_addr_range_sdram_9
                    4752   ask_addr_range_sdram_8:
                    4753   ; } else {
                    4754   ; printf ("Start address valid.\n");
00002AC8  4879 0000 4755          pea       @m68kde~1_144.L
00002ACC  4EDE      
00002ACE  4E92      4756          jsr       (A2)
00002AD0  584F      4757          addq.w    #4,A7
                    4758   ; start_addr_valid = 1;
00002AD2  7801      4759          moveq     #1,D4
                    4760   ask_addr_range_sdram_9:
00002AD4  6000 FF72 4761          bra       ask_addr_range_sdram_1
                    4762   ask_addr_range_sdram_3:
                    4763   ; } 
                    4764   ; }
                    4765   ; }
                    4766   ; while (!end_addr_valid) {
                    4767   ask_addr_range_sdram_10:
00002AD8  4A83      4768          tst.l     D3
00002ADA  6600 0094 4769          bne       ask_addr_range_sdram_12
                    4770   ; printf("\r\nProvide the end address of the test.\n");
00002ADE  4879 0000 4771          pea       @m68kde~1_145.L
00002AE2  4EF4      
00002AE4  4E92      4772          jsr       (A2)
00002AE6  584F      4773          addq.w    #4,A7
                    4774   ; //scanf("%x", addr_array+1);
                    4775   ; addr_array[1] = Get8HexDigits(0);
00002AE8  42A7      4776          clr.l     -(A7)
00002AEA  4EB8 0CDE 4777          jsr       _Get8HexDigits
00002AEE  584F      4778          addq.w    #4,A7
00002AF0  2042      4779          move.l    D2,A0
00002AF2  2140 0004 4780          move.l    D0,4(A0)
                    4781   ; if (addr_array[1] < 134217728) {
00002AF6  2042      4782          move.l    D2,A0
00002AF8  2028 0004 4783          move.l    4(A0),D0
00002AFC  0C80 0800 4784          cmp.l     #134217728,D0
00002B00  0000      
00002B02  640E      4785          bhs.s     ask_addr_range_sdram_13
                    4786   ; printf ("The end address is smaller than 0x08000000, invalid!\n");
00002B04  4879 0000 4787          pea       @m68kde~1_152.L
00002B08  5040      
00002B0A  4E92      4788          jsr       (A2)
00002B0C  584F      4789          addq.w    #4,A7
00002B0E  6000 005C 4790          bra       ask_addr_range_sdram_18
                    4791   ask_addr_range_sdram_13:
                    4792   ; } else if (addr_array[1] > 201326591)
00002B12  2042      4793          move.l    D2,A0
00002B14  2028 0004 4794          move.l    4(A0),D0
00002B18  0C80 0BFF 4795          cmp.l     #201326591,D0
00002B1C  FFFF      
00002B1E  630E      4796          bls.s     ask_addr_range_sdram_15
                    4797   ; {
                    4798   ; printf ("The end address is bigger than 0x0bffffff, invalid!\n");
00002B20  4879 0000 4799          pea       @m68kde~1_153.L
00002B24  5076      
00002B26  4E92      4800          jsr       (A2)
00002B28  584F      4801          addq.w    #4,A7
00002B2A  6000 0040 4802          bra       ask_addr_range_sdram_18
                    4803   ask_addr_range_sdram_15:
                    4804   ; } else { 
                    4805   ; if (data_length > 1 && addr_array[1] % 2 != 0) {
00002B2E  202E 000C 4806          move.l    12(A6),D0
00002B32  0C80 0000 4807          cmp.l     #1,D0
00002B36  0001      
00002B38  6F26      4808          ble.s     ask_addr_range_sdram_17
00002B3A  2042      4809          move.l    D2,A0
00002B3C  2F28 0004 4810          move.l    4(A0),-(A7)
00002B40  4878 0002 4811          pea       2
00002B44  4EB9 0000 4812          jsr       ULDIV
00002B48  324E      
00002B4A  202F 0004 4813          move.l    4(A7),D0
00002B4E  504F      4814          addq.w    #8,A7
00002B50  4A80      4815          tst.l     D0
00002B52  670C      4816          beq.s     ask_addr_range_sdram_17
                    4817   ; printf("The end address provided is odd, need an even one!\n");
00002B54  4879 0000 4818          pea       @m68kde~1_148.L
00002B58  4F88      
00002B5A  4E92      4819          jsr       (A2)
00002B5C  584F      4820          addq.w    #4,A7
00002B5E  600C      4821          bra.s     ask_addr_range_sdram_18
                    4822   ask_addr_range_sdram_17:
                    4823   ; } else {
                    4824   ; printf ("End address valid.\n");
00002B60  4879 0000 4825          pea       @m68kde~1_149.L
00002B64  4FBC      
00002B66  4E92      4826          jsr       (A2)
00002B68  584F      4827          addq.w    #4,A7
                    4828   ; end_addr_valid = 1;
00002B6A  7601      4829          moveq     #1,D3
                    4830   ask_addr_range_sdram_18:
00002B6C  6000 FF6A 4831          bra       ask_addr_range_sdram_10
                    4832   ask_addr_range_sdram_12:
00002B70  4CDF 041C 4833          movem.l   (A7)+,D2/D3/D4/A2
00002B74  4E5E      4834          unlk      A6
00002B76  4E75      4835          rts
                    4836   ; } 
                    4837   ; }
                    4838   ; }
                    4839   ; }
                    4840   ; // Return the byte data with the correct pattern
                    4841   ; unsigned char byte_data (int data_pattern){
                    4842   _byte_data:
00002B78  4E56 0000 4843          link      A6,#0
00002B7C  2F02      4844          move.l    D2,-(A7)
00002B7E  242E 0008 4845          move.l    8(A6),D2
                    4846   ; if (data_pattern == 1) {
00002B82  0C82 0000 4847          cmp.l     #1,D2
00002B86  0001      
00002B88  6604      4848          bne.s     byte_data_1
                    4849   ; return 0;
00002B8A  4200      4850          clr.b     D0
00002B8C  602A      4851          bra.s     byte_data_8
                    4852   byte_data_1:
                    4853   ; } else if (data_pattern == 2) {
00002B8E  0C82 0000 4854          cmp.l     #2,D2
00002B92  0002      
00002B94  6604      4855          bne.s     byte_data_4
                    4856   ; return 0x55;
00002B96  7055      4857          moveq     #85,D0
00002B98  601E      4858          bra.s     byte_data_8
                    4859   byte_data_4:
                    4860   ; } else if (data_pattern == 3) {
00002B9A  0C82 0000 4861          cmp.l     #3,D2
00002B9E  0003      
00002BA0  6606      4862          bne.s     byte_data_6
                    4863   ; return 0xaa;
00002BA2  103C 00AA 4864          move.b    #170,D0
00002BA6  6010      4865          bra.s     byte_data_8
                    4866   byte_data_6:
                    4867   ; } else if (data_pattern == 4) {
00002BA8  0C82 0000 4868          cmp.l     #4,D2
00002BAC  0004      
00002BAE  6608      4869          bne.s     byte_data_8
                    4870   ; return 0xff;
00002BB0  103C 00FF 4871          move.b    #255,D0
00002BB4  6000 0002 4872          bra       byte_data_8
                    4873   byte_data_8:
00002BB8  241F      4874          move.l    (A7)+,D2
00002BBA  4E5E      4875          unlk      A6
00002BBC  4E75      4876          rts
                    4877   ; } 
                    4878   ; }
                    4879   ; // Return the word data (16 bits) with the correct pattern
                    4880   ; unsigned short word_data (int data_pattern){
                    4881   _word_data:
00002BBE  4E56 0000 4882          link      A6,#0
00002BC2  2F02      4883          move.l    D2,-(A7)
00002BC4  242E 0008 4884          move.l    8(A6),D2
                    4885   ; if (data_pattern == 1) {
00002BC8  0C82 0000 4886          cmp.l     #1,D2
00002BCC  0001      
00002BCE  6604      4887          bne.s     word_data_1
                    4888   ; return 0;
00002BD0  4240      4889          clr.w     D0
00002BD2  602C      4890          bra.s     word_data_8
                    4891   word_data_1:
                    4892   ; } else if (data_pattern == 2) {
00002BD4  0C82 0000 4893          cmp.l     #2,D2
00002BD8  0002      
00002BDA  6606      4894          bne.s     word_data_4
                    4895   ; return 0x5555;
00002BDC  303C 5555 4896          move.w    #21845,D0
00002BE0  601E      4897          bra.s     word_data_8
                    4898   word_data_4:
                    4899   ; } else if (data_pattern == 3) {
00002BE2  0C82 0000 4900          cmp.l     #3,D2
00002BE6  0003      
00002BE8  6606      4901          bne.s     word_data_6
                    4902   ; return 0xaaaa;
00002BEA  303C AAAA 4903          move.w    #43690,D0
00002BEE  6010      4904          bra.s     word_data_8
                    4905   word_data_6:
                    4906   ; } else if (data_pattern == 4) {
00002BF0  0C82 0000 4907          cmp.l     #4,D2
00002BF4  0004      
00002BF6  6608      4908          bne.s     word_data_8
                    4909   ; return 0xffff;
00002BF8  303C FFFF 4910          move.w    #65535,D0
00002BFC  6000 0002 4911          bra       word_data_8
                    4912   word_data_8:
00002C00  241F      4913          move.l    (A7)+,D2
00002C02  4E5E      4914          unlk      A6
00002C04  4E75      4915          rts
                    4916   ; } 
                    4917   ; }
                    4918   ; // Return the long word data (32 bits) with the correct pattern
                    4919   ; unsigned int long_word_data (int data_pattern){
                    4920   _long_word_data:
00002C06  4E56 0000 4921          link      A6,#0
00002C0A  2F02      4922          move.l    D2,-(A7)
00002C0C  242E 0008 4923          move.l    8(A6),D2
                    4924   ; if (data_pattern == 1) {
00002C10  0C82 0000 4925          cmp.l     #1,D2
00002C14  0001      
00002C16  6604      4926          bne.s     long_word_data_1
                    4927   ; return 0;
00002C18  4280      4928          clr.l     D0
00002C1A  602E      4929          bra.s     long_word_data_8
                    4930   long_word_data_1:
                    4931   ; } else if (data_pattern == 2) {
00002C1C  0C82 0000 4932          cmp.l     #2,D2
00002C20  0002      
00002C22  6608      4933          bne.s     long_word_data_4
                    4934   ; return 0x55555555;
00002C24  203C 5555 4935          move.l    #1431655765,D0
00002C28  5555      
00002C2A  601E      4936          bra.s     long_word_data_8
                    4937   long_word_data_4:
                    4938   ; } else if (data_pattern == 3) {
00002C2C  0C82 0000 4939          cmp.l     #3,D2
00002C30  0003      
00002C32  6608      4940          bne.s     long_word_data_6
                    4941   ; return 0xaaaaaaaa;
00002C34  203C AAAA 4942          move.l    #-1431655766,D0
00002C38  AAAA      
00002C3A  600E      4943          bra.s     long_word_data_8
                    4944   long_word_data_6:
                    4945   ; } else if (data_pattern == 4) {
00002C3C  0C82 0000 4946          cmp.l     #4,D2
00002C40  0004      
00002C42  6606      4947          bne.s     long_word_data_8
                    4948   ; return 0xffffffff;
00002C44  70FF      4949          moveq     #-1,D0
00002C46  6000 0002 4950          bra       long_word_data_8
                    4951   long_word_data_8:
00002C4A  241F      4952          move.l    (A7)+,D2
00002C4C  4E5E      4953          unlk      A6
00002C4E  4E75      4954          rts
                    4955   ; } 
                    4956   ; }
                    4957   ; int byte_test (unsigned char byte, unsigned int* addr_array) {
                    4958   _byte_test:
00002C50  4E56 FFFC 4959          link      A6,#-4
00002C54  48E7 3C00 4960          movem.l   D2/D3/D4/D5,-(A7)
00002C58  1A2E 000B 4961          move.b    11(A6),D5
00002C5C  CABC 0000 4962          and.l     #255,D5
00002C60  00FF      
                    4963   ; unsigned int start_addr = addr_array[0];
00002C62  206E 000C 4964          move.l    12(A6),A0
00002C66  2810      4965          move.l    (A0),D4
                    4966   ; unsigned int end_addr = addr_array[1];
00002C68  206E 000C 4967          move.l    12(A6),A0
00002C6C  2D68 0004 4968          move.l    4(A0),-4(A6)
00002C70  FFFC      
                    4969   ; volatile unsigned char *test_addr = (volatile unsigned char *) start_addr;
00002C72  2404      4970          move.l    D4,D2
                    4971   ; int i;
                    4972   ; for (i = 0; i < (end_addr - start_addr); i ++) {
00002C74  4283      4973          clr.l     D3
                    4974   byte_test_1:
00002C76  202E FFFC 4975          move.l    -4(A6),D0
00002C7A  9084      4976          sub.l     D4,D0
00002C7C  B680      4977          cmp.l     D0,D3
00002C7E  6400 0066 4978          bhs       byte_test_3
                    4979   ; test_addr = start_addr + i; 
00002C82  2004      4980          move.l    D4,D0
00002C84  D083      4981          add.l     D3,D0
00002C86  2400      4982          move.l    D0,D2
                    4983   ; *test_addr = byte;
00002C88  2042      4984          move.l    D2,A0
00002C8A  1085      4985          move.b    D5,(A0)
                    4986   ; if (i % 10000 == 0){
00002C8C  2F03      4987          move.l    D3,-(A7)
00002C8E  4878 2710 4988          pea       10000
00002C92  4EB9 0000 4989          jsr       LDIV
00002C96  3260      
00002C98  202F 0004 4990          move.l    4(A7),D0
00002C9C  504F      4991          addq.w    #8,A7
00002C9E  4A80      4992          tst.l     D0
00002CA0  6626      4993          bne.s     byte_test_4
                    4994   ; printf("Location %x, write data: %x, read data: %x\n", test_addr, byte, *test_addr);
00002CA2  2042      4995          move.l    D2,A0
00002CA4  1210      4996          move.b    (A0),D1
00002CA6  C2BC 0000 4997          and.l     #255,D1
00002CAA  00FF      
00002CAC  2F01      4998          move.l    D1,-(A7)
00002CAE  CABC 0000 4999          and.l     #255,D5
00002CB2  00FF      
00002CB4  2F05      5000          move.l    D5,-(A7)
00002CB6  2F02      5001          move.l    D2,-(A7)
00002CB8  4879 0000 5002          pea       @m68kde~1_154.L
00002CBC  50AC      
00002CBE  4EB9 0000 5003          jsr       _printf
00002CC2  343A      
00002CC4  DEFC 0010 5004          add.w     #16,A7
                    5005   byte_test_4:
                    5006   ; }
                    5007   ; if (*test_addr != byte) {
00002CC8  2042      5008          move.l    D2,A0
00002CCA  BA10      5009          cmp.b     (A0),D5
00002CCC  6714      5010          beq.s     byte_test_6
                    5011   ; printf("Test failed at location %x!\n", test_addr);
00002CCE  2F02      5012          move.l    D2,-(A7)
00002CD0  4879 0000 5013          pea       @m68kde~1_155.L
00002CD4  50D8      
00002CD6  4EB9 0000 5014          jsr       _printf
00002CDA  343A      
00002CDC  504F      5015          addq.w    #8,A7
                    5016   ; return 0;
00002CDE  4280      5017          clr.l     D0
00002CE0  6006      5018          bra.s     byte_test_8
                    5019   byte_test_6:
00002CE2  5283      5020          addq.l    #1,D3
00002CE4  6090      5021          bra       byte_test_1
                    5022   byte_test_3:
                    5023   ; }
                    5024   ; }
                    5025   ; return 1;
00002CE6  7001      5026          moveq     #1,D0
                    5027   byte_test_8:
00002CE8  4CDF 003C 5028          movem.l   (A7)+,D2/D3/D4/D5
00002CEC  4E5E      5029          unlk      A6
00002CEE  4E75      5030          rts
                    5031   ; }
                    5032   ; int word_test (unsigned short word, unsigned int* addr_array) {
                    5033   _word_test:
00002CF0  4E56 FFFC 5034          link      A6,#-4
00002CF4  48E7 3C00 5035          movem.l   D2/D3/D4/D5,-(A7)
00002CF8  3A2E 000A 5036          move.w    10(A6),D5
00002CFC  CABC 0000 5037          and.l     #65535,D5
00002D00  FFFF      
                    5038   ; unsigned int start_addr = addr_array[0];
00002D02  206E 000C 5039          move.l    12(A6),A0
00002D06  2810      5040          move.l    (A0),D4
                    5041   ; unsigned int end_addr = addr_array[1];
00002D08  206E 000C 5042          move.l    12(A6),A0
00002D0C  2D68 0004 5043          move.l    4(A0),-4(A6)
00002D10  FFFC      
                    5044   ; volatile unsigned short *test_addr = (volatile unsigned short *) start_addr;
00002D12  2404      5045          move.l    D4,D2
                    5046   ; int i;
                    5047   ; for (i = 0; i < (end_addr - start_addr); i=i+2) {
00002D14  4283      5048          clr.l     D3
                    5049   word_test_1:
00002D16  202E FFFC 5050          move.l    -4(A6),D0
00002D1A  9084      5051          sub.l     D4,D0
00002D1C  B680      5052          cmp.l     D0,D3
00002D1E  6400 0066 5053          bhs       word_test_3
                    5054   ; test_addr = start_addr + i;
00002D22  2004      5055          move.l    D4,D0
00002D24  D083      5056          add.l     D3,D0
00002D26  2400      5057          move.l    D0,D2
                    5058   ; *test_addr = word;
00002D28  2042      5059          move.l    D2,A0
00002D2A  3085      5060          move.w    D5,(A0)
                    5061   ; if (i % 10000 == 0){
00002D2C  2F03      5062          move.l    D3,-(A7)
00002D2E  4878 2710 5063          pea       10000
00002D32  4EB9 0000 5064          jsr       LDIV
00002D36  3260      
00002D38  202F 0004 5065          move.l    4(A7),D0
00002D3C  504F      5066          addq.w    #8,A7
00002D3E  4A80      5067          tst.l     D0
00002D40  6626      5068          bne.s     word_test_4
                    5069   ; printf("Location %x, write data: %x, read data: %x\n", test_addr, word, *test_addr);
00002D42  2042      5070          move.l    D2,A0
00002D44  3210      5071          move.w    (A0),D1
00002D46  C2BC 0000 5072          and.l     #65535,D1
00002D4A  FFFF      
00002D4C  2F01      5073          move.l    D1,-(A7)
00002D4E  CABC 0000 5074          and.l     #65535,D5
00002D52  FFFF      
00002D54  2F05      5075          move.l    D5,-(A7)
00002D56  2F02      5076          move.l    D2,-(A7)
00002D58  4879 0000 5077          pea       @m68kde~1_154.L
00002D5C  50AC      
00002D5E  4EB9 0000 5078          jsr       _printf
00002D62  343A      
00002D64  DEFC 0010 5079          add.w     #16,A7
                    5080   word_test_4:
                    5081   ; }
                    5082   ; if (*test_addr != word) {
00002D68  2042      5083          move.l    D2,A0
00002D6A  BA50      5084          cmp.w     (A0),D5
00002D6C  6714      5085          beq.s     word_test_6
                    5086   ; printf("Test failed at location %x!\n", test_addr);
00002D6E  2F02      5087          move.l    D2,-(A7)
00002D70  4879 0000 5088          pea       @m68kde~1_155.L
00002D74  50D8      
00002D76  4EB9 0000 5089          jsr       _printf
00002D7A  343A      
00002D7C  504F      5090          addq.w    #8,A7
                    5091   ; return 0;
00002D7E  4280      5092          clr.l     D0
00002D80  6006      5093          bra.s     word_test_8
                    5094   word_test_6:
00002D82  5483      5095          addq.l    #2,D3
00002D84  6090      5096          bra       word_test_1
                    5097   word_test_3:
                    5098   ; }
                    5099   ; }
                    5100   ; return 1;
00002D86  7001      5101          moveq     #1,D0
                    5102   word_test_8:
00002D88  4CDF 003C 5103          movem.l   (A7)+,D2/D3/D4/D5
00002D8C  4E5E      5104          unlk      A6
00002D8E  4E75      5105          rts
                    5106   ; }
                    5107   ; int long_word_test (unsigned int long_word, unsigned int* addr_array) {
                    5108   _long_word_test:
00002D90  4E56 FFFC 5109          link      A6,#-4
00002D94  48E7 3C00 5110          movem.l   D2/D3/D4/D5,-(A7)
00002D98  2A2E 0008 5111          move.l    8(A6),D5
                    5112   ; unsigned int start_addr = addr_array[0];
00002D9C  206E 000C 5113          move.l    12(A6),A0
00002DA0  2810      5114          move.l    (A0),D4
                    5115   ; unsigned int end_addr = addr_array[1];
00002DA2  206E 000C 5116          move.l    12(A6),A0
00002DA6  2D68 0004 5117          move.l    4(A0),-4(A6)
00002DAA  FFFC      
                    5118   ; volatile unsigned int *test_addr = (volatile unsigned int *) start_addr;
00002DAC  2404      5119          move.l    D4,D2
                    5120   ; int i;
                    5121   ; for (i = 0; i < (end_addr - start_addr); i=i+4) {
00002DAE  4283      5122          clr.l     D3
                    5123   long_word_test_1:
00002DB0  202E FFFC 5124          move.l    -4(A6),D0
00002DB4  9084      5125          sub.l     D4,D0
00002DB6  B680      5126          cmp.l     D0,D3
00002DB8  6400 0058 5127          bhs       long_word_test_3
                    5128   ; test_addr = start_addr + i; 
00002DBC  2004      5129          move.l    D4,D0
00002DBE  D083      5130          add.l     D3,D0
00002DC0  2400      5131          move.l    D0,D2
                    5132   ; *test_addr = long_word;
00002DC2  2042      5133          move.l    D2,A0
00002DC4  2085      5134          move.l    D5,(A0)
                    5135   ; if (i % 10000 == 0){
00002DC6  2F03      5136          move.l    D3,-(A7)
00002DC8  4878 2710 5137          pea       10000
00002DCC  4EB9 0000 5138          jsr       LDIV
00002DD0  3260      
00002DD2  202F 0004 5139          move.l    4(A7),D0
00002DD6  504F      5140          addq.w    #8,A7
00002DD8  4A80      5141          tst.l     D0
00002DDA  6618      5142          bne.s     long_word_test_4
                    5143   ; printf("Location %x, write data: %x, read data: %x\n", test_addr, long_word, *test_addr);
00002DDC  2042      5144          move.l    D2,A0
00002DDE  2F10      5145          move.l    (A0),-(A7)
00002DE0  2F05      5146          move.l    D5,-(A7)
00002DE2  2F02      5147          move.l    D2,-(A7)
00002DE4  4879 0000 5148          pea       @m68kde~1_154.L
00002DE8  50AC      
00002DEA  4EB9 0000 5149          jsr       _printf
00002DEE  343A      
00002DF0  DEFC 0010 5150          add.w     #16,A7
                    5151   long_word_test_4:
                    5152   ; }
                    5153   ; if (*test_addr != long_word) {
00002DF4  2042      5154          move.l    D2,A0
00002DF6  BA90      5155          cmp.l     (A0),D5
00002DF8  6714      5156          beq.s     long_word_test_6
                    5157   ; printf("Test failed at location %x!\n", test_addr);
00002DFA  2F02      5158          move.l    D2,-(A7)
00002DFC  4879 0000 5159          pea       @m68kde~1_155.L
00002E00  50D8      
00002E02  4EB9 0000 5160          jsr       _printf
00002E06  343A      
00002E08  504F      5161          addq.w    #8,A7
                    5162   ; return 0;
00002E0A  4280      5163          clr.l     D0
00002E0C  6006      5164          bra.s     long_word_test_8
                    5165   long_word_test_6:
00002E0E  5883      5166          addq.l    #4,D3
00002E10  609E      5167          bra       long_word_test_1
                    5168   long_word_test_3:
                    5169   ; }
                    5170   ; }
                    5171   ; return 1;
00002E12  7001      5172          moveq     #1,D0
                    5173   long_word_test_8:
00002E14  4CDF 003C 5174          movem.l   (A7)+,D2/D3/D4/D5
00002E18  4E5E      5175          unlk      A6
00002E1A  4E75      5176          rts
                    5177   ; }
                    5178   ; void MemoryTest(void)
                    5179   ; {
                    5180   _MemoryTest:
00002E1C  4E56 FFD8 5181          link      A6,#-40
00002E20  48E7 3F3C 5182          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00002E24  45F9 0000 5183          lea       _printf.L,A2
00002E28  343A      
00002E2A  47EE FFF0 5184          lea       -16(A6),A3
00002E2E  4BF8 0C0A 5185          lea       _Get1HexDigits.L,A5
                    5186   ; unsigned int *RamPtr, counter1=1 ;
00002E32  2D7C 0000 5187          move.l    #1,-34(A6)
00002E36  0001 FFDE 
                    5188   ; register unsigned int i ;
                    5189   ; unsigned int Start, End ;
                    5190   ; char c ;
                    5191   ; int data_length;
                    5192   ; int data_pattern;
                    5193   ; int test_type;
                    5194   ; unsigned int addr_array[2];
                    5195   ; unsigned int start_addr, end_addr;
                    5196   ; unsigned char byte;
                    5197   ; unsigned short word;
                    5198   ; unsigned int long_word;
                    5199   ; int result;
                    5200   ; /*printf("\r\nStart Address: ") ;
                    5201   ; Start = Get8HexDigits(0) ;
                    5202   ; printf("\r\nEnd Address: ") ;
                    5203   ; End = Get8HexDigits(0) ;*/
                    5204   ; printf("\r\nDo you want the data to be 1. bytes, 2. words, or 3. long words? Provide the integer below.\n");
00002E3A  4879 0000 5205          pea       @m68kde~1_156.L
00002E3E  50F6      
00002E40  4E92      5206          jsr       (A2)
00002E42  584F      5207          addq.w    #4,A7
                    5208   ; //scanf("%x", &data_length);
                    5209   ; data_length = Get1HexDigits(0);
00002E44  42A7      5210          clr.l     -(A7)
00002E46  4E95      5211          jsr       (A5)
00002E48  584F      5212          addq.w    #4,A7
00002E4A  2400      5213          move.l    D0,D2
                    5214   ; //printf("data_length: %d", data_length);
                    5215   ; printf("\r\nDo you want the data to be composed of (hex) 1. 0, 2. 5, 3. A, or 4. F? Provide the integer below.\n");
00002E4C  4879 0000 5216          pea       @m68kde~1_157.L
00002E50  5156      
00002E52  4E92      5217          jsr       (A2)
00002E54  584F      5218          addq.w    #4,A7
                    5219   ; //scanf("%x", &data_pattern);
                    5220   ; data_pattern = Get1HexDigits(0);
00002E56  42A7      5221          clr.l     -(A7)
00002E58  4E95      5222          jsr       (A5)
00002E5A  584F      5223          addq.w    #4,A7
00002E5C  2800      5224          move.l    D0,D4
                    5225   ; //printf("data_pattern: %d", data_pattern);
                    5226   ; printf("\r\nDo you want to test 1. SRAM or 2. SDRAM? Provide the integer below.\n");
00002E5E  4879 0000 5227          pea       @m68kde~1_158.L
00002E62  51BC      
00002E64  4E92      5228          jsr       (A2)
00002E66  584F      5229          addq.w    #4,A7
                    5230   ; test_type = Get1HexDigits(0);
00002E68  42A7      5231          clr.l     -(A7)
00002E6A  4E95      5232          jsr       (A5)
00002E6C  584F      5233          addq.w    #4,A7
00002E6E  2840      5234          move.l    D0,A4
                    5235   ; if (test_type == 1){
00002E70  200C      5236          move.l    A4,D0
00002E72  0C80 0000 5237          cmp.l     #1,D0
00002E76  0001      
00002E78  660C      5238          bne.s     MemoryTest_1
                    5239   ; ask_addr_range_sram(addr_array, data_length);
00002E7A  2F02      5240          move.l    D2,-(A7)
00002E7C  2F0B      5241          move.l    A3,-(A7)
00002E7E  4EB8 28EC 5242          jsr       _ask_addr_range_sram
00002E82  504F      5243          addq.w    #8,A7
00002E84  6014      5244          bra.s     MemoryTest_3
                    5245   MemoryTest_1:
                    5246   ; } else if (test_type == 2) {
00002E86  200C      5247          move.l    A4,D0
00002E88  0C80 0000 5248          cmp.l     #2,D0
00002E8C  0002      
00002E8E  660A      5249          bne.s     MemoryTest_3
                    5250   ; ask_addr_range_sdram(addr_array, data_length);
00002E90  2F02      5251          move.l    D2,-(A7)
00002E92  2F0B      5252          move.l    A3,-(A7)
00002E94  4EB8 2A32 5253          jsr       _ask_addr_range_sdram
00002E98  504F      5254          addq.w    #8,A7
                    5255   MemoryTest_3:
                    5256   ; }
                    5257   ; start_addr = addr_array[0];
00002E9A  2D53 FFF8 5258          move.l    (A3),-8(A6)
                    5259   ; end_addr = addr_array[1];
00002E9E  2D6B 0004 5260          move.l    4(A3),-4(A6)
00002EA2  FFFC      
                    5261   ; printf("Start address: %x\n", start_addr);
00002EA4  2F2E FFF8 5262          move.l    -8(A6),-(A7)
00002EA8  4879 0000 5263          pea       @m68kde~1_159.L
00002EAC  5204      
00002EAE  4E92      5264          jsr       (A2)
00002EB0  504F      5265          addq.w    #8,A7
                    5266   ; printf("End address: %x\n", end_addr);
00002EB2  2F2E FFFC 5267          move.l    -4(A6),-(A7)
00002EB6  4879 0000 5268          pea       @m68kde~1_160.L
00002EBA  5218      
00002EBC  4E92      5269          jsr       (A2)
00002EBE  504F      5270          addq.w    #8,A7
                    5271   ; if (data_length == 1) {
00002EC0  0C82 0000 5272          cmp.l     #1,D2
00002EC4  0001      
00002EC6  6600 0034 5273          bne       MemoryTest_5
                    5274   ; byte = byte_data (data_pattern);
00002ECA  2F04      5275          move.l    D4,-(A7)
00002ECC  4EB8 2B78 5276          jsr       _byte_data
00002ED0  584F      5277          addq.w    #4,A7
00002ED2  1E00      5278          move.b    D0,D7
                    5279   ; printf ("Test data: %x\n",byte);
00002ED4  CEBC 0000 5280          and.l     #255,D7
00002ED8  00FF      
00002EDA  2F07      5281          move.l    D7,-(A7)
00002EDC  4879 0000 5282          pea       @m68kde~1_161.L
00002EE0  522A      
00002EE2  4E92      5283          jsr       (A2)
00002EE4  504F      5284          addq.w    #8,A7
                    5285   ; result = byte_test(byte, addr_array);
00002EE6  2F0B      5286          move.l    A3,-(A7)
00002EE8  CEBC 0000 5287          and.l     #255,D7
00002EEC  00FF      
00002EEE  2F07      5288          move.l    D7,-(A7)
00002EF0  4EB8 2C50 5289          jsr       _byte_test
00002EF4  504F      5290          addq.w    #8,A7
00002EF6  2600      5291          move.l    D0,D3
00002EF8  6000 0066 5292          bra       MemoryTest_9
                    5293   MemoryTest_5:
                    5294   ; } else if (data_length == 2) {
00002EFC  0C82 0000 5295          cmp.l     #2,D2
00002F00  0002      
00002F02  6600 0032 5296          bne       MemoryTest_7
                    5297   ; word = word_data (data_pattern);
00002F06  2F04      5298          move.l    D4,-(A7)
00002F08  4EB8 2BBE 5299          jsr       _word_data
00002F0C  584F      5300          addq.w    #4,A7
00002F0E  3C00      5301          move.w    D0,D6
                    5302   ; printf ("Test data: %x\n", word);
00002F10  CCBC 0000 5303          and.l     #65535,D6
00002F14  FFFF      
00002F16  2F06      5304          move.l    D6,-(A7)
00002F18  4879 0000 5305          pea       @m68kde~1_161.L
00002F1C  522A      
00002F1E  4E92      5306          jsr       (A2)
00002F20  504F      5307          addq.w    #8,A7
                    5308   ; result = word_test (word, addr_array);
00002F22  2F0B      5309          move.l    A3,-(A7)
00002F24  CCBC 0000 5310          and.l     #65535,D6
00002F28  FFFF      
00002F2A  2F06      5311          move.l    D6,-(A7)
00002F2C  4EB8 2CF0 5312          jsr       _word_test
00002F30  504F      5313          addq.w    #8,A7
00002F32  2600      5314          move.l    D0,D3
00002F34  602A      5315          bra.s     MemoryTest_9
                    5316   MemoryTest_7:
                    5317   ; } else if (data_length == 3) {
00002F36  0C82 0000 5318          cmp.l     #3,D2
00002F3A  0003      
00002F3C  6622      5319          bne.s     MemoryTest_9
                    5320   ; long_word = long_word_data (data_pattern);
00002F3E  2F04      5321          move.l    D4,-(A7)
00002F40  4EB8 2C06 5322          jsr       _long_word_data
00002F44  584F      5323          addq.w    #4,A7
00002F46  2A00      5324          move.l    D0,D5
                    5325   ; printf ("Test data: %x\n", long_word);
00002F48  2F05      5326          move.l    D5,-(A7)
00002F4A  4879 0000 5327          pea       @m68kde~1_161.L
00002F4E  522A      
00002F50  4E92      5328          jsr       (A2)
00002F52  504F      5329          addq.w    #8,A7
                    5330   ; result = long_word_test (long_word, addr_array);
00002F54  2F0B      5331          move.l    A3,-(A7)
00002F56  2F05      5332          move.l    D5,-(A7)
00002F58  4EB8 2D90 5333          jsr       _long_word_test
00002F5C  504F      5334          addq.w    #8,A7
00002F5E  2600      5335          move.l    D0,D3
                    5336   MemoryTest_9:
                    5337   ; }
                    5338   ; if (result == 1) {
00002F60  0C83 0000 5339          cmp.l     #1,D3
00002F64  0001      
00002F66  660A      5340          bne.s     MemoryTest_11
                    5341   ; printf("Test passed!\n");
00002F68  4879 0000 5342          pea       @m68kde~1_162.L
00002F6C  523A      
00002F6E  4E92      5343          jsr       (A2)
00002F70  584F      5344          addq.w    #4,A7
                    5345   MemoryTest_11:
00002F72  4CDF 3CFC 5346          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00002F76  4E5E      5347          unlk      A6
00002F78  4E75      5348          rts
                    5349   ; }
                    5350   ; }
                    5351   ; void main(void)
                    5352   ; {
                    5353   _main:
00002F7A  4E56 FFF4 5354          link      A6,#-12
00002F7E  48E7 3030 5355          movem.l   D2/D3/A2/A3,-(A7)
00002F82  45F8 0A36 5356          lea       _InstallExceptionHandler.L,A2
00002F86  47F9 0000 5357          lea       _printf.L,A3
00002F8A  343A      
                    5358   ; char c ;
                    5359   ; int i, j ;
                    5360   ; char *BugMessage = "DE1-68k Bug V1.77";
00002F8C  41F9 0000 5361          lea       @m68kde~1_163.L,A0
00002F90  5248      
00002F92  2608      5362          move.l    A0,D3
                    5363   ; char *CopyrightMessage = "Copyright (C) PJ Davies 2016";
00002F94  41F9 0000 5364          lea       @m68kde~1_164.L,A0
00002F98  525A      
00002F9A  2D48 FFFC 5365          move.l    A0,-4(A6)
                    5366   ; KillAllBreakPoints() ;
00002F9E  4EB8 1F98 5367          jsr       _KillAllBreakPoints
                    5368   ; i = x = y = z = PortA_Count = 0;
00002FA2  42B9 0B00 5369          clr.l     _PortA_Count.L
00002FA6  00D4      
00002FA8  42B9 0B00 5370          clr.l     _z.L
00002FAC  00D0      
00002FAE  42B9 0B00 5371          clr.l     _y.L
00002FB2  00CC      
00002FB4  42B9 0B00 5372          clr.l     _x.L
00002FB8  00C8      
00002FBA  4282      5373          clr.l     D2
                    5374   ; Trace = GoFlag = 0;                       // used in tracing/single stepping
00002FBC  42B9 0B00 5375          clr.l     _GoFlag.L
00002FC0  00DC      
00002FC2  42B9 0B00 5376          clr.l     _Trace.L
00002FC6  00D8      
                    5377   ; Echo = 1 ;
00002FC8  23FC 0000 5378          move.l    #1,_Echo.L
00002FCC  0001 0B00 
00002FD0  00E0      
                    5379   ; d0=d1=d2=d3=d4=d5=d6=d7=0 ;
00002FD2  42B9 0B00 5380          clr.l     _d7.L
00002FD6  0100      
00002FD8  42B9 0B00 5381          clr.l     _d6.L
00002FDC  00FC      
00002FDE  42B9 0B00 5382          clr.l     _d5.L
00002FE2  00F8      
00002FE4  42B9 0B00 5383          clr.l     _d4.L
00002FE8  00F4      
00002FEA  42B9 0B00 5384          clr.l     _d3.L
00002FEE  00F0      
00002FF0  42B9 0B00 5385          clr.l     _d2.L
00002FF4  00EC      
00002FF6  42B9 0B00 5386          clr.l     _d1.L
00002FFA  00E8      
00002FFC  42B9 0B00 5387          clr.l     _d0.L
00003000  00E4      
                    5388   ; a0=a1=a2=a3=a4=a5=a6=0 ;
00003002  42B9 0B00 5389          clr.l     _a6.L
00003006  011C      
00003008  42B9 0B00 5390          clr.l     _a5.L
0000300C  0118      
0000300E  42B9 0B00 5391          clr.l     _a4.L
00003012  0114      
00003014  42B9 0B00 5392          clr.l     _a3.L
00003018  0110      
0000301A  42B9 0B00 5393          clr.l     _a2.L
0000301E  010C      
00003020  42B9 0B00 5394          clr.l     _a1.L
00003024  0108      
00003026  42B9 0B00 5395          clr.l     _a0.L
0000302A  0104      
                    5396   ; PC = ProgramStart, SSP=TopOfStack, USP = TopOfStack;
0000302C  23FC 0800 5397          move.l    #134217728,_PC.L
00003030  0000 0B00 
00003034  0120      
00003036  23FC 0C00 5398          move.l    #201326592,_SSP.L
0000303A  0000 0B00 
0000303E  0124      
00003040  23FC 0C00 5399          move.l    #201326592,_USP.L
00003044  0000 0B00 
00003048  0128      
                    5400   ; SR = 0x2000;                            // clear interrupts enable tracing  uses IRQ6
0000304A  33FC 2000 5401          move.w    #8192,_SR.L
0000304E  0B00 012C 
                    5402   ; // Initialise Breakpoint variables
                    5403   ; for(i = 0; i < 8; i++)  {
00003052  4282      5404          clr.l     D2
                    5405   main_1:
00003054  0C82 0000 5406          cmp.l     #8,D2
00003058  0008      
0000305A  6C00 004C 5407          bge       main_3
                    5408   ; BreakPointAddress[i] = 0;               //array of 8 breakpoint addresses
0000305E  2002      5409          move.l    D2,D0
00003060  E588      5410          lsl.l     #2,D0
00003062  41F9 0B00 5411          lea       _BreakPointAddress.L,A0
00003066  012E      
00003068  42B0 0800 5412          clr.l     0(A0,D0.L)
                    5413   ; WatchPointAddress[i] = 0 ;
0000306C  2002      5414          move.l    D2,D0
0000306E  E588      5415          lsl.l     #2,D0
00003070  41F9 0B00 5416          lea       _WatchPointAddress.L,A0
00003074  0182      
00003076  42B0 0800 5417          clr.l     0(A0,D0.L)
                    5418   ; BreakPointInstruction[i] = 0;           // to hold the instruction at the break point
0000307A  2002      5419          move.l    D2,D0
0000307C  E388      5420          lsl.l     #1,D0
0000307E  41F9 0B00 5421          lea       _BreakPointInstruction.L,A0
00003082  014E      
00003084  4270 0800 5422          clr.w     0(A0,D0.L)
                    5423   ; BreakPointSetOrCleared[i] = 0;          // indicates if break point set
00003088  2002      5424          move.l    D2,D0
0000308A  E588      5425          lsl.l     #2,D0
0000308C  41F9 0B00 5426          lea       _BreakPointSetOrCleared.L,A0
00003090  015E      
00003092  42B0 0800 5427          clr.l     0(A0,D0.L)
                    5428   ; WatchPointSetOrCleared[i] = 0;
00003096  2002      5429          move.l    D2,D0
00003098  E588      5430          lsl.l     #2,D0
0000309A  41F9 0B00 5431          lea       _WatchPointSetOrCleared.L,A0
0000309E  01A2      
000030A0  42B0 0800 5432          clr.l     0(A0,D0.L)
000030A4  5282      5433          addq.l    #1,D2
000030A6  60AC      5434          bra       main_1
                    5435   main_3:
                    5436   ; }
                    5437   ; Init_RS232() ;     // initialise the RS232 port
000030A8  4EB8 0B18 5438          jsr       _Init_RS232
                    5439   ; Init_LCD() ;
000030AC  4EB8 0964 5440          jsr       _Init_LCD
                    5441   ; for( i = 32; i < 48; i++)
000030B0  7420      5442          moveq     #32,D2
                    5443   main_4:
000030B2  0C82 0000 5444          cmp.l     #48,D2
000030B6  0030      
000030B8  6C0E      5445          bge.s     main_6
                    5446   ; InstallExceptionHandler(UnhandledTrap, i) ;		        // install Trap exception handler on vector 32-47
000030BA  2F02      5447          move.l    D2,-(A7)
000030BC  4878 2810 5448          pea       _UnhandledTrap.L
000030C0  4E92      5449          jsr       (A2)
000030C2  504F      5450          addq.w    #8,A7
000030C4  5282      5451          addq.l    #1,D2
000030C6  60EA      5452          bra       main_4
                    5453   main_6:
                    5454   ; InstallExceptionHandler(menu, 47) ;		                   // TRAP #15 call debug and end program
000030C8  4878 002F 5455          pea       47
000030CC  4878 24EA 5456          pea       _menu.L
000030D0  4E92      5457          jsr       (A2)
000030D2  504F      5458          addq.w    #8,A7
                    5459   ; InstallExceptionHandler(UnhandledIRQ1, 25) ;		      // install handler for interrupts
000030D4  4878 0019 5460          pea       25
000030D8  4878 27B6 5461          pea       _UnhandledIRQ1.L
000030DC  4E92      5462          jsr       (A2)
000030DE  504F      5463          addq.w    #8,A7
                    5464   ; InstallExceptionHandler(UnhandledIRQ2, 26) ;		      // install handler for interrupts
000030E0  4878 001A 5465          pea       26
000030E4  4878 27C2 5466          pea       _UnhandledIRQ2.L
000030E8  4E92      5467          jsr       (A2)
000030EA  504F      5468          addq.w    #8,A7
                    5469   ; InstallExceptionHandler(UnhandledIRQ3, 27) ;		      // install handler for interrupts
000030EC  4878 001B 5470          pea       27
000030F0  4878 27CE 5471          pea       _UnhandledIRQ3.L
000030F4  4E92      5472          jsr       (A2)
000030F6  504F      5473          addq.w    #8,A7
                    5474   ; InstallExceptionHandler(UnhandledIRQ4, 28) ;		      // install handler for interrupts
000030F8  4878 001C 5475          pea       28
000030FC  4878 27DA 5476          pea       _UnhandledIRQ4.L
00003100  4E92      5477          jsr       (A2)
00003102  504F      5478          addq.w    #8,A7
                    5479   ; InstallExceptionHandler(UnhandledIRQ5, 29) ;		      // install handler for interrupts
00003104  4878 001D 5480          pea       29
00003108  4878 27E6 5481          pea       _UnhandledIRQ5.L
0000310C  4E92      5482          jsr       (A2)
0000310E  504F      5483          addq.w    #8,A7
                    5484   ; InstallExceptionHandler(UnhandledIRQ6, 30) ;		      // install handler for interrupts
00003110  4878 001E 5485          pea       30
00003114  4878 27F2 5486          pea       _UnhandledIRQ6.L
00003118  4E92      5487          jsr       (A2)
0000311A  504F      5488          addq.w    #8,A7
                    5489   ; InstallExceptionHandler(UnhandledIRQ7, 31) ;		      // install handler for interrupts
0000311C  4878 001F 5490          pea       31
00003120  4878 2804 5491          pea       _UnhandledIRQ7.L
00003124  4E92      5492          jsr       (A2)
00003126  504F      5493          addq.w    #8,A7
                    5494   ; InstallExceptionHandler(HandleBreakPoint, 46) ;		           // install Trap 14 Break Point exception handler on vector 46
00003128  4878 002E 5495          pea       46
0000312C  4878 2226 5496          pea       _HandleBreakPoint.L
00003130  4E92      5497          jsr       (A2)
00003132  504F      5498          addq.w    #8,A7
                    5499   ; InstallExceptionHandler(DumpRegistersandPause, 29) ;		   // install TRACE handler for IRQ5 on vector 29
00003134  4878 001D 5500          pea       29
00003138  4878 1906 5501          pea       _DumpRegistersandPause.L
0000313C  4E92      5502          jsr       (A2)
0000313E  504F      5503          addq.w    #8,A7
                    5504   ; InstallExceptionHandler(BusError,2) ;                          // install Bus error handler
00003140  4878 0002 5505          pea       2
00003144  4878 281E 5506          pea       _BusError.L
00003148  4E92      5507          jsr       (A2)
0000314A  504F      5508          addq.w    #8,A7
                    5509   ; InstallExceptionHandler(AddressError,3) ;                      // install address error handler (doesn't work on soft core 68k implementation)
0000314C  4878 0003 5510          pea       3
00003150  4878 282C 5511          pea       _AddressError.L
00003154  4E92      5512          jsr       (A2)
00003156  504F      5513          addq.w    #8,A7
                    5514   ; InstallExceptionHandler(IllegalInstruction,4) ;                // install illegal instruction exception handler
00003158  4878 0004 5515          pea       4
0000315C  4878 283A 5516          pea       _IllegalInstruction.L
00003160  4E92      5517          jsr       (A2)
00003162  504F      5518          addq.w    #8,A7
                    5519   ; InstallExceptionHandler(Dividebyzero,5) ;                      // install /0 exception handler
00003164  4878 0005 5520          pea       5
00003168  4878 2848 5521          pea       _Dividebyzero.L
0000316C  4E92      5522          jsr       (A2)
0000316E  504F      5523          addq.w    #8,A7
                    5524   ; InstallExceptionHandler(Check,6) ;                             // install check instruction exception handler
00003170  4878 0006 5525          pea       6
00003174  4878 2856 5526          pea       _Check.L
00003178  4E92      5527          jsr       (A2)
0000317A  504F      5528          addq.w    #8,A7
                    5529   ; InstallExceptionHandler(Trapv,7) ;                             // install trapv instruction exception handler
0000317C  4878 0007 5530          pea       7
00003180  4878 2864 5531          pea       _Trapv.L
00003184  4E92      5532          jsr       (A2)
00003186  504F      5533          addq.w    #8,A7
                    5534   ; InstallExceptionHandler(PrivError,8) ;                         // install Priv Violation exception handler
00003188  4878 0008 5535          pea       8
0000318C  4878 2872 5536          pea       _PrivError.L
00003190  4E92      5537          jsr       (A2)
00003192  504F      5538          addq.w    #8,A7
                    5539   ; InstallExceptionHandler(UnitIRQ,15) ;                          // install uninitialised IRQ exception handler
00003194  4878 000F 5540          pea       15
00003198  4878 2880 5541          pea       _UnitIRQ.L
0000319C  4E92      5542          jsr       (A2)
0000319E  504F      5543          addq.w    #8,A7
                    5544   ; InstallExceptionHandler(Check,24) ;                            // install spurious IRQ exception handler
000031A0  4878 0018 5545          pea       24
000031A4  4878 2856 5546          pea       _Check.L
000031A8  4E92      5547          jsr       (A2)
000031AA  504F      5548          addq.w    #8,A7
                    5549   ; FlushKeyboard() ;                        // dump unread characters from keyboard
000031AC  4EB8 0BAC 5550          jsr       _FlushKeyboard
                    5551   ; TraceException = 0 ;                     // clear trace exception port to remove any software generated single step/trace
000031B0  4239 0040 5552          clr.b     4194314
000031B4  000A      
                    5553   ; // test for auto flash boot and run from Flash by reading switch 9 on DE1-soc board. If set, copy program from flash into Dram and run
                    5554   ; while(((char)(PortB & 0x02)) == (char)(0x02))    {
                    5555   main_7:
000031B6  1039 0040 5556          move.b    4194306,D0
000031BA  0002      
000031BC  C03C 0002 5557          and.b     #2,D0
000031C0  0C00 0002 5558          cmp.b     #2,D0
000031C4  662A      5559          bne.s     main_9
                    5560   ; LoadFromFlashChip();
000031C6  4EB8 143A 5561          jsr       _LoadFromFlashChip
                    5562   ; printf("\r\nRunning.....") ;
000031CA  4879 0000 5563          pea       @m68kde~1_165.L
000031CE  5278      
000031D0  4E93      5564          jsr       (A3)
000031D2  584F      5565          addq.w    #4,A7
                    5566   ; Oline1("Running.....") ;
000031D4  4879 0000 5567          pea       @m68kde~1_166.L
000031D8  5288      
000031DA  4EB8 0A08 5568          jsr       _Oline1
000031DE  584F      5569          addq.w    #4,A7
                    5570   ; GoFlag = 1;
000031E0  23FC 0000 5571          move.l    #1,_GoFlag.L
000031E4  0001 0B00 
000031E8  00DC      
                    5572   ; go() ;
000031EA  4EB8 08BE 5573          jsr       _go
000031EE  60C6      5574          bra       main_7
                    5575   main_9:
                    5576   ; }
                    5577   ; // otherwise start the debug monitor
                    5578   ; Oline0(BugMessage) ;
000031F0  2F03      5579          move.l    D3,-(A7)
000031F2  4EB8 09DA 5580          jsr       _Oline0
000031F6  584F      5581          addq.w    #4,A7
                    5582   ; Oline1("By: PJ Davies") ;
000031F8  4879 0000 5583          pea       @m68kde~1_167.L
000031FC  5296      
000031FE  4EB8 0A08 5584          jsr       _Oline1
00003202  584F      5585          addq.w    #4,A7
                    5586   ; printf("\r\n%s", BugMessage) ;
00003204  2F03      5587          move.l    D3,-(A7)
00003206  4879 0000 5588          pea       @m68kde~1_168.L
0000320A  52A4      
0000320C  4E93      5589          jsr       (A3)
0000320E  504F      5590          addq.w    #8,A7
                    5591   ; printf("\r\n%s", CopyrightMessage) ;
00003210  2F2E FFFC 5592          move.l    -4(A6),-(A7)
00003214  4879 0000 5593          pea       @m68kde~1_168.L
00003218  52A4      
0000321A  4E93      5594          jsr       (A3)
0000321C  504F      5595          addq.w    #8,A7
                    5596   ; printf("\r\nStudent Name: Shidi Xi") ;
0000321E  4879 0000 5597          pea       @m68kde~1_169.L
00003222  52AA      
00003224  4E93      5598          jsr       (A3)
00003226  584F      5599          addq.w    #4,A7
                    5600   ; printf("\r\nStudent Number: 90506643");
00003228  4879 0000 5601          pea       @m68kde~1_170.L
0000322C  52C4      
0000322E  4E93      5602          jsr       (A3)
00003230  584F      5603          addq.w    #4,A7
                    5604   ; menu();
00003232  4EB8 24EA 5605          jsr       _menu
00003236  4CDF 0C0C 5606          movem.l   (A7)+,D2/D3/A2/A3
0000323A  4E5E      5607          unlk      A6
0000323C  4E75      5608          rts
                    5609   ; }
                    5610   _strcpy:
0000323E  206F 0004 5611          move.l    (4,A7),A0
00003242  226F 0008 5612          move.l    (8,A7),A1
00003246  2008      5613          move.l    A0,D0
                    5614   strcpy_1:
00003248  10D9      5615          move.b    (A1)+,(A0)+
0000324A  66FC      5616          bne       strcpy_1
0000324C  4E75      5617          rts
                    5618   ULDIV:
0000324E  4E56 0000 5619          link    A6,#0
00003252  48E7 C000 5620          movem.l D0/D1,-(A7)
00003256  222E 0008 5621          move.l  8(A6),D1
0000325A  202E 000C 5622          move.l  12(A6),D0
0000325E  6036      5623          bra.s   ldiv_3
                    5624   LDIV:
00003260  4E56 0000 5625          link    A6,#0
00003264  48E7 C000 5626          movem.l D0/D1,-(A7)
00003268  222E 0008 5627          move.l  8(A6),D1
0000326C  202E 000C 5628          move.l  12(A6),D0
00003270  4A80      5629          tst.l   D0
00003272  6A0E      5630          bpl.s   ldiv_1
00003274  4480      5631          neg.l   D0
00003276  4A81      5632          tst.l   D1
00003278  6A14      5633          bpl.s   ldiv_2
0000327A  4481      5634          neg.l   D1
0000327C  612A      5635          bsr.s   dodiv
0000327E  4481      5636          neg.l   D1
00003280  6016      5637          bra.s   ldiv_4
                    5638   ldiv_1:
00003282  4A81      5639          tst.l   D1
00003284  6A10      5640          bpl.s   ldiv_3
00003286  4481      5641          neg.l   D1
00003288  611E      5642          bsr.s   dodiv
0000328A  4480      5643          neg.l   D0
0000328C  600A      5644          bra.s   ldiv_4
                    5645   ldiv_2:
0000328E  6118      5646          bsr.s   dodiv
00003290  4480      5647          neg.l   D0
00003292  4481      5648          neg.l   D1
00003294  6002      5649          bra.s   ldiv_4
                    5650   ldiv_3:
00003296  6110      5651          bsr.s   dodiv
                    5652   ldiv_4:
00003298  2D40 0008 5653          move.l  D0,8(A6)
0000329C  2D41 000C 5654          move.l  D1,12(A6)
000032A0  4CDF 0003 5655          movem.l (A7)+,D0/D1
000032A4  4E5E      5656          unlk    A6
000032A6  4E75      5657          rts
                    5658   dodiv:
000032A8  0C81 0000 5659          cmpi.l  #$FFFF,D1
000032AC  FFFF      
000032AE  6236      5660          bhi.s   dodiv_2
000032B0  0C80 0000 5661          cmpi.l  #$FFFF,D0
000032B4  FFFF      
000032B6  6210      5662          bhi.s   dodiv_1
000032B8  80C1      5663          divu    D1,D0
000032BA  2200      5664          move.l  D0,D1
000032BC  4241      5665          clr.w   D1
000032BE  4841      5666          swap    D1
000032C0  0280 0000 5667          andi.l  #$FFFF,D0
000032C4  FFFF      
000032C6  4E75      5668          rts
                    5669   dodiv_1:
000032C8  48A7 A000 5670          movem.w D0/D2,-(A7)
000032CC  4240      5671          clr.w   D0
000032CE  4840      5672          swap    D0
000032D0  80C1      5673          divu    D1,D0
000032D2  3400      5674          move.w  D0,D2
000032D4  301F      5675          move.w  (A7)+,D0
000032D6  80C1      5676          divu    D1,D0
000032D8  4840      5677          swap    D0
000032DA  4281      5678          clr.l   D1
000032DC  3200      5679          move.w  D0,D1
000032DE  3002      5680          move.w  D2,D0
000032E0  4840      5681          swap    D0
000032E2  341F      5682          move.w  (A7)+,D2
000032E4  4E75      5683          rts
                    5684   dodiv_2:
000032E6  48E7 3800 5685          movem.l D2/D3/D4,-(A7)
000032EA  2401      5686          move.l  D1,D2
000032EC  4242      5687          clr.w   D2
000032EE  4842      5688          swap    D2
000032F0  5282      5689          addq.l  #1,D2
000032F2  2600      5690          move.l  D0,D3
000032F4  2801      5691          move.l  D1,D4
000032F6  2202      5692          move.l  D2,D1
000032F8  61CE      5693          bsr.s   dodiv_1
000032FA  2204      5694          move.l  D4,D1
000032FC  82C2      5695          divu    D2,D1
000032FE  80C1      5696          divu    D1,D0
00003300  0280 0000 5697          andi.l  #$FFFF,D0
00003304  FFFF      
                    5698   dodiv_3:
00003306  2204      5699          move.l  D4,D1
00003308  2404      5700          move.l  D4,D2
0000330A  4842      5701          swap    D2
0000330C  C2C0      5702          mulu    D0,D1
0000330E  C4C0      5703          mulu    D0,D2
00003310  4842      5704          swap    D2
00003312  D282      5705          add.l   D2,D1
00003314  9283      5706          sub.l   D3,D1
00003316  620A      5707          bhi.s   dodiv_4
00003318  4481      5708          neg.l   D1
0000331A  B881      5709          cmp.l   D1,D4
0000331C  6208      5710          bhi.s   dodiv_5
0000331E  5280      5711          addq.l  #1,D0
00003320  60E4      5712          bra.s   dodiv_3
                    5713   dodiv_4:
00003322  5380      5714          subq.l  #1,D0
00003324  60E0      5715          bra.s   dodiv_3
                    5716   dodiv_5:
00003326  4CDF 001C 5717          movem.l (A7)+,D2/D3/D4
0000332A  4E75      5718          rts
                    5719   _putch:
0000332C  4E56 0000 5720          link      A6,#0
00003330  48E7 2000 5721          movem.l   D2,-(A7)
00003334  242E 0008 5722          move.l    8(A6),D2
00003338  0C82 0000 5723          cmp.l     #10,D2
0000333C  000A      
0000333E  660A      5724          bne.s     putch_1
00003340  4878 000D 5725          pea       13
00003344  6100 D7FC 5726          bsr       __putch
00003348  584F      5727          addq.w    #4,A7
                    5728   putch_1:
0000334A  2F02      5729          move.l    D2,-(A7)
0000334C  6100 D7F4 5730          bsr       __putch
00003350  584F      5731          addq.w    #4,A7
00003352  2002      5732          move.l    D2,D0
00003354  4CDF 0004 5733          movem.l   (A7)+,D2
00003358  4E5E      5734          unlk      A6
0000335A  4E75      5735          rts
                    5736   _getch:
0000335C  48E7 2000 5737          movem.l   D2,-(A7)
00003360  2439 0B00 5738          move.l    __ungetbuf,D2
00003364  00C0      
00003366  2039 0B00 5739          move.l    __ungetbuf,D0
0000336A  00C0      
0000336C  0C80 FFFF 5740          cmp.l     #-1,D0
00003370  FFFF      
00003372  670C      5741          beq.s     getch_1
00003374  23FC FFFF 5742          move.l    #-1,__ungetbuf
00003378  FFFF 0B00 
0000337C  00C0      
0000337E  6010      5743          bra.s     getch_3
                    5744   getch_1:
00003380  6100 D7EC 5745          bsr       __getch
00003384  2400      5746          move.l    D0,D2
00003386  0C80 0000 5747          cmp.l     #13,D0
0000338A  000D      
0000338C  6602      5748          bne.s     getch_3
0000338E  740A      5749          moveq     #10,D2
                    5750   getch_3:
00003390  2002      5751          move.l    D2,D0
00003392  4CDF 0004 5752          movem.l   (A7)+,D2
00003396  4E75      5753          rts
                    5754   _tolower:
00003398  4E56 0000 5755          link      A6,#0
0000339C  48E7 2000 5756          movem.l   D2,-(A7)
000033A0  242E 0008 5757          move.l    8(A6),D2
000033A4  0C82 0000 5758          cmp.l     #65,D2
000033A8  0041      
000033AA  6D0E      5759          blt.s     tolower_1
000033AC  0C82 0000 5760          cmp.l     #90,D2
000033B0  005A      
000033B2  6E06      5761          bgt.s     tolower_1
000033B4  84BC 0000 5762          or.l      #32,D2
000033B8  0020      
                    5763   tolower_1:
000033BA  2002      5764          move.l    D2,D0
000033BC  4CDF 0004 5765          movem.l   (A7)+,D2
000033C0  4E5E      5766          unlk      A6
000033C2  4E75      5767          rts
                    5768   _sprintf:
000033C4  4E56 FFFC 5769          link      A6,#-4
000033C8  48E7 2000 5770          movem.l   D2,-(A7)
000033CC  41EE 000C 5771          lea       12(A6),A0
000033D0  5848      5772          addq.w    #4,A0
000033D2  2408      5773          move.l    A0,D2
000033D4  2F02      5774          move.l    D2,-(A7)
000033D6  2F2E 000C 5775          move.l    12(A6),-(A7)
000033DA  2F2E 0008 5776          move.l    8(A6),-(A7)
000033DE  6100 013E 5777          bsr       _vsprintf
000033E2  DEFC 000C 5778          add.w     #12,A7
000033E6  2D40 FFFC 5779          move.l    D0,-4(A6)
000033EA  4282      5780          clr.l     D2
000033EC  202E FFFC 5781          move.l    -4(A6),D0
000033F0  4CDF 0004 5782          movem.l   (A7)+,D2
000033F4  4E5E      5783          unlk      A6
000033F6  4E75      5784          rts
                    5785   _strcat:
000033F8  206F 0004 5786          move.l    (4,A7),A0	
000033FC  226F 0008 5787          move.l    (8,A7),A1	
00003400  2008      5788          move.l    A0,D0		
                    5789   strcat_0:
00003402  4A18      5790          tst.b     (A0)+
00003404  66FC      5791          bne       strcat_0
00003406  5348      5792          subq      #1,A0
                    5793   strcat_1:
00003408  10D9      5794          move.b    (A1)+,(A0)+
0000340A  66FC      5795          bne       strcat_1
0000340C  4E75      5796          rts
                    5797   _toupper:
0000340E  4E56 0000 5798          link      A6,#0
00003412  48E7 2000 5799          movem.l   D2,-(A7)
00003416  242E 0008 5800          move.l    8(A6),D2
0000341A  0C82 0000 5801          cmp.l     #97,D2
0000341E  0061      
00003420  6D0E      5802          blt.s     toupper_1
00003422  0C82 0000 5803          cmp.l     #122,D2
00003426  007A      
00003428  6E06      5804          bgt.s     toupper_1
0000342A  C4BC 0000 5805          and.l     #95,D2
0000342E  005F      
                    5806   toupper_1:
00003430  2002      5807          move.l    D2,D0
00003432  4CDF 0004 5808          movem.l   (A7)+,D2
00003436  4E5E      5809          unlk      A6
00003438  4E75      5810          rts
                    5811   _printf:
0000343A  4E56 FFFC 5812          link      A6,#-4
0000343E  48E7 2000 5813          movem.l   D2,-(A7)
00003442  41EE 0008 5814          lea       8(A6),A0
00003446  5848      5815          addq.w    #4,A0
00003448  2408      5816          move.l    A0,D2
0000344A  2F02      5817          move.l    D2,-(A7)
0000344C  2F2E 0008 5818          move.l    8(A6),-(A7)
00003450  42A7      5819          clr.l     -(A7)
00003452  6100 00CA 5820          bsr       _vsprintf
00003456  DEFC 000C 5821          add.w     #12,A7
0000345A  2D40 FFFC 5822          move.l    D0,-4(A6)
0000345E  4282      5823          clr.l     D2
00003460  202E FFFC 5824          move.l    -4(A6),D0
00003464  4CDF 0004 5825          movem.l   (A7)+,D2
00003468  4E5E      5826          unlk      A6
0000346A  4E75      5827          rts
                    5828   @vsprintf_copy:
0000346C  4E56 0000 5829          link      A6,#0
00003470  206E 0008 5830          move.l    8(A6),A0
00003474  4A90      5831          tst.l     (A0)
00003476  6710      5832          beq.s     @vsprintf_copy_1
00003478  202E 000C 5833          move.l    12(A6),D0
0000347C  206E 0008 5834          move.l    8(A6),A0
00003480  2250      5835          move.l    (A0),A1
00003482  5290      5836          addq.l    #1,(A0)
00003484  1280      5837          move.b    D0,(A1)
00003486  600A      5838          bra.s     @vsprintf_copy_2
                    5839   @vsprintf_copy_1:
00003488  2F2E 000C 5840          move.l    12(A6),-(A7)
0000348C  6100 FE9E 5841          bsr       _putch
00003490  584F      5842          addq.w    #4,A7
                    5843   @vsprintf_copy_2:
00003492  4E5E      5844          unlk      A6
00003494  4E75      5845          rts
                    5846   @vsprintf_getval:
00003496  4E56 0000 5847          link      A6,#0
0000349A  48E7 3000 5848          movem.l   D2/D3,-(A7)
0000349E  242E 0008 5849          move.l    8(A6),D2
000034A2  4283      5850          clr.l     D3
000034A4  2042      5851          move.l    D2,A0
000034A6  2050      5852          move.l    (A0),A0
000034A8  1010      5853          move.b    (A0),D0
000034AA  4880      5854          ext.w     D0
000034AC  48C0      5855          ext.l     D0
000034AE  0C80 0000 5856          cmp.l     #42,D0
000034B2  002A      
000034B4  6612      5857          bne.s     @vsprintf_getval_1
000034B6  206E 000C 5858          move.l    12(A6),A0
000034BA  2250      5859          move.l    (A0),A1
000034BC  5890      5860          addq.l    #4,(A0)
000034BE  2611      5861          move.l    (A1),D3
000034C0  2042      5862          move.l    D2,A0
000034C2  5290      5863          addq.l    #1,(A0)
000034C4  6000 004E 5864          bra       @vsprintf_getval_5
                    5865   @vsprintf_getval_1:
000034C8  2042      5866          move.l    D2,A0
000034CA  2050      5867          move.l    (A0),A0
000034CC  1010      5868          move.b    (A0),D0
000034CE  4880      5869          ext.w     D0
000034D0  48C0      5870          ext.l     D0
000034D2  0C80 0000 5871          cmp.l     #48,D0
000034D6  0030      
000034D8  6D00 003A 5872          blt       @vsprintf_getval_5
000034DC  2042      5873          move.l    D2,A0
000034DE  2050      5874          move.l    (A0),A0
000034E0  1010      5875          move.b    (A0),D0
000034E2  4880      5876          ext.w     D0
000034E4  48C0      5877          ext.l     D0
000034E6  0C80 0000 5878          cmp.l     #57,D0
000034EA  0039      
000034EC  6E26      5879          bgt.s     @vsprintf_getval_5
000034EE  2F03      5880          move.l    D3,-(A7)
000034F0  4878 000A 5881          pea       10
000034F4  6100 07F4 5882          bsr       LMUL
000034F8  2017      5883          move.l    (A7),D0
000034FA  504F      5884          addq.w    #8,A7
000034FC  2042      5885          move.l    D2,A0
000034FE  2250      5886          move.l    (A0),A1
00003500  5290      5887          addq.l    #1,(A0)
00003502  1211      5888          move.b    (A1),D1
00003504  4881      5889          ext.w     D1
00003506  48C1      5890          ext.l     D1
00003508  D081      5891          add.l     D1,D0
0000350A  0480 0000 5892          sub.l     #48,D0
0000350E  0030      
00003510  2600      5893          move.l    D0,D3
00003512  60B4      5894          bra       @vsprintf_getval_1
                    5895   @vsprintf_getval_5:
00003514  2003      5896          move.l    D3,D0
00003516  4CDF 000C 5897          movem.l   (A7)+,D2/D3
0000351A  4E5E      5898          unlk      A6
0000351C  4E75      5899          rts
                    5900   _vsprintf:
0000351E  4E56 FFCC 5901          link      A6,#-52
00003522  48E7 3F3C 5902          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00003526  45EE 0008 5903          lea       8(A6),A2
0000352A  47F8 346C 5904          lea       @vsprintf_copy,A3
0000352E  49F9 0000 5905          lea       _ultoa,A4
00003532  3C76      
00003534  4286      5906          clr.l     D6
                    5907   vsprintf_1:
00003536  206E 000C 5908          move.l    12(A6),A0
0000353A  4A10      5909          tst.b     (A0)
0000353C  6700 0624 5910          beq       vsprintf_3
00003540  206E 000C 5911          move.l    12(A6),A0
00003544  1010      5912          move.b    (A0),D0
00003546  4880      5913          ext.w     D0
00003548  48C0      5914          ext.l     D0
0000354A  0C80 0000 5915          cmp.l     #37,D0
0000354E  0025      
00003550  671C      5916          beq.s     vsprintf_4
00003552  206E 000C 5917          move.l    12(A6),A0
00003556  52AE 000C 5918          addq.l    #1,12(A6)
0000355A  1210      5919          move.b    (A0),D1
0000355C  4881      5920          ext.w     D1
0000355E  48C1      5921          ext.l     D1
00003560  2F01      5922          move.l    D1,-(A7)
00003562  2F0A      5923          move.l    A2,-(A7)
00003564  4E93      5924          jsr       (A3)
00003566  504F      5925          addq.w    #8,A7
00003568  5286      5926          addq.l    #1,D6
0000356A  6000 05F2 5927          bra       vsprintf_2
                    5928   vsprintf_4:
0000356E  52AE 000C 5929          addq.l    #1,12(A6)
00003572  422E FFD3 5930          clr.b     -45(A6)
00003576  422E FFD2 5931          clr.b     -46(A6)
0000357A  422E FFD0 5932          clr.b     -48(A6)
0000357E  422E FFCF 5933          clr.b     -49(A6)
00003582  422E FFCE 5934          clr.b     -50(A6)
00003586  422E FFCD 5935          clr.b     -51(A6)
0000358A  42AE FFFC 5936          clr.l     -4(A6)
0000358E  7AFF      5937          moveq     #-1,D5
00003590  41EE FFDC 5938          lea       -36(A6),A0
00003594  2608      5939          move.l    A0,D3
00003596  2408      5940          move.l    A0,D2
                    5941   vsprintf_6:
00003598  206E 000C 5942          move.l    12(A6),A0
0000359C  1010      5943          move.b    (A0),D0
0000359E  4880      5944          ext.w     D0
000035A0  48C0      5945          ext.l     D0
000035A2  0C80 0000 5946          cmp.l     #43,D0
000035A6  002B      
000035A8  6730      5947          beq.s     vsprintf_12
000035AA  6E18      5948          bgt.s     vsprintf_15
000035AC  0C80 0000 5949          cmp.l     #35,D0
000035B0  0023      
000035B2  6700 003E 5950          beq       vsprintf_14
000035B6  6E00 0046 5951          bgt       vsprintf_9
000035BA  0C80 0000 5952          cmp.l     #32,D0
000035BE  0020      
000035C0  6724      5953          beq.s     vsprintf_13
000035C2  603A      5954          bra.s     vsprintf_9
                    5955   vsprintf_15:
000035C4  0C80 0000 5956          cmp.l     #45,D0
000035C8  002D      
000035CA  6702      5957          beq.s     vsprintf_11
000035CC  6030      5958          bra.s     vsprintf_9
                    5959   vsprintf_11:
000035CE  1D7C 0001 5960          move.b    #1,-51(A6)
000035D2  FFCD      
000035D4  52AE 000C 5961          addq.l    #1,12(A6)
000035D8  6026      5962          bra.s     vsprintf_7
                    5963   vsprintf_12:
000035DA  1D7C 0001 5964          move.b    #1,-50(A6)
000035DE  FFCE      
000035E0  52AE 000C 5965          addq.l    #1,12(A6)
000035E4  601A      5966          bra.s     vsprintf_7
                    5967   vsprintf_13:
000035E6  1D7C 0001 5968          move.b    #1,-49(A6)
000035EA  FFCF      
000035EC  52AE 000C 5969          addq.l    #1,12(A6)
000035F0  600E      5970          bra.s     vsprintf_7
                    5971   vsprintf_14:
000035F2  1D7C 0001 5972          move.b    #1,-48(A6)
000035F6  FFD0      
000035F8  52AE 000C 5973          addq.l    #1,12(A6)
000035FC  6002      5974          bra.s     vsprintf_7
                    5975   vsprintf_9:
000035FE  6002      5976          bra.s     vsprintf_8
                    5977   vsprintf_7:
00003600  6096      5978          bra       vsprintf_6
                    5979   vsprintf_8:
00003602  206E 000C 5980          move.l    12(A6),A0
00003606  1010      5981          move.b    (A0),D0
00003608  4880      5982          ext.w     D0
0000360A  48C0      5983          ext.l     D0
0000360C  0C80 0000 5984          cmp.l     #48,D0
00003610  0030      
00003612  660A      5985          bne.s     vsprintf_16
00003614  52AE 000C 5986          addq.l    #1,12(A6)
00003618  1D7C 0001 5987          move.b    #1,-46(A6)
0000361C  FFD2      
                    5988   vsprintf_16:
0000361E  486E 0010 5989          pea       16(A6)
00003622  486E 000C 5990          pea       12(A6)
00003626  6100 FE6E 5991          bsr       @vsprintf_getval
0000362A  504F      5992          addq.w    #8,A7
0000362C  2A40      5993          move.l    D0,A5
0000362E  206E 000C 5994          move.l    12(A6),A0
00003632  1010      5995          move.b    (A0),D0
00003634  4880      5996          ext.w     D0
00003636  48C0      5997          ext.l     D0
00003638  0C80 0000 5998          cmp.l     #46,D0
0000363C  002E      
0000363E  6614      5999          bne.s     vsprintf_18
00003640  52AE 000C 6000          addq.l    #1,12(A6)
00003644  486E 0010 6001          pea       16(A6)
00003648  486E 000C 6002          pea       12(A6)
0000364C  6100 FE48 6003          bsr       @vsprintf_getval
00003650  504F      6004          addq.w    #8,A7
00003652  2A00      6005          move.l    D0,D5
                    6006   vsprintf_18:
00003654  206E 000C 6007          move.l    12(A6),A0
00003658  1010      6008          move.b    (A0),D0
0000365A  4880      6009          ext.w     D0
0000365C  48C0      6010          ext.l     D0
0000365E  0C80 0000 6011          cmp.l     #108,D0
00003662  006C      
00003664  660A      6012          bne.s     vsprintf_20
00003666  52AE 000C 6013          addq.l    #1,12(A6)
0000366A  1D7C 0001 6014          move.b    #1,-45(A6)
0000366E  FFD3      
                    6015   vsprintf_20:
00003670  206E 000C 6016          move.l    12(A6),A0
00003674  1010      6017          move.b    (A0),D0
00003676  4880      6018          ext.w     D0
00003678  48C0      6019          ext.l     D0
0000367A  0C80 0000 6020          cmp.l     #111,D0
0000367E  006F      
00003680  6700 00D4 6021          beq       vsprintf_27
00003684  6E34      6022          bgt.s     vsprintf_33
00003686  0C80 0000 6023          cmp.l     #100,D0
0000368A  0064      
0000368C  6700 0054 6024          beq       vsprintf_24
00003690  6E1C      6025          bgt.s     vsprintf_34
00003692  0C80 0000 6026          cmp.l     #99,D0
00003696  0063      
00003698  6700 012C 6027          beq       vsprintf_30
0000369C  6E00 016A 6028          bgt       vsprintf_22
000036A0  0C80 0000 6029          cmp.l     #88,D0
000036A4  0058      
000036A6  6700 00E6 6030          beq       vsprintf_28
000036AA  6000 015C 6031          bra       vsprintf_22
                    6032   vsprintf_34:
000036AE  0C80 0000 6033          cmp.l     #105,D0
000036B2  0069      
000036B4  672C      6034          beq.s     vsprintf_24
000036B6  6000 0150 6035          bra       vsprintf_22
                    6036   vsprintf_33:
000036BA  0C80 0000 6037          cmp.l     #117,D0
000036BE  0075      
000036C0  6700 005C 6038          beq       vsprintf_26
000036C4  6E0E      6039          bgt.s     vsprintf_35
000036C6  0C80 0000 6040          cmp.l     #115,D0
000036CA  0073      
000036CC  6700 011C 6041          beq       vsprintf_31
000036D0  6000 0136 6042          bra       vsprintf_22
                    6043   vsprintf_35:
000036D4  0C80 0000 6044          cmp.l     #120,D0
000036D8  0078      
000036DA  6700 00B2 6045          beq       vsprintf_28
000036DE  6000 0128 6046          bra       vsprintf_22
                    6047   vsprintf_24:
000036E2  4A2E FFD3 6048          tst.b     -45(A6)
000036E6  671A      6049          beq.s     vsprintf_36
000036E8  4878 000A 6050          pea       10
000036EC  2F03      6051          move.l    D3,-(A7)
000036EE  206E 0010 6052          move.l    16(A6),A0
000036F2  58AE 0010 6053          addq.l    #4,16(A6)
000036F6  2F10      6054          move.l    (A0),-(A7)
000036F8  6100 04F8 6055          bsr       _ltoa
000036FC  DEFC 000C 6056          add.w     #12,A7
00003700  6018      6057          bra.s     vsprintf_37
                    6058   vsprintf_36:
00003702  4878 000A 6059          pea       10
00003706  2F03      6060          move.l    D3,-(A7)
00003708  206E 0010 6061          move.l    16(A6),A0
0000370C  58AE 0010 6062          addq.l    #4,16(A6)
00003710  2F10      6063          move.l    (A0),-(A7)
00003712  6100 04DE 6064          bsr       _ltoa
00003716  DEFC 000C 6065          add.w     #12,A7
                    6066   vsprintf_37:
0000371A  6000 00FA 6067          bra       vsprintf_23
                    6068   vsprintf_26:
0000371E  4A2E FFD3 6069          tst.b     -45(A6)
00003722  6718      6070          beq.s     vsprintf_38
00003724  4878 000A 6071          pea       10
00003728  2F03      6072          move.l    D3,-(A7)
0000372A  206E 0010 6073          move.l    16(A6),A0
0000372E  58AE 0010 6074          addq.l    #4,16(A6)
00003732  2F10      6075          move.l    (A0),-(A7)
00003734  4E94      6076          jsr       (A4)
00003736  DEFC 000C 6077          add.w     #12,A7
0000373A  6016      6078          bra.s     vsprintf_39
                    6079   vsprintf_38:
0000373C  4878 000A 6080          pea       10
00003740  2F03      6081          move.l    D3,-(A7)
00003742  206E 0010 6082          move.l    16(A6),A0
00003746  58AE 0010 6083          addq.l    #4,16(A6)
0000374A  2F10      6084          move.l    (A0),-(A7)
0000374C  4E94      6085          jsr       (A4)
0000374E  DEFC 000C 6086          add.w     #12,A7
                    6087   vsprintf_39:
00003752  6000 00C2 6088          bra       vsprintf_23
                    6089   vsprintf_27:
00003756  4A2E FFD3 6090          tst.b     -45(A6)
0000375A  6718      6091          beq.s     vsprintf_40
0000375C  4878 0008 6092          pea       8
00003760  2F03      6093          move.l    D3,-(A7)
00003762  206E 0010 6094          move.l    16(A6),A0
00003766  58AE 0010 6095          addq.l    #4,16(A6)
0000376A  2F10      6096          move.l    (A0),-(A7)
0000376C  4E94      6097          jsr       (A4)
0000376E  DEFC 000C 6098          add.w     #12,A7
00003772  6016      6099          bra.s     vsprintf_41
                    6100   vsprintf_40:
00003774  4878 0008 6101          pea       8
00003778  2F03      6102          move.l    D3,-(A7)
0000377A  206E 0010 6103          move.l    16(A6),A0
0000377E  58AE 0010 6104          addq.l    #4,16(A6)
00003782  2F10      6105          move.l    (A0),-(A7)
00003784  4E94      6106          jsr       (A4)
00003786  DEFC 000C 6107          add.w     #12,A7
                    6108   vsprintf_41:
0000378A  6000 008A 6109          bra       vsprintf_23
                    6110   vsprintf_28:
0000378E  4A2E FFD3 6111          tst.b     -45(A6)
00003792  6718      6112          beq.s     vsprintf_42
00003794  4878 0010 6113          pea       16
00003798  2F03      6114          move.l    D3,-(A7)
0000379A  206E 0010 6115          move.l    16(A6),A0
0000379E  58AE 0010 6116          addq.l    #4,16(A6)
000037A2  2F10      6117          move.l    (A0),-(A7)
000037A4  4E94      6118          jsr       (A4)
000037A6  DEFC 000C 6119          add.w     #12,A7
000037AA  6016      6120          bra.s     vsprintf_43
                    6121   vsprintf_42:
000037AC  4878 0010 6122          pea       16
000037B0  2F03      6123          move.l    D3,-(A7)
000037B2  206E 0010 6124          move.l    16(A6),A0
000037B6  58AE 0010 6125          addq.l    #4,16(A6)
000037BA  2F10      6126          move.l    (A0),-(A7)
000037BC  4E94      6127          jsr       (A4)
000037BE  DEFC 000C 6128          add.w     #12,A7
                    6129   vsprintf_43:
000037C2  6000 0052 6130          bra       vsprintf_23
                    6131   vsprintf_30:
000037C6  206E 0010 6132          move.l    16(A6),A0
000037CA  58AE 0010 6133          addq.l    #4,16(A6)
000037CE  2010      6134          move.l    (A0),D0
000037D0  2042      6135          move.l    D2,A0
000037D2  5282      6136          addq.l    #1,D2
000037D4  1080      6137          move.b    D0,(A0)
000037D6  2042      6138          move.l    D2,A0
000037D8  4210      6139          clr.b     (A0)
000037DA  200D      6140          move.l    A5,D0
000037DC  6704      6141          beq.s     vsprintf_44
000037DE  200D      6142          move.l    A5,D0
000037E0  6002      6143          bra.s     vsprintf_45
                    6144   vsprintf_44:
000037E2  7001      6145          moveq     #1,D0
                    6146   vsprintf_45:
000037E4  2A00      6147          move.l    D0,D5
000037E6  6000 002E 6148          bra       vsprintf_23
                    6149   vsprintf_31:
000037EA  206E 0010 6150          move.l    16(A6),A0
000037EE  58AE 0010 6151          addq.l    #4,16(A6)
000037F2  2610      6152          move.l    (A0),D3
000037F4  0C85 FFFF 6153          cmp.l     #-1,D5
000037F8  FFFF      
000037FA  660A      6154          bne.s     vsprintf_46
000037FC  2F03      6155          move.l    D3,-(A7)
000037FE  6100 0578 6156          bsr       _strlen
00003802  584F      6157          addq.w    #4,A7
00003804  2A00      6158          move.l    D0,D5
                    6159   vsprintf_46:
00003806  600E      6160          bra.s     vsprintf_23
                    6161   vsprintf_22:
00003808  206E 000C 6162          move.l    12(A6),A0
0000380C  2242      6163          move.l    D2,A1
0000380E  5282      6164          addq.l    #1,D2
00003810  1290      6165          move.b    (A0),(A1)
00003812  2042      6166          move.l    D2,A0
00003814  4210      6167          clr.b     (A0)
                    6168   vsprintf_23:
00003816  2F03      6169          move.l    D3,-(A7)
00003818  6100 055E 6170          bsr       _strlen
0000381C  584F      6171          addq.w    #4,A7
0000381E  1800      6172          move.b    D0,D4
00003820  206E 000C 6173          move.l    12(A6),A0
00003824  1010      6174          move.b    (A0),D0
00003826  4880      6175          ext.w     D0
00003828  48C0      6176          ext.l     D0
0000382A  0C80 0000 6177          cmp.l     #115,D0
0000382E  0073      
00003830  6618      6178          bne.s     vsprintf_48
00003832  0C85 0000 6179          cmp.l     #0,D5
00003836  0000      
00003838  6D10      6180          blt.s     vsprintf_48
0000383A  4884      6181          ext.w     D4
0000383C  48C4      6182          ext.l     D4
0000383E  B885      6183          cmp.l     D5,D4
00003840  6F04      6184          ble.s     vsprintf_50
00003842  1005      6185          move.b    D5,D0
00003844  6002      6186          bra.s     vsprintf_51
                    6187   vsprintf_50:
00003846  1004      6188          move.b    D4,D0
                    6189   vsprintf_51:
00003848  1800      6190          move.b    D0,D4
                    6191   vsprintf_48:
0000384A  206E 000C 6192          move.l    12(A6),A0
0000384E  1010      6193          move.b    (A0),D0
00003850  4880      6194          ext.w     D0
00003852  48C0      6195          ext.l     D0
00003854  0C80 0000 6196          cmp.l     #88,D0
00003858  0058      
0000385A  6600 0026 6197          bne       vsprintf_56
0000385E  41EE FFDC 6198          lea       -36(A6),A0
00003862  2408      6199          move.l    A0,D2
                    6200   vsprintf_54:
00003864  2042      6201          move.l    D2,A0
00003866  4A10      6202          tst.b     (A0)
00003868  6718      6203          beq.s     vsprintf_56
0000386A  2042      6204          move.l    D2,A0
0000386C  1210      6205          move.b    (A0),D1
0000386E  4881      6206          ext.w     D1
00003870  48C1      6207          ext.l     D1
00003872  2F01      6208          move.l    D1,-(A7)
00003874  6100 FB98 6209          bsr       _toupper
00003878  584F      6210          addq.w    #4,A7
0000387A  2042      6211          move.l    D2,A0
0000387C  1080      6212          move.b    D0,(A0)
0000387E  5282      6213          addq.l    #1,D2
00003880  60E2      6214          bra       vsprintf_54
                    6215   vsprintf_56:
00003882  7E00      6216          moveq     #0,D7
00003884  41EE FFD4 6217          lea       -44(A6),A0
00003888  2408      6218          move.l    A0,D2
0000388A  206E 000C 6219          move.l    12(A6),A0
0000388E  1010      6220          move.b    (A0),D0
00003890  4880      6221          ext.w     D0
00003892  48C0      6222          ext.l     D0
00003894  0C80 0000 6223          cmp.l     #100,D0
00003898  0064      
0000389A  6714      6224          beq.s     vsprintf_59
0000389C  206E 000C 6225          move.l    12(A6),A0
000038A0  1010      6226          move.b    (A0),D0
000038A2  4880      6227          ext.w     D0
000038A4  48C0      6228          ext.l     D0
000038A6  0C80 0000 6229          cmp.l     #105,D0
000038AA  0069      
000038AC  6600 0076 6230          bne       vsprintf_65
                    6231   vsprintf_59:
000038B0  4A2E FFCE 6232          tst.b     -50(A6)
000038B4  6612      6233          bne.s     vsprintf_62
000038B6  2043      6234          move.l    D3,A0
000038B8  1010      6235          move.b    (A0),D0
000038BA  4880      6236          ext.w     D0
000038BC  48C0      6237          ext.l     D0
000038BE  0C80 0000 6238          cmp.l     #45,D0
000038C2  002D      
000038C4  6600 002E 6239          bne       vsprintf_60
                    6240   vsprintf_62:
000038C8  2043      6241          move.l    D3,A0
000038CA  1010      6242          move.b    (A0),D0
000038CC  4880      6243          ext.w     D0
000038CE  48C0      6244          ext.l     D0
000038D0  0C80 0000 6245          cmp.l     #45,D0
000038D4  002D      
000038D6  660E      6246          bne.s     vsprintf_63
000038D8  2043      6247          move.l    D3,A0
000038DA  5283      6248          addq.l    #1,D3
000038DC  2242      6249          move.l    D2,A1
000038DE  5282      6250          addq.l    #1,D2
000038E0  1290      6251          move.b    (A0),(A1)
000038E2  5304      6252          subq.b    #1,D4
000038E4  6008      6253          bra.s     vsprintf_64
                    6254   vsprintf_63:
000038E6  2042      6255          move.l    D2,A0
000038E8  5282      6256          addq.l    #1,D2
000038EA  10BC 002B 6257          move.b    #43,(A0)
                    6258   vsprintf_64:
000038EE  5287      6259          addq.l    #1,D7
000038F0  6000 0032 6260          bra       vsprintf_65
                    6261   vsprintf_60:
000038F4  4A2E FFCF 6262          tst.b     -49(A6)
000038F8  6700 002A 6263          beq       vsprintf_65
000038FC  2043      6264          move.l    D3,A0
000038FE  1010      6265          move.b    (A0),D0
00003900  4880      6266          ext.w     D0
00003902  48C0      6267          ext.l     D0
00003904  0C80 0000 6268          cmp.l     #45,D0
00003908  002D      
0000390A  660E      6269          bne.s     vsprintf_67
0000390C  2043      6270          move.l    D3,A0
0000390E  5283      6271          addq.l    #1,D3
00003910  2242      6272          move.l    D2,A1
00003912  5282      6273          addq.l    #1,D2
00003914  1290      6274          move.b    (A0),(A1)
00003916  5304      6275          subq.b    #1,D4
00003918  6008      6276          bra.s     vsprintf_68
                    6277   vsprintf_67:
0000391A  2042      6278          move.l    D2,A0
0000391C  5282      6279          addq.l    #1,D2
0000391E  10BC 0020 6280          move.b    #32,(A0)
                    6281   vsprintf_68:
00003922  5287      6282          addq.l    #1,D7
                    6283   vsprintf_65:
00003924  4A2E FFD0 6284          tst.b     -48(A6)
00003928  6700 0066 6285          beq       vsprintf_77
0000392C  206E 000C 6286          move.l    12(A6),A0
00003930  1010      6287          move.b    (A0),D0
00003932  4880      6288          ext.w     D0
00003934  48C0      6289          ext.l     D0
00003936  0C80 0000 6290          cmp.l     #111,D0
0000393A  006F      
0000393C  671A      6291          beq.s     vsprintf_73
0000393E  6E0C      6292          bgt.s     vsprintf_76
00003940  0C80 0000 6293          cmp.l     #88,D0
00003944  0058      
00003946  6710      6294          beq.s     vsprintf_73
00003948  6000 0046 6295          bra       vsprintf_77
                    6296   vsprintf_76:
0000394C  0C80 0000 6297          cmp.l     #120,D0
00003950  0078      
00003952  6704      6298          beq.s     vsprintf_73
00003954  6000 003A 6299          bra       vsprintf_77
                    6300   vsprintf_73:
00003958  2042      6301          move.l    D2,A0
0000395A  5282      6302          addq.l    #1,D2
0000395C  10BC 0030 6303          move.b    #48,(A0)
00003960  5287      6304          addq.l    #1,D7
00003962  206E 000C 6305          move.l    12(A6),A0
00003966  1010      6306          move.b    (A0),D0
00003968  4880      6307          ext.w     D0
0000396A  48C0      6308          ext.l     D0
0000396C  0C80 0000 6309          cmp.l     #120,D0
00003970  0078      
00003972  6712      6310          beq.s     vsprintf_79
00003974  206E 000C 6311          move.l    12(A6),A0
00003978  1010      6312          move.b    (A0),D0
0000397A  4880      6313          ext.w     D0
0000397C  48C0      6314          ext.l     D0
0000397E  0C80 0000 6315          cmp.l     #88,D0
00003982  0058      
00003984  660A      6316          bne.s     vsprintf_77
                    6317   vsprintf_79:
00003986  2042      6318          move.l    D2,A0
00003988  5282      6319          addq.l    #1,D2
0000398A  10BC 0078 6320          move.b    #120,(A0)
0000398E  5287      6321          addq.l    #1,D7
                    6322   vsprintf_77:
00003990  2042      6323          move.l    D2,A0
00003992  4210      6324          clr.b     (A0)
00003994  206E 000C 6325          move.l    12(A6),A0
00003998  1010      6326          move.b    (A0),D0
0000399A  4880      6327          ext.w     D0
0000399C  48C0      6328          ext.l     D0
0000399E  0C80 0000 6329          cmp.l     #105,D0
000039A2  0069      
000039A4  6700 0076 6330          beq       vsprintf_82
000039A8  6E42      6331          bgt.s     vsprintf_93
000039AA  0C80 0000 6332          cmp.l     #99,D0
000039AE  0063      
000039B0  6700 0084 6333          beq       vsprintf_96
000039B4  6E1C      6334          bgt.s     vsprintf_94
000039B6  0C80 0000 6335          cmp.l     #88,D0
000039BA  0058      
000039BC  6700 005E 6336          beq       vsprintf_82
000039C0  6E00 0184 6337          bgt       vsprintf_80
000039C4  0C80 0000 6338          cmp.l     #69,D0
000039C8  0045      
000039CA  6700 0050 6339          beq       vsprintf_82
000039CE  6000 0176 6340          bra       vsprintf_80
                    6341   vsprintf_94:
000039D2  0C80 0000 6342          cmp.l     #101,D0
000039D6  0065      
000039D8  6700 0042 6343          beq       vsprintf_82
000039DC  6E00 0168 6344          bgt       vsprintf_80
000039E0  0C80 0000 6345          cmp.l     #100,D0
000039E4  0064      
000039E6  6734      6346          beq.s     vsprintf_82
000039E8  6000 015C 6347          bra       vsprintf_80
                    6348   vsprintf_93:
000039EC  0C80 0000 6349          cmp.l     #117,D0
000039F0  0075      
000039F2  6728      6350          beq.s     vsprintf_82
000039F4  6E1A      6351          bgt.s     vsprintf_95
000039F6  0C80 0000 6352          cmp.l     #115,D0
000039FA  0073      
000039FC  6700 0038 6353          beq       vsprintf_96
00003A00  6E00 0144 6354          bgt       vsprintf_80
00003A04  0C80 0000 6355          cmp.l     #111,D0
00003A08  006F      
00003A0A  6710      6356          beq.s     vsprintf_82
00003A0C  6000 0138 6357          bra       vsprintf_80
                    6358   vsprintf_95:
00003A10  0C80 0000 6359          cmp.l     #120,D0
00003A14  0078      
00003A16  6704      6360          beq.s     vsprintf_82
00003A18  6000 012C 6361          bra       vsprintf_80
                    6362   vsprintf_82:
00003A1C  4A2E FFD2 6363          tst.b     -46(A6)
00003A20  6714      6364          beq.s     vsprintf_96
00003A22  4A2E FFCD 6365          tst.b     -51(A6)
00003A26  660E      6366          bne.s     vsprintf_96
00003A28  200D      6367          move.l    A5,D0
00003A2A  9087      6368          sub.l     D7,D0
00003A2C  4884      6369          ext.w     D4
00003A2E  48C4      6370          ext.l     D4
00003A30  9084      6371          sub.l     D4,D0
00003A32  2D40 FFFC 6372          move.l    D0,-4(A6)
                    6373   vsprintf_96:
00003A36  202E FFFC 6374          move.l    -4(A6),D0
00003A3A  0C80 0000 6375          cmp.l     #0,D0
00003A3E  0000      
00003A40  6C04      6376          bge.s     vsprintf_98
00003A42  42AE FFFC 6377          clr.l     -4(A6)
                    6378   vsprintf_98:
00003A46  4A2E FFCD 6379          tst.b     -51(A6)
00003A4A  6600 0030 6380          bne       vsprintf_104
00003A4E  4884      6381          ext.w     D4
00003A50  48C4      6382          ext.l     D4
00003A52  2004      6383          move.l    D4,D0
00003A54  D0AE FFFC 6384          add.l     -4(A6),D0
00003A58  D087      6385          add.l     D7,D0
00003A5A  1D40 FFD1 6386          move.b    D0,-47(A6)
                    6387   vsprintf_102:
00003A5E  102E FFD1 6388          move.b    -47(A6),D0
00003A62  4880      6389          ext.w     D0
00003A64  48C0      6390          ext.l     D0
00003A66  220D      6391          move.l    A5,D1
00003A68  534D      6392          subq.w    #1,A5
00003A6A  B081      6393          cmp.l     D1,D0
00003A6C  6C0E      6394          bge.s     vsprintf_104
00003A6E  4878 0020 6395          pea       32
00003A72  2F0A      6396          move.l    A2,-(A7)
00003A74  4E93      6397          jsr       (A3)
00003A76  504F      6398          addq.w    #8,A7
00003A78  5286      6399          addq.l    #1,D6
00003A7A  60E2      6400          bra       vsprintf_102
                    6401   vsprintf_104:
00003A7C  41EE FFD4 6402          lea       -44(A6),A0
00003A80  2408      6403          move.l    A0,D2
                    6404   vsprintf_105:
00003A82  2042      6405          move.l    D2,A0
00003A84  4A10      6406          tst.b     (A0)
00003A86  6716      6407          beq.s     vsprintf_107
00003A88  2042      6408          move.l    D2,A0
00003A8A  5282      6409          addq.l    #1,D2
00003A8C  1210      6410          move.b    (A0),D1
00003A8E  4881      6411          ext.w     D1
00003A90  48C1      6412          ext.l     D1
00003A92  2F01      6413          move.l    D1,-(A7)
00003A94  2F0A      6414          move.l    A2,-(A7)
00003A96  4E93      6415          jsr       (A3)
00003A98  504F      6416          addq.w    #8,A7
00003A9A  5286      6417          addq.l    #1,D6
00003A9C  60E4      6418          bra       vsprintf_105
                    6419   vsprintf_107:
00003A9E  202E FFFC 6420          move.l    -4(A6),D0
00003AA2  1D40 FFD1 6421          move.b    D0,-47(A6)
                    6422   vsprintf_108:
00003AA6  102E FFD1 6423          move.b    -47(A6),D0
00003AAA  532E FFD1 6424          subq.b    #1,-47(A6)
00003AAE  4A00      6425          tst.b     D0
00003AB0  670E      6426          beq.s     vsprintf_110
00003AB2  4878 0030 6427          pea       48
00003AB6  2F0A      6428          move.l    A2,-(A7)
00003AB8  4E93      6429          jsr       (A3)
00003ABA  504F      6430          addq.w    #8,A7
00003ABC  5286      6431          addq.l    #1,D6
00003ABE  60E6      6432          bra       vsprintf_108
                    6433   vsprintf_110:
00003AC0  2043      6434          move.l    D3,A0
00003AC2  4A10      6435          tst.b     (A0)
00003AC4  6700 0048 6436          beq       vsprintf_113
00003AC8  206E 000C 6437          move.l    12(A6),A0
00003ACC  1010      6438          move.b    (A0),D0
00003ACE  4880      6439          ext.w     D0
00003AD0  48C0      6440          ext.l     D0
00003AD2  0C80 0000 6441          cmp.l     #115,D0
00003AD6  0073      
00003AD8  670C      6442          beq.s     vsprintf_116
00003ADA  6E18      6443          bgt.s     vsprintf_119
00003ADC  0C80 0000 6444          cmp.l     #99,D0
00003AE0  0063      
00003AE2  6702      6445          beq.s     vsprintf_116
00003AE4  600E      6446          bra.s     vsprintf_119
                    6447   vsprintf_116:
00003AE6  2005      6448          move.l    D5,D0
00003AE8  5385      6449          subq.l    #1,D5
00003AEA  0C80 0000 6450          cmp.l     #0,D0
00003AEE  0000      
00003AF0  6E02      6451          bgt.s     vsprintf_119
00003AF2  6016      6452          bra.s     vsprintf_115
                    6453   vsprintf_119:
00003AF4  2043      6454          move.l    D3,A0
00003AF6  5283      6455          addq.l    #1,D3
00003AF8  1210      6456          move.b    (A0),D1
00003AFA  4881      6457          ext.w     D1
00003AFC  48C1      6458          ext.l     D1
00003AFE  2F01      6459          move.l    D1,-(A7)
00003B00  2F0A      6460          move.l    A2,-(A7)
00003B02  4E93      6461          jsr       (A3)
00003B04  504F      6462          addq.w    #8,A7
00003B06  5286      6463          addq.l    #1,D6
00003B08  6002      6464          bra.s     vsprintf_112
                    6465   vsprintf_115:
00003B0A  6002      6466          bra.s     vsprintf_113
                    6467   vsprintf_112:
00003B0C  60B2      6468          bra       vsprintf_110
                    6469   vsprintf_113:
00003B0E  4A2E FFCD 6470          tst.b     -51(A6)
00003B12  6700 0030 6471          beq       vsprintf_125
00003B16  4884      6472          ext.w     D4
00003B18  48C4      6473          ext.l     D4
00003B1A  2004      6474          move.l    D4,D0
00003B1C  D0AE FFFC 6475          add.l     -4(A6),D0
00003B20  D087      6476          add.l     D7,D0
00003B22  1D40 FFD1 6477          move.b    D0,-47(A6)
                    6478   vsprintf_123:
00003B26  102E FFD1 6479          move.b    -47(A6),D0
00003B2A  4880      6480          ext.w     D0
00003B2C  48C0      6481          ext.l     D0
00003B2E  220D      6482          move.l    A5,D1
00003B30  534D      6483          subq.w    #1,A5
00003B32  B081      6484          cmp.l     D1,D0
00003B34  6C0E      6485          bge.s     vsprintf_125
00003B36  4878 0020 6486          pea       32
00003B3A  2F0A      6487          move.l    A2,-(A7)
00003B3C  4E93      6488          jsr       (A3)
00003B3E  504F      6489          addq.w    #8,A7
00003B40  5386      6490          subq.l    #1,D6
00003B42  60E2      6491          bra       vsprintf_123
                    6492   vsprintf_125:
00003B44  6014      6493          bra.s     vsprintf_81
                    6494   vsprintf_80:
00003B46  206E 000C 6495          move.l    12(A6),A0
00003B4A  1210      6496          move.b    (A0),D1
00003B4C  4881      6497          ext.w     D1
00003B4E  48C1      6498          ext.l     D1
00003B50  2F01      6499          move.l    D1,-(A7)
00003B52  2F0A      6500          move.l    A2,-(A7)
00003B54  4E93      6501          jsr       (A3)
00003B56  504F      6502          addq.w    #8,A7
00003B58  5286      6503          addq.l    #1,D6
                    6504   vsprintf_81:
00003B5A  52AE 000C 6505          addq.l    #1,12(A6)
                    6506   vsprintf_2:
00003B5E  6000 F9D6 6507          bra       vsprintf_1
                    6508   vsprintf_3:
00003B62  4A92      6509          tst.l     (A2)
00003B64  6710      6510          beq.s     vsprintf_126
00003B66  4201      6511          clr.b     D1
00003B68  C2BC 0000 6512          and.l     #255,D1
00003B6C  00FF      
00003B6E  2F01      6513          move.l    D1,-(A7)
00003B70  2F0A      6514          move.l    A2,-(A7)
00003B72  4E93      6515          jsr       (A3)
00003B74  504F      6516          addq.w    #8,A7
                    6517   vsprintf_126:
00003B76  2006      6518          move.l    D6,D0
00003B78  4CDF 3CFC 6519          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00003B7C  4E5E      6520          unlk      A6
00003B7E  4E75      6521          rts
                    6522   @itoa_convert:
00003B80  4E56 0000 6523          link      A6,#0
00003B84  48E7 3C00 6524          movem.l   D2/D3/D4/D5,-(A7)
00003B88  242E 0008 6525          move.l    8(A6),D2
00003B8C  262E 0010 6526          move.l    16(A6),D3
00003B90  2A2E 000C 6527          move.l    12(A6),D5
00003B94  2F05      6528          move.l    D5,-(A7)
00003B96  2F03      6529          move.l    D3,-(A7)
00003B98  6100 F6B4 6530          bsr       ULDIV
00003B9C  202F 0004 6531          move.l    4(A7),D0
00003BA0  504F      6532          addq.w    #8,A7
00003BA2  2800      6533          move.l    D0,D4
00003BA4  BA83      6534          cmp.l     D3,D5
00003BA6  651A      6535          blo.s     @itoa_convert_1
00003BA8  2F03      6536          move.l    D3,-(A7)
00003BAA  2F05      6537          move.l    D5,-(A7)
00003BAC  2F03      6538          move.l    D3,-(A7)
00003BAE  6100 F69E 6539          bsr       ULDIV
00003BB2  2217      6540          move.l    (A7),D1
00003BB4  504F      6541          addq.w    #8,A7
00003BB6  2F01      6542          move.l    D1,-(A7)
00003BB8  2F02      6543          move.l    D2,-(A7)
00003BBA  61C4      6544          bsr       @itoa_convert
00003BBC  DEFC 000C 6545          add.w     #12,A7
00003BC0  2400      6546          move.l    D0,D2
                    6547   @itoa_convert_1:
00003BC2  0C84 0000 6548          cmp.l     #9,D4
00003BC6  0009      
00003BC8  6E0A      6549          bgt.s     @itoa_convert_3
00003BCA  2004      6550          move.l    D4,D0
00003BCC  0680 0000 6551          add.l     #48,D0
00003BD0  0030      
00003BD2  600E      6552          bra.s     @itoa_convert_4
                    6553   @itoa_convert_3:
00003BD4  2004      6554          move.l    D4,D0
00003BD6  0680 0000 6555          add.l     #97,D0
00003BDA  0061      
00003BDC  0480 0000 6556          sub.l     #10,D0
00003BE0  000A      
                    6557   @itoa_convert_4:
00003BE2  2042      6558          move.l    D2,A0
00003BE4  1080      6559          move.b    D0,(A0)
00003BE6  2002      6560          move.l    D2,D0
00003BE8  5280      6561          addq.l    #1,D0
00003BEA  4CDF 003C 6562          movem.l   (A7)+,D2/D3/D4/D5
00003BEE  4E5E      6563          unlk      A6
00003BF0  4E75      6564          rts
                    6565   _ltoa:
00003BF2  4E56 0000 6566          link      A6,#0
00003BF6  48E7 3C00 6567          movem.l   D2/D3/D4/D5,-(A7)
00003BFA  242E 0008 6568          move.l    8(A6),D2
00003BFE  262E 000C 6569          move.l    12(A6),D3
00003C02  2A2E 0010 6570          move.l    16(A6),D5
00003C06  2803      6571          move.l    D3,D4
00003C08  0C85 0000 6572          cmp.l     #2,D5
00003C0C  0002      
00003C0E  6D08      6573          blt.s     ltoa_3
00003C10  0C85 0000 6574          cmp.l     #36,D5
00003C14  0024      
00003C16  6F06      6575          ble.s     ltoa_1
                    6576   ltoa_3:
00003C18  2003      6577          move.l    D3,D0
00003C1A  6000 0052 6578          bra       ltoa_4
                    6579   ltoa_1:
00003C1E  0C85 0000 6580          cmp.l     #10,D5
00003C22  000A      
00003C24  6600 0032 6581          bne       ltoa_5
00003C28  0C82 0000 6582          cmp.l     #0,D2
00003C2C  0000      
00003C2E  6C28      6583          bge.s     ltoa_5
00003C30  2002      6584          move.l    D2,D0
00003C32  4480      6585          neg.l     D0
00003C34  2400      6586          move.l    D0,D2
00003C36  0C82 0000 6587          cmp.l     #0,D2
00003C3A  0000      
00003C3C  6C12      6588          bge.s     ltoa_7
00003C3E  4879 0000 6589          pea       @itoa_1
00003C42  52E0      
00003C44  2F03      6590          move.l    D3,-(A7)
00003C46  6100 F5F6 6591          bsr       _strcpy
00003C4A  504F      6592          addq.w    #8,A7
00003C4C  2003      6593          move.l    D3,D0
00003C4E  601E      6594          bra.s     ltoa_4
                    6595   ltoa_7:
00003C50  2044      6596          move.l    D4,A0
00003C52  5284      6597          addq.l    #1,D4
00003C54  10BC 002D 6598          move.b    #45,(A0)
                    6599   ltoa_5:
00003C58  2F05      6600          move.l    D5,-(A7)
00003C5A  2F02      6601          move.l    D2,-(A7)
00003C5C  2F04      6602          move.l    D4,-(A7)
00003C5E  6100 FF20 6603          bsr       @itoa_convert
00003C62  DEFC 000C 6604          add.w     #12,A7
00003C66  2800      6605          move.l    D0,D4
00003C68  2044      6606          move.l    D4,A0
00003C6A  4210      6607          clr.b     (A0)
00003C6C  2003      6608          move.l    D3,D0
                    6609   ltoa_4:
00003C6E  4CDF 003C 6610          movem.l   (A7)+,D2/D3/D4/D5
00003C72  4E5E      6611          unlk      A6
00003C74  4E75      6612          rts
                    6613   _ultoa:
00003C76  4E56 0000 6614          link      A6,#0
00003C7A  48E7 3800 6615          movem.l   D2/D3/D4,-(A7)
00003C7E  262E 0010 6616          move.l    16(A6),D3
00003C82  282E 000C 6617          move.l    12(A6),D4
00003C86  2404      6618          move.l    D4,D2
00003C88  0C83 0000 6619          cmp.l     #2,D3
00003C8C  0002      
00003C8E  6D08      6620          blt.s     ultoa_3
00003C90  0C83 0000 6621          cmp.l     #36,D3
00003C94  0024      
00003C96  6F04      6622          ble.s     ultoa_1
                    6623   ultoa_3:
00003C98  2004      6624          move.l    D4,D0
00003C9A  6018      6625          bra.s     ultoa_4
                    6626   ultoa_1:
00003C9C  2F03      6627          move.l    D3,-(A7)
00003C9E  2F2E 0008 6628          move.l    8(A6),-(A7)
00003CA2  2F02      6629          move.l    D2,-(A7)
00003CA4  6100 FEDA 6630          bsr       @itoa_convert
00003CA8  DEFC 000C 6631          add.w     #12,A7
00003CAC  2400      6632          move.l    D0,D2
00003CAE  2042      6633          move.l    D2,A0
00003CB0  4210      6634          clr.b     (A0)
00003CB2  2004      6635          move.l    D4,D0
                    6636   ultoa_4:
00003CB4  4CDF 001C 6637          movem.l   (A7)+,D2/D3/D4
00003CB8  4E5E      6638          unlk      A6
00003CBA  4E75      6639          rts
                    6640   _itoa:
00003CBC  4E56 0000 6641          link      A6,#0
00003CC0  2F2E 0010 6642          move.l    16(A6),-(A7)
00003CC4  2F2E 000C 6643          move.l    12(A6),-(A7)
00003CC8  2F2E 0008 6644          move.l    8(A6),-(A7)
00003CCC  6100 FF24 6645          bsr       _ltoa
00003CD0  DEFC 000C 6646          add.w     #12,A7
00003CD4  4E5E      6647          unlk      A6
00003CD6  4E75      6648          rts
                    6649   ULMUL:
00003CD8  4E56 0000 6650          link    A6,#0
00003CDC  48E7 C000 6651          movem.l D0/D1,-(A7)
00003CE0  222E 0008 6652          move.l  8(A6),D1
00003CE4  202E 000C 6653          move.l  12(A6),D0
00003CE8  602C      6654          bra.s   lmul_3
                    6655   LMUL:
00003CEA  4E56 0000 6656          link    A6,#0
00003CEE  48E7 C000 6657          movem.l D0/D1,-(A7)
00003CF2  222E 0008 6658          move.l  8(A6),D1
00003CF6  202E 000C 6659          move.l  12(A6),D0
00003CFA  4A80      6660          tst.l   D0
00003CFC  6A0A      6661          bpl.s   lmul_1
00003CFE  4480      6662          neg.l   D0
00003D00  4A81      6663          tst.l   D1
00003D02  6A0A      6664          bpl.s   lmul_2
00003D04  4481      6665          neg.l   D1
00003D06  600E      6666          bra.s   lmul_3
                    6667   lmul_1:
00003D08  4A81      6668          tst.l   D1
00003D0A  6A0A      6669          bpl.s   lmul_3
00003D0C  4481      6670          neg.l   D1
                    6671   lmul_2:
00003D0E  6114      6672          bsr.s   domul
00003D10  4481      6673          neg.l   D1
00003D12  4080      6674          negx.l  D0
00003D14  6002      6675          bra.s   lmul_4
                    6676   lmul_3:
00003D16  610C      6677          bsr.s   domul
                    6678   lmul_4:
00003D18  2D41 0008 6679          move.l  D1,8(A6)
00003D1C  4CDF 0003 6680          movem.l (A7)+,D0/D1
00003D20  4E5E      6681          unlk    A6
00003D22  4E75      6682          rts
                    6683   domul:
00003D24  0C81 0000 6684          cmpi.l  #$FFFF,D1
00003D28  FFFF      
00003D2A  620C      6685          bhi.s   domul_1
00003D2C  0C80 0000 6686          cmpi.l  #$FFFF,D0
00003D30  FFFF      
00003D32  620E      6687          bhi.s   domul_2
00003D34  C2C0      6688          mulu    D0,D1
00003D36  4E75      6689          rts
                    6690   domul_1:
00003D38  0C80 0000 6691          cmpi.l  #$FFFF,D0
00003D3C  FFFF      
00003D3E  6218      6692          bhi.s   domul_4
00003D40  6002      6693          bra.s   domul_3
                    6694   domul_2
00003D42  C141      6695          exg     D0,D1
                    6696   domul_3:
00003D44  2F02      6697          move.l  D2,-(A7)
00003D46  2401      6698          move.l  D1,D2
00003D48  4842      6699          swap    D2
00003D4A  C2C0      6700          mulu    D0,D1
00003D4C  C4C0      6701          mulu    D0,D2
00003D4E  4842      6702          swap    D2
00003D50  4242      6703          clr.w   D2
00003D52  D282      6704          add.l   D2,D1
00003D54  241F      6705          move.l  (A7)+,D2
00003D56  4E75      6706          rts
                    6707   domul_4:
00003D58  48E7 3000 6708          movem.l D2/D3,-(A7)
00003D5C  2401      6709          move.l  D1,D2
00003D5E  2601      6710          move.l  D1,D3
00003D60  C2C0      6711          mulu    D0,D1
00003D62  4842      6712          swap    D2
00003D64  C4C0      6713          mulu    D0,D2
00003D66  4840      6714          swap    D0
00003D68  C6C0      6715          mulu    D0,D3
00003D6A  D483      6716          add.l   D3,D2
00003D6C  4842      6717          swap    D2
00003D6E  4242      6718          clr.w   D2
00003D70  D282      6719          add.l   D2,D1
00003D72  4CDF 000C 6720          movem.l (A7)+,D2/D3
00003D76  4E75      6721          rts
                    6722   _strlen:
00003D78  206F 0004 6723          move.l    (4,A7),A0
00003D7C  2248      6724          move.l    A0,A1
                    6725   strlen_1:
00003D7E  4A19      6726          tst.b     (A1)+
00003D80  66FC      6727          bne       strlen_1
00003D82  2009      6728          move.l    A1,D0
00003D84  9088      6729          sub.l     A0,D0
00003D86  5380      6730          subq.l    #1,D0
00003D88  4E75      6731          rts
                    6732          section   const
                    6733   
                    6734   @m68kde~1_1:
00003D8A  0D0A 00   6735          dc.b      13,10,0
                    6736   @m68kde~1_2:
00003D8E  0D53 7769 6737          dc.b      13,83,119,105,116,99,104,101,115,32,83,87,91
00003D92  7463 6865 
00003D96  7320 5357 
00003D9A  5B        
00003D9B  372D 305D 6738          dc.b      55,45,48,93,32,61,32,0
00003D9F  203D 2000 
                    6739   @m68kde~1_3:
00003DA4  3000      6740          dc.b      48,0
                    6741   @m68kde~1_4:
00003DA6  3100      6742          dc.b      49,0
                    6743   @m68kde~1_5:
00003DA8  0D0A 4475 6744          dc.b      13,10,68,117,109,112,32,77,101,109,111,114,121
00003DAC  6D70 204D 
00003DB0  656D 6F72 
00003DB4  79        
00003DB5  2042 6C6F 6745          dc.b      32,66,108,111,99,107,58,32,60,69,83,67,62,32
00003DB9  636B 3A20 
00003DBD  3C45 5343 
00003DC1  3E20      
00003DC3  746F 2041 6746          dc.b      116,111,32,65,98,111,114,116,44,32,60,83,80
00003DC7  626F 7274 
00003DCB  2C20 3C53 
00003DCF  50        
00003DD0  4143 453E 6747          dc.b      65,67,69,62,32,116,111,32,67,111,110,116,105
00003DD4  2074 6F20 
00003DD8  436F 6E74 
00003DDC  69        
00003DDD  6E75 6500 6748          dc.b      110,117,101,0
                    6749   @m68kde~1_6:
00003DE2  0D0A 456E 6750          dc.b      13,10,69,110,116,101,114,32,83,116,97,114,116
00003DE6  7465 7220 
00003DEA  5374 6172 
00003DEE  74        
00003DEF  2041 6464 6751          dc.b      32,65,100,100,114,101,115,115,58,32,0
00003DF3  7265 7373 
00003DF7  3A20 00   
                    6752   @m68kde~1_7:
00003DFA  0D0A 2530 6753          dc.b      13,10,37,48,56,120,32,0
00003DFE  3878 2000 
                    6754   @m68kde~1_8:
00003E02  2530 3258 6755          dc.b      37,48,50,88,0
00003E06  00        
                    6756   @m68kde~1_9:
00003E08  2020 00   6757          dc.b      32,32,0
                    6758   @m68kde~1_10:
00003E0C  0D0A 4669 6759          dc.b      13,10,70,105,108,108,32,77,101,109,111,114,121
00003E10  6C6C 204D 
00003E14  656D 6F72 
00003E18  79        
00003E19  2042 6C6F 6760          dc.b      32,66,108,111,99,107,0
00003E1D  636B 00   
                    6761   @m68kde~1_11:
00003E20  0D0A 456E 6762          dc.b      13,10,69,110,116,101,114,32,69,110,100,32,65
00003E24  7465 7220 
00003E28  456E 6420 
00003E2C  41        
00003E2D  6464 7265 6763          dc.b      100,100,114,101,115,115,58,32,0
00003E31  7373 3A20 
00003E35  00        
                    6764   @m68kde~1_12:
00003E36  0D0A 456E 6765          dc.b      13,10,69,110,116,101,114,32,70,105,108,108,32
00003E3A  7465 7220 
00003E3E  4669 6C6C 
00003E42  20        
00003E43  4461 7461 6766          dc.b      68,97,116,97,58,32,0
00003E47  3A20 00   
                    6767   @m68kde~1_13:
00003E4A  0D0A 4669 6768          dc.b      13,10,70,105,108,108,105,110,103,32,65,100,100
00003E4E  6C6C 696E 
00003E52  6720 4164 
00003E56  64        
00003E57  7265 7373 6769          dc.b      114,101,115,115,101,115,32,91,36,37,48,56,88
00003E5B  6573 205B 
00003E5F  2425 3038 
00003E63  58        
00003E64  202D 2024 6770          dc.b      32,45,32,36,37,48,56,88,93,32,119,105,116,104
00003E68  2530 3858 
00003E6C  5D20 7769 
00003E70  7468      
00003E72  2024 2530 6771          dc.b      32,36,37,48,50,88,0
00003E76  3258 00   
                    6772   @m68kde~1_14:
00003E7A  0D0A 5573 6773          dc.b      13,10,85,115,101,32,72,121,112,101,114,84,101
00003E7E  6520 4879 
00003E82  7065 7254 
00003E86  65        
00003E87  726D 696E 6774          dc.b      114,109,105,110,97,108,32,116,111,32,83,101
00003E8B  616C 2074 
00003E8F  6F20 5365 
00003E93  6E64 2054 6775          dc.b      110,100,32,84,101,120,116,32,70,105,108,101
00003E97  6578 7420 
00003E9B  4669 6C65 
00003E9F  2028 2E68 6776          dc.b      32,40,46,104,101,120,41,13,10,0
00003EA3  6578 290D 
00003EA7  0A00      
                    6777   @m68kde~1_15:
00003EAA  0D0A 4C6F 6778          dc.b      13,10,76,111,97,100,32,70,97,105,108,101,100
00003EAE  6164 2046 
00003EB2  6169 6C65 
00003EB6  64        
00003EB7  2061 7420 6779          dc.b      32,97,116,32,65,100,100,114,101,115,115,32,61
00003EBB  4164 6472 
00003EBF  6573 7320 
00003EC3  3D        
00003EC4  205B 2425 6780          dc.b      32,91,36,37,48,56,88,93,13,10,0
00003EC8  3038 585D 
00003ECC  0D0A 00   
                    6781   @m68kde~1_16:
00003ED0  0D0A 5375 6782          dc.b      13,10,83,117,99,99,101,115,115,58,32,68,111
00003ED4  6363 6573 
00003ED8  733A 2044 
00003EDC  6F        
00003EDD  776E 6C6F 6783          dc.b      119,110,108,111,97,100,101,100,32,37,100,32
00003EE1  6164 6564 
00003EE5  2025 6420 
00003EE9  6279 7465 6784          dc.b      98,121,116,101,115,13,10,0
00003EED  730D 0A00 
                    6785   @m68kde~1_17:
00003EF2  0D0A 4578 6786          dc.b      13,10,69,120,97,109,105,110,101,32,97,110,100
00003EF6  616D 696E 
00003EFA  6520 616E 
00003EFE  64        
00003EFF  2043 6861 6787          dc.b      32,67,104,97,110,103,101,32,77,101,109,111,114
00003F03  6E67 6520 
00003F07  4D65 6D6F 
00003F0B  72        
00003F0C  7900      6788          dc.b      121,0
                    6789   @m68kde~1_18:
00003F0E  0D0A 3C45 6790          dc.b      13,10,60,69,83,67,62,32,116,111,32,83,116,111
00003F12  5343 3E20 
00003F16  746F 2053 
00003F1A  746F      
00003F1C  702C 203C 6791          dc.b      112,44,32,60,83,80,65,67,69,62,32,116,111,32
00003F20  5350 4143 
00003F24  453E 2074 
00003F28  6F20      
00003F2A  4164 7661 6792          dc.b      65,100,118,97,110,99,101,44,32,39,45,39,32,116
00003F2E  6E63 652C 
00003F32  2027 2D27 
00003F36  2074      
00003F38  6F20 476F 6793          dc.b      111,32,71,111,32,66,97,99,107,44,32,60,68,65
00003F3C  2042 6163 
00003F40  6B2C 203C 
00003F44  4441      
00003F46  5441 3E20 6794          dc.b      84,65,62,32,116,111,32,99,104,97,110,103,101
00003F4A  746F 2063 
00003F4E  6861 6E67 
00003F52  65        
00003F53  00        6795          dc.b      0
                    6796   @m68kde~1_19:
00003F54  0D0A 456E 6797          dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
00003F58  7465 7220 
00003F5C  4164 6472 
00003F60  65        
00003F61  7373 3A20 6798          dc.b      115,115,58,32,0
00003F65  00        
                    6799   @m68kde~1_20:
00003F66  0D0A 5B25 6800          dc.b      13,10,91,37,48,56,120,93,32,58,32,37,48,50,120
00003F6A  3038 785D 
00003F6E  203A 2025 
00003F72  3032 78   
00003F75  2020 00   6801          dc.b      32,32,0
                    6802   @m68kde~1_21:
00003F78  0D0A 5761 6803          dc.b      13,10,87,97,114,110,105,110,103,32,67,104,97
00003F7C  726E 696E 
00003F80  6720 4368 
00003F84  61        
00003F85  6E67 6520 6804          dc.b      110,103,101,32,70,97,105,108,101,100,58,32,87
00003F89  4661 696C 
00003F8D  6564 3A20 
00003F91  57        
00003F92  726F 7465 6805          dc.b      114,111,116,101,32,91,37,48,50,120,93,44,32
00003F96  205B 2530 
00003F9A  3278 5D2C 
00003F9E  20        
00003F9F  5265 6164 6806          dc.b      82,101,97,100,32,91,37,48,50,120,93,0
00003FA3  205B 2530 
00003FA7  3278 5D00 
                    6807   @m68kde~1_22:
00003FAC  0D0A 4461 6808          dc.b      13,10,68,97,116,97,32,100,105,115,99,114,101
00003FB0  7461 2064 
00003FB4  6973 6372 
00003FB8  65        
00003FB9  7061 6E63 6809          dc.b      112,97,110,99,121,32,97,116,32,108,111,99,97
00003FBD  7920 6174 
00003FC1  206C 6F63 
00003FC5  61        
00003FC6  7469 6F6E 6810          dc.b      116,105,111,110,58,32,37,120,32,83,68,82,65
00003FCA  3A20 2578 
00003FCE  2053 4452 
00003FD2  41        
00003FD3  4D20 6461 6811          dc.b      77,32,100,97,116,97,58,32,37,120,32,70,108,97
00003FD7  7461 3A20 
00003FDB  2578 2046 
00003FDF  6C61      
00003FE1  7368 2064 6812          dc.b      115,104,32,100,97,116,97,58,32,37,120,0
00003FE5  6174 613A 
00003FE9  2025 7800 
                    6813   @m68kde~1_23:
00003FEE  0D0A 6C6F 6814          dc.b      13,10,108,111,99,97,116,105,111,110,58,32,37
00003FF2  6361 7469 
00003FF6  6F6E 3A20 
00003FFA  25        
00003FFB  7820 5344 6815          dc.b      120,32,83,68,82,65,77,32,100,97,116,97,58,32
00003FFF  5241 4D20 
00004003  6461 7461 
00004007  3A20      
00004009  2578 2046 6816          dc.b      37,120,32,70,108,97,115,104,32,100,97,116,97
0000400D  6C61 7368 
00004011  2064 6174 
00004015  61        
00004016  3A20 2578 6817          dc.b      58,32,37,120,0
0000401A  00        
                    6818   @m68kde~1_24:
0000401C  0D0A 4572 6819          dc.b      13,10,69,114,97,115,105,110,103,32,83,80,73
00004020  6173 696E 
00004024  6720 5350 
00004028  49        
00004029  2066 6C61 6820          dc.b      32,102,108,97,115,104,46,46,46,46,0
0000402D  7368 2E2E 
00004031  2E2E 00   
                    6821   @m68kde~1_25:
00004034  0D0A 5772 6822          dc.b      13,10,87,114,105,116,116,105,110,103,32,116
00004038  6974 7469 
0000403C  6E67 2074 
00004040  6865 2053 6823          dc.b      104,101,32,83,80,73,32,102,108,97,115,104,32
00004044  5049 2066 
00004048  6C61 7368 
0000404C  20        
0000404D  7573 696E 6824          dc.b      117,115,105,110,103,32,83,68,82,65,77,32,100
00004051  6720 5344 
00004055  5241 4D20 
00004059  64        
0000405A  6174 612E 6825          dc.b      97,116,97,46,46,46,46,0
0000405E  2E2E 2E00 
                    6826   @m68kde~1_26:
00004062  0D0A 5265 6827          dc.b      13,10,82,101,97,100,105,110,103,32,116,104,101
00004066  6164 696E 
0000406A  6720 7468 
0000406E  65        
0000406F  2053 5049 6828          dc.b      32,83,80,73,32,102,108,97,115,104,32,100,97
00004073  2066 6C61 
00004077  7368 2064 
0000407B  61        
0000407C  7461 2061 6829          dc.b      116,97,32,97,110,100,32,99,111,109,112,97,114
00004080  6E64 2063 
00004084  6F6D 7061 
00004088  72        
00004089  696E 6720 6830          dc.b      105,110,103,32,116,111,32,83,68,82,65,77,46
0000408D  746F 2053 
00004091  4452 414D 
00004095  2E        
00004096  2E2E 2E00 6831          dc.b      46,46,46,0
                    6832   @m68kde~1_27:
0000409A  0D0A 4C6F 6833          dc.b      13,10,76,111,97,100,105,110,103,32,80,114,111
0000409E  6164 696E 
000040A2  6720 5072 
000040A6  6F        
000040A7  6772 616D 6834          dc.b      103,114,97,109,32,70,114,111,109,32,83,80,73
000040AB  2046 726F 
000040AF  6D20 5350 
000040B3  49        
000040B4  2046 6C61 6835          dc.b      32,70,108,97,115,104,46,46,46,46,0
000040B8  7368 2E2E 
000040BC  2E2E 00   
                    6836   @m68kde~1_28:
000040C0  2425 3038 6837          dc.b      36,37,48,56,88,32,32,0
000040C4  5820 2000 
                    6838   @m68kde~1_29:
000040C8  2000      6839          dc.b      32,0
                    6840   @m68kde~1_30:
000040CA  2E00      6841          dc.b      46,0
                    6842   @m68kde~1_31:
000040CC  2563 00   6843          dc.b      37,99,0
                    6844   @m68kde~1_32:
000040D0  00        6845          dc.b      0
                    6846   @m68kde~1_33:
000040D2  0D0A 0D0A 6847          dc.b      13,10,13,10,32,68,48,32,61,32,36,37,48,56,88
000040D6  2044 3020 
000040DA  3D20 2425 
000040DE  3038 58   
000040E1  2020 4130 6848          dc.b      32,32,65,48,32,61,32,36,37,48,56,88,0
000040E5  203D 2024 
000040E9  2530 3858 
000040ED  00        
                    6849   @m68kde~1_34:
000040EE  0D0A 2044 6850          dc.b      13,10,32,68,49,32,61,32,36,37,48,56,88,32,32
000040F2  3120 3D20 
000040F6  2425 3038 
000040FA  5820 20   
000040FD  4131 203D 6851          dc.b      65,49,32,61,32,36,37,48,56,88,0
00004101  2024 2530 
00004105  3858 00   
                    6852   @m68kde~1_35:
00004108  0D0A 2044 6853          dc.b      13,10,32,68,50,32,61,32,36,37,48,56,88,32,32
0000410C  3220 3D20 
00004110  2425 3038 
00004114  5820 20   
00004117  4132 203D 6854          dc.b      65,50,32,61,32,36,37,48,56,88,0
0000411B  2024 2530 
0000411F  3858 00   
                    6855   @m68kde~1_36:
00004122  0D0A 2044 6856          dc.b      13,10,32,68,51,32,61,32,36,37,48,56,88,32,32
00004126  3320 3D20 
0000412A  2425 3038 
0000412E  5820 20   
00004131  4133 203D 6857          dc.b      65,51,32,61,32,36,37,48,56,88,0
00004135  2024 2530 
00004139  3858 00   
                    6858   @m68kde~1_37:
0000413C  0D0A 2044 6859          dc.b      13,10,32,68,52,32,61,32,36,37,48,56,88,32,32
00004140  3420 3D20 
00004144  2425 3038 
00004148  5820 20   
0000414B  4134 203D 6860          dc.b      65,52,32,61,32,36,37,48,56,88,0
0000414F  2024 2530 
00004153  3858 00   
                    6861   @m68kde~1_38:
00004156  0D0A 2044 6862          dc.b      13,10,32,68,53,32,61,32,36,37,48,56,88,32,32
0000415A  3520 3D20 
0000415E  2425 3038 
00004162  5820 20   
00004165  4135 203D 6863          dc.b      65,53,32,61,32,36,37,48,56,88,0
00004169  2024 2530 
0000416D  3858 00   
                    6864   @m68kde~1_39:
00004170  0D0A 2044 6865          dc.b      13,10,32,68,54,32,61,32,36,37,48,56,88,32,32
00004174  3620 3D20 
00004178  2425 3038 
0000417C  5820 20   
0000417F  4136 203D 6866          dc.b      65,54,32,61,32,36,37,48,56,88,0
00004183  2024 2530 
00004187  3858 00   
                    6867   @m68kde~1_40:
0000418A  0D0A 2044 6868          dc.b      13,10,32,68,55,32,61,32,36,37,48,56,88,32,32
0000418E  3720 3D20 
00004192  2425 3038 
00004196  5820 20   
00004199  4137 203D 6869          dc.b      65,55,32,61,32,36,37,48,56,88,0
0000419D  2024 2530 
000041A1  3858 00   
                    6870   @m68kde~1_41:
000041A4  0D0A 0D0A 6871          dc.b      13,10,13,10,85,83,80,32,61,32,36,37,48,56,88
000041A8  5553 5020 
000041AC  3D20 2425 
000041B0  3038 58   
000041B3  2020 2841 6872          dc.b      32,32,40,65,55,41,32,85,115,101,114,32,83,80
000041B7  3729 2055 
000041BB  7365 7220 
000041BF  5350      
000041C1  00        6873          dc.b      0
                    6874   @m68kde~1_42:
000041C2  0D0A 5353 6875          dc.b      13,10,83,83,80,32,61,32,36,37,48,56,88,32,32
000041C6  5020 3D20 
000041CA  2425 3038 
000041CE  5820 20   
000041D1  2841 3729 6876          dc.b      40,65,55,41,32,83,117,112,101,114,118,105,115
000041D5  2053 7570 
000041D9  6572 7669 
000041DD  73        
000041DE  6F72 2053 6877          dc.b      111,114,32,83,80,0
000041E2  5000      
                    6878   @m68kde~1_43:
000041E4  0D0A 2053 6879          dc.b      13,10,32,83,82,32,61,32,36,37,48,52,88,32,32
000041E8  5220 3D20 
000041EC  2425 3034 
000041F0  5820 20   
000041F3  2000      6880          dc.b      32,0
                    6881   @m68kde~1_44:
000041F6  2020 205B 6882          dc.b      32,32,32,91,0
000041FA  00        
                    6883   @m68kde~1_45:
000041FC  0D0A 2050 6884          dc.b      13,10,32,80,67,32,61,32,36,37,48,56,88,32,32
00004200  4320 3D20 
00004204  2425 3038 
00004208  5820 20   
0000420B  00        6885          dc.b      0
                    6886   @m68kde~1_46:
0000420C  5B40 2042 6887          dc.b      91,64,32,66,82,69,65,75,80,79,73,78,84,93,0
00004210  5245 414B 
00004214  504F 494E 
00004218  545D 00   
                    6888   @m68kde~1_47:
0000421C  0D0A 5750 6889          dc.b      13,10,87,80,37,100,32,61,32,37,115,0
00004220  2564 203D 
00004224  2025 7300 
                    6890   @m68kde~1_48:
00004228  0D0A 0D0A 6891          dc.b      13,10,13,10,13,10,13,10,13,10,13,10,83,105,110
0000422C  0D0A 0D0A 
00004230  0D0A 0D0A 
00004234  5369 6E   
00004237  676C 6520 6892          dc.b      103,108,101,32,83,116,101,112,32,32,58,91,79
0000423B  5374 6570 
0000423F  2020 3A5B 
00004243  4F        
00004244  4E5D 00   6893          dc.b      78,93,0
                    6894   @m68kde~1_49:
00004248  0D0A 4272 6895          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000424C  6561 6B20 
00004250  506F 696E 
00004254  74        
00004255  7320 3A5B 6896          dc.b      115,32,58,91,68,105,115,97,98,108,101,100,93
00004259  4469 7361 
0000425D  626C 6564 
00004261  5D        
00004262  00        6897          dc.b      0
                    6898   @m68kde~1_50:
00004264  0D0A 5072 6899          dc.b      13,10,80,114,101,115,115,32,60,83,80,65,67,69
00004268  6573 7320 
0000426C  3C53 5041 
00004270  4345      
00004272  3E20 746F 6900          dc.b      62,32,116,111,32,69,120,101,99,117,116,101,32
00004276  2045 7865 
0000427A  6375 7465 
0000427E  20        
0000427F  4E65 7874 6901          dc.b      78,101,120,116,32,73,110,115,116,114,117,99
00004283  2049 6E73 
00004287  7472 7563 
0000428B  7469 6F6E 6902          dc.b      116,105,111,110,0
0000428F  00        
                    6903   @m68kde~1_51:
00004290  0D0A 5072 6904          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00004294  6573 7320 
00004298  3C45 5343 
0000429C  3E20      
0000429E  746F 2052 6905          dc.b      116,111,32,82,101,115,117,109,101,32,80,114
000042A2  6573 756D 
000042A6  6520 5072 
000042AA  6F67 7261 6906          dc.b      111,103,114,97,109,0
000042AE  6D00      
                    6907   @m68kde~1_52:
000042B0  0D0A 496C 6908          dc.b      13,10,73,108,108,101,103,97,108,32,68,97,116
000042B4  6C65 6761 
000042B8  6C20 4461 
000042BC  74        
000042BD  6120 5265 6909          dc.b      97,32,82,101,103,105,115,116,101,114,32,58,32
000042C1  6769 7374 
000042C5  6572 203A 
000042C9  20        
000042CA  5573 6520 6910          dc.b      85,115,101,32,68,48,45,68,55,46,46,46,46,46
000042CE  4430 2D44 
000042D2  372E 2E2E 
000042D6  2E2E      
000042D8  0D0A 00   6911          dc.b      13,10,0
                    6912   @m68kde~1_53:
000042DC  0D0A 4425 6913          dc.b      13,10,68,37,99,32,61,32,0
000042E0  6320 3D20 
000042E4  00        
                    6914   @m68kde~1_54:
000042E6  0D0A 496C 6915          dc.b      13,10,73,108,108,101,103,97,108,32,65,100,100
000042EA  6C65 6761 
000042EE  6C20 4164 
000042F2  64        
000042F3  7265 7373 6916          dc.b      114,101,115,115,32,82,101,103,105,115,116,101
000042F7  2052 6567 
000042FB  6973 7465 
000042FF  7220 3A20 6917          dc.b      114,32,58,32,85,115,101,32,65,48,45,65,55,46
00004303  5573 6520 
00004307  4130 2D41 
0000430B  372E      
0000430D  2E2E 2E2E 6918          dc.b      46,46,46,46,13,10,0
00004311  0D0A 00   
                    6919   @m68kde~1_55:
00004314  0D0A 4125 6920          dc.b      13,10,65,37,99,32,61,32,0
00004318  6320 3D20 
0000431C  00        
                    6921   @m68kde~1_56:
0000431E  0D0A 5573 6922          dc.b      13,10,85,115,101,114,32,83,80,32,61,32,0
00004322  6572 2053 
00004326  5020 3D20 
0000432A  00        
                    6923   @m68kde~1_57:
0000432C  0D0A 496C 6924          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
00004330  6C65 6761 
00004334  6C20 5265 
00004338  67        
00004339  6973 7465 6925          dc.b      105,115,116,101,114,46,46,46,46,0
0000433D  722E 2E2E 
00004341  2E00      
                    6926   @m68kde~1_58:
00004344  0D0A 5379 6927          dc.b      13,10,83,121,115,116,101,109,32,83,80,32,61
00004348  7374 656D 
0000434C  2053 5020 
00004350  3D        
00004351  2000      6928          dc.b      32,0
                    6929   @m68kde~1_59:
00004354  0D0A 5043 6930          dc.b      13,10,80,67,32,61,32,0
00004358  203D 2000 
                    6931   @m68kde~1_60:
0000435C  0D0A 5352 6932          dc.b      13,10,83,82,32,61,32,0
00004360  203D 2000 
                    6933   @m68kde~1_61:
00004364  0D0A 496C 6934          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
00004368  6C65 6761 
0000436C  6C20 5265 
00004370  67        
00004371  6973 7465 6935          dc.b      105,115,116,101,114,58,32,85,115,101,32,65,48
00004375  723A 2055 
00004379  7365 2041 
0000437D  30        
0000437E  2D41 372C 6936          dc.b      45,65,55,44,32,68,48,45,68,55,44,32,83,83,80
00004382  2044 302D 
00004386  4437 2C20 
0000438A  5353 50   
0000438D  2C20 5553 6937          dc.b      44,32,85,83,80,44,32,80,67,32,111,114,32,83
00004391  502C 2050 
00004395  4320 6F72 
00004399  2053      
0000439B  520D 0A00 6938          dc.b      82,13,10,0
                    6939   @m68kde~1_62:
000043A0  0D0A 0D0A 6940          dc.b      13,10,13,10,78,117,109,32,32,32,32,32,65,100
000043A4  4E75 6D20 
000043A8  2020 2020 
000043AC  4164      
000043AE  6472 6573 6941          dc.b      100,114,101,115,115,32,32,32,32,32,32,73,110
000043B2  7320 2020 
000043B6  2020 2049 
000043BA  6E        
000043BB  7374 7275 6942          dc.b      115,116,114,117,99,116,105,111,110,0
000043BF  6374 696F 
000043C3  6E00      
                    6943   @m68kde~1_63:
000043C6  0D0A 2D2D 6944          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
000043CA  2D20 2020 
000043CE  2020 2D2D 
000043D2  2D2D 2D   
000043D5  2D2D 2D2D 6945          dc.b      45,45,45,45,32,32,32,32,45,45,45,45,45,45,45
000043D9  2020 2020 
000043DD  2D2D 2D2D 
000043E1  2D2D 2D   
000043E4  2D2D 2D2D 6946          dc.b      45,45,45,45,0
000043E8  00        
                    6947   @m68kde~1_64:
000043EA  0D0A 4E6F 6948          dc.b      13,10,78,111,32,66,114,101,97,107,80,111,105
000043EE  2042 7265 
000043F2  616B 506F 
000043F6  69        
000043F7  6E74 7320 6949          dc.b      110,116,115,32,83,101,116,0
000043FB  5365 7400 
                    6950   @m68kde~1_65:
00004400  0D0A 2533 6951          dc.b      13,10,37,51,100,32,32,32,32,32,36,37,48,56,120
00004404  6420 2020 
00004408  2020 2425 
0000440C  3038 78   
0000440F  00        6952          dc.b      0
                    6953   @m68kde~1_66:
00004410  0D0A 4E75 6954          dc.b      13,10,78,117,109,32,32,32,32,32,65,100,100,114
00004414  6D20 2020 
00004418  2020 4164 
0000441C  6472      
0000441E  6573 7300 6955          dc.b      101,115,115,0
                    6956   @m68kde~1_67:
00004422  0D0A 2D2D 6957          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
00004426  2D20 2020 
0000442A  2020 2D2D 
0000442E  2D2D 2D   
00004431  2D2D 2D2D 6958          dc.b      45,45,45,45,0
00004435  00        
                    6959   @m68kde~1_68:
00004436  0D0A 4E6F 6960          dc.b      13,10,78,111,32,87,97,116,99,104,80,111,105
0000443A  2057 6174 
0000443E  6368 506F 
00004442  69        
00004443  6E74 7320 6961          dc.b      110,116,115,32,83,101,116,0
00004447  5365 7400 
                    6962   @m68kde~1_69:
0000444C  0D0A 456E 6963          dc.b      13,10,69,110,116,101,114,32,66,114,101,97,107
00004450  7465 7220 
00004454  4272 6561 
00004458  6B        
00004459  2050 6F69 6964          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
0000445D  6E74 204E 
00004461  756D 6265 
00004465  72        
00004466  3A20 00   6965          dc.b      58,32,0
                    6966   @m68kde~1_70:
0000446A  0D0A 496C 6967          dc.b      13,10,73,108,108,101,103,97,108,32,82,97,110
0000446E  6C65 6761 
00004472  6C20 5261 
00004476  6E        
00004477  6765 203A 6968          dc.b      103,101,32,58,32,85,115,101,32,48,32,45,32,55
0000447B  2055 7365 
0000447F  2030 202D 
00004483  2037      
00004485  00        6969          dc.b      0
                    6970   @m68kde~1_71:
00004486  0D0A 4272 6971          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000448A  6561 6B20 
0000448E  506F 696E 
00004492  74        
00004493  2043 6C65 6972          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
00004497  6172 6564 
0000449B  2E2E 2E2E 
0000449F  2E        
000044A0  0D0A 00   6973          dc.b      13,10,0
                    6974   @m68kde~1_72:
000044A4  0D0A 4272 6975          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
000044A8  6561 6B20 
000044AC  506F 696E 
000044B0  74        
000044B1  2077 6173 6976          dc.b      32,119,97,115,110,39,116,32,83,101,116,46,46
000044B5  6E27 7420 
000044B9  5365 742E 
000044BD  2E        
000044BE  2E2E 2E00 6977          dc.b      46,46,46,0
                    6978   @m68kde~1_73:
000044C2  0D0A 456E 6979          dc.b      13,10,69,110,116,101,114,32,87,97,116,99,104
000044C6  7465 7220 
000044CA  5761 7463 
000044CE  68        
000044CF  2050 6F69 6980          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
000044D3  6E74 204E 
000044D7  756D 6265 
000044DB  72        
000044DC  3A20 00   6981          dc.b      58,32,0
                    6982   @m68kde~1_74:
000044E0  0D0A 5761 6983          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
000044E4  7463 6820 
000044E8  506F 696E 
000044EC  74        
000044ED  2043 6C65 6984          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
000044F1  6172 6564 
000044F5  2E2E 2E2E 
000044F9  2E        
000044FA  0D0A 00   6985          dc.b      13,10,0
                    6986   @m68kde~1_75:
000044FE  0D0A 5761 6987          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00004502  7463 6820 
00004506  506F 696E 
0000450A  74        
0000450B  2057 6173 6988          dc.b      32,87,97,115,32,110,111,116,32,83,101,116,46
0000450F  206E 6F74 
00004513  2053 6574 
00004517  2E        
00004518  2E2E 2E2E 6989          dc.b      46,46,46,46,0
0000451C  00        
                    6990   @m68kde~1_76:
0000451E  0D0A 4E6F 6991          dc.b      13,10,78,111,32,70,82,69,69,32,66,114,101,97
00004522  2046 5245 
00004526  4520 4272 
0000452A  6561      
0000452C  6B20 506F 6992          dc.b      107,32,80,111,105,110,116,115,46,46,46,46,46
00004530  696E 7473 
00004534  2E2E 2E2E 
00004538  2E        
00004539  00        6993          dc.b      0
                    6994   @m68kde~1_77:
0000453A  0D0A 4272 6995          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000453E  6561 6B20 
00004542  506F 696E 
00004546  74        
00004547  2041 6464 6996          dc.b      32,65,100,100,114,101,115,115,58,32,0
0000454B  7265 7373 
0000454F  3A20 00   
                    6997   @m68kde~1_78:
00004552  0D0A 4572 6998          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
00004556  726F 7220 
0000455A  3A20 4272 
0000455E  65        
0000455F  616B 2050 6999          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
00004563  6F69 6E74 
00004567  7320 4341 
0000456B  4E        
0000456C  4E4F 5420 7000          dc.b      78,79,84,32,98,101,32,115,101,116,32,97,116
00004570  6265 2073 
00004574  6574 2061 
00004578  74        
00004579  204F 4444 7001          dc.b      32,79,68,68,32,97,100,100,114,101,115,115,101
0000457D  2061 6464 
00004581  7265 7373 
00004585  65        
00004586  7300      7002          dc.b      115,0
                    7003   @m68kde~1_79:
00004588  0D0A 4572 7004          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
0000458C  726F 7220 
00004590  3A20 4272 
00004594  65        
00004595  616B 2050 7005          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
00004599  6F69 6E74 
0000459D  7320 4341 
000045A1  4E        
000045A2  4E4F 5420 7006          dc.b      78,79,84,32,98,101,32,115,101,116,32,102,111
000045A6  6265 2073 
000045AA  6574 2066 
000045AE  6F        
000045AF  7220 524F 7007          dc.b      114,32,82,79,77,32,105,110,32,82,97,110,103
000045B3  4D20 696E 
000045B7  2052 616E 
000045BB  67        
000045BC  6520 3A20 7008          dc.b      101,32,58,32,91,36,48,45,36,48,48,48,48,55,70
000045C0  5B24 302D 
000045C4  2430 3030 
000045C8  3037 46   
000045CB  4646 5D00 7009          dc.b      70,70,93,0
                    7010   @m68kde~1_80:
000045D0  0D0A 4572 7011          dc.b      13,10,69,114,114,111,114,58,32,66,114,101,97
000045D4  726F 723A 
000045D8  2042 7265 
000045DC  61        
000045DD  6B20 506F 7012          dc.b      107,32,80,111,105,110,116,32,65,108,114,101
000045E1  696E 7420 
000045E5  416C 7265 
000045E9  6164 7920 7013          dc.b      97,100,121,32,69,120,105,115,116,115,32,97,116
000045ED  4578 6973 
000045F1  7473 2061 
000045F5  74        
000045F6  2041 6464 7014          dc.b      32,65,100,100,114,101,115,115,32,58,32,37,48
000045FA  7265 7373 
000045FE  203A 2025 
00004602  30        
00004603  3878 0D0A 7015          dc.b      56,120,13,10,0
00004607  00        
                    7016   @m68kde~1_81:
00004608  0D0A 4272 7017          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000460C  6561 6B20 
00004610  506F 696E 
00004614  74        
00004615  2053 6574 7018          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
00004619  2061 7420 
0000461D  4164 6472 
00004621  65        
00004622  7373 3A20 7019          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
00004626  5B24 2530 
0000462A  3878 5D00 
                    7020   @m68kde~1_82:
0000462E  0D0A 4E6F 7021          dc.b      13,10,78,111,32,70,82,69,69,32,87,97,116,99
00004632  2046 5245 
00004636  4520 5761 
0000463A  7463      
0000463C  6820 506F 7022          dc.b      104,32,80,111,105,110,116,115,46,46,46,46,46
00004640  696E 7473 
00004644  2E2E 2E2E 
00004648  2E        
00004649  00        7023          dc.b      0
                    7024   @m68kde~1_83:
0000464A  0D0A 5761 7025          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
0000464E  7463 6820 
00004652  506F 696E 
00004656  74        
00004657  2041 6464 7026          dc.b      32,65,100,100,114,101,115,115,58,32,0
0000465B  7265 7373 
0000465F  3A20 00   
                    7027   @m68kde~1_84:
00004662  0D0A 4572 7028          dc.b      13,10,69,114,114,111,114,58,32,87,97,116,99
00004666  726F 723A 
0000466A  2057 6174 
0000466E  63        
0000466F  6820 506F 7029          dc.b      104,32,80,111,105,110,116,32,65,108,114,101
00004673  696E 7420 
00004677  416C 7265 
0000467B  6164 7920 7030          dc.b      97,100,121,32,83,101,116,32,97,116,32,65,100
0000467F  5365 7420 
00004683  6174 2041 
00004687  64        
00004688  6472 6573 7031          dc.b      100,114,101,115,115,32,58,32,37,48,56,120,13
0000468C  7320 3A20 
00004690  2530 3878 
00004694  0D        
00004695  0A00      7032          dc.b      10,0
                    7033   @m68kde~1_85:
00004698  0D0A 5761 7034          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
0000469C  7463 6820 
000046A0  506F 696E 
000046A4  74        
000046A5  2053 6574 7035          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
000046A9  2061 7420 
000046AD  4164 6472 
000046B1  65        
000046B2  7373 3A20 7036          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
000046B6  5B24 2530 
000046BA  3878 5D00 
                    7037   @m68kde~1_86:
000046BE  0D0A 0D0A 7038          dc.b      13,10,13,10,13,10,13,10,64,66,82,69,65,75,80
000046C2  0D0A 0D0A 
000046C6  4042 5245 
000046CA  414B 50   
000046CD  4F49 4E54 7039          dc.b      79,73,78,84,0
000046D1  00        
                    7040   @m68kde~1_87:
000046D2  0D0A 5369 7041          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
000046D6  6E67 6C65 
000046DA  2053 7465 
000046DE  70        
000046DF  203A 205B 7042          dc.b      32,58,32,91,79,78,93,0
000046E3  4F4E 5D00 
                    7043   @m68kde~1_88:
000046E8  0D0A 4272 7044          dc.b      13,10,66,114,101,97,107,80,111,105,110,116,115
000046EC  6561 6B50 
000046F0  6F69 6E74 
000046F4  73        
000046F5  203A 205B 7045          dc.b      32,58,32,91,69,110,97,98,108,101,100,93,0
000046F9  456E 6162 
000046FD  6C65 645D 
00004701  00        
                    7046   @m68kde~1_89:
00004702  0D0A 5072 7047          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00004706  6573 7320 
0000470A  3C45 5343 
0000470E  3E20      
00004710  746F 2052 7048          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
00004714  6573 756D 
00004718  6520 5573 
0000471C  6572 2050 7049          dc.b      101,114,32,80,114,111,103,114,97,109,13,10,0
00004720  726F 6772 
00004724  616D 0D0A 
00004728  00        
                    7050   @m68kde~1_90:
0000472A  0D0A 556E 7051          dc.b      13,10,85,110,107,110,111,119,110,32,67,111,109
0000472E  6B6E 6F77 
00004732  6E20 436F 
00004736  6D        
00004737  6D61 6E64 7052          dc.b      109,97,110,100,46,46,46,46,46,13,10,0
0000473B  2E2E 2E2E 
0000473F  2E0D 0A00 
                    7053   @m68kde~1_91:
00004744  0D0A 5072 7054          dc.b      13,10,80,114,111,103,114,97,109,32,69,110,100
00004748  6F67 7261 
0000474C  6D20 456E 
00004750  64        
00004751  6564 2028 7055          dc.b      101,100,32,40,84,82,65,80,32,35,49,53,41,46
00004755  5452 4150 
00004759  2023 3135 
0000475D  292E      
0000475F  2E2E 2E00 7056          dc.b      46,46,46,0
                    7057   @m68kde~1_92:
00004764  0D0A 4B69 7058          dc.b      13,10,75,105,108,108,32,65,108,108,32,66,114
00004768  6C6C 2041 
0000476C  6C6C 2042 
00004770  72        
00004771  6561 6B20 7059          dc.b      101,97,107,32,80,111,105,110,116,115,46,46,46
00004775  506F 696E 
00004779  7473 2E2E 
0000477D  2E        
0000477E  2879 2F6E 7060          dc.b      40,121,47,110,41,63,0
00004782  293F 00   
                    7061   @m68kde~1_93:
00004786  0D0A 4B69 7062          dc.b      13,10,75,105,108,108,32,65,108,108,32,87,97
0000478A  6C6C 2041 
0000478E  6C6C 2057 
00004792  61        
00004793  7463 6820 7063          dc.b      116,99,104,32,80,111,105,110,116,115,46,46,46
00004797  506F 696E 
0000479B  7473 2E2E 
0000479F  2E        
000047A0  2879 2F6E 7064          dc.b      40,121,47,110,41,63,0
000047A4  293F 00   
                    7065   @m68kde~1_94:
000047A8  0D0A 2D2D 7066          dc.b      13,10,45,45,45,45,45,45,45,45,45,45,45,45,45
000047AC  2D2D 2D2D 
000047B0  2D2D 2D2D 
000047B4  2D2D 2D   
000047B7  2D2D 2D2D 7067          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000047BB  2D2D 2D2D 
000047BF  2D2D 2D2D 
000047C3  2D2D 2D   
000047C6  2D2D 2D2D 7068          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000047CA  2D2D 2D2D 
000047CE  2D2D 2D2D 
000047D2  2D2D 2D   
000047D5  2D2D 2D2D 7069          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000047D9  2D2D 2D2D 
000047DD  2D2D 2D2D 
000047E1  2D2D 2D   
000047E4  2D2D 2D2D 7070          dc.b      45,45,45,45,45,45,0
000047E8  2D2D 00   
                    7071   @m68kde~1_95:
000047EC  0D0A 2020 7072          dc.b      13,10,32,32,68,101,98,117,103,103,101,114,32
000047F0  4465 6275 
000047F4  6767 6572 
000047F8  20        
000047F9  436F 6D6D 7073          dc.b      67,111,109,109,97,110,100,32,83,117,109,109
000047FD  616E 6420 
00004801  5375 6D6D 
00004805  6172 7900 7074          dc.b      97,114,121,0
                    7075   @m68kde~1_96:
0000480A  0D0A 2020 7076          dc.b      13,10,32,32,46,40,114,101,103,41,32,32,32,32
0000480E  2E28 7265 
00004812  6729 2020 
00004816  2020      
00004818  2020 202D 7077          dc.b      32,32,32,45,32,67,104,97,110,103,101,32,82,101
0000481C  2043 6861 
00004820  6E67 6520 
00004824  5265      
00004826  6769 7374 7078          dc.b      103,105,115,116,101,114,115,58,32,101,46,103
0000482A  6572 733A 
0000482E  2065 2E67 
00004832  2041 302D 7079          dc.b      32,65,48,45,65,55,44,68,48,45,68,55,44,80,67
00004836  4137 2C44 
0000483A  302D 4437 
0000483E  2C50 43   
00004841  2C53 5350 7080          dc.b      44,83,83,80,44,85,83,80,44,83,82,0
00004845  2C55 5350 
00004849  2C53 5200 
                    7081   @m68kde~1_97:
0000484E  0D0A 2020 7082          dc.b      13,10,32,32,66,68,47,66,83,47,66,67,47,66,75
00004852  4244 2F42 
00004856  532F 4243 
0000485A  2F42 4B   
0000485D  2020 2D20 7083          dc.b      32,32,45,32,66,114,101,97,107,32,80,111,105
00004861  4272 6561 
00004865  6B20 506F 
00004869  69        
0000486A  6E74 3A20 7084          dc.b      110,116,58,32,68,105,115,112,108,97,121,47,83
0000486E  4469 7370 
00004872  6C61 792F 
00004876  53        
00004877  6574 2F43 7085          dc.b      101,116,47,67,108,101,97,114,47,75,105,108,108
0000487B  6C65 6172 
0000487F  2F4B 696C 
00004883  6C        
00004884  00        7086          dc.b      0
                    7087   @m68kde~1_98:
00004886  0D0A 2020 7088          dc.b      13,10,32,32,67,32,32,32,32,32,32,32,32,32,32
0000488A  4320 2020 
0000488E  2020 2020 
00004892  2020 20   
00004895  2020 2D20 7089          dc.b      32,32,45,32,67,111,112,121,32,80,114,111,103
00004899  436F 7079 
0000489D  2050 726F 
000048A1  67        
000048A2  7261 6D20 7090          dc.b      114,97,109,32,102,114,111,109,32,70,108,97,115
000048A6  6672 6F6D 
000048AA  2046 6C61 
000048AE  73        
000048AF  6820 746F 7091          dc.b      104,32,116,111,32,77,97,105,110,32,77,101,109
000048B3  204D 6169 
000048B7  6E20 4D65 
000048BB  6D        
000048BC  6F72 7900 7092          dc.b      111,114,121,0
                    7093   @m68kde~1_99:
000048C0  0D0A 2020 7094          dc.b      13,10,32,32,68,32,32,32,32,32,32,32,32,32,32
000048C4  4420 2020 
000048C8  2020 2020 
000048CC  2020 20   
000048CF  2020 2D20 7095          dc.b      32,32,45,32,68,117,109,112,32,77,101,109,111
000048D3  4475 6D70 
000048D7  204D 656D 
000048DB  6F        
000048DC  7279 2043 7096          dc.b      114,121,32,67,111,110,116,101,110,116,115,32
000048E0  6F6E 7465 
000048E4  6E74 7320 
000048E8  746F 2053 7097          dc.b      116,111,32,83,99,114,101,101,110,0
000048EC  6372 6565 
000048F0  6E00      
                    7098   @m68kde~1_100:
000048F2  0D0A 2020 7099          dc.b      13,10,32,32,69,32,32,32,32,32,32,32,32,32,32
000048F6  4520 2020 
000048FA  2020 2020 
000048FE  2020 20   
00004901  2020 2D20 7100          dc.b      32,32,45,32,69,110,116,101,114,32,83,116,114
00004905  456E 7465 
00004909  7220 5374 
0000490D  72        
0000490E  696E 6720 7101          dc.b      105,110,103,32,105,110,116,111,32,77,101,109
00004912  696E 746F 
00004916  204D 656D 
0000491A  6F72 7900 7102          dc.b      111,114,121,0
                    7103   @m68kde~1_101:
0000491E  0D0A 2020 7104          dc.b      13,10,32,32,70,32,32,32,32,32,32,32,32,32,32
00004922  4620 2020 
00004926  2020 2020 
0000492A  2020 20   
0000492D  2020 2D20 7105          dc.b      32,32,45,32,70,105,108,108,32,77,101,109,111
00004931  4669 6C6C 
00004935  204D 656D 
00004939  6F        
0000493A  7279 2077 7106          dc.b      114,121,32,119,105,116,104,32,68,97,116,97,0
0000493E  6974 6820 
00004942  4461 7461 
00004946  00        
                    7107   @m68kde~1_102:
00004948  0D0A 2020 7108          dc.b      13,10,32,32,71,32,32,32,32,32,32,32,32,32,32
0000494C  4720 2020 
00004950  2020 2020 
00004954  2020 20   
00004957  2020 2D20 7109          dc.b      32,32,45,32,71,111,32,80,114,111,103,114,97
0000495B  476F 2050 
0000495F  726F 6772 
00004963  61        
00004964  6D20 5374 7110          dc.b      109,32,83,116,97,114,116,105,110,103,32,97,116
00004968  6172 7469 
0000496C  6E67 2061 
00004970  74        
00004971  2041 6464 7111          dc.b      32,65,100,100,114,101,115,115,58,32,36,37,48
00004975  7265 7373 
00004979  3A20 2425 
0000497D  30        
0000497E  3858 00   7112          dc.b      56,88,0
                    7113   @m68kde~1_103:
00004982  0D0A 2020 7114          dc.b      13,10,32,32,76,32,32,32,32,32,32,32,32,32,32
00004986  4C20 2020 
0000498A  2020 2020 
0000498E  2020 20   
00004991  2020 2D20 7115          dc.b      32,32,45,32,76,111,97,100,32,80,114,111,103
00004995  4C6F 6164 
00004999  2050 726F 
0000499D  67        
0000499E  7261 6D20 7116          dc.b      114,97,109,32,40,46,72,69,88,32,102,105,108
000049A2  282E 4845 
000049A6  5820 6669 
000049AA  6C        
000049AB  6529 2066 7117          dc.b      101,41,32,102,114,111,109,32,76,97,112,116,111
000049AF  726F 6D20 
000049B3  4C61 7074 
000049B7  6F        
000049B8  7000      7118          dc.b      112,0
                    7119   @m68kde~1_104:
000049BA  0D0A 2020 7120          dc.b      13,10,32,32,77,32,32,32,32,32,32,32,32,32,32
000049BE  4D20 2020 
000049C2  2020 2020 
000049C6  2020 20   
000049C9  2020 2D20 7121          dc.b      32,32,45,32,77,101,109,111,114,121,32,69,120
000049CD  4D65 6D6F 
000049D1  7279 2045 
000049D5  78        
000049D6  616D 696E 7122          dc.b      97,109,105,110,101,32,97,110,100,32,67,104,97
000049DA  6520 616E 
000049DE  6420 4368 
000049E2  61        
000049E3  6E67 6500 7123          dc.b      110,103,101,0
                    7124   @m68kde~1_105:
000049E8  0D0A 2020 7125          dc.b      13,10,32,32,80,32,32,32,32,32,32,32,32,32,32
000049EC  5020 2020 
000049F0  2020 2020 
000049F4  2020 20   
000049F7  2020 2D20 7126          dc.b      32,32,45,32,80,114,111,103,114,97,109,32,70
000049FB  5072 6F67 
000049FF  7261 6D20 
00004A03  46        
00004A04  6C61 7368 7127          dc.b      108,97,115,104,32,77,101,109,111,114,121,32
00004A08  204D 656D 
00004A0C  6F72 7920 
00004A10  7769 7468 7128          dc.b      119,105,116,104,32,85,115,101,114,32,80,114
00004A14  2055 7365 
00004A18  7220 5072 
00004A1C  6F67 7261 7129          dc.b      111,103,114,97,109,0
00004A20  6D00      
                    7130   @m68kde~1_106:
00004A22  0D0A 2020 7131          dc.b      13,10,32,32,82,32,32,32,32,32,32,32,32,32,32
00004A26  5220 2020 
00004A2A  2020 2020 
00004A2E  2020 20   
00004A31  2020 2D20 7132          dc.b      32,32,45,32,68,105,115,112,108,97,121,32,54
00004A35  4469 7370 
00004A39  6C61 7920 
00004A3D  36        
00004A3E  3830 3030 7133          dc.b      56,48,48,48,32,82,101,103,105,115,116,101,114
00004A42  2052 6567 
00004A46  6973 7465 
00004A4A  72        
00004A4B  7300      7134          dc.b      115,0
                    7135   @m68kde~1_107:
00004A4E  0D0A 2020 7136          dc.b      13,10,32,32,83,32,32,32,32,32,32,32,32,32,32
00004A52  5320 2020 
00004A56  2020 2020 
00004A5A  2020 20   
00004A5D  2020 2D20 7137          dc.b      32,32,45,32,84,111,103,103,108,101,32,79,78
00004A61  546F 6767 
00004A65  6C65 204F 
00004A69  4E        
00004A6A  2F4F 4646 7138          dc.b      47,79,70,70,32,83,105,110,103,108,101,32,83
00004A6E  2053 696E 
00004A72  676C 6520 
00004A76  53        
00004A77  7465 7020 7139          dc.b      116,101,112,32,77,111,100,101,0
00004A7B  4D6F 6465 
00004A7F  00        
                    7140   @m68kde~1_108:
00004A80  0D0A 2020 7141          dc.b      13,10,32,32,84,77,32,32,32,32,32,32,32,32,32
00004A84  544D 2020 
00004A88  2020 2020 
00004A8C  2020 20   
00004A8F  2020 2D20 7142          dc.b      32,32,45,32,84,101,115,116,32,77,101,109,111
00004A93  5465 7374 
00004A97  204D 656D 
00004A9B  6F        
00004A9C  7279 00   7143          dc.b      114,121,0
                    7144   @m68kde~1_109:
00004AA0  0D0A 2020 7145          dc.b      13,10,32,32,84,83,32,32,32,32,32,32,32,32,32
00004AA4  5453 2020 
00004AA8  2020 2020 
00004AAC  2020 20   
00004AAF  2020 2D20 7146          dc.b      32,32,45,32,84,101,115,116,32,83,119,105,116
00004AB3  5465 7374 
00004AB7  2053 7769 
00004ABB  74        
00004ABC  6368 6573 7147          dc.b      99,104,101,115,58,32,83,87,55,45,48,0
00004AC0  3A20 5357 
00004AC4  372D 3000 
                    7148   @m68kde~1_110:
00004AC8  0D0A 2020 7149          dc.b      13,10,32,32,84,68,32,32,32,32,32,32,32,32,32
00004ACC  5444 2020 
00004AD0  2020 2020 
00004AD4  2020 20   
00004AD7  2020 2D20 7150          dc.b      32,32,45,32,84,101,115,116,32,68,105,115,112
00004ADB  5465 7374 
00004ADF  2044 6973 
00004AE3  70        
00004AE4  6C61 7973 7151          dc.b      108,97,121,115,58,32,76,69,68,115,32,97,110
00004AE8  3A20 4C45 
00004AEC  4473 2061 
00004AF0  6E        
00004AF1  6420 372D 7152          dc.b      100,32,55,45,83,101,103,109,101,110,116,0
00004AF5  5365 676D 
00004AF9  656E 7400 
                    7153   @m68kde~1_111:
00004AFE  0D0A 2020 7154          dc.b      13,10,32,32,87,68,47,87,83,47,87,67,47,87,75
00004B02  5744 2F57 
00004B06  532F 5743 
00004B0A  2F57 4B   
00004B0D  2020 2D20 7155          dc.b      32,32,45,32,87,97,116,99,104,32,80,111,105,110
00004B11  5761 7463 
00004B15  6820 506F 
00004B19  696E      
00004B1B  743A 2044 7156          dc.b      116,58,32,68,105,115,112,108,97,121,47,83,101
00004B1F  6973 706C 
00004B23  6179 2F53 
00004B27  65        
00004B28  742F 436C 7157          dc.b      116,47,67,108,101,97,114,47,75,105,108,108,0
00004B2C  6561 722F 
00004B30  4B69 6C6C 
00004B34  00        
                    7158   @m68kde~1_112:
00004B36  0D0A 2300 7159          dc.b      13,10,35,0
                    7160   @m68kde~1_113:
00004B3A  0D0A 5072 7161          dc.b      13,10,80,114,111,103,114,97,109,32,82,117,110
00004B3E  6F67 7261 
00004B42  6D20 5275 
00004B46  6E        
00004B47  6E69 6E67 7162          dc.b      110,105,110,103,46,46,46,46,46,0
00004B4B  2E2E 2E2E 
00004B4F  2E00      
                    7163   @m68kde~1_114:
00004B52  0D0A 5072 7164          dc.b      13,10,80,114,101,115,115,32,60,82,69,83,69,84
00004B56  6573 7320 
00004B5A  3C52 4553 
00004B5E  4554      
00004B60  3E20 6275 7165          dc.b      62,32,98,117,116,116,111,110,32,60,75,101,121
00004B64  7474 6F6E 
00004B68  203C 4B65 
00004B6C  79        
00004B6D  303E 206F 7166          dc.b      48,62,32,111,110,32,68,69,49,32,116,111,32,115
00004B71  6E20 4445 
00004B75  3120 746F 
00004B79  2073      
00004B7B  746F 7000 7167          dc.b      116,111,112,0
                    7168   @m68kde~1_115:
00004B80  0D0A 4572 7169          dc.b      13,10,69,114,114,111,114,58,32,80,114,101,115
00004B84  726F 723A 
00004B88  2050 7265 
00004B8C  73        
00004B8D  7320 2747 7170          dc.b      115,32,39,71,39,32,102,105,114,115,116,32,116
00004B91  2720 6669 
00004B95  7273 7420 
00004B99  74        
00004B9A  6F20 7374 7171          dc.b      111,32,115,116,97,114,116,32,112,114,111,103
00004B9E  6172 7420 
00004BA2  7072 6F67 
00004BA6  7261 6D00 7172          dc.b      114,97,109,0
                    7173   @m68kde~1_116:
00004BAA  0D0A 5369 7174          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00004BAE  6E67 6C65 
00004BB2  2053 7465 
00004BB6  70        
00004BB7  2020 3A5B 7175          dc.b      32,32,58,91,79,78,93,0
00004BBB  4F4E 5D00 
                    7176   @m68kde~1_117:
00004BC0  0D0A 5072 7177          dc.b      13,10,80,114,101,115,115,32,39,71,39,32,116
00004BC4  6573 7320 
00004BC8  2747 2720 
00004BCC  74        
00004BCD  6F20 5472 7178          dc.b      111,32,84,114,97,99,101,32,80,114,111,103,114
00004BD1  6163 6520 
00004BD5  5072 6F67 
00004BD9  72        
00004BDA  616D 2066 7179          dc.b      97,109,32,102,114,111,109,32,97,100,100,114
00004BDE  726F 6D20 
00004BE2  6164 6472 
00004BE6  6573 7320 7180          dc.b      101,115,115,32,36,37,88,46,46,46,46,46,0
00004BEA  2425 582E 
00004BEE  2E2E 2E2E 
00004BF2  00        
                    7181   @m68kde~1_118:
00004BF4  0D0A 5075 7182          dc.b      13,10,80,117,115,104,32,60,82,69,83,69,84,32
00004BF8  7368 203C 
00004BFC  5245 5345 
00004C00  5420      
00004C02  4275 7474 7183          dc.b      66,117,116,116,111,110,62,32,116,111,32,83,116
00004C06  6F6E 3E20 
00004C0A  746F 2053 
00004C0E  74        
00004C0F  6F70 2E2E 7184          dc.b      111,112,46,46,46,46,46,0
00004C13  2E2E 2E00 
                    7185   @m68kde~1_119:
00004C18  0D0A 5369 7186          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00004C1C  6E67 6C65 
00004C20  2053 7465 
00004C24  70        
00004C25  203A 205B 7187          dc.b      32,58,32,91,79,70,70,93,0
00004C29  4F46 465D 
00004C2D  00        
                    7188   @m68kde~1_120:
00004C2E  0D0A 4272 7189          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00004C32  6561 6B20 
00004C36  506F 696E 
00004C3A  74        
00004C3B  7320 3A5B 7190          dc.b      115,32,58,91,69,110,97,98,108,101,100,93,0
00004C3F  456E 6162 
00004C43  6C65 645D 
00004C47  00        
                    7191   @m68kde~1_121:
00004C48  0D0A 5072 7192          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00004C4C  6573 7320 
00004C50  3C45 5343 
00004C54  3E20      
00004C56  746F 2052 7193          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
00004C5A  6573 756D 
00004C5E  6520 5573 
00004C62  6572 2050 7194          dc.b      101,114,32,80,114,111,103,114,97,109,46,46,46
00004C66  726F 6772 
00004C6A  616D 2E2E 
00004C6E  2E        
00004C6F  2E2E 00   7195          dc.b      46,46,0
                    7196   @m68kde~1_122:
00004C72  0D0A 5369 7197          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00004C76  6E67 6C65 
00004C7A  2053 7465 
00004C7E  70        
00004C7F  2020 3A5B 7198          dc.b      32,32,58,91,79,70,70,93,0
00004C83  4F46 465D 
00004C87  00        
                    7199   @m68kde~1_123:
00004C88  0D0A 0D0A 7200          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
00004C8C  5072 6F67 
00004C90  7261 6D20 
00004C94  41        
00004C95  424F 5254 7201          dc.b      66,79,82,84,32,33,33,33,33,33,33,13,10,0
00004C99  2021 2121 
00004C9D  2121 210D 
00004CA1  0A00      
                    7202   @m68kde~1_124:
00004CA4  2573 0D0A 7203          dc.b      37,115,13,10,0
00004CA8  00        
                    7204   @m68kde~1_125:
00004CAA  0D0A 0D0A 7205          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
00004CAE  5072 6F67 
00004CB2  7261 6D20 
00004CB6  41        
00004CB7  424F 5254 7206          dc.b      66,79,82,84,32,33,33,33,33,33,0
00004CBB  2021 2121 
00004CBF  2121 00   
                    7207   @m68kde~1_126:
00004CC2  0D0A 556E 7208          dc.b      13,10,85,110,104,97,110,100,108,101,100,32,73
00004CC6  6861 6E64 
00004CCA  6C65 6420 
00004CCE  49        
00004CCF  6E74 6572 7209          dc.b      110,116,101,114,114,117,112,116,58,32,73,82
00004CD3  7275 7074 
00004CD7  3A20 4952 
00004CDB  5125 6420 7210          dc.b      81,37,100,32,33,33,33,33,33,0
00004CDF  2121 2121 
00004CE3  2100      
                    7211   @m68kde~1_127:
00004CE6  4144 4452 7212          dc.b      65,68,68,82,69,83,83,32,69,82,82,79,82,58,32
00004CEA  4553 5320 
00004CEE  4552 524F 
00004CF2  523A 20   
00004CF5  3136 206F 7213          dc.b      49,54,32,111,114,32,51,50,32,66,105,116,32,84
00004CF9  7220 3332 
00004CFD  2042 6974 
00004D01  2054      
00004D03  7261 6E73 7214          dc.b      114,97,110,115,102,101,114,32,116,111,47,102
00004D07  6665 7220 
00004D0B  746F 2F66 
00004D0F  726F 6D20 7215          dc.b      114,111,109,32,97,110,32,79,68,68,32,65,100
00004D13  616E 204F 
00004D17  4444 2041 
00004D1B  64        
00004D1C  6472 6573 7216          dc.b      100,114,101,115,115,46,46,46,46,0
00004D20  732E 2E2E 
00004D24  2E00      
                    7217   @m68kde~1_128:
00004D26  556E 6861 7218          dc.b      85,110,104,97,110,100,108,101,100,32,84,114
00004D2A  6E64 6C65 
00004D2E  6420 5472 
00004D32  6170 2021 7219          dc.b      97,112,32,33,33,33,33,33,0
00004D36  2121 2121 
00004D3A  00        
                    7220   @m68kde~1_129:
00004D3C  4255 5320 7221          dc.b      66,85,83,32,69,114,114,111,114,33,0
00004D40  4572 726F 
00004D44  7221 00   
                    7222   @m68kde~1_130:
00004D48  4144 4452 7223          dc.b      65,68,68,82,69,83,83,32,69,114,114,111,114,33
00004D4C  4553 5320 
00004D50  4572 726F 
00004D54  7221      
00004D56  00        7224          dc.b      0
                    7225   @m68kde~1_131:
00004D58  494C 4C45 7226          dc.b      73,76,76,69,71,65,76,32,73,78,83,84,82,85,67
00004D5C  4741 4C20 
00004D60  494E 5354 
00004D64  5255 43   
00004D67  5449 4F4E 7227          dc.b      84,73,79,78,0
00004D6B  00        
                    7228   @m68kde~1_132:
00004D6C  4449 5649 7229          dc.b      68,73,86,73,68,69,32,66,89,32,90,69,82,79,0
00004D70  4445 2042 
00004D74  5920 5A45 
00004D78  524F 00   
                    7230   @m68kde~1_133:
00004D7C  2743 484B 7231          dc.b      39,67,72,75,39,32,73,78,83,84,82,85,67,84,73
00004D80  2720 494E 
00004D84  5354 5255 
00004D88  4354 49   
00004D8B  4F4E 00   7232          dc.b      79,78,0
                    7233   @m68kde~1_134:
00004D8E  5452 4150 7234          dc.b      84,82,65,80,86,32,73,78,83,84,82,85,67,84,73
00004D92  5620 494E 
00004D96  5354 5255 
00004D9A  4354 49   
00004D9D  4F4E 00   7235          dc.b      79,78,0
                    7236   @m68kde~1_135:
00004DA0  5052 4956 7237          dc.b      80,82,73,86,73,76,69,71,69,32,86,73,79,76,65
00004DA4  494C 4547 
00004DA8  4520 5649 
00004DAC  4F4C 41   
00004DAF  5449 4F4E 7238          dc.b      84,73,79,78,0
00004DB3  00        
                    7239   @m68kde~1_136:
00004DB4  554E 494E 7240          dc.b      85,78,73,78,73,84,73,65,76,73,83,69,68,32,73
00004DB8  4954 4941 
00004DBC  4C49 5345 
00004DC0  4420 49   
00004DC3  5251 00   7241          dc.b      82,81,0
                    7242   @m68kde~1_137:
00004DC6  5350 5552 7243          dc.b      83,80,85,82,73,79,85,83,32,73,82,81,0
00004DCA  494F 5553 
00004DCE  2049 5251 
00004DD2  00        
                    7244   @m68kde~1_138:
00004DD4  0D0A 5374 7245          dc.b      13,10,83,116,97,114,116,32,65,100,100,114,101
00004DD8  6172 7420 
00004DDC  4164 6472 
00004DE0  65        
00004DE1  7373 2069 7246          dc.b      115,115,32,105,110,32,77,101,109,111,114,121
00004DE5  6E20 4D65 
00004DE9  6D6F 7279 
00004DED  3A20 00   7247          dc.b      58,32,0
                    7248   @m68kde~1_139:
00004DF0  0D0A 456E 7249          dc.b      13,10,69,110,116,101,114,32,83,116,114,105,110
00004DF4  7465 7220 
00004DF8  5374 7269 
00004DFC  6E        
00004DFD  6720 2845 7250          dc.b      103,32,40,69,83,67,32,116,111,32,101,110,100
00004E01  5343 2074 
00004E05  6F20 656E 
00004E09  64        
00004E0A  2920 3A00 7251          dc.b      41,32,58,0
                    7252   @m68kde~1_140:
00004E0E  0D0A 5072 7253          dc.b      13,10,80,114,111,118,105,100,101,32,116,104
00004E12  6F76 6964 
00004E16  6520 7468 
00004E1A  6520 7374 7254          dc.b      101,32,115,116,97,114,116,32,97,100,100,114
00004E1E  6172 7420 
00004E22  6164 6472 
00004E26  6573 7320 7255          dc.b      101,115,115,32,111,102,32,116,104,101,32,116
00004E2A  6F66 2074 
00004E2E  6865 2074 
00004E32  6573 742E 7256          dc.b      101,115,116,46,10,0
00004E36  0A00      
                    7257   @m68kde~1_141:
00004E38  5468 6520 7258          dc.b      84,104,101,32,115,116,97,114,116,32,97,100,100
00004E3C  7374 6172 
00004E40  7420 6164 
00004E44  64        
00004E45  7265 7373 7259          dc.b      114,101,115,115,32,105,115,32,115,109,97,108
00004E49  2069 7320 
00004E4D  736D 616C 
00004E51  6C65 7220 7260          dc.b      108,101,114,32,116,104,97,110,32,48,120,102
00004E55  7468 616E 
00004E59  2030 7866 
00004E5D  3030 3030 7261          dc.b      48,48,48,48,48,48,48,44,32,105,110,118,97,108
00004E61  3030 302C 
00004E65  2069 6E76 
00004E69  616C      
00004E6B  6964 210A 7262          dc.b      105,100,33,10,0
00004E6F  00        
                    7263   @m68kde~1_142:
00004E70  5468 6520 7264          dc.b      84,104,101,32,115,116,97,114,116,32,97,100,100
00004E74  7374 6172 
00004E78  7420 6164 
00004E7C  64        
00004E7D  7265 7373 7265          dc.b      114,101,115,115,32,105,115,32,98,105,103,103
00004E81  2069 7320 
00004E85  6269 6767 
00004E89  6572 2074 7266          dc.b      101,114,32,116,104,97,110,32,48,120,102,48,48
00004E8D  6861 6E20 
00004E91  3078 6630 
00004E95  30        
00004E96  3366 6666 7267          dc.b      51,102,102,102,102,44,32,105,110,118,97,108
00004E9A  662C 2069 
00004E9E  6E76 616C 
00004EA2  6964 210A 7268          dc.b      105,100,33,10,0
00004EA6  00        
                    7269   @m68kde~1_143:
00004EA8  5468 6520 7270          dc.b      84,104,101,32,115,116,97,114,116,32,97,100,100
00004EAC  7374 6172 
00004EB0  7420 6164 
00004EB4  64        
00004EB5  7265 7373 7271          dc.b      114,101,115,115,32,112,114,111,118,105,100,101
00004EB9  2070 726F 
00004EBD  7669 6465 
00004EC1  6420 6973 7272          dc.b      100,32,105,115,32,111,100,100,44,32,110,101
00004EC5  206F 6464 
00004EC9  2C20 6E65 
00004ECD  6564 2061 7273          dc.b      101,100,32,97,110,32,101,118,101,110,32,111
00004ED1  6E20 6576 
00004ED5  656E 206F 
00004ED9  6E65 210A 7274          dc.b      110,101,33,10,0
00004EDD  00        
                    7275   @m68kde~1_144:
00004EDE  5374 6172 7276          dc.b      83,116,97,114,116,32,97,100,100,114,101,115
00004EE2  7420 6164 
00004EE6  6472 6573 
00004EEA  7320 7661 7277          dc.b      115,32,118,97,108,105,100,46,10,0
00004EEE  6C69 642E 
00004EF2  0A00      
                    7278   @m68kde~1_145:
00004EF4  0D0A 5072 7279          dc.b      13,10,80,114,111,118,105,100,101,32,116,104
00004EF8  6F76 6964 
00004EFC  6520 7468 
00004F00  6520 656E 7280          dc.b      101,32,101,110,100,32,97,100,100,114,101,115
00004F04  6420 6164 
00004F08  6472 6573 
00004F0C  7320 6F66 7281          dc.b      115,32,111,102,32,116,104,101,32,116,101,115
00004F10  2074 6865 
00004F14  2074 6573 
00004F18  742E 0A00 7282          dc.b      116,46,10,0
                    7283   @m68kde~1_146:
00004F1C  5468 6520 7284          dc.b      84,104,101,32,101,110,100,32,97,100,100,114
00004F20  656E 6420 
00004F24  6164 6472 
00004F28  6573 7320 7285          dc.b      101,115,115,32,105,115,32,115,109,97,108,108
00004F2C  6973 2073 
00004F30  6D61 6C6C 
00004F34  6572 2074 7286          dc.b      101,114,32,116,104,97,110,32,48,120,102,48,48
00004F38  6861 6E20 
00004F3C  3078 6630 
00004F40  30        
00004F41  3030 3030 7287          dc.b      48,48,48,48,48,44,32,105,110,118,97,108,105
00004F45  302C 2069 
00004F49  6E76 616C 
00004F4D  69        
00004F4E  6421 0A00 7288          dc.b      100,33,10,0
                    7289   @m68kde~1_147:
00004F52  5468 6520 7290          dc.b      84,104,101,32,101,110,100,32,97,100,100,114
00004F56  656E 6420 
00004F5A  6164 6472 
00004F5E  6573 7320 7291          dc.b      101,115,115,32,105,115,32,98,105,103,103,101
00004F62  6973 2062 
00004F66  6967 6765 
00004F6A  7220 7468 7292          dc.b      114,32,116,104,97,110,32,48,120,102,48,48,51
00004F6E  616E 2030 
00004F72  7866 3030 
00004F76  33        
00004F77  6666 6666 7293          dc.b      102,102,102,102,44,32,105,110,118,97,108,105
00004F7B  2C20 696E 
00004F7F  7661 6C69 
00004F83  6421 0A00 7294          dc.b      100,33,10,0
                    7295   @m68kde~1_148:
00004F88  5468 6520 7296          dc.b      84,104,101,32,101,110,100,32,97,100,100,114
00004F8C  656E 6420 
00004F90  6164 6472 
00004F94  6573 7320 7297          dc.b      101,115,115,32,112,114,111,118,105,100,101,100
00004F98  7072 6F76 
00004F9C  6964 6564 
00004FA0  2069 7320 7298          dc.b      32,105,115,32,111,100,100,44,32,110,101,101
00004FA4  6F64 642C 
00004FA8  206E 6565 
00004FAC  6420 616E 7299          dc.b      100,32,97,110,32,101,118,101,110,32,111,110
00004FB0  2065 7665 
00004FB4  6E20 6F6E 
00004FB8  6521 0A00 7300          dc.b      101,33,10,0
                    7301   @m68kde~1_149:
00004FBC  456E 6420 7302          dc.b      69,110,100,32,97,100,100,114,101,115,115,32
00004FC0  6164 6472 
00004FC4  6573 7320 
00004FC8  7661 6C69 7303          dc.b      118,97,108,105,100,46,10,0
00004FCC  642E 0A00 
                    7304   @m68kde~1_150:
00004FD0  5468 6520 7305          dc.b      84,104,101,32,115,116,97,114,116,32,97,100,100
00004FD4  7374 6172 
00004FD8  7420 6164 
00004FDC  64        
00004FDD  7265 7373 7306          dc.b      114,101,115,115,32,105,115,32,115,109,97,108
00004FE1  2069 7320 
00004FE5  736D 616C 
00004FE9  6C65 7220 7307          dc.b      108,101,114,32,116,104,97,110,32,48,120,48,56
00004FED  7468 616E 
00004FF1  2030 7830 
00004FF5  38        
00004FF6  3030 3030 7308          dc.b      48,48,48,48,48,48,44,32,105,110,118,97,108,105
00004FFA  3030 2C20 
00004FFE  696E 7661 
00005002  6C69      
00005004  6421 0A00 7309          dc.b      100,33,10,0
                    7310   @m68kde~1_151:
00005008  5468 6520 7311          dc.b      84,104,101,32,115,116,97,114,116,32,97,100,100
0000500C  7374 6172 
00005010  7420 6164 
00005014  64        
00005015  7265 7373 7312          dc.b      114,101,115,115,32,105,115,32,98,105,103,103
00005019  2069 7320 
0000501D  6269 6767 
00005021  6572 2074 7313          dc.b      101,114,32,116,104,97,110,32,48,120,48,98,102
00005025  6861 6E20 
00005029  3078 3062 
0000502D  66        
0000502E  6666 6666 7314          dc.b      102,102,102,102,102,44,32,105,110,118,97,108
00005032  662C 2069 
00005036  6E76 616C 
0000503A  6964 210A 7315          dc.b      105,100,33,10,0
0000503E  00        
                    7316   @m68kde~1_152:
00005040  5468 6520 7317          dc.b      84,104,101,32,101,110,100,32,97,100,100,114
00005044  656E 6420 
00005048  6164 6472 
0000504C  6573 7320 7318          dc.b      101,115,115,32,105,115,32,115,109,97,108,108
00005050  6973 2073 
00005054  6D61 6C6C 
00005058  6572 2074 7319          dc.b      101,114,32,116,104,97,110,32,48,120,48,56,48
0000505C  6861 6E20 
00005060  3078 3038 
00005064  30        
00005065  3030 3030 7320          dc.b      48,48,48,48,48,44,32,105,110,118,97,108,105
00005069  302C 2069 
0000506D  6E76 616C 
00005071  69        
00005072  6421 0A00 7321          dc.b      100,33,10,0
                    7322   @m68kde~1_153:
00005076  5468 6520 7323          dc.b      84,104,101,32,101,110,100,32,97,100,100,114
0000507A  656E 6420 
0000507E  6164 6472 
00005082  6573 7320 7324          dc.b      101,115,115,32,105,115,32,98,105,103,103,101
00005086  6973 2062 
0000508A  6967 6765 
0000508E  7220 7468 7325          dc.b      114,32,116,104,97,110,32,48,120,48,98,102,102
00005092  616E 2030 
00005096  7830 6266 
0000509A  66        
0000509B  6666 6666 7326          dc.b      102,102,102,102,44,32,105,110,118,97,108,105
0000509F  2C20 696E 
000050A3  7661 6C69 
000050A7  6421 0A00 7327          dc.b      100,33,10,0
                    7328   @m68kde~1_154:
000050AC  4C6F 6361 7329          dc.b      76,111,99,97,116,105,111,110,32,37,120,44,32
000050B0  7469 6F6E 
000050B4  2025 782C 
000050B8  20        
000050B9  7772 6974 7330          dc.b      119,114,105,116,101,32,100,97,116,97,58,32,37
000050BD  6520 6461 
000050C1  7461 3A20 
000050C5  25        
000050C6  782C 2072 7331          dc.b      120,44,32,114,101,97,100,32,100,97,116,97,58
000050CA  6561 6420 
000050CE  6461 7461 
000050D2  3A        
000050D3  2025 780A 7332          dc.b      32,37,120,10,0
000050D7  00        
                    7333   @m68kde~1_155:
000050D8  5465 7374 7334          dc.b      84,101,115,116,32,102,97,105,108,101,100,32
000050DC  2066 6169 
000050E0  6C65 6420 
000050E4  6174 206C 7335          dc.b      97,116,32,108,111,99,97,116,105,111,110,32,37
000050E8  6F63 6174 
000050EC  696F 6E20 
000050F0  25        
000050F1  7821 0A00 7336          dc.b      120,33,10,0
                    7337   @m68kde~1_156:
000050F6  0D0A 446F 7338          dc.b      13,10,68,111,32,121,111,117,32,119,97,110,116
000050FA  2079 6F75 
000050FE  2077 616E 
00005102  74        
00005103  2074 6865 7339          dc.b      32,116,104,101,32,100,97,116,97,32,116,111,32
00005107  2064 6174 
0000510B  6120 746F 
0000510F  20        
00005110  6265 2031 7340          dc.b      98,101,32,49,46,32,98,121,116,101,115,44,32
00005114  2E20 6279 
00005118  7465 732C 
0000511C  20        
0000511D  322E 2077 7341          dc.b      50,46,32,119,111,114,100,115,44,32,111,114,32
00005121  6F72 6473 
00005125  2C20 6F72 
00005129  20        
0000512A  332E 206C 7342          dc.b      51,46,32,108,111,110,103,32,119,111,114,100
0000512E  6F6E 6720 
00005132  776F 7264 
00005136  733F 2050 7343          dc.b      115,63,32,80,114,111,118,105,100,101,32,116
0000513A  726F 7669 
0000513E  6465 2074 
00005142  6865 2069 7344          dc.b      104,101,32,105,110,116,101,103,101,114,32,98
00005146  6E74 6567 
0000514A  6572 2062 
0000514E  656C 6F77 7345          dc.b      101,108,111,119,46,10,0
00005152  2E0A 00   
                    7346   @m68kde~1_157:
00005156  0D0A 446F 7347          dc.b      13,10,68,111,32,121,111,117,32,119,97,110,116
0000515A  2079 6F75 
0000515E  2077 616E 
00005162  74        
00005163  2074 6865 7348          dc.b      32,116,104,101,32,100,97,116,97,32,116,111,32
00005167  2064 6174 
0000516B  6120 746F 
0000516F  20        
00005170  6265 2063 7349          dc.b      98,101,32,99,111,109,112,111,115,101,100,32
00005174  6F6D 706F 
00005178  7365 6420 
0000517C  6F66 2028 7350          dc.b      111,102,32,40,104,101,120,41,32,49,46,32,48
00005180  6865 7829 
00005184  2031 2E20 
00005188  30        
00005189  2C20 322E 7351          dc.b      44,32,50,46,32,53,44,32,51,46,32,65,44,32,111
0000518D  2035 2C20 
00005191  332E 2041 
00005195  2C20 6F   
00005198  7220 342E 7352          dc.b      114,32,52,46,32,70,63,32,80,114,111,118,105
0000519C  2046 3F20 
000051A0  5072 6F76 
000051A4  69        
000051A5  6465 2074 7353          dc.b      100,101,32,116,104,101,32,105,110,116,101,103
000051A9  6865 2069 
000051AD  6E74 6567 
000051B1  6572 2062 7354          dc.b      101,114,32,98,101,108,111,119,46,10,0
000051B5  656C 6F77 
000051B9  2E0A 00   
                    7355   @m68kde~1_158:
000051BC  0D0A 446F 7356          dc.b      13,10,68,111,32,121,111,117,32,119,97,110,116
000051C0  2079 6F75 
000051C4  2077 616E 
000051C8  74        
000051C9  2074 6F20 7357          dc.b      32,116,111,32,116,101,115,116,32,49,46,32,83
000051CD  7465 7374 
000051D1  2031 2E20 
000051D5  53        
000051D6  5241 4D20 7358          dc.b      82,65,77,32,111,114,32,50,46,32,83,68,82,65
000051DA  6F72 2032 
000051DE  2E20 5344 
000051E2  5241      
000051E4  4D3F 2050 7359          dc.b      77,63,32,80,114,111,118,105,100,101,32,116,104
000051E8  726F 7669 
000051EC  6465 2074 
000051F0  68        
000051F1  6520 696E 7360          dc.b      101,32,105,110,116,101,103,101,114,32,98,101
000051F5  7465 6765 
000051F9  7220 6265 
000051FD  6C6F 772E 7361          dc.b      108,111,119,46,10,0
00005201  0A00      
                    7362   @m68kde~1_159:
00005204  5374 6172 7363          dc.b      83,116,97,114,116,32,97,100,100,114,101,115
00005208  7420 6164 
0000520C  6472 6573 
00005210  733A 2025 7364          dc.b      115,58,32,37,120,10,0
00005214  780A 00   
                    7365   @m68kde~1_160:
00005218  456E 6420 7366          dc.b      69,110,100,32,97,100,100,114,101,115,115,58
0000521C  6164 6472 
00005220  6573 733A 
00005224  2025 780A 7367          dc.b      32,37,120,10,0
00005228  00        
                    7368   @m68kde~1_161:
0000522A  5465 7374 7369          dc.b      84,101,115,116,32,100,97,116,97,58,32,37,120
0000522E  2064 6174 
00005232  613A 2025 
00005236  78        
00005237  0A00      7370          dc.b      10,0
                    7371   @m68kde~1_162:
0000523A  5465 7374 7372          dc.b      84,101,115,116,32,112,97,115,115,101,100,33
0000523E  2070 6173 
00005242  7365 6421 
00005246  0A00      7373          dc.b      10,0
                    7374   @m68kde~1_163:
00005248  4445 312D 7375          dc.b      68,69,49,45,54,56,107,32,66,117,103,32,86,49
0000524C  3638 6B20 
00005250  4275 6720 
00005254  5631      
00005256  2E37 3700 7376          dc.b      46,55,55,0
                    7377   @m68kde~1_164:
0000525A  436F 7079 7378          dc.b      67,111,112,121,114,105,103,104,116,32,40,67
0000525E  7269 6768 
00005262  7420 2843 
00005266  2920 504A 7379          dc.b      41,32,80,74,32,68,97,118,105,101,115,32,50,48
0000526A  2044 6176 
0000526E  6965 7320 
00005272  3230      
00005274  3136 00   7380          dc.b      49,54,0
                    7381   @m68kde~1_165:
00005278  0D0A 5275 7382          dc.b      13,10,82,117,110,110,105,110,103,46,46,46,46
0000527C  6E6E 696E 
00005280  672E 2E2E 
00005284  2E        
00005285  2E00      7383          dc.b      46,0
                    7384   @m68kde~1_166:
00005288  5275 6E6E 7385          dc.b      82,117,110,110,105,110,103,46,46,46,46,46,0
0000528C  696E 672E 
00005290  2E2E 2E2E 
00005294  00        
                    7386   @m68kde~1_167:
00005296  4279 3A20 7387          dc.b      66,121,58,32,80,74,32,68,97,118,105,101,115
0000529A  504A 2044 
0000529E  6176 6965 
000052A2  73        
000052A3  00        7388          dc.b      0
                    7389   @m68kde~1_168:
000052A4  0D0A 2573 7390          dc.b      13,10,37,115,0
000052A8  00        
                    7391   @m68kde~1_169:
000052AA  0D0A 5374 7392          dc.b      13,10,83,116,117,100,101,110,116,32,78,97,109
000052AE  7564 656E 
000052B2  7420 4E61 
000052B6  6D        
000052B7  653A 2053 7393          dc.b      101,58,32,83,104,105,100,105,32,88,105,0
000052BB  6869 6469 
000052BF  2058 6900 
                    7394   @m68kde~1_170:
000052C4  0D0A 5374 7395          dc.b      13,10,83,116,117,100,101,110,116,32,78,117,109
000052C8  7564 656E 
000052CC  7420 4E75 
000052D0  6D        
000052D1  6265 723A 7396          dc.b      98,101,114,58,32,57,48,53,48,54,54,52,51,0
000052D5  2039 3035 
000052D9  3036 3634 
000052DD  3300      
                    7397          section   data
000052E0            7398                   align
          0000 52E0 7399   DataStart       equ       *
                    7400   
                    7401   *********************************************************************************************************
                    7402   * Data Section for Initialised Data - these will be placed in rom as constants and have to be copied
                    7403   * to ram as part of the CStart routine in this file
                    7404   *********************************************************************************************************
                    7405   
                    7406   @itoa_1:
000052E0  2D32 3134 7407          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
000052E4  3734 3833 
000052E8  3634 3800 
                    7408          section   bss
000052EC            7409                   align
          0000 52EC 7410   DataEnd         equ     *                       this label will equate to the address of the last byte of global variable in it
                    7411   
                    7412   *********************************************************************************************************
                    7413   * Section for Uninitialised Data held in ROM as constants
                    7414   *********************************************************************************************************
                    7415   
0B000000            7416                   org     RamVectorTable          Ram based vector table must be stored here otherwise InstallException Handler will not work
          0000 000C 7417   DataLength      equ     DataEnd-DataStart       length of data needed to copy to Ram on bootup
                    7418   
                    7419   
0B000000            7420   bss             org       bss
                    7421   
                    7422   *********************************************************************************************************
                    7423   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    7424   * install the exception handler using the C function InstallExceptionHandler()
                    7425   *********************************************************************************************************
                    7426   
                    7427   
                    7428   
0B000000            7429   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
0B000004            7430   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
0B000008            7431   VBusError        ds.l    1      storage for address of Bus Error Handler
0B00000C            7432   VAddressError    ds.l    1      storage for address of Address Error Handler
0B000010            7433   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
0B000014            7434   VDividebyZero    ds.l    1      storage for address of divide by zero handler
0B000018            7435   VCheck           ds.l    1      ditto
0B00001C            7436   VTrapV           ds.l    1      ditto
0B000020            7437   VPrivilege       ds.l    1      ditto
0B000024            7438   VTrace           ds.l    1
0B000028            7439   VLine1010emul    ds.l    1
0B00002C            7440   VLine1111emul    ds.l    1
0B000030            7441   VUnassigned1     ds.l    1
0B000034            7442   VUnassigned2     ds.l    1
0B000038            7443   VUnassigned3     ds.l    1
0B00003C            7444   VUninit_IRQ      ds.l    1
0B000040            7445   VUnassigned4     ds.l    1
0B000044            7446   VUnassigned5     ds.l    1
0B000048            7447   VUnassigned6     ds.l    1
0B00004C            7448   VUnassigned7     ds.l    1
0B000050            7449   VUnassigned8     ds.l    1
0B000054            7450   VUnassigned9     ds.l    1
0B000058            7451   VUnassigned10    ds.l    1
0B00005C            7452   VUnassigned11    ds.l    1
0B000060            7453   VSpuriousIRQ     ds.l    1
                    7454   
                    7455   * Interrupt handlers Vector 25-31
0B000064            7456   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000068            7457   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00006C            7458   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000070            7459   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000074            7460   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000078            7461   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00007C            7462   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    7463   
                    7464   * Trap Handler vectors 32-47
0B000080            7465   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000084            7466   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000088            7467   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00008C            7468   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000090            7469   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000094            7470   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000098            7471   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00009C            7472   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A0            7473   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A4            7474   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A8            7475   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000AC            7476   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B0            7477   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B4            7478   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B8            7479   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000BC            7480   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    7481   
                    7482   * the remaining exceptions are unassigned in the 68000 so no need to allocate storage for them here
                    7483   
                    7484   ***********************************************************************************************************
                    7485   * Other Variables
                    7486   ***********************************************************************************************************
                    7487   *__DebugA5       ds.l    1
                    7488   *__UserA5        ds.l    1
                    7489   
                    7490   ***********************************************************************************************************
0B0000C0            7491   __ungetbuf:     ds.l    1       ; ungetbuffer for stdio functions
0B0000C4            7492   __allocp:       ds.l    0       ; start of allocation units
0B0000C4            7493   __heap:         ds.l    0       ; pointers for malloc functions
                    7494   
                    7495   *__himem:       ds.l    himem            ; highest memory location + 1
                    7496   *__stklen:      ds.l    stklen           ; default stack size
                    7497   
                    7498   *********************************************************************************************************
                    7499   * Section for Heap
                    7500   *********************************************************************************************************
                    7501   
                    7502   _i:
0B0000C4            7503          ds.b      4
                    7504   _x:
0B0000C8            7505          ds.b      4
                    7506   _y:
0B0000CC            7507          ds.b      4
                    7508   _z:
0B0000D0            7509          ds.b      4
                    7510   _PortA_Count:
0B0000D4            7511          ds.b      4
                    7512   _Trace:
0B0000D8            7513          ds.b      4
                    7514   _GoFlag:
0B0000DC            7515          ds.b      4
                    7516   _Echo:
0B0000E0            7517          ds.b      4
                    7518   _d0:
0B0000E4            7519          ds.b      4
                    7520   _d1:
0B0000E8            7521          ds.b      4
                    7522   _d2:
0B0000EC            7523          ds.b      4
                    7524   _d3:
0B0000F0            7525          ds.b      4
                    7526   _d4:
0B0000F4            7527          ds.b      4
                    7528   _d5:
0B0000F8            7529          ds.b      4
                    7530   _d6:
0B0000FC            7531          ds.b      4
                    7532   _d7:
0B000100            7533          ds.b      4
                    7534   _a0:
0B000104            7535          ds.b      4
                    7536   _a1:
0B000108            7537          ds.b      4
                    7538   _a2:
0B00010C            7539          ds.b      4
                    7540   _a3:
0B000110            7541          ds.b      4
                    7542   _a4:
0B000114            7543          ds.b      4
                    7544   _a5:
0B000118            7545          ds.b      4
                    7546   _a6:
0B00011C            7547          ds.b      4
                    7548   _PC:
0B000120            7549          ds.b      4
                    7550   _SSP:
0B000124            7551          ds.b      4
                    7552   _USP:
0B000128            7553          ds.b      4
                    7554   _SR:
0B00012C            7555          ds.b      2
                    7556   _BreakPointAddress:
0B00012E            7557          ds.b      32
                    7558   _BreakPointInstruction:
0B00014E            7559          ds.b      16
                    7560   _BreakPointSetOrCleared:
0B00015E            7561          ds.b      32
                    7562   _InstructionSize:
0B00017E            7563          ds.b      4
                    7564   _WatchPointAddress:
0B000182            7565          ds.b      32
                    7566   _WatchPointSetOrCleared:
0B0001A2            7567          ds.b      32
                    7568   _WatchPointString:
0B0001C2            7569          ds.b      800
                    7570   _TempString:
0B0004E2            7571          ds.b      100
                    7572          section   heap
0B000546            7573                   align
          0B00 0546 7574   bssEnd          equ *                   end of storage space for unitialised variables
                    7575   *                                       we have to copy all initialised variable from rom to here at startup
          0B00 0546 7576   heap   equ       *
0B000546            7577                    align
          0000 0000

Assembly errors: 0
